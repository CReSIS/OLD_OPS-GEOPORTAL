var $jscomp = $jscomp || {};
$jscomp.scope = {};
$jscomp.ASSUME_ES5 = false;
$jscomp.ASSUME_NO_NATIVE_MAP = false;
$jscomp.ASSUME_NO_NATIVE_SET = false;
$jscomp.defineProperty = $jscomp.ASSUME_ES5 || typeof Object.defineProperties == 'function' ? Object.defineProperty : function(target, property, descriptor) {
  descriptor = descriptor;
  if (target == Array.prototype || target == Object.prototype) {
    return;
  }
  target[property] = descriptor.value;
};
$jscomp.getGlobal = function(maybeGlobal) {
  return typeof window != 'undefined' && window === maybeGlobal ? maybeGlobal : typeof global != 'undefined' && global != null ? global : maybeGlobal;
};
$jscomp.global = $jscomp.getGlobal(this);
$jscomp.polyfill = function(target, polyfill, fromLang, toLang) {
  if (!polyfill) {
    return;
  }
  var obj = $jscomp.global;
  var split = target.split('.');
  for (var i = 0; i < split.length - 1; i++) {
    var key = split[i];
    if (!(key in obj)) {
      obj[key] = {};
    }
    obj = obj[key];
  }
  var property = split[split.length - 1];
  var orig = obj[property];
  var impl = polyfill(orig);
  if (impl == orig || impl == null) {
    return;
  }
  $jscomp.defineProperty(obj, property, {configurable:true, writable:true, value:impl});
};
$jscomp.polyfill('Array.prototype.copyWithin', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, start, opt_end) {
    var len = this.length;
    target = Number(target);
    start = Number(start);
    opt_end = Number(opt_end != null ? opt_end : len);
    if (target < start) {
      opt_end = Math.min(opt_end, len);
      while (start < opt_end) {
        if (start in this) {
          this[target++] = this[start++];
        } else {
          delete this[target++];
          start++;
        }
      }
    } else {
      opt_end = Math.min(opt_end, len + start - target);
      target += opt_end - start;
      while (opt_end > start) {
        if (--opt_end in this) {
          this[--target] = this[opt_end];
        } else {
          delete this[target];
        }
      }
    }
    return this;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.SYMBOL_PREFIX = 'jscomp_symbol_';
$jscomp.initSymbol = function() {
  $jscomp.initSymbol = function() {
  };
  if (!$jscomp.global['Symbol']) {
    $jscomp.global['Symbol'] = $jscomp.Symbol;
  }
};
$jscomp.Symbol = function() {
  var counter = 0;
  function Symbol(opt_description) {
    return $jscomp.SYMBOL_PREFIX + (opt_description || '') + counter++;
  }
  return Symbol;
}();
$jscomp.initSymbolIterator = function() {
  $jscomp.initSymbol();
  var symbolIterator = $jscomp.global['Symbol'].iterator;
  if (!symbolIterator) {
    symbolIterator = $jscomp.global['Symbol'].iterator = $jscomp.global['Symbol']('iterator');
  }
  if (typeof Array.prototype[symbolIterator] != 'function') {
    $jscomp.defineProperty(Array.prototype, symbolIterator, {configurable:true, writable:true, value:function() {
      return $jscomp.arrayIterator(this);
    }});
  }
  $jscomp.initSymbolIterator = function() {
  };
};
$jscomp.arrayIterator = function(array) {
  var index = 0;
  return $jscomp.iteratorPrototype(function() {
    if (index < array.length) {
      return {done:false, value:array[index++]};
    } else {
      return {done:true};
    }
  });
};
$jscomp.iteratorPrototype = function(next) {
  $jscomp.initSymbolIterator();
  var iterator = {next:next};
  iterator[$jscomp.global['Symbol'].iterator] = function() {
    return this;
  };
  return iterator;
};
$jscomp.iteratorFromArray = function(array, transform) {
  $jscomp.initSymbolIterator();
  if (array instanceof String) {
    array = array + '';
  }
  var i = 0;
  var iter = {next:function() {
    if (i < array.length) {
      var index = i++;
      return {value:transform(index, array[index]), done:false};
    }
    iter.next = function() {
      return {done:true, value:void 0};
    };
    return iter.next();
  }};
  $jscomp.initSymbol();
  $jscomp.initSymbolIterator();
  iter[Symbol.iterator] = function() {
    return iter;
  };
  return iter;
};
$jscomp.polyfill('Array.prototype.entries', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function() {
    return $jscomp.iteratorFromArray(this, function(i, v) {
      return [i, v];
    });
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Array.prototype.fill', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(value, opt_start, opt_end) {
    var length = this.length || 0;
    if (opt_start < 0) {
      opt_start = Math.max(0, length + opt_start);
    }
    if (opt_end == null || opt_end > length) {
      opt_end = length;
    }
    opt_end = Number(opt_end);
    if (opt_end < 0) {
      opt_end = Math.max(0, length + opt_end);
    }
    for (var i = Number(opt_start || 0); i < opt_end; i++) {
      this[i] = value;
    }
    return this;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.findInternal = function(array, callback, thisArg) {
  if (array instanceof String) {
    array = String(array);
  }
  var len = array.length;
  for (var i = 0; i < len; i++) {
    var value = array[i];
    if (callback.call(thisArg, value, i, array)) {
      return {i:i, v:value};
    }
  }
  return {i:-1, v:void 0};
};
$jscomp.polyfill('Array.prototype.find', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(callback, opt_thisArg) {
    return $jscomp.findInternal(this, callback, opt_thisArg).v;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Array.prototype.findIndex', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(callback, opt_thisArg) {
    return $jscomp.findInternal(this, callback, opt_thisArg).i;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Array.from', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(arrayLike, opt_mapFn, opt_thisArg) {
    $jscomp.initSymbolIterator();
    opt_mapFn = opt_mapFn != null ? opt_mapFn : function(x) {
      return x;
    };
    var result = [];
    $jscomp.initSymbol();
    $jscomp.initSymbolIterator();
    var iteratorFunction = arrayLike[Symbol.iterator];
    if (typeof iteratorFunction == 'function') {
      arrayLike = iteratorFunction.call(arrayLike);
      var next;
      var k = 0;
      while (!(next = arrayLike.next()).done) {
        result.push(opt_mapFn.call(opt_thisArg, next.value, k++));
      }
    } else {
      var len = arrayLike.length;
      for (var i = 0; i < len; i++) {
        result.push(opt_mapFn.call(opt_thisArg, arrayLike[i], i));
      }
    }
    return result;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Object.is', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(left, right) {
    if (left === right) {
      return left !== 0 || 1 / left === 1 / right;
    } else {
      return left !== left && right !== right;
    }
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Array.prototype.includes', function(orig) {
  if (orig) {
    return orig;
  }
  var includes = function(searchElement, opt_fromIndex) {
    var array = this;
    if (array instanceof String) {
      array = String(array);
    }
    var len = array.length;
    var i = opt_fromIndex || 0;
    if (i < 0) {
      i = Math.max(i + len, 0);
    }
    for (; i < len; i++) {
      var element = array[i];
      if (element === searchElement || Object.is(element, searchElement)) {
        return true;
      }
    }
    return false;
  };
  return includes;
}, 'es7', 'es3');
$jscomp.polyfill('Array.prototype.keys', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function() {
    return $jscomp.iteratorFromArray(this, function(i) {
      return i;
    });
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Array.of', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(var_args) {
    return Array.from(arguments);
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Array.prototype.values', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function() {
    return $jscomp.iteratorFromArray(this, function(k, v) {
      return v;
    });
  };
  return polyfill;
}, 'es8', 'es3');
$jscomp.makeIterator = function(iterable) {
  $jscomp.initSymbolIterator();
  $jscomp.initSymbol();
  $jscomp.initSymbolIterator();
  var iteratorFunction = iterable[Symbol.iterator];
  return iteratorFunction ? iteratorFunction.call(iterable) : $jscomp.arrayIterator(iterable);
};
$jscomp.FORCE_POLYFILL_PROMISE = false;
$jscomp.polyfill('Promise', function(NativePromise) {
  if (NativePromise && !$jscomp.FORCE_POLYFILL_PROMISE) {
    return NativePromise;
  }
  function AsyncExecutor() {
    this.batch_ = null;
  }
  AsyncExecutor.prototype.asyncExecute = function(f) {
    if (this.batch_ == null) {
      this.batch_ = [];
      this.asyncExecuteBatch_();
    }
    this.batch_.push(f);
    return this;
  };
  AsyncExecutor.prototype.asyncExecuteBatch_ = function() {
    var self = this;
    this.asyncExecuteFunction(function() {
      self.executeBatch_();
    });
  };
  var nativeSetTimeout = $jscomp.global['setTimeout'];
  AsyncExecutor.prototype.asyncExecuteFunction = function(f) {
    nativeSetTimeout(f, 0);
  };
  AsyncExecutor.prototype.executeBatch_ = function() {
    while (this.batch_ && this.batch_.length) {
      var executingBatch = this.batch_;
      this.batch_ = [];
      for (var i = 0; i < executingBatch.length; ++i) {
        var f = executingBatch[i];
        executingBatch[i] = null;
        try {
          f();
        } catch (error) {
          this.asyncThrow_(error);
        }
      }
    }
    this.batch_ = null;
  };
  AsyncExecutor.prototype.asyncThrow_ = function(exception) {
    this.asyncExecuteFunction(function() {
      throw exception;
    });
  };
  var PromiseState = {PENDING:0, FULFILLED:1, REJECTED:2};
  var PolyfillPromise = function(executor) {
    this.state_ = PromiseState.PENDING;
    this.result_ = undefined;
    this.onSettledCallbacks_ = [];
    var resolveAndReject = this.createResolveAndReject_();
    try {
      executor(resolveAndReject.resolve, resolveAndReject.reject);
    } catch (e) {
      resolveAndReject.reject(e);
    }
  };
  PolyfillPromise.prototype.createResolveAndReject_ = function() {
    var thisPromise = this;
    var alreadyCalled = false;
    function firstCallWins(method) {
      return function(x) {
        if (!alreadyCalled) {
          alreadyCalled = true;
          method.call(thisPromise, x);
        }
      };
    }
    return {resolve:firstCallWins(this.resolveTo_), reject:firstCallWins(this.reject_)};
  };
  PolyfillPromise.prototype.resolveTo_ = function(value) {
    if (value === this) {
      this.reject_(new TypeError('A Promise cannot resolve to itself'));
    } else {
      if (value instanceof PolyfillPromise) {
        this.settleSameAsPromise_(value);
      } else {
        if (isObject(value)) {
          this.resolveToNonPromiseObj_(value);
        } else {
          this.fulfill_(value);
        }
      }
    }
  };
  PolyfillPromise.prototype.resolveToNonPromiseObj_ = function(obj) {
    var thenMethod = undefined;
    try {
      thenMethod = obj.then;
    } catch (error) {
      this.reject_(error);
      return;
    }
    if (typeof thenMethod == 'function') {
      this.settleSameAsThenable_(thenMethod, obj);
    } else {
      this.fulfill_(obj);
    }
  };
  function isObject(value) {
    switch(typeof value) {
      case 'object':
        return value != null;
      case 'function':
        return true;
      default:
        return false;
    }
  }
  PolyfillPromise.prototype.reject_ = function(reason) {
    this.settle_(PromiseState.REJECTED, reason);
  };
  PolyfillPromise.prototype.fulfill_ = function(value) {
    this.settle_(PromiseState.FULFILLED, value);
  };
  PolyfillPromise.prototype.settle_ = function(settledState, valueOrReason) {
    if (this.state_ != PromiseState.PENDING) {
      throw new Error('Cannot settle(' + settledState + ', ' + valueOrReason + '): Promise already settled in state' + this.state_);
    }
    this.state_ = settledState;
    this.result_ = valueOrReason;
    this.executeOnSettledCallbacks_();
  };
  PolyfillPromise.prototype.executeOnSettledCallbacks_ = function() {
    if (this.onSettledCallbacks_ != null) {
      for (var i = 0; i < this.onSettledCallbacks_.length; ++i) {
        asyncExecutor.asyncExecute(this.onSettledCallbacks_[i]);
      }
      this.onSettledCallbacks_ = null;
    }
  };
  var asyncExecutor = new AsyncExecutor;
  PolyfillPromise.prototype.settleSameAsPromise_ = function(promise) {
    var methods = this.createResolveAndReject_();
    promise.callWhenSettled_(methods.resolve, methods.reject);
  };
  PolyfillPromise.prototype.settleSameAsThenable_ = function(thenMethod, thenable) {
    var methods = this.createResolveAndReject_();
    try {
      thenMethod.call(thenable, methods.resolve, methods.reject);
    } catch (error) {
      methods.reject(error);
    }
  };
  PolyfillPromise.prototype.then = function(onFulfilled, onRejected) {
    var resolveChild;
    var rejectChild;
    var childPromise = new PolyfillPromise(function(resolve, reject) {
      resolveChild = resolve;
      rejectChild = reject;
    });
    function createCallback(paramF, defaultF) {
      if (typeof paramF == 'function') {
        return function(x) {
          try {
            resolveChild(paramF(x));
          } catch (error) {
            rejectChild(error);
          }
        };
      } else {
        return defaultF;
      }
    }
    this.callWhenSettled_(createCallback(onFulfilled, resolveChild), createCallback(onRejected, rejectChild));
    return childPromise;
  };
  PolyfillPromise.prototype['catch'] = function(onRejected) {
    return this.then(undefined, onRejected);
  };
  PolyfillPromise.prototype.callWhenSettled_ = function(onFulfilled, onRejected) {
    var thisPromise = this;
    function callback() {
      switch(thisPromise.state_) {
        case PromiseState.FULFILLED:
          onFulfilled(thisPromise.result_);
          break;
        case PromiseState.REJECTED:
          onRejected(thisPromise.result_);
          break;
        default:
          throw new Error('Unexpected state: ' + thisPromise.state_);
      }
    }
    if (this.onSettledCallbacks_ == null) {
      asyncExecutor.asyncExecute(callback);
    } else {
      this.onSettledCallbacks_.push(callback);
    }
  };
  function resolvingPromise(opt_value) {
    if (opt_value instanceof PolyfillPromise) {
      return opt_value;
    } else {
      return new PolyfillPromise(function(resolve, reject) {
        resolve(opt_value);
      });
    }
  }
  PolyfillPromise['resolve'] = resolvingPromise;
  PolyfillPromise['reject'] = function(opt_reason) {
    return new PolyfillPromise(function(resolve, reject) {
      reject(opt_reason);
    });
  };
  PolyfillPromise['race'] = function(thenablesOrValues) {
    return new PolyfillPromise(function(resolve, reject) {
      var iterator = $jscomp.makeIterator(thenablesOrValues);
      for (var iterRec = iterator.next(); !iterRec.done; iterRec = iterator.next()) {
        resolvingPromise(iterRec.value).callWhenSettled_(resolve, reject);
      }
    });
  };
  PolyfillPromise['all'] = function(thenablesOrValues) {
    var iterator = $jscomp.makeIterator(thenablesOrValues);
    var iterRec = iterator.next();
    if (iterRec.done) {
      return resolvingPromise([]);
    } else {
      return new PolyfillPromise(function(resolveAll, rejectAll) {
        var resultsArray = [];
        var unresolvedCount = 0;
        function onFulfilled(i) {
          return function(ithResult) {
            resultsArray[i] = ithResult;
            unresolvedCount--;
            if (unresolvedCount == 0) {
              resolveAll(resultsArray);
            }
          };
        }
        do {
          resultsArray.push(undefined);
          unresolvedCount++;
          resolvingPromise(iterRec.value).callWhenSettled_(onFulfilled(resultsArray.length - 1), rejectAll);
          iterRec = iterator.next();
        } while (!iterRec.done);
      });
    }
  };
  return PolyfillPromise;
}, 'es6', 'es3');
$jscomp.polyfill('Promise.prototype.finally', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(onFinally) {
    return this.then(function(value) {
      var promise = Promise.resolve(onFinally());
      return promise.then(function() {
        return value;
      });
    }, function(reason) {
      var promise = Promise.resolve(onFinally());
      return promise.then(function() {
        throw reason;
      });
    });
  };
  return polyfill;
}, 'es9', 'es3');
$jscomp.underscoreProtoCanBeSet = function() {
  var x = {a:true};
  var y = {};
  try {
    y.__proto__ = x;
    return y.a;
  } catch (e) {
  }
  return false;
};
$jscomp.setPrototypeOf = typeof Object.setPrototypeOf == 'function' ? Object.setPrototypeOf : $jscomp.underscoreProtoCanBeSet() ? function(target, proto) {
  target.__proto__ = proto;
  if (target.__proto__ !== proto) {
    throw new TypeError(target + ' is not extensible');
  }
  return target;
} : null;
$jscomp.generator = {};
$jscomp.generator.ensureIteratorResultIsObject_ = function(result) {
  if (result instanceof Object) {
    return;
  }
  throw new TypeError('Iterator result ' + result + ' is not an object');
};
$jscomp.generator.Context = function() {
  this.isRunning_ = false;
  this.yieldAllIterator_ = null;
  this.yieldResult = undefined;
  this.nextAddress = 1;
  this.catchAddress_ = 0;
  this.finallyAddress_ = 0;
  this.abruptCompletion_ = null;
  this.finallyContexts_ = null;
};
$jscomp.generator.Context.prototype.start_ = function() {
  if (this.isRunning_) {
    throw new TypeError('Generator is already running');
  }
  this.isRunning_ = true;
};
$jscomp.generator.Context.prototype.stop_ = function() {
  this.isRunning_ = false;
};
$jscomp.generator.Context.prototype.jumpToErrorHandler_ = function() {
  this.nextAddress = this.catchAddress_ || this.finallyAddress_;
};
$jscomp.generator.Context.prototype.next_ = function(value) {
  this.yieldResult = value;
};
$jscomp.generator.Context.prototype.throw_ = function(e) {
  this.abruptCompletion_ = {exception:e, isException:true};
  this.jumpToErrorHandler_();
};
$jscomp.generator.Context.prototype['return'] = function(value) {
  this.abruptCompletion_ = {'return':value};
  this.nextAddress = this.finallyAddress_;
};
$jscomp.generator.Context.prototype.jumpThroughFinallyBlocks = function(nextAddress) {
  this.abruptCompletion_ = {jumpTo:nextAddress};
  this.nextAddress = this.finallyAddress_;
};
$jscomp.generator.Context.prototype.yield = function(value, resumeAddress) {
  this.nextAddress = resumeAddress;
  return {value:value};
};
$jscomp.generator.Context.prototype.yieldAll = function(iterable, resumeAddress) {
  var iterator = $jscomp.makeIterator(iterable);
  var result = iterator.next();
  $jscomp.generator.ensureIteratorResultIsObject_(result);
  if (result.done) {
    this.yieldResult = result.value;
    this.nextAddress = resumeAddress;
    return;
  }
  this.yieldAllIterator_ = iterator;
  return this.yield(result.value, resumeAddress);
};
$jscomp.generator.Context.prototype.jumpTo = function(nextAddress) {
  this.nextAddress = nextAddress;
};
$jscomp.generator.Context.prototype.jumpToEnd = function() {
  this.nextAddress = 0;
};
$jscomp.generator.Context.prototype.setCatchFinallyBlocks = function(catchAddress, finallyAddress) {
  this.catchAddress_ = catchAddress;
  if (finallyAddress != undefined) {
    this.finallyAddress_ = finallyAddress;
  }
};
$jscomp.generator.Context.prototype.setFinallyBlock = function(finallyAddress) {
  this.catchAddress_ = 0;
  this.finallyAddress_ = finallyAddress || 0;
};
$jscomp.generator.Context.prototype.leaveTryBlock = function(nextAddress, catchAddress) {
  this.nextAddress = nextAddress;
  this.catchAddress_ = catchAddress || 0;
};
$jscomp.generator.Context.prototype.enterCatchBlock = function(nextCatchBlockAddress) {
  this.catchAddress_ = nextCatchBlockAddress || 0;
  var exception = this.abruptCompletion_.exception;
  this.abruptCompletion_ = null;
  return exception;
};
$jscomp.generator.Context.prototype.enterFinallyBlock = function(nextCatchAddress, nextFinallyAddress, finallyDepth) {
  if (!finallyDepth) {
    this.finallyContexts_ = [this.abruptCompletion_];
  } else {
    this.finallyContexts_[finallyDepth] = this.abruptCompletion_;
  }
  this.catchAddress_ = nextCatchAddress || 0;
  this.finallyAddress_ = nextFinallyAddress || 0;
};
$jscomp.generator.Context.prototype.leaveFinallyBlock = function(nextAddress, finallyDepth) {
  var preservedContext = this.finallyContexts_.splice(finallyDepth || 0)[0];
  var abruptCompletion = this.abruptCompletion_ = this.abruptCompletion_ || preservedContext;
  if (abruptCompletion) {
    if (abruptCompletion.isException) {
      return this.jumpToErrorHandler_();
    }
    if (abruptCompletion.jumpTo != undefined && this.finallyAddress_ < abruptCompletion.jumpTo) {
      this.nextAddress = abruptCompletion.jumpTo;
      this.abruptCompletion_ = null;
    } else {
      this.nextAddress = this.finallyAddress_;
    }
  } else {
    this.nextAddress = nextAddress;
  }
};
$jscomp.generator.Context.prototype.forIn = function(object) {
  return new $jscomp.generator.Context.PropertyIterator(object);
};
$jscomp.generator.Context.PropertyIterator = function(object) {
  this.object_ = object;
  this.properties_ = [];
  for (var property in object) {
    this.properties_.push(property);
  }
  this.properties_.reverse();
};
$jscomp.generator.Context.PropertyIterator.prototype.getNext = function() {
  while (this.properties_.length > 0) {
    var property = this.properties_.pop();
    if (property in this.object_) {
      return property;
    }
  }
  return null;
};
$jscomp.generator.Engine_ = function(program) {
  this.context_ = new $jscomp.generator.Context;
  this.program_ = program;
};
$jscomp.generator.Engine_.prototype.next_ = function(value) {
  this.context_.start_();
  if (this.context_.yieldAllIterator_) {
    return this.yieldAllStep_(this.context_.yieldAllIterator_.next, value, this.context_.next_);
  }
  this.context_.next_(value);
  return this.nextStep_();
};
$jscomp.generator.Engine_.prototype.return_ = function(value) {
  this.context_.start_();
  var yieldAllIterator = this.context_.yieldAllIterator_;
  if (yieldAllIterator) {
    var returnFunction = 'return' in yieldAllIterator ? yieldAllIterator['return'] : function(v) {
      return {value:v, done:true};
    };
    return this.yieldAllStep_(returnFunction, value, this.context_['return']);
  }
  this.context_['return'](value);
  return this.nextStep_();
};
$jscomp.generator.Engine_.prototype.throw_ = function(exception) {
  this.context_.start_();
  if (this.context_.yieldAllIterator_) {
    return this.yieldAllStep_(this.context_.yieldAllIterator_['throw'], exception, this.context_.next_);
  }
  this.context_.throw_(exception);
  return this.nextStep_();
};
$jscomp.generator.Engine_.prototype.yieldAllStep_ = function(action, value, nextAction) {
  try {
    var result = action.call(this.context_.yieldAllIterator_, value);
    $jscomp.generator.ensureIteratorResultIsObject_(result);
    if (!result.done) {
      this.context_.stop_();
      return result;
    }
    var resultValue = result.value;
  } catch (e) {
    this.context_.yieldAllIterator_ = null;
    this.context_.throw_(e);
    return this.nextStep_();
  }
  this.context_.yieldAllIterator_ = null;
  nextAction.call(this.context_, resultValue);
  return this.nextStep_();
};
$jscomp.generator.Engine_.prototype.nextStep_ = function() {
  while (this.context_.nextAddress) {
    try {
      var yieldValue = this.program_(this.context_);
      if (yieldValue) {
        this.context_.stop_();
        return {value:yieldValue.value, done:false};
      }
    } catch (e) {
      this.context_.yieldResult = undefined;
      this.context_.throw_(e);
    }
  }
  this.context_.stop_();
  if (this.context_.abruptCompletion_) {
    var abruptCompletion = this.context_.abruptCompletion_;
    this.context_.abruptCompletion_ = null;
    if (abruptCompletion.isException) {
      throw abruptCompletion.exception;
    }
    return {value:abruptCompletion['return'], done:true};
  }
  return {value:undefined, done:true};
};
$jscomp.generator.Generator_ = function(engine) {
  this.next = function(opt_value) {
    return engine.next_(opt_value);
  };
  this['throw'] = function(exception) {
    return engine.throw_(exception);
  };
  this['return'] = function(value) {
    return engine.return_(value);
  };
  $jscomp.initSymbolIterator();
  $jscomp.initSymbol();
  $jscomp.initSymbolIterator();
  this[Symbol.iterator] = function() {
    return this;
  };
};
$jscomp.generator.createGenerator = function(generator, program) {
  var result = new $jscomp.generator.Generator_(new $jscomp.generator.Engine_(program));
  if ($jscomp.setPrototypeOf) {
    $jscomp.setPrototypeOf(result, generator.prototype);
  }
  return result;
};
$jscomp.asyncExecutePromiseGenerator = function(generator) {
  function passValueToGenerator(value) {
    return generator.next(value);
  }
  function passErrorToGenerator(error) {
    return generator['throw'](error);
  }
  return new Promise(function(resolve, reject) {
    function handleGeneratorRecord(genRec) {
      if (genRec.done) {
        resolve(genRec.value);
      } else {
        Promise.resolve(genRec.value).then(passValueToGenerator, passErrorToGenerator).then(handleGeneratorRecord, reject);
      }
    }
    handleGeneratorRecord(generator.next());
  });
};
$jscomp.asyncExecutePromiseGeneratorFunction = function(generatorFunction) {
  return $jscomp.asyncExecutePromiseGenerator(generatorFunction());
};
$jscomp.asyncExecutePromiseGeneratorProgram = function(program) {
  return $jscomp.asyncExecutePromiseGenerator(new $jscomp.generator.Generator_(new $jscomp.generator.Engine_(program)));
};
$jscomp.checkEs6ConformanceViaProxy = function() {
  try {
    var proxied = {};
    var proxy = Object.create(new $jscomp.global['Proxy'](proxied, {'get':function(target, key, receiver) {
      return target == proxied && key == 'q' && receiver == proxy;
    }}));
    return proxy['q'] === true;
  } catch (err) {
    return false;
  }
};
$jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS = false;
$jscomp.ES6_CONFORMANCE = $jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS && $jscomp.checkEs6ConformanceViaProxy();
$jscomp.owns = function(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
};
$jscomp.polyfill('WeakMap', function(NativeWeakMap) {
  function isConformant() {
    if (!NativeWeakMap || !Object.seal) {
      return false;
    }
    try {
      var x = Object.seal({});
      var y = Object.seal({});
      var map = new NativeWeakMap([[x, 2], [y, 3]]);
      if (map.get(x) != 2 || map.get(y) != 3) {
        return false;
      }
      map['delete'](x);
      map.set(y, 4);
      return !map.has(x) && map.get(y) == 4;
    } catch (err) {
      return false;
    }
  }
  if ($jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS) {
    if (NativeWeakMap && $jscomp.ES6_CONFORMANCE) {
      return NativeWeakMap;
    }
  } else {
    if (isConformant()) {
      return NativeWeakMap;
    }
  }
  var prop = '$jscomp_hidden_' + Math.random();
  function insert(target) {
    if (!$jscomp.owns(target, prop)) {
      var obj = {};
      $jscomp.defineProperty(target, prop, {value:obj});
    }
  }
  function patch(name) {
    var prev = Object[name];
    if (prev) {
      Object[name] = function(target) {
        insert(target);
        return prev(target);
      };
    }
  }
  patch('freeze');
  patch('preventExtensions');
  patch('seal');
  var index = 0;
  var PolyfillWeakMap = function(opt_iterable) {
    this.id_ = (index += Math.random() + 1).toString();
    if (opt_iterable) {
      $jscomp.initSymbol();
      $jscomp.initSymbolIterator();
      var iter = $jscomp.makeIterator(opt_iterable);
      var entry;
      while (!(entry = iter.next()).done) {
        var item = entry.value;
        this.set(item[0], item[1]);
      }
    }
  };
  PolyfillWeakMap.prototype.set = function(key, value) {
    insert(key);
    if (!$jscomp.owns(key, prop)) {
      throw new Error('WeakMap key fail: ' + key);
    }
    key[prop][this.id_] = value;
    return this;
  };
  PolyfillWeakMap.prototype.get = function(key) {
    return $jscomp.owns(key, prop) ? key[prop][this.id_] : undefined;
  };
  PolyfillWeakMap.prototype.has = function(key) {
    return $jscomp.owns(key, prop) && $jscomp.owns(key[prop], this.id_);
  };
  PolyfillWeakMap.prototype['delete'] = function(key) {
    if (!$jscomp.owns(key, prop) || !$jscomp.owns(key[prop], this.id_)) {
      return false;
    }
    return delete key[prop][this.id_];
  };
  return PolyfillWeakMap;
}, 'es6', 'es3');
$jscomp.MapEntry = function() {
  this.previous;
  this.next;
  this.head;
  this.key;
  this.value;
};
$jscomp.polyfill('Map', function(NativeMap) {
  function isConformant() {
    if ($jscomp.ASSUME_NO_NATIVE_MAP || !NativeMap || typeof NativeMap != 'function' || !NativeMap.prototype.entries || typeof Object.seal != 'function') {
      return false;
    }
    try {
      NativeMap = NativeMap;
      var key = Object.seal({x:4});
      var map = new NativeMap($jscomp.makeIterator([[key, 's']]));
      if (map.get(key) != 's' || map.size != 1 || map.get({x:4}) || map.set({x:4}, 't') != map || map.size != 2) {
        return false;
      }
      var iter = map.entries();
      var item = iter.next();
      if (item.done || item.value[0] != key || item.value[1] != 's') {
        return false;
      }
      item = iter.next();
      if (item.done || item.value[0].x != 4 || item.value[1] != 't' || !iter.next().done) {
        return false;
      }
      return true;
    } catch (err) {
      return false;
    }
  }
  if ($jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS) {
    if (NativeMap && $jscomp.ES6_CONFORMANCE) {
      return NativeMap;
    }
  } else {
    if (isConformant()) {
      return NativeMap;
    }
  }
  $jscomp.initSymbol();
  $jscomp.initSymbolIterator();
  var idMap = new WeakMap;
  var PolyfillMap = function(opt_iterable) {
    this.data_ = {};
    this.head_ = createHead();
    this.size = 0;
    if (opt_iterable) {
      var iter = $jscomp.makeIterator(opt_iterable);
      var entry;
      while (!(entry = iter.next()).done) {
        var item = entry.value;
        this.set(item[0], item[1]);
      }
    }
  };
  PolyfillMap.prototype.set = function(key, value) {
    key = key === 0 ? 0 : key;
    var r = maybeGetEntry(this, key);
    if (!r.list) {
      r.list = this.data_[r.id] = [];
    }
    if (!r.entry) {
      r.entry = {next:this.head_, previous:this.head_.previous, head:this.head_, key:key, value:value};
      r.list.push(r.entry);
      this.head_.previous.next = r.entry;
      this.head_.previous = r.entry;
      this.size++;
    } else {
      r.entry.value = value;
    }
    return this;
  };
  PolyfillMap.prototype['delete'] = function(key) {
    var r = maybeGetEntry(this, key);
    if (r.entry && r.list) {
      r.list.splice(r.index, 1);
      if (!r.list.length) {
        delete this.data_[r.id];
      }
      r.entry.previous.next = r.entry.next;
      r.entry.next.previous = r.entry.previous;
      r.entry.head = null;
      this.size--;
      return true;
    }
    return false;
  };
  PolyfillMap.prototype.clear = function() {
    this.data_ = {};
    this.head_ = this.head_.previous = createHead();
    this.size = 0;
  };
  PolyfillMap.prototype.has = function(key) {
    return !!maybeGetEntry(this, key).entry;
  };
  PolyfillMap.prototype.get = function(key) {
    var entry = maybeGetEntry(this, key).entry;
    return entry && entry.value;
  };
  PolyfillMap.prototype.entries = function() {
    return makeIterator(this, function(entry) {
      return [entry.key, entry.value];
    });
  };
  PolyfillMap.prototype.keys = function() {
    return makeIterator(this, function(entry) {
      return entry.key;
    });
  };
  PolyfillMap.prototype.values = function() {
    return makeIterator(this, function(entry) {
      return entry.value;
    });
  };
  PolyfillMap.prototype.forEach = function(callback, opt_thisArg) {
    var iter = this.entries();
    var item;
    while (!(item = iter.next()).done) {
      var entry = item.value;
      callback.call(opt_thisArg, entry[1], entry[0], this);
    }
  };
  $jscomp.initSymbol();
  $jscomp.initSymbolIterator();
  PolyfillMap.prototype[Symbol.iterator] = PolyfillMap.prototype.entries;
  var maybeGetEntry = function(map, key) {
    var id = getId(key);
    var list = map.data_[id];
    if (list && $jscomp.owns(map.data_, id)) {
      for (var index = 0; index < list.length; index++) {
        var entry = list[index];
        if (key !== key && entry.key !== entry.key || key === entry.key) {
          return {id:id, list:list, index:index, entry:entry};
        }
      }
    }
    return {id:id, list:list, index:-1, entry:undefined};
  };
  var makeIterator = function(map, func) {
    var entry = map.head_;
    return $jscomp.iteratorPrototype(function() {
      if (entry) {
        while (entry.head != map.head_) {
          entry = entry.previous;
        }
        while (entry.next != entry.head) {
          entry = entry.next;
          return {done:false, value:func(entry)};
        }
        entry = null;
      }
      return {done:true, value:void 0};
    });
  };
  var createHead = function() {
    var head = {};
    head.previous = head.next = head.head = head;
    return head;
  };
  var mapIndex = 0;
  var getId = function(obj) {
    var type = obj && typeof obj;
    if (type == 'object' || type == 'function') {
      obj = obj;
      if (!idMap.has(obj)) {
        var id = '' + ++mapIndex;
        idMap.set(obj, id);
        return id;
      }
      return idMap.get(obj);
    }
    return 'p_' + obj;
  };
  return PolyfillMap;
}, 'es6', 'es3');
$jscomp.polyfill('Math.acosh', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    return Math.log(x + Math.sqrt(x * x - 1));
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.asinh', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    if (x === 0) {
      return x;
    }
    var y = Math.log(Math.abs(x) + Math.sqrt(x * x + 1));
    return x < 0 ? -y : y;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.log1p', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    if (x < 0.25 && x > -0.25) {
      var y = x;
      var d = 1;
      var z = x;
      var zPrev = 0;
      var s = 1;
      while (zPrev != z) {
        y *= x;
        s *= -1;
        z = (zPrev = z) + s * y / ++d;
      }
      return z;
    }
    return Math.log(1 + x);
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.atanh', function(orig) {
  if (orig) {
    return orig;
  }
  var log1p = Math.log1p;
  var polyfill = function(x) {
    x = Number(x);
    return (log1p(x) - log1p(-x)) / 2;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.cbrt', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    if (x === 0) {
      return x;
    }
    x = Number(x);
    var y = Math.pow(Math.abs(x), 1 / 3);
    return x < 0 ? -y : y;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.clz32', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x) >>> 0;
    if (x === 0) {
      return 32;
    }
    var result = 0;
    if ((x & 4294901760) === 0) {
      x <<= 16;
      result += 16;
    }
    if ((x & 4278190080) === 0) {
      x <<= 8;
      result += 8;
    }
    if ((x & 4026531840) === 0) {
      x <<= 4;
      result += 4;
    }
    if ((x & 3221225472) === 0) {
      x <<= 2;
      result += 2;
    }
    if ((x & 2147483648) === 0) {
      result++;
    }
    return result;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.cosh', function(orig) {
  if (orig) {
    return orig;
  }
  var exp = Math.exp;
  var polyfill = function(x) {
    x = Number(x);
    return (exp(x) + exp(-x)) / 2;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.expm1', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    if (x < .25 && x > -.25) {
      var y = x;
      var d = 1;
      var z = x;
      var zPrev = 0;
      while (zPrev != z) {
        y *= x / ++d;
        z = (zPrev = z) + y;
      }
      return z;
    }
    return Math.exp(x) - 1;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.hypot', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x, y, var_args) {
    x = Number(x);
    y = Number(y);
    var i, z, sum;
    var max = Math.max(Math.abs(x), Math.abs(y));
    for (i = 2; i < arguments.length; i++) {
      max = Math.max(max, Math.abs(arguments[i]));
    }
    if (max > 1e100 || max < 1e-100) {
      if (!max) {
        return max;
      }
      x = x / max;
      y = y / max;
      sum = x * x + y * y;
      for (i = 2; i < arguments.length; i++) {
        z = Number(arguments[i]) / max;
        sum += z * z;
      }
      return Math.sqrt(sum) * max;
    } else {
      sum = x * x + y * y;
      for (i = 2; i < arguments.length; i++) {
        z = Number(arguments[i]);
        sum += z * z;
      }
      return Math.sqrt(sum);
    }
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.imul', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(a, b) {
    a = Number(a);
    b = Number(b);
    var ah = a >>> 16 & 65535;
    var al = a & 65535;
    var bh = b >>> 16 & 65535;
    var bl = b & 65535;
    var lh = ah * bl + al * bh << 16 >>> 0;
    return al * bl + lh | 0;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.log10', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    return Math.log(x) / Math.LN10;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.log2', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    return Math.log(x) / Math.LN2;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.sign', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    return x === 0 || isNaN(x) ? x : x > 0 ? 1 : -1;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.sinh', function(orig) {
  if (orig) {
    return orig;
  }
  var exp = Math.exp;
  var polyfill = function(x) {
    x = Number(x);
    if (x === 0) {
      return x;
    }
    return (exp(x) - exp(-x)) / 2;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.tanh', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    if (x === 0) {
      return x;
    }
    var y = Math.exp(-2 * Math.abs(x));
    var z = (1 - y) / (1 + y);
    return x < 0 ? -z : z;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.trunc', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    if (isNaN(x) || x === Infinity || x === -Infinity || x === 0) {
      return x;
    }
    var y = Math.floor(Math.abs(x));
    return x < 0 ? -y : y;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Number.EPSILON', function(orig) {
  return Math.pow(2, -52);
}, 'es6', 'es3');
$jscomp.polyfill('Number.MAX_SAFE_INTEGER', function() {
  return 9007199254740991;
}, 'es6', 'es3');
$jscomp.polyfill('Number.MIN_SAFE_INTEGER', function() {
  return -9007199254740991;
}, 'es6', 'es3');
$jscomp.polyfill('Number.isFinite', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    if (typeof x !== 'number') {
      return false;
    }
    return !isNaN(x) && x !== Infinity && x !== -Infinity;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Number.isInteger', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    if (!Number.isFinite(x)) {
      return false;
    }
    return x === Math.floor(x);
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Number.isNaN', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    return typeof x === 'number' && isNaN(x);
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Number.isSafeInteger', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    return Number.isInteger(x) && Math.abs(x) <= Number.MAX_SAFE_INTEGER;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Number.parseFloat', function(orig) {
  return orig || parseFloat;
}, 'es6', 'es3');
$jscomp.polyfill('Number.parseInt', function(orig) {
  return orig || parseInt;
}, 'es6', 'es3');
$jscomp.assign = typeof Object.assign == 'function' ? Object.assign : function(target, var_args) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    if (!source) {
      continue;
    }
    for (var key in source) {
      if ($jscomp.owns(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
$jscomp.polyfill('Object.assign', function(orig) {
  return orig || $jscomp.assign;
}, 'es6', 'es3');
$jscomp.polyfill('Object.entries', function(orig) {
  if (orig) {
    return orig;
  }
  var entries = function(obj) {
    var result = [];
    for (var key in obj) {
      if ($jscomp.owns(obj, key)) {
        result.push([key, obj[key]]);
      }
    }
    return result;
  };
  return entries;
}, 'es8', 'es3');
$jscomp.polyfill('Object.getOwnPropertySymbols', function(orig) {
  if (orig) {
    return orig;
  }
  return function() {
    return [];
  };
}, 'es6', 'es5');
$jscomp.polyfill('Reflect.ownKeys', function(orig) {
  if (orig) {
    return orig;
  }
  var symbolPrefix = 'jscomp_symbol_';
  function isSymbol(key) {
    return key.substring(0, symbolPrefix.length) == symbolPrefix;
  }
  var polyfill = function(target) {
    var keys = [];
    var names = Object.getOwnPropertyNames(target);
    var symbols = Object.getOwnPropertySymbols(target);
    for (var i = 0; i < names.length; i++) {
      (isSymbol(names[i]) ? symbols : keys).push(names[i]);
    }
    return keys.concat(symbols);
  };
  return polyfill;
}, 'es6', 'es5');
$jscomp.polyfill('Object.getOwnPropertyDescriptors', function(orig) {
  if (orig) {
    return orig;
  }
  var getOwnPropertyDescriptors = function(obj) {
    var result = {};
    var keys = Reflect.ownKeys(obj);
    for (var i = 0; i < keys.length; i++) {
      result[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return result;
  };
  return getOwnPropertyDescriptors;
}, 'es8', 'es5');
$jscomp.polyfill('Object.setPrototypeOf', function(orig) {
  return orig || $jscomp.setPrototypeOf;
}, 'es6', 'es5');
$jscomp.polyfill('Object.values', function(orig) {
  if (orig) {
    return orig;
  }
  var values = function(obj) {
    var result = [];
    for (var key in obj) {
      if ($jscomp.owns(obj, key)) {
        result.push(obj[key]);
      }
    }
    return result;
  };
  return values;
}, 'es8', 'es3');
$jscomp.polyfill('Reflect.apply', function(orig) {
  if (orig) {
    return orig;
  }
  var apply = Function.prototype.apply;
  var polyfill = function(target, thisArg, argList) {
    return apply.call(target, thisArg, argList);
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.objectCreate = $jscomp.ASSUME_ES5 || typeof Object.create == 'function' ? Object.create : function(prototype) {
  var ctor = function() {
  };
  ctor.prototype = prototype;
  return new ctor;
};
$jscomp.construct = function() {
  function reflectConstructWorks() {
    function Base() {
    }
    function Derived() {
    }
    new Base;
    Reflect.construct(Base, [], Derived);
    return new Base instanceof Base;
  }
  if (typeof Reflect != 'undefined' && Reflect.construct) {
    if (reflectConstructWorks()) {
      return Reflect.construct;
    }
    var brokenConstruct = Reflect.construct;
    var patchedConstruct = function(target, argList, opt_newTarget) {
      var out = brokenConstruct(target, argList);
      if (opt_newTarget) {
        Reflect.setPrototypeOf(out, opt_newTarget.prototype);
      }
      return out;
    };
    return patchedConstruct;
  }
  function construct(target, argList, opt_newTarget) {
    if (opt_newTarget === undefined) {
      opt_newTarget = target;
    }
    var proto = opt_newTarget.prototype || Object.prototype;
    var obj = $jscomp.objectCreate(proto);
    var apply = Function.prototype.apply;
    var out = apply.call(target, obj, argList);
    return out || obj;
  }
  return construct;
}();
$jscomp.polyfill('Reflect.construct', function(orig) {
  return $jscomp.construct;
}, 'es6', 'es3');
$jscomp.polyfill('Reflect.defineProperty', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, propertyKey, attributes) {
    try {
      Object.defineProperty(target, propertyKey, attributes);
      var desc = Object.getOwnPropertyDescriptor(target, propertyKey);
      if (!desc) {
        return false;
      }
      return desc.configurable === (attributes.configurable || false) && desc.enumerable === (attributes.enumerable || false) && ('value' in desc ? desc.value === attributes.value && desc.writable === (attributes.writable || false) : desc.get === attributes.get && desc.set === attributes.set);
    } catch (err) {
      return false;
    }
  };
  return polyfill;
}, 'es6', 'es5');
$jscomp.polyfill('Reflect.deleteProperty', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, propertyKey) {
    if (!$jscomp.owns(target, propertyKey)) {
      return true;
    }
    try {
      return delete target[propertyKey];
    } catch (err) {
      return false;
    }
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Reflect.getOwnPropertyDescriptor', function(orig) {
  return orig || Object.getOwnPropertyDescriptor;
}, 'es6', 'es5');
$jscomp.polyfill('Reflect.getPrototypeOf', function(orig) {
  return orig || Object.getPrototypeOf;
}, 'es6', 'es5');
$jscomp.findDescriptor = function(target, propertyKey) {
  var obj = target;
  while (obj) {
    var property = Reflect.getOwnPropertyDescriptor(obj, propertyKey);
    if (property) {
      return property;
    }
    obj = Reflect.getPrototypeOf(obj);
  }
  return undefined;
};
$jscomp.polyfill('Reflect.get', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, propertyKey, opt_receiver) {
    if (arguments.length <= 2) {
      return target[propertyKey];
    }
    var property = $jscomp.findDescriptor(target, propertyKey);
    if (property) {
      return property.get ? property.get.call(opt_receiver) : property.value;
    }
    return undefined;
  };
  return polyfill;
}, 'es6', 'es5');
$jscomp.polyfill('Reflect.has', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, propertyKey) {
    return propertyKey in target;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Reflect.isExtensible', function(orig) {
  if (orig) {
    return orig;
  }
  if ($jscomp.ASSUME_ES5 || typeof Object.isExtensible == 'function') {
    return Object.isExtensible;
  }
  return function() {
    return true;
  };
}, 'es6', 'es3');
$jscomp.polyfill('Reflect.preventExtensions', function(orig) {
  if (orig) {
    return orig;
  }
  if (!($jscomp.ASSUME_ES5 || typeof Object.preventExtensions == 'function')) {
    return function() {
      return false;
    };
  }
  var polyfill = function(target) {
    Object.preventExtensions(target);
    return !Object.isExtensible(target);
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Reflect.set', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, propertyKey, value, opt_receiver) {
    var property = $jscomp.findDescriptor(target, propertyKey);
    if (!property) {
      if (Reflect.isExtensible(target)) {
        target[propertyKey] = value;
        return true;
      }
      return false;
    }
    if (property.set) {
      property.set.call(arguments.length > 3 ? opt_receiver : target, value);
      return true;
    } else {
      if (property.writable && !Object.isFrozen(target)) {
        target[propertyKey] = value;
        return true;
      }
    }
    return false;
  };
  return polyfill;
}, 'es6', 'es5');
$jscomp.polyfill('Reflect.setPrototypeOf', function(orig) {
  if (orig) {
    return orig;
  } else {
    if ($jscomp.setPrototypeOf) {
      var setPrototypeOf = $jscomp.setPrototypeOf;
      var polyfill = function(target, proto) {
        try {
          setPrototypeOf(target, proto);
          return true;
        } catch (e) {
          return false;
        }
      };
      return polyfill;
    } else {
      return null;
    }
  }
}, 'es6', 'es5');
$jscomp.polyfill('Set', function(NativeSet) {
  function isConformant() {
    if ($jscomp.ASSUME_NO_NATIVE_SET || !NativeSet || typeof NativeSet != 'function' || !NativeSet.prototype.entries || typeof Object.seal != 'function') {
      return false;
    }
    try {
      NativeSet = NativeSet;
      var value = Object.seal({x:4});
      var set = new NativeSet($jscomp.makeIterator([value]));
      if (!set.has(value) || set.size != 1 || set.add(value) != set || set.size != 1 || set.add({x:4}) != set || set.size != 2) {
        return false;
      }
      var iter = set.entries();
      var item = iter.next();
      if (item.done || item.value[0] != value || item.value[1] != value) {
        return false;
      }
      item = iter.next();
      if (item.done || item.value[0] == value || item.value[0].x != 4 || item.value[1] != item.value[0]) {
        return false;
      }
      return iter.next().done;
    } catch (err) {
      return false;
    }
  }
  if ($jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS) {
    if (NativeSet && $jscomp.ES6_CONFORMANCE) {
      return NativeSet;
    }
  } else {
    if (isConformant()) {
      return NativeSet;
    }
  }
  $jscomp.initSymbol();
  $jscomp.initSymbolIterator();
  var PolyfillSet = function(opt_iterable) {
    this.map_ = new Map;
    if (opt_iterable) {
      var iter = $jscomp.makeIterator(opt_iterable);
      var entry;
      while (!(entry = iter.next()).done) {
        var item = entry.value;
        this.add(item);
      }
    }
    this.size = this.map_.size;
  };
  PolyfillSet.prototype.add = function(value) {
    value = value === 0 ? 0 : value;
    this.map_.set(value, value);
    this.size = this.map_.size;
    return this;
  };
  PolyfillSet.prototype['delete'] = function(value) {
    var result = this.map_['delete'](value);
    this.size = this.map_.size;
    return result;
  };
  PolyfillSet.prototype.clear = function() {
    this.map_.clear();
    this.size = 0;
  };
  PolyfillSet.prototype.has = function(value) {
    return this.map_.has(value);
  };
  PolyfillSet.prototype.entries = function() {
    return this.map_.entries();
  };
  PolyfillSet.prototype.values = function() {
    return this.map_.values();
  };
  PolyfillSet.prototype.keys = PolyfillSet.prototype.values;
  $jscomp.initSymbol();
  $jscomp.initSymbolIterator();
  PolyfillSet.prototype[Symbol.iterator] = PolyfillSet.prototype.values;
  PolyfillSet.prototype.forEach = function(callback, opt_thisArg) {
    var set = this;
    this.map_.forEach(function(value) {
      return callback.call(opt_thisArg, value, value, set);
    });
  };
  return PolyfillSet;
}, 'es6', 'es3');
$jscomp.checkStringArgs = function(thisArg, arg, func) {
  if (thisArg == null) {
    throw new TypeError("The 'this' value for String.prototype." + func + ' must not be null or undefined');
  }
  if (arg instanceof RegExp) {
    throw new TypeError('First argument to String.prototype.' + func + ' must not be a regular expression');
  }
  return thisArg + '';
};
$jscomp.polyfill('String.prototype.codePointAt', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(position) {
    var string = $jscomp.checkStringArgs(this, null, 'codePointAt');
    var size = string.length;
    position = Number(position) || 0;
    if (!(position >= 0 && position < size)) {
      return void 0;
    }
    position = position | 0;
    var first = string.charCodeAt(position);
    if (first < 55296 || first > 56319 || position + 1 === size) {
      return first;
    }
    var second = string.charCodeAt(position + 1);
    if (second < 56320 || second > 57343) {
      return first;
    }
    return (first - 55296) * 1024 + second + 9216;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('String.prototype.endsWith', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(searchString, opt_position) {
    var string = $jscomp.checkStringArgs(this, searchString, 'endsWith');
    searchString = searchString + '';
    if (opt_position === void 0) {
      opt_position = string.length;
    }
    var i = Math.max(0, Math.min(opt_position | 0, string.length));
    var j = searchString.length;
    while (j > 0 && i > 0) {
      if (string[--i] != searchString[--j]) {
        return false;
      }
    }
    return j <= 0;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('String.fromCodePoint', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(var_args) {
    var result = '';
    for (var i = 0; i < arguments.length; i++) {
      var code = Number(arguments[i]);
      if (code < 0 || code > 1114111 || code !== Math.floor(code)) {
        throw new RangeError('invalid_code_point ' + code);
      }
      if (code <= 65535) {
        result += String.fromCharCode(code);
      } else {
        code -= 65536;
        result += String.fromCharCode(code >>> 10 & 1023 | 55296);
        result += String.fromCharCode(code & 1023 | 56320);
      }
    }
    return result;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('String.prototype.includes', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(searchString, opt_position) {
    var string = $jscomp.checkStringArgs(this, searchString, 'includes');
    return string.indexOf(searchString, opt_position || 0) !== -1;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('String.prototype.repeat', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(copies) {
    var string = $jscomp.checkStringArgs(this, null, 'repeat');
    if (copies < 0 || copies > 1342177279) {
      throw new RangeError('Invalid count value');
    }
    copies = copies | 0;
    var result = '';
    while (copies) {
      if (copies & 1) {
        result += string;
      }
      if (copies >>>= 1) {
        string += string;
      }
    }
    return result;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.stringPadding = function(padString, padLength) {
  var padding = padString !== undefined ? String(padString) : ' ';
  if (!(padLength > 0) || !padding) {
    return '';
  }
  var repeats = Math.ceil(padLength / padding.length);
  return padding.repeat(repeats).substring(0, padLength);
};
$jscomp.polyfill('String.prototype.padEnd', function(orig) {
  if (orig) {
    return orig;
  }
  var padEnd = function(targetLength, opt_padString) {
    var string = $jscomp.checkStringArgs(this, null, 'padStart');
    var padLength = targetLength - string.length;
    return string + $jscomp.stringPadding(opt_padString, padLength);
  };
  return padEnd;
}, 'es8', 'es3');
$jscomp.polyfill('String.prototype.padStart', function(orig) {
  if (orig) {
    return orig;
  }
  var padStart = function(targetLength, opt_padString) {
    var string = $jscomp.checkStringArgs(this, null, 'padStart');
    var padLength = targetLength - string.length;
    return $jscomp.stringPadding(opt_padString, padLength) + string;
  };
  return padStart;
}, 'es8', 'es3');
$jscomp.polyfill('String.prototype.startsWith', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(searchString, opt_position) {
    var string = $jscomp.checkStringArgs(this, searchString, 'startsWith');
    searchString = searchString + '';
    var strLen = string.length;
    var searchLen = searchString.length;
    var i = Math.max(0, Math.min(opt_position | 0, string.length));
    var j = 0;
    while (j < searchLen && i < strLen) {
      if (string[i++] != searchString[j++]) {
        return false;
      }
    }
    return j >= searchLen;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.arrayFromIterator = function(iterator) {
  var i;
  var arr = [];
  while (!(i = iterator.next()).done) {
    arr.push(i.value);
  }
  return arr;
};
$jscomp.arrayFromIterable = function(iterable) {
  if (iterable instanceof Array) {
    return iterable;
  } else {
    return $jscomp.arrayFromIterator($jscomp.makeIterator(iterable));
  }
};
$jscomp.inherits = function(childCtor, parentCtor) {
  childCtor.prototype = $jscomp.objectCreate(parentCtor.prototype);
  childCtor.prototype.constructor = childCtor;
  if ($jscomp.setPrototypeOf) {
    var setPrototypeOf = $jscomp.setPrototypeOf;
    setPrototypeOf(childCtor, parentCtor);
  } else {
    for (var p in parentCtor) {
      if (p == 'prototype') {
        continue;
      }
      if (Object.defineProperties) {
        var descriptor = Object.getOwnPropertyDescriptor(parentCtor, p);
        if (descriptor) {
          Object.defineProperty(childCtor, p, descriptor);
        }
      } else {
        childCtor[p] = parentCtor[p];
      }
    }
  }
  childCtor.superClass_ = parentCtor.prototype;
};
$jscomp.polyfill('WeakSet', function(NativeWeakSet) {
  function isConformant() {
    if (!NativeWeakSet || !Object.seal) {
      return false;
    }
    try {
      var x = Object.seal({});
      var y = Object.seal({});
      var set = new NativeWeakSet([x]);
      if (!set.has(x) || set.has(y)) {
        return false;
      }
      set['delete'](x);
      set.add(y);
      return !set.has(x) && set.has(y);
    } catch (err) {
      return false;
    }
  }
  if ($jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS) {
    if (NativeWeakSet && $jscomp.ES6_CONFORMANCE) {
      return NativeWeakSet;
    }
  } else {
    if (isConformant()) {
      return NativeWeakSet;
    }
  }
  var PolyfillWeakSet = function(opt_iterable) {
    this.map_ = new WeakMap;
    if (opt_iterable) {
      $jscomp.initSymbol();
      $jscomp.initSymbolIterator();
      var iter = $jscomp.makeIterator(opt_iterable);
      var entry;
      while (!(entry = iter.next()).done) {
        var item = entry.value;
        this.add(item);
      }
    }
  };
  PolyfillWeakSet.prototype.add = function(elem) {
    this.map_.set(elem, true);
    return this;
  };
  PolyfillWeakSet.prototype.has = function(elem) {
    return this.map_.has(elem);
  };
  PolyfillWeakSet.prototype['delete'] = function(elem) {
    return this.map_['delete'](elem);
  };
  return PolyfillWeakSet;
}, 'es6', 'es3');
try {
  if (Array.prototype.values.toString().indexOf('[native code]') == -1) {
    delete Array.prototype.values;
  }
} catch (e) {
}
var Ext = Ext || {};
Ext._startTime = (new Date).getTime();
(function() {
  var global = this, objectPrototype = Object.prototype, toString = objectPrototype.toString, enumerables = true, enumerablesTest = {toString:1}, emptyFn = function() {
  }, callOverrideParent = function() {
    var method = callOverrideParent.caller.caller;
    return method.$owner.prototype[method.$name].apply(this, arguments);
  }, i, nonWhitespaceRe = /\S/, ExtApp, iterableRe = /\[object\s*(?:Array|Arguments|\w*Collection|\w*List|HTML\s+document\.all\s+class)\]/;
  Function.prototype.$extIsFunction = true;
  Ext.global = global;
  for (i in enumerablesTest) {
    enumerables = null;
  }
  if (enumerables) {
    enumerables = ['hasOwnProperty', 'valueOf', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'constructor'];
  }
  Ext.enumerables = enumerables;
  Ext.apply = function(object, config, defaults) {
    if (defaults) {
      Ext.apply(object, defaults);
    }
    if (object && config && typeof config === 'object') {
      var i, j, k;
      for (i in config) {
        object[i] = config[i];
      }
      if (enumerables) {
        for (j = enumerables.length; j--;) {
          k = enumerables[j];
          if (config.hasOwnProperty(k)) {
            object[k] = config[k];
          }
        }
      }
    }
    return object;
  };
  Ext.buildSettings = Ext.apply({baseCSSPrefix:'x-'}, Ext.buildSettings || {});
  Ext.apply(Ext, {name:Ext.sandboxName || 'Ext', emptyFn:emptyFn, identityFn:function(o) {
    return o;
  }, emptyString:new String, baseCSSPrefix:Ext.buildSettings.baseCSSPrefix, applyIf:function(object, config) {
    var property;
    if (object) {
      for (property in config) {
        if (object[property] === undefined) {
          object[property] = config[property];
        }
      }
    }
    return object;
  }, iterate:function(object, fn, scope) {
    if (Ext.isEmpty(object)) {
      return;
    }
    if (scope === undefined) {
      scope = object;
    }
    if (Ext.isIterable(object)) {
      Ext.Array.each.call(Ext.Array, object, fn, scope);
    } else {
      Ext.Object.each.call(Ext.Object, object, fn, scope);
    }
  }});
  Ext.apply(Ext, {extend:function() {
    var objectConstructor = objectPrototype.constructor, inlineOverrides = function(o) {
      for (var m in o) {
        if (!o.hasOwnProperty(m)) {
          continue;
        }
        this[m] = o[m];
      }
    };
    return function(subclass, superclass, overrides) {
      if (Ext.isObject(superclass)) {
        overrides = superclass;
        superclass = subclass;
        subclass = overrides.constructor !== objectConstructor ? overrides.constructor : function() {
          superclass.apply(this, arguments);
        };
      }
      if (!superclass) {
        Ext.Error.raise({sourceClass:'Ext', sourceMethod:'extend', msg:'Attempting to extend from a class which has not been loaded on the page.'});
      }
      var F = function() {
      }, subclassProto, superclassProto = superclass.prototype;
      F.prototype = superclassProto;
      subclassProto = subclass.prototype = new F;
      subclassProto.constructor = subclass;
      subclass.superclass = superclassProto;
      if (superclassProto.constructor === objectConstructor) {
        superclassProto.constructor = superclass;
      }
      subclass.override = function(overrides) {
        Ext.override(subclass, overrides);
      };
      subclassProto.override = inlineOverrides;
      subclassProto.proto = subclassProto;
      subclass.override(overrides);
      subclass.extend = function(o) {
        return Ext.extend(subclass, o);
      };
      return subclass;
    };
  }(), override:function(target, overrides) {
    if (target.$isClass) {
      target.override(overrides);
    } else {
      if (typeof target == 'function') {
        Ext.apply(target.prototype, overrides);
      } else {
        var owner = target.self, name, value;
        if (owner && owner.$isClass) {
          for (name in overrides) {
            if (overrides.hasOwnProperty(name)) {
              value = overrides[name];
              if (typeof value == 'function') {
                if (owner.$className) {
                  value.displayName = owner.$className + '#' + name;
                }
                value.$name = name;
                value.$owner = owner;
                value.$previous = target.hasOwnProperty(name) ? target[name] : callOverrideParent;
              }
              target[name] = value;
            }
          }
        } else {
          Ext.apply(target, overrides);
        }
      }
    }
    return target;
  }});
  Ext.apply(Ext, {valueFrom:function(value, defaultValue, allowBlank) {
    return Ext.isEmpty(value, allowBlank) ? defaultValue : value;
  }, typeOf:function(value) {
    var type, typeToString;
    if (value === null) {
      return 'null';
    }
    type = typeof value;
    if (type === 'undefined' || type === 'string' || type === 'number' || type === 'boolean') {
      return type;
    }
    typeToString = toString.call(value);
    switch(typeToString) {
      case '[object Array]':
        return 'array';
      case '[object Date]':
        return 'date';
      case '[object Boolean]':
        return 'boolean';
      case '[object Number]':
        return 'number';
      case '[object RegExp]':
        return 'regexp';
    }
    if (type === 'function') {
      return 'function';
    }
    if (type === 'object') {
      if (value.nodeType !== undefined) {
        if (value.nodeType === 3) {
          return nonWhitespaceRe.test(value.nodeValue) ? 'textnode' : 'whitespace';
        } else {
          return 'element';
        }
      }
      return 'object';
    }
    Ext.Error.raise({sourceClass:'Ext', sourceMethod:'typeOf', msg:'Failed to determine the type of the specified value "' + value + '". This is most likely a bug.'});
  }, coerce:function(from, to) {
    var fromType = Ext.typeOf(from), toType = Ext.typeOf(to), isString = typeof from === 'string';
    if (fromType !== toType) {
      switch(toType) {
        case 'string':
          return String(from);
        case 'number':
          return Number(from);
        case 'boolean':
          return isString && (!from || from === 'false') ? false : Boolean(from);
        case 'null':
          return isString && (!from || from === 'null') ? null : from;
        case 'undefined':
          return isString && (!from || from === 'undefined') ? undefined : from;
        case 'date':
          return isString && isNaN(from) ? Ext.Date.parse(from, Ext.Date.defaultFormat) : Date(Number(from));
      }
    }
    return from;
  }, isEmpty:function(value, allowEmptyString) {
    return value === null || value === undefined || (!allowEmptyString ? value === '' : false) || Ext.isArray(value) && value.length === 0;
  }, isArray:'isArray' in Array ? Array.isArray : function(value) {
    return toString.call(value) === '[object Array]';
  }, isDate:function(value) {
    return toString.call(value) === '[object Date]';
  }, isObject:toString.call(null) === '[object Object]' ? function(value) {
    return value !== null && value !== undefined && toString.call(value) === '[object Object]' && value.ownerDocument === undefined;
  } : function(value) {
    return toString.call(value) === '[object Object]';
  }, isSimpleObject:function(value) {
    return value instanceof Object && value.constructor === Object;
  }, isPrimitive:function(value) {
    var type = typeof value;
    return type === 'string' || type === 'number' || type === 'boolean';
  }, isFunction:function(value) {
    return !!(value && value.$extIsFunction);
  }, isNumber:function(value) {
    return typeof value === 'number' && isFinite(value);
  }, isNumeric:function(value) {
    return !isNaN(parseFloat(value)) && isFinite(value);
  }, isString:function(value) {
    return typeof value === 'string';
  }, isBoolean:function(value) {
    return typeof value === 'boolean';
  }, isElement:function(value) {
    return value ? value.nodeType === 1 : false;
  }, isTextNode:function(value) {
    return value ? value.nodeName === '#text' : false;
  }, isDefined:function(value) {
    return typeof value !== 'undefined';
  }, isIterable:function(value) {
    if (!value || typeof value.length !== 'number' || typeof value === 'string' || value.$extIsFunction) {
      return false;
    }
    if (!value.propertyIsEnumerable) {
      return !!value.item;
    }
    if (value.hasOwnProperty('length') && !value.propertyIsEnumerable('length')) {
      return true;
    }
    return iterableRe.test(toString.call(value));
  }});
  Ext.apply(Ext, {clone:function(item) {
    var type, i, j, k, clone, key;
    if (item === null || item === undefined) {
      return item;
    }
    if (item.nodeType && item.cloneNode) {
      return item.cloneNode(true);
    }
    type = toString.call(item);
    if (type === '[object Date]') {
      return new Date(item.getTime());
    }
    if (type === '[object Array]') {
      i = item.length;
      clone = [];
      while (i--) {
        clone[i] = Ext.clone(item[i]);
      }
    } else {
      if (type === '[object Object]' && item.constructor === Object) {
        clone = {};
        for (key in item) {
          clone[key] = Ext.clone(item[key]);
        }
        if (enumerables) {
          for (j = enumerables.length; j--;) {
            k = enumerables[j];
            if (item.hasOwnProperty(k)) {
              clone[k] = item[k];
            }
          }
        }
      }
    }
    return clone || item;
  }, getUniqueGlobalNamespace:function() {
    var uniqueGlobalNamespace = this.uniqueGlobalNamespace, i;
    if (uniqueGlobalNamespace === undefined) {
      i = 0;
      do {
        uniqueGlobalNamespace = 'ExtBox' + ++i;
      } while (Ext.global[uniqueGlobalNamespace] !== undefined);
      Ext.global[uniqueGlobalNamespace] = Ext;
      this.uniqueGlobalNamespace = uniqueGlobalNamespace;
    }
    return uniqueGlobalNamespace;
  }, functionFactoryCache:{}, cacheableFunctionFactory:function() {
    var me = this, args = Array.prototype.slice.call(arguments), cache = me.functionFactoryCache, idx, fn, ln;
    if (Ext.isSandboxed) {
      ln = args.length;
      if (ln > 0) {
        ln--;
        args[ln] = 'var Ext\x3dwindow.' + Ext.name + ';' + args[ln];
      }
    }
    idx = args.join('');
    fn = cache[idx];
    if (!fn) {
      fn = Function.prototype.constructor.apply(Function.prototype, args);
      cache[idx] = fn;
    }
    return fn;
  }, functionFactory:function() {
    var me = this, args = Array.prototype.slice.call(arguments), ln;
    if (Ext.isSandboxed) {
      ln = args.length;
      if (ln > 0) {
        ln--;
        args[ln] = 'var Ext\x3dwindow.' + Ext.name + ';' + args[ln];
      }
    }
    return Function.prototype.constructor.apply(Function.prototype, args);
  }, Logger:{verbose:emptyFn, log:emptyFn, info:emptyFn, warn:emptyFn, error:function(message) {
    throw new Error(message);
  }, deprecate:emptyFn}});
  Ext.type = Ext.typeOf;
  ExtApp = Ext.app;
  if (!ExtApp) {
    ExtApp = Ext.app = {};
  }
  Ext.apply(ExtApp, {namespaces:{}, collectNamespaces:function(paths) {
    var namespaces = Ext.app.namespaces, path;
    for (path in paths) {
      if (paths.hasOwnProperty(path)) {
        namespaces[path] = true;
      }
    }
  }, addNamespaces:function(ns) {
    var namespaces = Ext.app.namespaces, i, l;
    if (!Ext.isArray(ns)) {
      ns = [ns];
    }
    for (i = 0, l = ns.length; i < l; i++) {
      namespaces[ns[i]] = true;
    }
  }, clearNamespaces:function() {
    Ext.app.namespaces = {};
  }, getNamespace:function(className) {
    var namespaces = Ext.app.namespaces, deepestPrefix = '', prefix;
    for (prefix in namespaces) {
      if (namespaces.hasOwnProperty(prefix) && prefix.length > deepestPrefix.length && prefix + '.' === className.substring(0, prefix.length + 1)) {
        deepestPrefix = prefix;
      }
    }
    return deepestPrefix === '' ? undefined : deepestPrefix;
  }});
})();
Ext.globalEval = Ext.global.execScript ? function(code) {
  execScript(code);
} : function($$code) {
  (function() {
    var Ext = this.Ext;
    eval($$code);
  })();
};
(function() {
  var version = '4.2.1.883', Version;
  Ext.Version = Version = Ext.extend(Object, {constructor:function(version) {
    var parts, releaseStartIndex;
    if (version instanceof Version) {
      return version;
    }
    this.version = this.shortVersion = String(version).toLowerCase().replace(/_/g, '.').replace(/[\-+]/g, '');
    releaseStartIndex = this.version.search(/([^\d\.])/);
    if (releaseStartIndex !== -1) {
      this.release = this.version.substr(releaseStartIndex, version.length);
      this.shortVersion = this.version.substr(0, releaseStartIndex);
    }
    this.shortVersion = this.shortVersion.replace(/[^\d]/g, '');
    parts = this.version.split('.');
    this.major = parseInt(parts.shift() || 0, 10);
    this.minor = parseInt(parts.shift() || 0, 10);
    this.patch = parseInt(parts.shift() || 0, 10);
    this.build = parseInt(parts.shift() || 0, 10);
    return this;
  }, toString:function() {
    return this.version;
  }, valueOf:function() {
    return this.version;
  }, getMajor:function() {
    return this.major || 0;
  }, getMinor:function() {
    return this.minor || 0;
  }, getPatch:function() {
    return this.patch || 0;
  }, getBuild:function() {
    return this.build || 0;
  }, getRelease:function() {
    return this.release || '';
  }, isGreaterThan:function(target) {
    return Version.compare(this.version, target) === 1;
  }, isGreaterThanOrEqual:function(target) {
    return Version.compare(this.version, target) >= 0;
  }, isLessThan:function(target) {
    return Version.compare(this.version, target) === -1;
  }, isLessThanOrEqual:function(target) {
    return Version.compare(this.version, target) <= 0;
  }, equals:function(target) {
    return Version.compare(this.version, target) === 0;
  }, match:function(target) {
    target = String(target);
    return this.version.substr(0, target.length) === target;
  }, toArray:function() {
    return [this.getMajor(), this.getMinor(), this.getPatch(), this.getBuild(), this.getRelease()];
  }, getShortVersion:function() {
    return this.shortVersion;
  }, gt:function() {
    return this.isGreaterThan.apply(this, arguments);
  }, lt:function() {
    return this.isLessThan.apply(this, arguments);
  }, gtEq:function() {
    return this.isGreaterThanOrEqual.apply(this, arguments);
  }, ltEq:function() {
    return this.isLessThanOrEqual.apply(this, arguments);
  }});
  Ext.apply(Version, {releaseValueMap:{'dev':-6, 'alpha':-5, 'a':-5, 'beta':-4, 'b':-4, 'rc':-3, '#':-2, 'p':-1, 'pl':-1}, getComponentValue:function(value) {
    return !value ? 0 : isNaN(value) ? this.releaseValueMap[value] || value : parseInt(value, 10);
  }, compare:function(current, target) {
    var currentValue, targetValue, i;
    current = (new Version(current)).toArray();
    target = (new Version(target)).toArray();
    for (i = 0; i < Math.max(current.length, target.length); i++) {
      currentValue = this.getComponentValue(current[i]);
      targetValue = this.getComponentValue(target[i]);
      if (currentValue < targetValue) {
        return -1;
      } else {
        if (currentValue > targetValue) {
          return 1;
        }
      }
    }
    return 0;
  }});
  Ext.apply(Ext, {versions:{}, lastRegisteredVersion:null, setVersion:function(packageName, version) {
    Ext.versions[packageName] = new Version(version);
    Ext.lastRegisteredVersion = Ext.versions[packageName];
    return this;
  }, getVersion:function(packageName) {
    if (packageName === undefined) {
      return Ext.lastRegisteredVersion;
    }
    return Ext.versions[packageName];
  }, deprecate:function(packageName, since, closure, scope) {
    if (Version.compare(Ext.getVersion(packageName), since) < 1) {
      closure.call(scope);
    }
  }});
  Ext.setVersion('core', version);
})();
Ext.String = function() {
  var trimRegex = /^[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000]+|[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000]+$/g, escapeRe = /('|\\)/g, formatRe = /\{(\d+)\}/g, escapeRegexRe = /([-.*+?\^${}()|\[\]\/\\])/g, basicTrimRe = /^\s+|\s+$/g, whitespaceRe = /\s+/, varReplace = /(^[^a-z]*|[^\w])/gi, charToEntity, entityToChar, 
  charToEntityRegex, entityToCharRegex, htmlEncodeReplaceFn = function(match, capture) {
    return charToEntity[capture];
  }, htmlDecodeReplaceFn = function(match, capture) {
    return capture in entityToChar ? entityToChar[capture] : String.fromCharCode(parseInt(capture.substr(2), 10));
  }, boundsCheck = function(s, other) {
    if (s === null || s === undefined || other === null || other === undefined) {
      return false;
    }
    return other.length <= s.length;
  };
  return {insert:function(s, value, index) {
    if (!s) {
      return value;
    }
    if (!value) {
      return s;
    }
    var len = s.length;
    if (!index && index !== 0) {
      index = len;
    }
    if (index < 0) {
      index *= -1;
      if (index >= len) {
        index = 0;
      } else {
        index = len - index;
      }
    }
    if (index === 0) {
      s = value + s;
    } else {
      if (index >= s.length) {
        s += value;
      } else {
        s = s.substr(0, index) + value + s.substr(index);
      }
    }
    return s;
  }, startsWith:function(s, start, ignoreCase) {
    var result = boundsCheck(s, start);
    if (result) {
      if (ignoreCase) {
        s = s.toLowerCase();
        start = start.toLowerCase();
      }
      result = s.lastIndexOf(start, 0) === 0;
    }
    return result;
  }, endsWith:function(s, end, ignoreCase) {
    var result = boundsCheck(s, end);
    if (result) {
      if (ignoreCase) {
        s = s.toLowerCase();
        end = end.toLowerCase();
      }
      result = s.indexOf(end, s.length - end.length) !== -1;
    }
    return result;
  }, createVarName:function(s) {
    return s.replace(varReplace, '');
  }, htmlEncode:function(value) {
    return !value ? value : String(value).replace(charToEntityRegex, htmlEncodeReplaceFn);
  }, htmlDecode:function(value) {
    return !value ? value : String(value).replace(entityToCharRegex, htmlDecodeReplaceFn);
  }, addCharacterEntities:function(newEntities) {
    var charKeys = [], entityKeys = [], key, echar;
    for (key in newEntities) {
      echar = newEntities[key];
      entityToChar[key] = echar;
      charToEntity[echar] = key;
      charKeys.push(echar);
      entityKeys.push(key);
    }
    charToEntityRegex = new RegExp('(' + charKeys.join('|') + ')', 'g');
    entityToCharRegex = new RegExp('(' + entityKeys.join('|') + '|\x26#[0-9]{1,5};' + ')', 'g');
  }, resetCharacterEntities:function() {
    charToEntity = {};
    entityToChar = {};
    this.addCharacterEntities({'\x26amp;':'\x26', '\x26gt;':'\x3e', '\x26lt;':'\x3c', '\x26quot;':'"', '\x26#39;':"'"});
  }, urlAppend:function(url, string) {
    if (!Ext.isEmpty(string)) {
      return url + (url.indexOf('?') === -1 ? '?' : '\x26') + string;
    }
    return url;
  }, trim:function(string) {
    return string.replace(trimRegex, '');
  }, capitalize:function(string) {
    return string.charAt(0).toUpperCase() + string.substr(1);
  }, uncapitalize:function(string) {
    return string.charAt(0).toLowerCase() + string.substr(1);
  }, ellipsis:function(value, len, word) {
    if (value && value.length > len) {
      if (word) {
        var vs = value.substr(0, len - 2), index = Math.max(vs.lastIndexOf(' '), vs.lastIndexOf('.'), vs.lastIndexOf('!'), vs.lastIndexOf('?'));
        if (index !== -1 && index >= len - 15) {
          return vs.substr(0, index) + '...';
        }
      }
      return value.substr(0, len - 3) + '...';
    }
    return value;
  }, escapeRegex:function(string) {
    return string.replace(escapeRegexRe, '\\$1');
  }, escape:function(string) {
    return string.replace(escapeRe, '\\$1');
  }, toggle:function(string, value, other) {
    return string === value ? other : value;
  }, leftPad:function(string, size, character) {
    var result = String(string);
    character = character || ' ';
    while (result.length < size) {
      result = character + result;
    }
    return result;
  }, format:function(format) {
    var args = Ext.Array.toArray(arguments, 1);
    return format.replace(formatRe, function(m, i) {
      return args[i];
    });
  }, repeat:function(pattern, count, sep) {
    if (count < 1) {
      count = 0;
    }
    for (var buf = [], i = count; i--;) {
      buf.push(pattern);
    }
    return buf.join(sep || '');
  }, splitWords:function(words) {
    if (words && typeof words == 'string') {
      return words.replace(basicTrimRe, '').split(whitespaceRe);
    }
    return words || [];
  }};
}();
Ext.String.resetCharacterEntities();
Ext.htmlEncode = Ext.String.htmlEncode;
Ext.htmlDecode = Ext.String.htmlDecode;
Ext.urlAppend = Ext.String.urlAppend;
Ext.Number = new function() {
  var me = this, isToFixedBroken = (0.9).toFixed() !== '1', math = Math;
  Ext.apply(this, {constrain:function(number, min, max) {
    var x = parseFloat(number);
    return x < min ? min : x > max ? max : x;
  }, snap:function(value, increment, minValue, maxValue) {
    var m;
    if (value === undefined || value < minValue) {
      return minValue || 0;
    }
    if (increment) {
      m = value % increment;
      if (m !== 0) {
        value -= m;
        if (m * 2 >= increment) {
          value += increment;
        } else {
          if (m * 2 < -increment) {
            value -= increment;
          }
        }
      }
    }
    return me.constrain(value, minValue, maxValue);
  }, snapInRange:function(value, increment, minValue, maxValue) {
    var tween;
    minValue = minValue || 0;
    if (value === undefined || value < minValue) {
      return minValue;
    }
    if (increment && (tween = (value - minValue) % increment)) {
      value -= tween;
      tween *= 2;
      if (tween >= increment) {
        value += increment;
      }
    }
    if (maxValue !== undefined) {
      if (value > (maxValue = me.snapInRange(maxValue, increment, minValue))) {
        value = maxValue;
      }
    }
    return value;
  }, toFixed:isToFixedBroken ? function(value, precision) {
    precision = precision || 0;
    var pow = math.pow(10, precision);
    return (math.round(value * pow) / pow).toFixed(precision);
  } : function(value, precision) {
    return value.toFixed(precision);
  }, from:function(value, defaultValue) {
    if (isFinite(value)) {
      value = parseFloat(value);
    }
    return !isNaN(value) ? value : defaultValue;
  }, randomInt:function(from, to) {
    return math.floor(math.random() * (to - from + 1) + from);
  }, correctFloat:function(n) {
    return parseFloat(n.toPrecision(14));
  }});
  Ext.num = function() {
    return me.from.apply(this, arguments);
  };
};
(function() {
  var arrayPrototype = Array.prototype, slice = arrayPrototype.slice, supportsSplice = function() {
    var array = [], lengthBefore, j = 20;
    if (!array.splice) {
      return false;
    }
    while (j--) {
      array.push('A');
    }
    array.splice(15, 0, 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F');
    lengthBefore = array.length;
    array.splice(13, 0, 'XXX');
    if (lengthBefore + 1 != array.length) {
      return false;
    }
    return true;
  }(), supportsForEach = 'forEach' in arrayPrototype, supportsMap = 'map' in arrayPrototype, supportsIndexOf = 'indexOf' in arrayPrototype, supportsEvery = 'every' in arrayPrototype, supportsSome = 'some' in arrayPrototype, supportsFilter = 'filter' in arrayPrototype, supportsSort = function() {
    var a = [1, 2, 3, 4, 5].sort(function() {
      return 0;
    });
    return a[0] === 1 && a[1] === 2 && a[2] === 3 && a[3] === 4 && a[4] === 5;
  }(), supportsSliceOnNodeList = true, ExtArray, erase, replace, splice;
  try {
    if (typeof document !== 'undefined') {
      slice.call(document.getElementsByTagName('body'));
    }
  } catch (e$0) {
    supportsSliceOnNodeList = false;
  }
  function fixArrayIndex(array, index) {
    return index < 0 ? Math.max(0, array.length + index) : Math.min(array.length, index);
  }
  function replaceSim(array, index, removeCount, insert) {
    var add = insert ? insert.length : 0, length = array.length, pos = fixArrayIndex(array, index), remove, tailOldPos, tailNewPos, tailCount, lengthAfterRemove, i;
    if (pos === length) {
      if (add) {
        array.push.apply(array, insert);
      }
    } else {
      remove = Math.min(removeCount, length - pos);
      tailOldPos = pos + remove;
      tailNewPos = tailOldPos + add - remove;
      tailCount = length - tailOldPos;
      lengthAfterRemove = length - remove;
      if (tailNewPos < tailOldPos) {
        for (i = 0; i < tailCount; ++i) {
          array[tailNewPos + i] = array[tailOldPos + i];
        }
      } else {
        if (tailNewPos > tailOldPos) {
          for (i = tailCount; i--;) {
            array[tailNewPos + i] = array[tailOldPos + i];
          }
        }
      }
      if (add && pos === lengthAfterRemove) {
        array.length = lengthAfterRemove;
        array.push.apply(array, insert);
      } else {
        array.length = lengthAfterRemove + add;
        for (i = 0; i < add; ++i) {
          array[pos + i] = insert[i];
        }
      }
    }
    return array;
  }
  function replaceNative(array, index, removeCount, insert) {
    if (insert && insert.length) {
      if (index === 0 && !removeCount) {
        array.unshift.apply(array, insert);
      } else {
        if (index < array.length) {
          array.splice.apply(array, [index, removeCount].concat(insert));
        } else {
          array.push.apply(array, insert);
        }
      }
    } else {
      array.splice(index, removeCount);
    }
    return array;
  }
  function eraseSim(array, index, removeCount) {
    return replaceSim(array, index, removeCount);
  }
  function eraseNative(array, index, removeCount) {
    array.splice(index, removeCount);
    return array;
  }
  function spliceSim(array, index, removeCount) {
    var pos = fixArrayIndex(array, index), removed = array.slice(index, fixArrayIndex(array, pos + removeCount));
    if (arguments.length < 4) {
      replaceSim(array, pos, removeCount);
    } else {
      replaceSim(array, pos, removeCount, slice.call(arguments, 3));
    }
    return removed;
  }
  function spliceNative(array) {
    return array.splice.apply(array, slice.call(arguments, 1));
  }
  erase = supportsSplice ? eraseNative : eraseSim;
  replace = supportsSplice ? replaceNative : replaceSim;
  splice = supportsSplice ? spliceNative : spliceSim;
  ExtArray = Ext.Array = {each:function(array, fn, scope, reverse) {
    array = ExtArray.from(array);
    var i, ln = array.length;
    if (reverse !== true) {
      for (i = 0; i < ln; i++) {
        if (fn.call(scope || array[i], array[i], i, array) === false) {
          return i;
        }
      }
    } else {
      for (i = ln - 1; i > -1; i--) {
        if (fn.call(scope || array[i], array[i], i, array) === false) {
          return i;
        }
      }
    }
    return true;
  }, forEach:supportsForEach ? function(array, fn, scope) {
    array.forEach(fn, scope);
  } : function(array, fn, scope) {
    var i = 0, ln = array.length;
    for (; i < ln; i++) {
      fn.call(scope, array[i], i, array);
    }
  }, indexOf:supportsIndexOf ? function(array, item, from) {
    return arrayPrototype.indexOf.call(array, item, from);
  } : function(array, item, from) {
    var i, length = array.length;
    for (i = from < 0 ? Math.max(0, length + from) : from || 0; i < length; i++) {
      if (array[i] === item) {
        return i;
      }
    }
    return -1;
  }, contains:supportsIndexOf ? function(array, item) {
    return arrayPrototype.indexOf.call(array, item) !== -1;
  } : function(array, item) {
    var i, ln;
    for (i = 0, ln = array.length; i < ln; i++) {
      if (array[i] === item) {
        return true;
      }
    }
    return false;
  }, toArray:function(iterable, start, end) {
    if (!iterable || !iterable.length) {
      return [];
    }
    if (typeof iterable === 'string') {
      iterable = iterable.split('');
    }
    if (supportsSliceOnNodeList) {
      return slice.call(iterable, start || 0, end || iterable.length);
    }
    var array = [], i;
    start = start || 0;
    end = end ? end < 0 ? iterable.length + end : end : iterable.length;
    for (i = start; i < end; i++) {
      array.push(iterable[i]);
    }
    return array;
  }, pluck:function(array, propertyName) {
    var ret = [], i, ln, item;
    for (i = 0, ln = array.length; i < ln; i++) {
      item = array[i];
      ret.push(item[propertyName]);
    }
    return ret;
  }, map:supportsMap ? function(array, fn, scope) {
    if (!fn) {
      Ext.Error.raise('Ext.Array.map must have a callback function passed as second argument.');
    }
    return array.map(fn, scope);
  } : function(array, fn, scope) {
    if (!fn) {
      Ext.Error.raise('Ext.Array.map must have a callback function passed as second argument.');
    }
    var results = [], i = 0, len = array.length;
    for (; i < len; i++) {
      results[i] = fn.call(scope, array[i], i, array);
    }
    return results;
  }, every:supportsEvery ? function(array, fn, scope) {
    if (!fn) {
      Ext.Error.raise('Ext.Array.every must have a callback function passed as second argument.');
    }
    return array.every(fn, scope);
  } : function(array, fn, scope) {
    if (!fn) {
      Ext.Error.raise('Ext.Array.every must have a callback function passed as second argument.');
    }
    var i = 0, ln = array.length;
    for (; i < ln; ++i) {
      if (!fn.call(scope, array[i], i, array)) {
        return false;
      }
    }
    return true;
  }, some:supportsSome ? function(array, fn, scope) {
    if (!fn) {
      Ext.Error.raise('Ext.Array.some must have a callback function passed as second argument.');
    }
    return array.some(fn, scope);
  } : function(array, fn, scope) {
    if (!fn) {
      Ext.Error.raise('Ext.Array.some must have a callback function passed as second argument.');
    }
    var i = 0, ln = array.length;
    for (; i < ln; ++i) {
      if (fn.call(scope, array[i], i, array)) {
        return true;
      }
    }
    return false;
  }, equals:function(array1, array2) {
    var len1 = array1.length, len2 = array2.length, i;
    if (array1 === array2) {
      return true;
    }
    if (len1 !== len2) {
      return false;
    }
    for (i = 0; i < len1; ++i) {
      if (array1[i] !== array2[i]) {
        return false;
      }
    }
    return true;
  }, clean:function(array) {
    var results = [], i = 0, ln = array.length, item;
    for (; i < ln; i++) {
      item = array[i];
      if (!Ext.isEmpty(item)) {
        results.push(item);
      }
    }
    return results;
  }, unique:function(array) {
    var clone = [], i = 0, ln = array.length, item;
    for (; i < ln; i++) {
      item = array[i];
      if (ExtArray.indexOf(clone, item) === -1) {
        clone.push(item);
      }
    }
    return clone;
  }, filter:supportsFilter ? function(array, fn, scope) {
    if (!fn) {
      Ext.Error.raise('Ext.Array.filter must have a filter function passed as second argument.');
    }
    return array.filter(fn, scope);
  } : function(array, fn, scope) {
    if (!fn) {
      Ext.Error.raise('Ext.Array.filter must have a filter function passed as second argument.');
    }
    var results = [], i = 0, ln = array.length;
    for (; i < ln; i++) {
      if (fn.call(scope, array[i], i, array)) {
        results.push(array[i]);
      }
    }
    return results;
  }, findBy:function(array, fn, scope) {
    var i = 0, len = array.length;
    for (; i < len; i++) {
      if (fn.call(scope || array, array[i], i)) {
        return array[i];
      }
    }
    return null;
  }, from:function(value, newReference) {
    if (value === undefined || value === null) {
      return [];
    }
    if (Ext.isArray(value)) {
      return newReference ? slice.call(value) : value;
    }
    var type = typeof value;
    if (value && value.length !== undefined && type !== 'string' && (type !== 'function' || !value.apply)) {
      return ExtArray.toArray(value);
    }
    return [value];
  }, remove:function(array, item) {
    var index = ExtArray.indexOf(array, item);
    if (index !== -1) {
      erase(array, index, 1);
    }
    return array;
  }, include:function(array, item) {
    if (!ExtArray.contains(array, item)) {
      array.push(item);
    }
  }, clone:function(array) {
    return slice.call(array);
  }, merge:function() {
    var args = slice.call(arguments), array = [], i, ln;
    for (i = 0, ln = args.length; i < ln; i++) {
      array = array.concat(args[i]);
    }
    return ExtArray.unique(array);
  }, intersect:function() {
    var intersection = [], arrays = slice.call(arguments), arraysLength, array, arrayLength, minArray, minArrayIndex, minArrayCandidate, minArrayLength, element, elementCandidate, elementCount, i, j, k;
    if (!arrays.length) {
      return intersection;
    }
    arraysLength = arrays.length;
    for (i = minArrayIndex = 0; i < arraysLength; i++) {
      minArrayCandidate = arrays[i];
      if (!minArray || minArrayCandidate.length < minArray.length) {
        minArray = minArrayCandidate;
        minArrayIndex = i;
      }
    }
    minArray = ExtArray.unique(minArray);
    erase(arrays, minArrayIndex, 1);
    minArrayLength = minArray.length;
    arraysLength = arrays.length;
    for (i = 0; i < minArrayLength; i++) {
      element = minArray[i];
      elementCount = 0;
      for (j = 0; j < arraysLength; j++) {
        array = arrays[j];
        arrayLength = array.length;
        for (k = 0; k < arrayLength; k++) {
          elementCandidate = array[k];
          if (element === elementCandidate) {
            elementCount++;
            break;
          }
        }
      }
      if (elementCount === arraysLength) {
        intersection.push(element);
      }
    }
    return intersection;
  }, difference:function(arrayA, arrayB) {
    var clone = slice.call(arrayA), ln = clone.length, i, j, lnB;
    for (i = 0, lnB = arrayB.length; i < lnB; i++) {
      for (j = 0; j < ln; j++) {
        if (clone[j] === arrayB[i]) {
          erase(clone, j, 1);
          j--;
          ln--;
        }
      }
    }
    return clone;
  }, slice:[1, 2].slice(1, undefined).length ? function(array, begin, end) {
    return slice.call(array, begin, end);
  } : function(array, begin, end) {
    if (typeof begin === 'undefined') {
      return slice.call(array);
    }
    if (typeof end === 'undefined') {
      return slice.call(array, begin);
    }
    return slice.call(array, begin, end);
  }, sort:supportsSort ? function(array, sortFn) {
    if (sortFn) {
      return array.sort(sortFn);
    } else {
      return array.sort();
    }
  } : function(array, sortFn) {
    var length = array.length, i = 0, comparison, j, min, tmp;
    for (; i < length; i++) {
      min = i;
      for (j = i + 1; j < length; j++) {
        if (sortFn) {
          comparison = sortFn(array[j], array[min]);
          if (comparison < 0) {
            min = j;
          }
        } else {
          if (array[j] < array[min]) {
            min = j;
          }
        }
      }
      if (min !== i) {
        tmp = array[i];
        array[i] = array[min];
        array[min] = tmp;
      }
    }
    return array;
  }, flatten:function(array) {
    var worker = [];
    function rFlatten(a) {
      var i, ln, v;
      for (i = 0, ln = a.length; i < ln; i++) {
        v = a[i];
        if (Ext.isArray(v)) {
          rFlatten(v);
        } else {
          worker.push(v);
        }
      }
      return worker;
    }
    return rFlatten(array);
  }, min:function(array, comparisonFn) {
    var min = array[0], i, ln, item;
    for (i = 0, ln = array.length; i < ln; i++) {
      item = array[i];
      if (comparisonFn) {
        if (comparisonFn(min, item) === 1) {
          min = item;
        }
      } else {
        if (item < min) {
          min = item;
        }
      }
    }
    return min;
  }, max:function(array, comparisonFn) {
    var max = array[0], i, ln, item;
    for (i = 0, ln = array.length; i < ln; i++) {
      item = array[i];
      if (comparisonFn) {
        if (comparisonFn(max, item) === -1) {
          max = item;
        }
      } else {
        if (item > max) {
          max = item;
        }
      }
    }
    return max;
  }, mean:function(array) {
    return array.length > 0 ? ExtArray.sum(array) / array.length : undefined;
  }, sum:function(array) {
    var sum = 0, i, ln, item;
    for (i = 0, ln = array.length; i < ln; i++) {
      item = array[i];
      sum += item;
    }
    return sum;
  }, toMap:function(array, getKey, scope) {
    var map = {}, i = array.length;
    if (!getKey) {
      while (i--) {
        map[array[i]] = i + 1;
      }
    } else {
      if (typeof getKey == 'string') {
        while (i--) {
          map[array[i][getKey]] = i + 1;
        }
      } else {
        while (i--) {
          map[getKey.call(scope, array[i])] = i + 1;
        }
      }
    }
    return map;
  }, toValueMap:function(array, getKey, scope) {
    var map = {}, i = array.length;
    if (!getKey) {
      while (i--) {
        map[array[i]] = array[i];
      }
    } else {
      if (typeof getKey == 'string') {
        while (i--) {
          map[array[i][getKey]] = array[i];
        }
      } else {
        while (i--) {
          map[getKey.call(scope, array[i])] = array[i];
        }
      }
    }
    return map;
  }, _replaceSim:replaceSim, _spliceSim:spliceSim, erase:erase, insert:function(array, index, items) {
    return replace(array, index, 0, items);
  }, replace:replace, splice:splice, push:function(array) {
    var len = arguments.length, i = 1, newItem;
    if (array === undefined) {
      array = [];
    } else {
      if (!Ext.isArray(array)) {
        array = [array];
      }
    }
    for (; i < len; i++) {
      newItem = arguments[i];
      Array.prototype.push[Ext.isIterable(newItem) ? 'apply' : 'call'](array, newItem);
    }
    return array;
  }};
  Ext.each = ExtArray.each;
  ExtArray.union = ExtArray.merge;
  Ext.min = ExtArray.min;
  Ext.max = ExtArray.max;
  Ext.sum = ExtArray.sum;
  Ext.mean = ExtArray.mean;
  Ext.flatten = ExtArray.flatten;
  Ext.clean = ExtArray.clean;
  Ext.unique = ExtArray.unique;
  Ext.pluck = ExtArray.pluck;
  Ext.toArray = function() {
    return ExtArray.toArray.apply(ExtArray, arguments);
  };
})();
Ext.Function = {flexSetter:function(fn) {
  return function(a, b) {
    var k, i;
    if (a === null) {
      return this;
    }
    if (typeof a !== 'string') {
      for (k in a) {
        if (a.hasOwnProperty(k)) {
          fn.call(this, k, a[k]);
        }
      }
      if (Ext.enumerables) {
        for (i = Ext.enumerables.length; i--;) {
          k = Ext.enumerables[i];
          if (a.hasOwnProperty(k)) {
            fn.call(this, k, a[k]);
          }
        }
      }
    } else {
      fn.call(this, a, b);
    }
    return this;
  };
}, bind:function(fn, scope, args, appendArgs) {
  if (arguments.length === 2) {
    return function() {
      return fn.apply(scope, arguments);
    };
  }
  var method = fn, slice = Array.prototype.slice;
  return function() {
    var callArgs = args || arguments;
    if (appendArgs === true) {
      callArgs = slice.call(arguments, 0);
      callArgs = callArgs.concat(args);
    } else {
      if (typeof appendArgs == 'number') {
        callArgs = slice.call(arguments, 0);
        Ext.Array.insert(callArgs, appendArgs, args);
      }
    }
    return method.apply(scope || Ext.global, callArgs);
  };
}, pass:function(fn, args, scope) {
  if (!Ext.isArray(args)) {
    if (Ext.isIterable(args)) {
      args = Ext.Array.clone(args);
    } else {
      args = args !== undefined ? [args] : [];
    }
  }
  return function() {
    var fnArgs = [].concat(args);
    fnArgs.push.apply(fnArgs, arguments);
    return fn.apply(scope || this, fnArgs);
  };
}, alias:function(object, methodName) {
  return function() {
    return object[methodName].apply(object, arguments);
  };
}, clone:function(method) {
  return function() {
    return method.apply(this, arguments);
  };
}, createInterceptor:function(origFn, newFn, scope, returnValue) {
  var method = origFn;
  if (!Ext.isFunction(newFn)) {
    return origFn;
  } else {
    returnValue = Ext.isDefined(returnValue) ? returnValue : null;
    return function() {
      var me = this, args = arguments;
      newFn.target = me;
      newFn.method = origFn;
      return newFn.apply(scope || me || Ext.global, args) !== false ? origFn.apply(me || Ext.global, args) : returnValue;
    };
  }
}, createDelayed:function(fn, delay, scope, args, appendArgs) {
  if (scope || args) {
    fn = Ext.Function.bind(fn, scope, args, appendArgs);
  }
  return function() {
    var me = this, args = Array.prototype.slice.call(arguments);
    setTimeout(function() {
      fn.apply(me, args);
    }, delay);
  };
}, defer:function(fn, millis, scope, args, appendArgs) {
  fn = Ext.Function.bind(fn, scope, args, appendArgs);
  if (millis > 0) {
    return setTimeout(Ext.supports.TimeoutActualLateness ? function() {
      fn();
    } : fn, millis);
  }
  fn();
  return 0;
}, createSequence:function(originalFn, newFn, scope) {
  if (!newFn) {
    return originalFn;
  } else {
    return function() {
      var result = originalFn.apply(this, arguments);
      newFn.apply(scope || this, arguments);
      return result;
    };
  }
}, createBuffered:function(fn, buffer, scope, args) {
  var timerId;
  return function() {
    var callArgs = args || Array.prototype.slice.call(arguments, 0), me = scope || this;
    if (timerId) {
      clearTimeout(timerId);
    }
    timerId = setTimeout(function() {
      fn.apply(me, callArgs);
    }, buffer);
  };
}, createThrottled:function(fn, interval, scope) {
  var lastCallTime, elapsed, lastArgs, timer, execute = function() {
    fn.apply(scope || this, lastArgs);
    lastCallTime = Ext.Date.now();
  };
  return function() {
    elapsed = Ext.Date.now() - lastCallTime;
    lastArgs = arguments;
    clearTimeout(timer);
    if (!lastCallTime || elapsed >= interval) {
      execute();
    } else {
      timer = setTimeout(execute, interval - elapsed);
    }
  };
}, interceptBefore:function(object, methodName, fn, scope) {
  var method = object[methodName] || Ext.emptyFn;
  return object[methodName] = function() {
    var ret = fn.apply(scope || this, arguments);
    method.apply(this, arguments);
    return ret;
  };
}, interceptAfter:function(object, methodName, fn, scope) {
  var method = object[methodName] || Ext.emptyFn;
  return object[methodName] = function() {
    method.apply(this, arguments);
    return fn.apply(scope || this, arguments);
  };
}};
Ext.defer = Ext.Function.alias(Ext.Function, 'defer');
Ext.pass = Ext.Function.alias(Ext.Function, 'pass');
Ext.bind = Ext.Function.alias(Ext.Function, 'bind');
(function() {
  var TemplateClass = function() {
  }, ExtObject = Ext.Object = {chain:Object.create || function(object) {
    TemplateClass.prototype = object;
    var result = new TemplateClass;
    TemplateClass.prototype = null;
    return result;
  }, toQueryObjects:function(name, value, recursive) {
    var self = ExtObject.toQueryObjects, objects = [], i, ln;
    if (Ext.isArray(value)) {
      for (i = 0, ln = value.length; i < ln; i++) {
        if (recursive) {
          objects = objects.concat(self(name + '[' + i + ']', value[i], true));
        } else {
          objects.push({name:name, value:value[i]});
        }
      }
    } else {
      if (Ext.isObject(value)) {
        for (i in value) {
          if (value.hasOwnProperty(i)) {
            if (recursive) {
              objects = objects.concat(self(name + '[' + i + ']', value[i], true));
            } else {
              objects.push({name:name, value:value[i]});
            }
          }
        }
      } else {
        objects.push({name:name, value:value});
      }
    }
    return objects;
  }, toQueryString:function(object, recursive) {
    var paramObjects = [], params = [], i, j, ln, paramObject, value;
    for (i in object) {
      if (object.hasOwnProperty(i)) {
        paramObjects = paramObjects.concat(ExtObject.toQueryObjects(i, object[i], recursive));
      }
    }
    for (j = 0, ln = paramObjects.length; j < ln; j++) {
      paramObject = paramObjects[j];
      value = paramObject.value;
      if (Ext.isEmpty(value)) {
        value = '';
      } else {
        if (Ext.isDate(value)) {
          value = Ext.Date.toString(value);
        }
      }
      params.push(encodeURIComponent(paramObject.name) + '\x3d' + encodeURIComponent(String(value)));
    }
    return params.join('\x26');
  }, fromQueryString:function(queryString, recursive) {
    var parts = queryString.replace(/^\?/, '').split('\x26'), object = {}, temp, components, name, value, i, ln, part, j, subLn, matchedKeys, matchedName, keys, key, nextKey;
    for (i = 0, ln = parts.length; i < ln; i++) {
      part = parts[i];
      if (part.length > 0) {
        components = part.split('\x3d');
        name = decodeURIComponent(components[0]);
        value = components[1] !== undefined ? decodeURIComponent(components[1]) : '';
        if (!recursive) {
          if (object.hasOwnProperty(name)) {
            if (!Ext.isArray(object[name])) {
              object[name] = [object[name]];
            }
            object[name].push(value);
          } else {
            object[name] = value;
          }
        } else {
          matchedKeys = name.match(/(\[):?([^\]]*)\]/g);
          matchedName = name.match(/^([^\[]+)/);
          if (!matchedName) {
            throw new Error('[Ext.Object.fromQueryString] Malformed query string given, failed parsing name from "' + part + '"');
          }
          name = matchedName[0];
          keys = [];
          if (matchedKeys === null) {
            object[name] = value;
            continue;
          }
          for (j = 0, subLn = matchedKeys.length; j < subLn; j++) {
            key = matchedKeys[j];
            key = key.length === 2 ? '' : key.substring(1, key.length - 1);
            keys.push(key);
          }
          keys.unshift(name);
          temp = object;
          for (j = 0, subLn = keys.length; j < subLn; j++) {
            key = keys[j];
            if (j === subLn - 1) {
              if (Ext.isArray(temp) && key === '') {
                temp.push(value);
              } else {
                temp[key] = value;
              }
            } else {
              if (temp[key] === undefined || typeof temp[key] === 'string') {
                nextKey = keys[j + 1];
                temp[key] = Ext.isNumeric(nextKey) || nextKey === '' ? [] : {};
              }
              temp = temp[key];
            }
          }
        }
      }
    }
    return object;
  }, each:function(object, fn, scope) {
    for (var property in object) {
      if (object.hasOwnProperty(property)) {
        if (fn.call(scope || object, property, object[property], object) === false) {
          return;
        }
      }
    }
  }, merge:function(destination) {
    var i = 1, ln = arguments.length, mergeFn = ExtObject.merge, cloneFn = Ext.clone, object, key, value, sourceKey;
    for (; i < ln; i++) {
      object = arguments[i];
      for (key in object) {
        value = object[key];
        if (value && value.constructor === Object) {
          sourceKey = destination[key];
          if (sourceKey && sourceKey.constructor === Object) {
            mergeFn(sourceKey, value);
          } else {
            destination[key] = cloneFn(value);
          }
        } else {
          destination[key] = value;
        }
      }
    }
    return destination;
  }, mergeIf:function(destination) {
    var i = 1, ln = arguments.length, cloneFn = Ext.clone, object, key, value;
    for (; i < ln; i++) {
      object = arguments[i];
      for (key in object) {
        if (!(key in destination)) {
          value = object[key];
          if (value && value.constructor === Object) {
            destination[key] = cloneFn(value);
          } else {
            destination[key] = value;
          }
        }
      }
    }
    return destination;
  }, getKey:function(object, value) {
    for (var property in object) {
      if (object.hasOwnProperty(property) && object[property] === value) {
        return property;
      }
    }
    return null;
  }, getValues:function(object) {
    var values = [], property;
    for (property in object) {
      if (object.hasOwnProperty(property)) {
        values.push(object[property]);
      }
    }
    return values;
  }, getKeys:typeof Object.keys == 'function' ? function(object) {
    if (!object) {
      return [];
    }
    return Object.keys(object);
  } : function(object) {
    var keys = [], property;
    for (property in object) {
      if (object.hasOwnProperty(property)) {
        keys.push(property);
      }
    }
    return keys;
  }, getSize:function(object) {
    var size = 0, property;
    for (property in object) {
      if (object.hasOwnProperty(property)) {
        size++;
      }
    }
    return size;
  }, isEmpty:function(object) {
    for (var key in object) {
      if (object.hasOwnProperty(key)) {
        return false;
      }
    }
    return true;
  }, equals:function() {
    var check = function(o1, o2) {
      var key;
      for (key in o1) {
        if (o1.hasOwnProperty(key)) {
          if (o1[key] !== o2[key]) {
            return false;
          }
        }
      }
      return true;
    };
    return function(object1, object2) {
      if (object1 === object2) {
        return true;
      }
      if (object1 && object2) {
        return check(object1, object2) && check(object2, object1);
      } else {
        if (!object1 && !object2) {
          return object1 === object2;
        } else {
          return false;
        }
      }
    };
  }(), classify:function(object) {
    var prototype = object, objectProperties = [], propertyClassesMap = {}, objectClass = function() {
      var i = 0, ln = objectProperties.length, property;
      for (; i < ln; i++) {
        property = objectProperties[i];
        this[property] = new propertyClassesMap[property];
      }
    }, key, value;
    for (key in object) {
      if (object.hasOwnProperty(key)) {
        value = object[key];
        if (value && value.constructor === Object) {
          objectProperties.push(key);
          propertyClassesMap[key] = ExtObject.classify(value);
        }
      }
    }
    objectClass.prototype = prototype;
    return objectClass;
  }};
  Ext.merge = Ext.Object.merge;
  Ext.mergeIf = Ext.Object.mergeIf;
  Ext.urlEncode = function() {
    var args = Ext.Array.from(arguments), prefix = '';
    if (typeof args[1] === 'string') {
      prefix = args[1] + '\x26';
      args[1] = false;
    }
    return prefix + ExtObject.toQueryString.apply(ExtObject, args);
  };
  Ext.urlDecode = function() {
    return ExtObject.fromQueryString.apply(ExtObject, arguments);
  };
})();
Ext.Date = new function() {
  var utilDate = this, stripEscapeRe = /(\\.)/g, hourInfoRe = /([gGhHisucUOPZ]|MS)/, dateInfoRe = /([djzmnYycU]|MS)/, slashRe = /\\/gi, numberTokenRe = /\{(\d+)\}/g, MSFormatRe = new RegExp('\\/Date\\(([-+])?(\\d+)(?:[+-]\\d{4})?\\)\\/'), code = ['var me \x3d this, dt, y, m, d, h, i, s, ms, o, O, z, zz, u, v, W, year, jan4, week1monday, daysInMonth, dayMatched,', 'def \x3d me.defaults,', 'from \x3d Ext.Number.from,', 'results \x3d String(input).match(me.parseRegexes[{0}]);', 'if(results){', '{1}', 
  'if(u !\x3d null){', 'v \x3d new Date(u * 1000);', '}else{', 'dt \x3d me.clearTime(new Date);', 'y \x3d from(y, from(def.y, dt.getFullYear()));', 'm \x3d from(m, from(def.m - 1, dt.getMonth()));', 'dayMatched \x3d d !\x3d\x3d undefined;', 'd \x3d from(d, from(def.d, dt.getDate()));', 'if (!dayMatched) {', 'dt.setDate(1);', 'dt.setMonth(m);', 'dt.setFullYear(y);', 'daysInMonth \x3d me.getDaysInMonth(dt);', 'if (d \x3e daysInMonth) {', 'd \x3d daysInMonth;', '}', '}', 'h  \x3d from(h, from(def.h, dt.getHours()));', 
  'i  \x3d from(i, from(def.i, dt.getMinutes()));', 's  \x3d from(s, from(def.s, dt.getSeconds()));', 'ms \x3d from(ms, from(def.ms, dt.getMilliseconds()));', 'if(z \x3e\x3d 0 \x26\x26 y \x3e\x3d 0){', 'v \x3d me.add(new Date(y \x3c 100 ? 100 : y, 0, 1, h, i, s, ms), me.YEAR, y \x3c 100 ? y - 100 : 0);', 'v \x3d !strict? v : (strict \x3d\x3d\x3d true \x26\x26 (z \x3c\x3d 364 || (me.isLeapYear(v) \x26\x26 z \x3c\x3d 365))? me.add(v, me.DAY, z) : null);', '}else if(strict \x3d\x3d\x3d true \x26\x26 !me.isValid(y, m + 1, d, h, i, s, ms)){', 
  'v \x3d null;', '}else{', 'if (W) {', 'year \x3d y || (new Date()).getFullYear(),', 'jan4 \x3d new Date(year, 0, 4, 0, 0, 0),', 'week1monday \x3d new Date(jan4.getTime() - ((jan4.getDay() - 1) * 86400000));', 'v \x3d Ext.Date.clearTime(new Date(week1monday.getTime() + ((W - 1) * 604800000)));', '} else {', 'v \x3d me.add(new Date(y \x3c 100 ? 100 : y, m, d, h, i, s, ms), me.YEAR, y \x3c 100 ? y - 100 : 0);', '}', '}', '}', '}', 'if(v){', 'if(zz !\x3d null){', 'v \x3d me.add(v, me.SECOND, -v.getTimezoneOffset() * 60 - zz);', 
  '}else if(o){', "v \x3d me.add(v, me.MINUTE, -v.getTimezoneOffset() + (sn \x3d\x3d '+'? -1 : 1) * (hr * 60 + mn));", '}', '}', 'return v;'].join('\n');
  function xf(format) {
    var args = Array.prototype.slice.call(arguments, 1);
    return format.replace(numberTokenRe, function(m, i) {
      return args[i];
    });
  }
  Ext.apply(utilDate, {now:Date.now || function() {
    return +new Date;
  }, toString:function(date) {
    var pad = Ext.String.leftPad;
    return date.getFullYear() + '-' + pad(date.getMonth() + 1, 2, '0') + '-' + pad(date.getDate(), 2, '0') + 'T' + pad(date.getHours(), 2, '0') + ':' + pad(date.getMinutes(), 2, '0') + ':' + pad(date.getSeconds(), 2, '0');
  }, getElapsed:function(dateA, dateB) {
    return Math.abs(dateA - (dateB || utilDate.now()));
  }, useStrict:false, formatCodeToRegex:function(character, currentGroup) {
    var p = utilDate.parseCodes[character];
    if (p) {
      p = typeof p == 'function' ? p() : p;
      utilDate.parseCodes[character] = p;
    }
    return p ? Ext.applyIf({c:p.c ? xf(p.c, currentGroup || '{0}') : p.c}, p) : {g:0, c:null, s:Ext.String.escapeRegex(character)};
  }, parseFunctions:{'MS':function(input, strict) {
    var r = (input || '').match(MSFormatRe);
    return r ? new Date(((r[1] || '') + r[2]) * 1) : null;
  }, 'time':function(input, strict) {
    var num = parseInt(input, 10);
    if (num || num === 0) {
      return new Date(num);
    }
    return null;
  }, 'timestamp':function(input, strict) {
    var num = parseInt(input, 10);
    if (num || num === 0) {
      return new Date(num * 1000);
    }
    return null;
  }}, parseRegexes:[], formatFunctions:{'MS':function() {
    return '\\/Date(' + this.getTime() + ')\\/';
  }, 'time':function() {
    return this.getTime().toString();
  }, 'timestamp':function() {
    return utilDate.format(this, 'U');
  }}, y2kYear:50, MILLI:'ms', SECOND:'s', MINUTE:'mi', HOUR:'h', DAY:'d', MONTH:'mo', YEAR:'y', defaults:{}, dayNames:['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'], monthNames:['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'], monthNumbers:{January:0, Jan:0, February:1, Feb:1, March:2, Mar:2, April:3, Apr:3, May:4, June:5, Jun:5, July:6, Jul:6, August:7, Aug:7, September:8, Sep:8, October:9, 
  Oct:9, November:10, Nov:10, December:11, Dec:11}, defaultFormat:'m/d/Y', getShortMonthName:function(month) {
    return Ext.Date.monthNames[month].substring(0, 3);
  }, getShortDayName:function(day) {
    return Ext.Date.dayNames[day].substring(0, 3);
  }, getMonthNumber:function(name) {
    return Ext.Date.monthNumbers[name.substring(0, 1).toUpperCase() + name.substring(1, 3).toLowerCase()];
  }, formatContainsHourInfo:function(format) {
    return hourInfoRe.test(format.replace(stripEscapeRe, ''));
  }, formatContainsDateInfo:function(format) {
    return dateInfoRe.test(format.replace(stripEscapeRe, ''));
  }, unescapeFormat:function(format) {
    return format.replace(slashRe, '');
  }, formatCodes:{d:"Ext.String.leftPad(this.getDate(), 2, '0')", D:'Ext.Date.getShortDayName(this.getDay())', j:'this.getDate()', l:'Ext.Date.dayNames[this.getDay()]', N:'(this.getDay() ? this.getDay() : 7)', S:'Ext.Date.getSuffix(this)', w:'this.getDay()', z:'Ext.Date.getDayOfYear(this)', W:"Ext.String.leftPad(Ext.Date.getWeekOfYear(this), 2, '0')", F:'Ext.Date.monthNames[this.getMonth()]', m:"Ext.String.leftPad(this.getMonth() + 1, 2, '0')", M:'Ext.Date.getShortMonthName(this.getMonth())', n:'(this.getMonth() + 1)', 
  t:'Ext.Date.getDaysInMonth(this)', L:'(Ext.Date.isLeapYear(this) ? 1 : 0)', o:'(this.getFullYear() + (Ext.Date.getWeekOfYear(this) \x3d\x3d 1 \x26\x26 this.getMonth() \x3e 0 ? +1 : (Ext.Date.getWeekOfYear(this) \x3e\x3d 52 \x26\x26 this.getMonth() \x3c 11 ? -1 : 0)))', Y:"Ext.String.leftPad(this.getFullYear(), 4, '0')", y:"('' + this.getFullYear()).substring(2, 4)", a:"(this.getHours() \x3c 12 ? 'am' : 'pm')", A:"(this.getHours() \x3c 12 ? 'AM' : 'PM')", g:'((this.getHours() % 12) ? this.getHours() % 12 : 12)', 
  G:'this.getHours()', h:"Ext.String.leftPad((this.getHours() % 12) ? this.getHours() % 12 : 12, 2, '0')", H:"Ext.String.leftPad(this.getHours(), 2, '0')", i:"Ext.String.leftPad(this.getMinutes(), 2, '0')", s:"Ext.String.leftPad(this.getSeconds(), 2, '0')", u:"Ext.String.leftPad(this.getMilliseconds(), 3, '0')", O:'Ext.Date.getGMTOffset(this)', P:'Ext.Date.getGMTOffset(this, true)', T:'Ext.Date.getTimezone(this)', Z:'(this.getTimezoneOffset() * -60)', c:function() {
    var c, code, i, l, e;
    for (c = 'Y-m-dTH:i:sP', code = [], i = 0, l = c.length; i < l; ++i) {
      e = c.charAt(i);
      code.push(e == 'T' ? "'T'" : utilDate.getFormatCode(e));
    }
    return code.join(' + ');
  }, U:'Math.round(this.getTime() / 1000)'}, isValid:function(y, m, d, h, i, s, ms) {
    h = h || 0;
    i = i || 0;
    s = s || 0;
    ms = ms || 0;
    var dt = utilDate.add(new Date(y < 100 ? 100 : y, m - 1, d, h, i, s, ms), utilDate.YEAR, y < 100 ? y - 100 : 0);
    return y == dt.getFullYear() && m == dt.getMonth() + 1 && d == dt.getDate() && h == dt.getHours() && i == dt.getMinutes() && s == dt.getSeconds() && ms == dt.getMilliseconds();
  }, parse:function(input, format, strict) {
    var p = utilDate.parseFunctions;
    if (p[format] == null) {
      utilDate.createParser(format);
    }
    return p[format].call(utilDate, input, Ext.isDefined(strict) ? strict : utilDate.useStrict);
  }, parseDate:function(input, format, strict) {
    return utilDate.parse(input, format, strict);
  }, getFormatCode:function(character) {
    var f = utilDate.formatCodes[character];
    if (f) {
      f = typeof f == 'function' ? f() : f;
      utilDate.formatCodes[character] = f;
    }
    return f || "'" + Ext.String.escape(character) + "'";
  }, createFormat:function(format) {
    var code = [], special = false, ch = '', i;
    for (i = 0; i < format.length; ++i) {
      ch = format.charAt(i);
      if (!special && ch == '\\') {
        special = true;
      } else {
        if (special) {
          special = false;
          code.push("'" + Ext.String.escape(ch) + "'");
        } else {
          code.push(utilDate.getFormatCode(ch));
        }
      }
    }
    utilDate.formatFunctions[format] = Ext.functionFactory('return ' + code.join('+'));
  }, createParser:function(format) {
    var regexNum = utilDate.parseRegexes.length, currentGroup = 1, calc = [], regex = [], special = false, ch = '', i = 0, len = format.length, atEnd = [], obj;
    for (; i < len; ++i) {
      ch = format.charAt(i);
      if (!special && ch == '\\') {
        special = true;
      } else {
        if (special) {
          special = false;
          regex.push(Ext.String.escape(ch));
        } else {
          obj = utilDate.formatCodeToRegex(ch, currentGroup);
          currentGroup += obj.g;
          regex.push(obj.s);
          if (obj.g && obj.c) {
            if (obj.calcAtEnd) {
              atEnd.push(obj.c);
            } else {
              calc.push(obj.c);
            }
          }
        }
      }
    }
    calc = calc.concat(atEnd);
    utilDate.parseRegexes[regexNum] = new RegExp('^' + regex.join('') + '$', 'i');
    utilDate.parseFunctions[format] = Ext.functionFactory('input', 'strict', xf(code, regexNum, calc.join('')));
  }, parseCodes:{d:{g:1, c:'d \x3d parseInt(results[{0}], 10);\n', s:'(3[0-1]|[1-2][0-9]|0[1-9])'}, j:{g:1, c:'d \x3d parseInt(results[{0}], 10);\n', s:'(3[0-1]|[1-2][0-9]|[1-9])'}, D:function() {
    for (var a = [], i = 0; i < 7; a.push(utilDate.getShortDayName(i)), ++i) {
    }
    return {g:0, c:null, s:'(?:' + a.join('|') + ')'};
  }, l:function() {
    return {g:0, c:null, s:'(?:' + utilDate.dayNames.join('|') + ')'};
  }, N:{g:0, c:null, s:'[1-7]'}, S:{g:0, c:null, s:'(?:st|nd|rd|th)'}, w:{g:0, c:null, s:'[0-6]'}, z:{g:1, c:'z \x3d parseInt(results[{0}], 10);\n', s:'(\\d{1,3})'}, W:{g:1, c:'W \x3d parseInt(results[{0}], 10);\n', s:'(\\d{2})'}, F:function() {
    return {g:1, c:'m \x3d parseInt(me.getMonthNumber(results[{0}]), 10);\n', s:'(' + utilDate.monthNames.join('|') + ')'};
  }, M:function() {
    for (var a = [], i = 0; i < 12; a.push(utilDate.getShortMonthName(i)), ++i) {
    }
    return Ext.applyIf({s:'(' + a.join('|') + ')'}, utilDate.formatCodeToRegex('F'));
  }, m:{g:1, c:'m \x3d parseInt(results[{0}], 10) - 1;\n', s:'(1[0-2]|0[1-9])'}, n:{g:1, c:'m \x3d parseInt(results[{0}], 10) - 1;\n', s:'(1[0-2]|[1-9])'}, t:{g:0, c:null, s:'(?:\\d{2})'}, L:{g:0, c:null, s:'(?:1|0)'}, o:{g:1, c:'y \x3d parseInt(results[{0}], 10);\n', s:'(\\d{4})'}, Y:{g:1, c:'y \x3d parseInt(results[{0}], 10);\n', s:'(\\d{4})'}, y:{g:1, c:'var ty \x3d parseInt(results[{0}], 10);\n' + 'y \x3d ty \x3e me.y2kYear ? 1900 + ty : 2000 + ty;\n', s:'(\\d{1,2})'}, a:{g:1, c:'if (/(am)/i.test(results[{0}])) {\n' + 
  'if (!h || h \x3d\x3d 12) { h \x3d 0; }\n' + '} else { if (!h || h \x3c 12) { h \x3d (h || 0) + 12; }}', s:'(am|pm|AM|PM)', calcAtEnd:true}, A:{g:1, c:'if (/(am)/i.test(results[{0}])) {\n' + 'if (!h || h \x3d\x3d 12) { h \x3d 0; }\n' + '} else { if (!h || h \x3c 12) { h \x3d (h || 0) + 12; }}', s:'(AM|PM|am|pm)', calcAtEnd:true}, g:{g:1, c:'h \x3d parseInt(results[{0}], 10);\n', s:'(1[0-2]|[0-9])'}, G:{g:1, c:'h \x3d parseInt(results[{0}], 10);\n', s:'(2[0-3]|1[0-9]|[0-9])'}, h:{g:1, c:'h \x3d parseInt(results[{0}], 10);\n', 
  s:'(1[0-2]|0[1-9])'}, H:{g:1, c:'h \x3d parseInt(results[{0}], 10);\n', s:'(2[0-3]|[0-1][0-9])'}, i:{g:1, c:'i \x3d parseInt(results[{0}], 10);\n', s:'([0-5][0-9])'}, s:{g:1, c:'s \x3d parseInt(results[{0}], 10);\n', s:'([0-5][0-9])'}, u:{g:1, c:'ms \x3d results[{0}]; ms \x3d parseInt(ms, 10)/Math.pow(10, ms.length - 3);\n', s:'(\\d+)'}, O:{g:1, c:['o \x3d results[{0}];', 'var sn \x3d o.substring(0,1),', 'hr \x3d o.substring(1,3)*1 + Math.floor(o.substring(3,5) / 60),', 'mn \x3d o.substring(3,5) % 60;', 
  "o \x3d ((-12 \x3c\x3d (hr*60 + mn)/60) \x26\x26 ((hr*60 + mn)/60 \x3c\x3d 14))? (sn + Ext.String.leftPad(hr, 2, '0') + Ext.String.leftPad(mn, 2, '0')) : null;\n"].join('\n'), s:'([+-]\\d{4})'}, P:{g:1, c:['o \x3d results[{0}];', 'var sn \x3d o.substring(0,1),', 'hr \x3d o.substring(1,3)*1 + Math.floor(o.substring(4,6) / 60),', 'mn \x3d o.substring(4,6) % 60;', "o \x3d ((-12 \x3c\x3d (hr*60 + mn)/60) \x26\x26 ((hr*60 + mn)/60 \x3c\x3d 14))? (sn + Ext.String.leftPad(hr, 2, '0') + Ext.String.leftPad(mn, 2, '0')) : null;\n"].join('\n'), 
  s:'([+-]\\d{2}:\\d{2})'}, T:{g:0, c:null, s:'[A-Z]{1,5}'}, Z:{g:1, c:'zz \x3d results[{0}] * 1;\n' + 'zz \x3d (-43200 \x3c\x3d zz \x26\x26 zz \x3c\x3d 50400)? zz : null;\n', s:'([+-]?\\d{1,5})'}, c:function() {
    var calc = [], arr = [utilDate.formatCodeToRegex('Y', 1), utilDate.formatCodeToRegex('m', 2), utilDate.formatCodeToRegex('d', 3), utilDate.formatCodeToRegex('H', 4), utilDate.formatCodeToRegex('i', 5), utilDate.formatCodeToRegex('s', 6), {c:"ms \x3d results[7] || '0'; ms \x3d parseInt(ms, 10)/Math.pow(10, ms.length - 3);\n"}, {c:['if(results[8]) {', "if(results[8] \x3d\x3d 'Z'){", 'zz \x3d 0;', "}else if (results[8].indexOf(':') \x3e -1){", utilDate.formatCodeToRegex('P', 8).c, '}else{', utilDate.formatCodeToRegex('O', 
    8).c, '}', '}'].join('\n')}], i, l;
    for (i = 0, l = arr.length; i < l; ++i) {
      calc.push(arr[i].c);
    }
    return {g:1, c:calc.join(''), s:[arr[0].s, '(?:', '-', arr[1].s, '(?:', '-', arr[2].s, '(?:', '(?:T| )?', arr[3].s, ':', arr[4].s, '(?::', arr[5].s, ')?', '(?:(?:\\.|,)(\\d+))?', '(Z|(?:[-+]\\d{2}(?::)?\\d{2}))?', ')?', ')?', ')?'].join('')};
  }, U:{g:1, c:'u \x3d parseInt(results[{0}], 10);\n', s:'(-?\\d+)'}}, dateFormat:function(date, format) {
    return utilDate.format(date, format);
  }, isEqual:function(date1, date2) {
    if (date1 && date2) {
      return date1.getTime() === date2.getTime();
    }
    return !(date1 || date2);
  }, format:function(date, format) {
    var formatFunctions = utilDate.formatFunctions;
    if (!Ext.isDate(date)) {
      return '';
    }
    if (formatFunctions[format] == null) {
      utilDate.createFormat(format);
    }
    return formatFunctions[format].call(date) + '';
  }, getTimezone:function(date) {
    return date.toString().replace(/^.* (?:\((.*)\)|([A-Z]{1,5})(?:[\-+][0-9]{4})?(?: -?\d+)?)$/, '$1$2').replace(/[^A-Z]/g, '');
  }, getGMTOffset:function(date, colon) {
    var offset = date.getTimezoneOffset();
    return (offset > 0 ? '-' : '+') + Ext.String.leftPad(Math.floor(Math.abs(offset) / 60), 2, '0') + (colon ? ':' : '') + Ext.String.leftPad(Math.abs(offset % 60), 2, '0');
  }, getDayOfYear:function(date) {
    var num = 0, d = Ext.Date.clone(date), m = date.getMonth(), i;
    for (i = 0, d.setDate(1), d.setMonth(0); i < m; d.setMonth(++i)) {
      num += utilDate.getDaysInMonth(d);
    }
    return num + date.getDate() - 1;
  }, getWeekOfYear:function() {
    var ms1d = 86400000, ms7d = 7 * ms1d;
    return function(date) {
      var DC3 = Date.UTC(date.getFullYear(), date.getMonth(), date.getDate() + 3) / ms1d, AWN = Math.floor(DC3 / 7), Wyr = (new Date(AWN * ms7d)).getUTCFullYear();
      return AWN - Math.floor(Date.UTC(Wyr, 0, 7) / ms7d) + 1;
    };
  }(), isLeapYear:function(date) {
    var year = date.getFullYear();
    return !!((year & 3) == 0 && (year % 100 || year % 400 == 0 && year));
  }, getFirstDayOfMonth:function(date) {
    var day = (date.getDay() - (date.getDate() - 1)) % 7;
    return day < 0 ? day + 7 : day;
  }, getLastDayOfMonth:function(date) {
    return utilDate.getLastDateOfMonth(date).getDay();
  }, getFirstDateOfMonth:function(date) {
    return new Date(date.getFullYear(), date.getMonth(), 1);
  }, getLastDateOfMonth:function(date) {
    return new Date(date.getFullYear(), date.getMonth(), utilDate.getDaysInMonth(date));
  }, getDaysInMonth:function() {
    var daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    return function(date) {
      var m = date.getMonth();
      return m == 1 && utilDate.isLeapYear(date) ? 29 : daysInMonth[m];
    };
  }(), getSuffix:function(date) {
    switch(date.getDate()) {
      case 1:
      case 21:
      case 31:
        return 'st';
      case 2:
      case 22:
        return 'nd';
      case 3:
      case 23:
        return 'rd';
      default:
        return 'th';
    }
  }, clone:function(date) {
    return new Date(date.getTime());
  }, isDST:function(date) {
    return (new Date(date.getFullYear(), 0, 1)).getTimezoneOffset() != date.getTimezoneOffset();
  }, clearTime:function(date, clone) {
    if (clone) {
      return Ext.Date.clearTime(Ext.Date.clone(date));
    }
    var d = date.getDate(), hr, c;
    date.setHours(0);
    date.setMinutes(0);
    date.setSeconds(0);
    date.setMilliseconds(0);
    if (date.getDate() != d) {
      for (hr = 1, c = utilDate.add(date, Ext.Date.HOUR, hr); c.getDate() != d; hr++, c = utilDate.add(date, Ext.Date.HOUR, hr)) {
      }
      date.setDate(d);
      date.setHours(c.getHours());
    }
    return date;
  }, add:function(date, interval, value) {
    var d = Ext.Date.clone(date), Date = Ext.Date, day, decimalValue, base = 0;
    if (!interval || value === 0) {
      return d;
    }
    decimalValue = value - parseInt(value, 10);
    value = parseInt(value, 10);
    if (value) {
      switch(interval.toLowerCase()) {
        case Ext.Date.MILLI:
          d.setTime(d.getTime() + value);
          break;
        case Ext.Date.SECOND:
          d.setTime(d.getTime() + value * 1000);
          break;
        case Ext.Date.MINUTE:
          d.setTime(d.getTime() + value * 60 * 1000);
          break;
        case Ext.Date.HOUR:
          d.setTime(d.getTime() + value * 60 * 60 * 1000);
          break;
        case Ext.Date.DAY:
          d.setDate(d.getDate() + value);
          break;
        case Ext.Date.MONTH:
          day = date.getDate();
          if (day > 28) {
            day = Math.min(day, Ext.Date.getLastDateOfMonth(Ext.Date.add(Ext.Date.getFirstDateOfMonth(date), Ext.Date.MONTH, value)).getDate());
          }
          d.setDate(day);
          d.setMonth(date.getMonth() + value);
          break;
        case Ext.Date.YEAR:
          day = date.getDate();
          if (day > 28) {
            day = Math.min(day, Ext.Date.getLastDateOfMonth(Ext.Date.add(Ext.Date.getFirstDateOfMonth(date), Ext.Date.YEAR, value)).getDate());
          }
          d.setDate(day);
          d.setFullYear(date.getFullYear() + value);
          break;
      }
    }
    if (decimalValue) {
      switch(interval.toLowerCase()) {
        case Ext.Date.MILLI:
          base = 1;
          break;
        case Ext.Date.SECOND:
          base = 1000;
          break;
        case Ext.Date.MINUTE:
          base = 1000 * 60;
          break;
        case Ext.Date.HOUR:
          base = 1000 * 60 * 60;
          break;
        case Ext.Date.DAY:
          base = 1000 * 60 * 60 * 24;
          break;
        case Ext.Date.MONTH:
          day = utilDate.getDaysInMonth(d);
          base = 1000 * 60 * 60 * 24 * day;
          break;
        case Ext.Date.YEAR:
          day = utilDate.isLeapYear(d) ? 366 : 365;
          base = 1000 * 60 * 60 * 24 * day;
          break;
      }
      if (base) {
        d.setTime(d.getTime() + base * decimalValue);
      }
    }
    return d;
  }, subtract:function(date, interval, value) {
    return utilDate.add(date, interval, -value);
  }, between:function(date, start, end) {
    var t = date.getTime();
    return start.getTime() <= t && t <= end.getTime();
  }, compat:function() {
    var nativeDate = window.Date, p, statics = ['useStrict', 'formatCodeToRegex', 'parseFunctions', 'parseRegexes', 'formatFunctions', 'y2kYear', 'MILLI', 'SECOND', 'MINUTE', 'HOUR', 'DAY', 'MONTH', 'YEAR', 'defaults', 'dayNames', 'monthNames', 'monthNumbers', 'getShortMonthName', 'getShortDayName', 'getMonthNumber', 'formatCodes', 'isValid', 'parseDate', 'getFormatCode', 'createFormat', 'createParser', 'parseCodes'], proto = ['dateFormat', 'format', 'getTimezone', 'getGMTOffset', 'getDayOfYear', 
    'getWeekOfYear', 'isLeapYear', 'getFirstDayOfMonth', 'getLastDayOfMonth', 'getDaysInMonth', 'getSuffix', 'clone', 'isDST', 'clearTime', 'add', 'between'], sLen = statics.length, pLen = proto.length, stat, prot, s;
    for (s = 0; s < sLen; s++) {
      stat = statics[s];
      nativeDate[stat] = utilDate[stat];
    }
    for (p = 0; p < pLen; p++) {
      prot = proto[p];
      nativeDate.prototype[prot] = function() {
        var args = Array.prototype.slice.call(arguments);
        args.unshift(this);
        return utilDate[prot].apply(utilDate, args);
      };
    }
  }});
};
(function(flexSetter) {
  var noArgs = [], Base = function() {
  }, hookFunctionFactory = function(hookFunction, underriddenFunction, methodName, owningClass) {
    var result = function() {
      var result = this.callParent(arguments);
      hookFunction.apply(this, arguments);
      return result;
    };
    result.$name = methodName;
    result.$owner = owningClass;
    if (underriddenFunction) {
      result.$previous = underriddenFunction.$previous;
      underriddenFunction.$previous = result;
    }
    return result;
  };
  Ext.apply(Base, {$className:'Ext.Base', $isClass:true, create:function() {
    return Ext.create.apply(Ext, [this].concat(Array.prototype.slice.call(arguments, 0)));
  }, extend:function(parent) {
    var parentPrototype = parent.prototype, basePrototype, prototype, i, ln, name, statics;
    prototype = this.prototype = Ext.Object.chain(parentPrototype);
    prototype.self = this;
    this.superclass = prototype.superclass = parentPrototype;
    if (!parent.$isClass) {
      basePrototype = Ext.Base.prototype;
      for (i in basePrototype) {
        if (i in prototype) {
          prototype[i] = basePrototype[i];
        }
      }
    }
    statics = parentPrototype.$inheritableStatics;
    if (statics) {
      for (i = 0, ln = statics.length; i < ln; i++) {
        name = statics[i];
        if (!this.hasOwnProperty(name)) {
          this[name] = parent[name];
        }
      }
    }
    if (parent.$onExtended) {
      this.$onExtended = parent.$onExtended.slice();
    }
    prototype.config = new prototype.configClass;
    prototype.initConfigList = prototype.initConfigList.slice();
    prototype.initConfigMap = Ext.clone(prototype.initConfigMap);
    prototype.configMap = Ext.Object.chain(prototype.configMap);
  }, $onExtended:[], triggerExtended:function() {
    Ext.classSystemMonitor && Ext.classSystemMonitor(this, 'Ext.Base#triggerExtended', arguments);
    var callbacks = this.$onExtended, ln = callbacks.length, i, callback;
    if (ln > 0) {
      for (i = 0; i < ln; i++) {
        callback = callbacks[i];
        callback.fn.apply(callback.scope || this, arguments);
      }
    }
  }, onExtended:function(fn, scope) {
    this.$onExtended.push({fn:fn, scope:scope});
    return this;
  }, addConfig:function(config, fullMerge) {
    var prototype = this.prototype, configNameCache = Ext.Class.configNameCache, hasConfig = prototype.configMap, initConfigList = prototype.initConfigList, initConfigMap = prototype.initConfigMap, defaultConfig = prototype.config, initializedName, name, value;
    for (name in config) {
      if (config.hasOwnProperty(name)) {
        if (!hasConfig[name]) {
          hasConfig[name] = true;
        }
        value = config[name];
        initializedName = configNameCache[name].initialized;
        if (!initConfigMap[name] && value !== null && !prototype[initializedName]) {
          initConfigMap[name] = true;
          initConfigList.push(name);
        }
      }
    }
    if (fullMerge) {
      Ext.merge(defaultConfig, config);
    } else {
      Ext.mergeIf(defaultConfig, config);
    }
    prototype.configClass = Ext.Object.classify(defaultConfig);
  }, addStatics:function(members) {
    var member, name;
    for (name in members) {
      if (members.hasOwnProperty(name)) {
        member = members[name];
        if (typeof member == 'function' && !member.$isClass && member !== Ext.emptyFn && member !== Ext.identityFn) {
          member.$owner = this;
          member.$name = name;
          member.displayName = Ext.getClassName(this) + '.' + name;
        }
        this[name] = member;
      }
    }
    return this;
  }, addInheritableStatics:function(members) {
    var inheritableStatics, hasInheritableStatics, prototype = this.prototype, name, member;
    inheritableStatics = prototype.$inheritableStatics;
    hasInheritableStatics = prototype.$hasInheritableStatics;
    if (!inheritableStatics) {
      inheritableStatics = prototype.$inheritableStatics = [];
      hasInheritableStatics = prototype.$hasInheritableStatics = {};
    }
    for (name in members) {
      if (members.hasOwnProperty(name)) {
        member = members[name];
        if (typeof member == 'function') {
          member.displayName = Ext.getClassName(this) + '.' + name;
        }
        this[name] = member;
        if (!hasInheritableStatics[name]) {
          hasInheritableStatics[name] = true;
          inheritableStatics.push(name);
        }
      }
    }
    return this;
  }, addMembers:function(members) {
    var prototype = this.prototype, enumerables = Ext.enumerables, names = [], i, ln, name, member;
    for (name in members) {
      names.push(name);
    }
    if (enumerables) {
      names.push.apply(names, enumerables);
    }
    for (i = 0, ln = names.length; i < ln; i++) {
      name = names[i];
      if (members.hasOwnProperty(name)) {
        member = members[name];
        if (typeof member == 'function' && !member.$isClass && member !== Ext.emptyFn && member !== Ext.identityFn) {
          member.$owner = this;
          member.$name = name;
          member.displayName = (this.$className || '') + '#' + name;
        }
        prototype[name] = member;
      }
    }
    return this;
  }, addMember:function(name, member) {
    if (typeof member == 'function' && !member.$isClass && member !== Ext.emptyFn && member !== Ext.identityFn) {
      member.$owner = this;
      member.$name = name;
      member.displayName = (this.$className || '') + '#' + name;
    }
    this.prototype[name] = member;
    return this;
  }, implement:function() {
    this.addMembers.apply(this, arguments);
  }, borrow:function(fromClass, members) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(this, 'Ext.Base#borrow', arguments);
    var prototype = this.prototype, fromPrototype = fromClass.prototype, className = Ext.getClassName(this), i, ln, name, fn, toBorrow;
    members = Ext.Array.from(members);
    for (i = 0, ln = members.length; i < ln; i++) {
      name = members[i];
      toBorrow = fromPrototype[name];
      if (typeof toBorrow == 'function') {
        fn = Ext.Function.clone(toBorrow);
        if (className) {
          fn.displayName = className + '#' + name;
        }
        fn.$owner = this;
        fn.$name = name;
        prototype[name] = fn;
      } else {
        prototype[name] = toBorrow;
      }
    }
    return this;
  }, override:function(members) {
    var me = this, enumerables = Ext.enumerables, target = me.prototype, cloneFunction = Ext.Function.clone, name, index, member, statics, names, previous;
    if (arguments.length === 2) {
      name = members;
      members = {};
      members[name] = arguments[1];
      enumerables = null;
    }
    do {
      names = [];
      statics = null;
      for (name in members) {
        if (name == 'statics') {
          statics = members[name];
        } else {
          if (name == 'inheritableStatics') {
            me.addInheritableStatics(members[name]);
          } else {
            if (name == 'config') {
              me.addConfig(members[name], true);
            } else {
              names.push(name);
            }
          }
        }
      }
      if (enumerables) {
        names.push.apply(names, enumerables);
      }
      for (index = names.length; index--;) {
        name = names[index];
        if (members.hasOwnProperty(name)) {
          member = members[name];
          if (typeof member == 'function' && !member.$className && member !== Ext.emptyFn && member !== Ext.identityFn) {
            if (typeof member.$owner != 'undefined') {
              member = cloneFunction(member);
            }
            if (me.$className) {
              member.displayName = me.$className + '#' + name;
            }
            member.$owner = me;
            member.$name = name;
            previous = target[name];
            if (previous) {
              member.$previous = previous;
            }
          }
          target[name] = member;
        }
      }
      target = me;
      members = statics;
    } while (members);
    return this;
  }, callParent:function(args) {
    var method;
    return (method = this.callParent.caller) && (method.$previous || (method = method.$owner ? method : method.caller) && method.$owner.superclass.self[method.$name]).apply(this, args || noArgs);
  }, callSuper:function(args) {
    var method;
    return (method = this.callSuper.caller) && ((method = method.$owner ? method : method.caller) && method.$owner.superclass.self[method.$name]).apply(this, args || noArgs);
  }, mixin:function(name, mixinClass) {
    var me = this, mixin = mixinClass.prototype, prototype = me.prototype, key, statics, i, ln, staticName, mixinValue, hookKey, hookFunction;
    if (typeof mixin.onClassMixedIn != 'undefined') {
      mixin.onClassMixedIn.call(mixinClass, me);
    }
    if (!prototype.hasOwnProperty('mixins')) {
      if ('mixins' in prototype) {
        prototype.mixins = Ext.Object.chain(prototype.mixins);
      } else {
        prototype.mixins = {};
      }
    }
    for (key in mixin) {
      mixinValue = mixin[key];
      if (key === 'mixins') {
        Ext.merge(prototype.mixins, mixinValue);
      } else {
        if (key === 'xhooks') {
          for (hookKey in mixinValue) {
            hookFunction = mixinValue[hookKey];
            hookFunction.$previous = Ext.emptyFn;
            if (prototype.hasOwnProperty(hookKey)) {
              hookFunctionFactory(hookFunction, prototype[hookKey], hookKey, me);
            } else {
              prototype[hookKey] = hookFunctionFactory(hookFunction, null, hookKey, me);
            }
          }
        } else {
          if (!(key === 'mixinId' || key === 'config') && prototype[key] === undefined) {
            prototype[key] = mixinValue;
          }
        }
      }
    }
    statics = mixin.$inheritableStatics;
    if (statics) {
      for (i = 0, ln = statics.length; i < ln; i++) {
        staticName = statics[i];
        if (!me.hasOwnProperty(staticName)) {
          me[staticName] = mixinClass[staticName];
        }
      }
    }
    if ('config' in mixin) {
      me.addConfig(mixin.config, false);
    }
    prototype.mixins[name] = mixin;
    return me;
  }, getName:function() {
    return Ext.getClassName(this);
  }, createAlias:flexSetter(function(alias, origin) {
    this.override(alias, function() {
      return this[origin].apply(this, arguments);
    });
  }), addXtype:function(xtype) {
    var prototype = this.prototype, xtypesMap = prototype.xtypesMap, xtypes = prototype.xtypes, xtypesChain = prototype.xtypesChain;
    if (!prototype.hasOwnProperty('xtypesMap')) {
      xtypesMap = prototype.xtypesMap = Ext.merge({}, prototype.xtypesMap || {});
      xtypes = prototype.xtypes = prototype.xtypes ? [].concat(prototype.xtypes) : [];
      xtypesChain = prototype.xtypesChain = prototype.xtypesChain ? [].concat(prototype.xtypesChain) : [];
      prototype.xtype = xtype;
    }
    if (!xtypesMap[xtype]) {
      xtypesMap[xtype] = true;
      xtypes.push(xtype);
      xtypesChain.push(xtype);
      Ext.ClassManager.setAlias(this, 'widget.' + xtype);
    }
    return this;
  }});
  Base.implement({isInstance:true, $className:'Ext.Base', configClass:Ext.emptyFn, initConfigList:[], configMap:{}, initConfigMap:{}, statics:function() {
    var method = this.statics.caller, self = this.self;
    if (!method) {
      return self;
    }
    return method.$owner;
  }, callParent:function(args) {
    var method, superMethod = (method = this.callParent.caller) && (method.$previous || (method = method.$owner ? method : method.caller) && method.$owner.superclass[method.$name]);
    if (!superMethod) {
      method = this.callParent.caller;
      var parentClass, methodName;
      if (!method.$owner) {
        if (!method.caller) {
          throw new Error('Attempting to call a protected method from the public scope, which is not allowed');
        }
        method = method.caller;
      }
      parentClass = method.$owner.superclass;
      methodName = method.$name;
      if (!(methodName in parentClass)) {
        throw new Error("this.callParent() was called but there's no such method (" + methodName + ') found in the parent class (' + (Ext.getClassName(parentClass) || 'Object') + ')');
      }
    }
    return superMethod.apply(this, args || noArgs);
  }, callSuper:function(args) {
    var method, superMethod = (method = this.callSuper.caller) && ((method = method.$owner ? method : method.caller) && method.$owner.superclass[method.$name]);
    if (!superMethod) {
      method = this.callSuper.caller;
      var parentClass, methodName;
      if (!method.$owner) {
        if (!method.caller) {
          throw new Error('Attempting to call a protected method from the public scope, which is not allowed');
        }
        method = method.caller;
      }
      parentClass = method.$owner.superclass;
      methodName = method.$name;
      if (!(methodName in parentClass)) {
        throw new Error("this.callSuper() was called but there's no such method (" + methodName + ') found in the parent class (' + (Ext.getClassName(parentClass) || 'Object') + ')');
      }
    }
    return superMethod.apply(this, args || noArgs);
  }, self:Base, constructor:function() {
    return this;
  }, initConfig:function(config) {
    var instanceConfig = config, configNameCache = Ext.Class.configNameCache, defaultConfig = new this.configClass, defaultConfigList = this.initConfigList, hasConfig = this.configMap, nameMap, i, ln, name, initializedName;
    this.initConfig = Ext.emptyFn;
    this.initialConfig = instanceConfig || {};
    this.config = config = instanceConfig ? Ext.merge(defaultConfig, config) : defaultConfig;
    if (instanceConfig) {
      defaultConfigList = defaultConfigList.slice();
      for (name in instanceConfig) {
        if (hasConfig[name]) {
          if (instanceConfig[name] !== null) {
            defaultConfigList.push(name);
            this[configNameCache[name].initialized] = false;
          }
        }
      }
    }
    for (i = 0, ln = defaultConfigList.length; i < ln; i++) {
      name = defaultConfigList[i];
      nameMap = configNameCache[name];
      initializedName = nameMap.initialized;
      if (!this[initializedName]) {
        this[initializedName] = true;
        this[nameMap.set].call(this, config[name]);
      }
    }
    return this;
  }, hasConfig:function(name) {
    return Boolean(this.configMap[name]);
  }, setConfig:function(config, applyIfNotSet) {
    if (!config) {
      return this;
    }
    var configNameCache = Ext.Class.configNameCache, currentConfig = this.config, hasConfig = this.configMap, initialConfig = this.initialConfig, name, value;
    applyIfNotSet = Boolean(applyIfNotSet);
    for (name in config) {
      if (applyIfNotSet && initialConfig.hasOwnProperty(name)) {
        continue;
      }
      value = config[name];
      currentConfig[name] = value;
      if (hasConfig[name]) {
        this[configNameCache[name].set](value);
      }
    }
    return this;
  }, getConfig:function(name) {
    var configNameCache = Ext.Class.configNameCache;
    return this[configNameCache[name].get]();
  }, getInitialConfig:function(name) {
    var config = this.config;
    if (!name) {
      return config;
    } else {
      return config[name];
    }
  }, onConfigUpdate:function(names, callback, scope) {
    var self = this.self, className = self.$className, i, ln, name, updaterName, updater, newUpdater;
    names = Ext.Array.from(names);
    scope = scope || this;
    for (i = 0, ln = names.length; i < ln; i++) {
      name = names[i];
      updaterName = 'update' + Ext.String.capitalize(name);
      updater = this[updaterName] || Ext.emptyFn;
      newUpdater = function() {
        updater.apply(this, arguments);
        scope[callback].apply(scope, arguments);
      };
      newUpdater.$name = updaterName;
      newUpdater.$owner = self;
      newUpdater.displayName = className + '#' + updaterName;
      this[updaterName] = newUpdater;
    }
  }, destroy:function() {
    this.destroy = Ext.emptyFn;
  }});
  Base.prototype.callOverridden = Base.prototype.callParent;
  Ext.Base = Base;
})(Ext.Function.flexSetter);
(function() {
  var ExtClass, Base = Ext.Base, baseStaticMembers = [], baseStaticMember, baseStaticMemberLength;
  for (baseStaticMember in Base) {
    if (Base.hasOwnProperty(baseStaticMember)) {
      baseStaticMembers.push(baseStaticMember);
    }
  }
  baseStaticMemberLength = baseStaticMembers.length;
  function makeCtor(className) {
    function constructor() {
      return this.constructor.apply(this, arguments) || null;
    }
    if (className) {
      constructor.displayName = className;
    }
    return constructor;
  }
  Ext.Class = ExtClass = function(Class, data, onCreated) {
    if (typeof Class != 'function') {
      onCreated = data;
      data = Class;
      Class = null;
    }
    if (!data) {
      data = {};
    }
    Class = ExtClass.create(Class, data);
    ExtClass.process(Class, data, onCreated);
    return Class;
  };
  Ext.apply(ExtClass, {onBeforeCreated:function(Class, data, hooks) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(Class, '\x3e\x3e Ext.Class#onBeforeCreated', arguments);
    Class.addMembers(data);
    hooks.onCreated.call(Class, Class);
    Ext.classSystemMonitor && Ext.classSystemMonitor(Class, '\x3c\x3c Ext.Class#onBeforeCreated', arguments);
  }, create:function(Class, data) {
    var name, i;
    if (!Class) {
      Class = makeCtor(data.$className);
    }
    for (i = 0; i < baseStaticMemberLength; i++) {
      name = baseStaticMembers[i];
      Class[name] = Base[name];
    }
    return Class;
  }, process:function(Class, data, onCreated) {
    var preprocessorStack = data.preprocessors || ExtClass.defaultPreprocessors, registeredPreprocessors = this.preprocessors, hooks = {onBeforeCreated:this.onBeforeCreated}, preprocessors = [], preprocessor, preprocessorsProperties, i, ln, j, subLn, preprocessorProperty;
    delete data.preprocessors;
    for (i = 0, ln = preprocessorStack.length; i < ln; i++) {
      preprocessor = preprocessorStack[i];
      if (typeof preprocessor == 'string') {
        preprocessor = registeredPreprocessors[preprocessor];
        preprocessorsProperties = preprocessor.properties;
        if (preprocessorsProperties === true) {
          preprocessors.push(preprocessor.fn);
        } else {
          if (preprocessorsProperties) {
            for (j = 0, subLn = preprocessorsProperties.length; j < subLn; j++) {
              preprocessorProperty = preprocessorsProperties[j];
              if (data.hasOwnProperty(preprocessorProperty)) {
                preprocessors.push(preprocessor.fn);
                break;
              }
            }
          }
        }
      } else {
        preprocessors.push(preprocessor);
      }
    }
    hooks.onCreated = onCreated ? onCreated : Ext.emptyFn;
    hooks.preprocessors = preprocessors;
    this.doProcess(Class, data, hooks);
  }, doProcess:function(Class, data, hooks) {
    var me = this, preprocessors = hooks.preprocessors, preprocessor = preprocessors.shift(), doProcess = me.doProcess;
    for (; preprocessor; preprocessor = preprocessors.shift()) {
      if (preprocessor.call(me, Class, data, hooks, doProcess) === false) {
        return;
      }
    }
    hooks.onBeforeCreated.apply(me, arguments);
  }, preprocessors:{}, registerPreprocessor:function(name, fn, properties, position, relativeTo) {
    if (!position) {
      position = 'last';
    }
    if (!properties) {
      properties = [name];
    }
    this.preprocessors[name] = {name:name, properties:properties || false, fn:fn};
    this.setDefaultPreprocessorPosition(name, position, relativeTo);
    return this;
  }, getPreprocessor:function(name) {
    return this.preprocessors[name];
  }, getPreprocessors:function() {
    return this.preprocessors;
  }, defaultPreprocessors:[], getDefaultPreprocessors:function() {
    return this.defaultPreprocessors;
  }, setDefaultPreprocessors:function(preprocessors) {
    this.defaultPreprocessors = Ext.Array.from(preprocessors);
    return this;
  }, setDefaultPreprocessorPosition:function(name, offset, relativeName) {
    var defaultPreprocessors = this.defaultPreprocessors, index;
    if (typeof offset == 'string') {
      if (offset === 'first') {
        defaultPreprocessors.unshift(name);
        return this;
      } else {
        if (offset === 'last') {
          defaultPreprocessors.push(name);
          return this;
        }
      }
      offset = offset === 'after' ? 1 : -1;
    }
    index = Ext.Array.indexOf(defaultPreprocessors, relativeName);
    if (index !== -1) {
      Ext.Array.splice(defaultPreprocessors, Math.max(0, index + offset), 0, name);
    }
    return this;
  }, configNameCache:{}, getConfigNameMap:function(name) {
    var cache = this.configNameCache, map = cache[name], capitalizedName;
    if (!map) {
      capitalizedName = name.charAt(0).toUpperCase() + name.substr(1);
      map = cache[name] = {internal:name, initialized:'_is' + capitalizedName + 'Initialized', apply:'apply' + capitalizedName, update:'update' + capitalizedName, 'set':'set' + capitalizedName, 'get':'get' + capitalizedName, doSet:'doSet' + capitalizedName, changeEvent:name.toLowerCase() + 'change'};
    }
    return map;
  }});
  ExtClass.registerPreprocessor('extend', function(Class, data, hooks) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(Class, 'Ext.Class#extendPreProcessor', arguments);
    var Base = Ext.Base, basePrototype = Base.prototype, extend = data.extend, Parent, parentPrototype, i;
    delete data.extend;
    if (extend && extend !== Object) {
      Parent = extend;
    } else {
      Parent = Base;
    }
    parentPrototype = Parent.prototype;
    if (!Parent.$isClass) {
      for (i in basePrototype) {
        if (!parentPrototype[i]) {
          parentPrototype[i] = basePrototype[i];
        }
      }
    }
    Class.extend(Parent);
    Class.triggerExtended.apply(Class, arguments);
    if (data.onClassExtended) {
      Class.onExtended(data.onClassExtended, Class);
      delete data.onClassExtended;
    }
  }, true);
  ExtClass.registerPreprocessor('statics', function(Class, data) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(Class, 'Ext.Class#staticsPreprocessor', arguments);
    Class.addStatics(data.statics);
    delete data.statics;
  });
  ExtClass.registerPreprocessor('inheritableStatics', function(Class, data) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(Class, 'Ext.Class#inheritableStaticsPreprocessor', arguments);
    Class.addInheritableStatics(data.inheritableStatics);
    delete data.inheritableStatics;
  });
  ExtClass.registerPreprocessor('config', function(Class, data) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(Class, 'Ext.Class#configPreProcessor', arguments);
    var config = data.config, prototype = Class.prototype;
    delete data.config;
    Ext.Object.each(config, function(name, value) {
      var nameMap = ExtClass.getConfigNameMap(name), internalName = nameMap.internal, initializedName = nameMap.initialized, applyName = nameMap.apply, updateName = nameMap.update, setName = nameMap.set, getName = nameMap.get, hasOwnSetter = setName in prototype || data.hasOwnProperty(setName), hasOwnApplier = applyName in prototype || data.hasOwnProperty(applyName), hasOwnUpdater = updateName in prototype || data.hasOwnProperty(updateName), optimizedGetter, customGetter;
      if (value === null || !hasOwnSetter && !hasOwnApplier && !hasOwnUpdater) {
        prototype[internalName] = value;
        prototype[initializedName] = true;
      } else {
        prototype[initializedName] = false;
      }
      if (!hasOwnSetter) {
        data[setName] = function(value) {
          var oldValue = this[internalName], applier = this[applyName], updater = this[updateName];
          if (!this[initializedName]) {
            this[initializedName] = true;
          }
          if (applier) {
            value = applier.call(this, value, oldValue);
          }
          if (typeof value != 'undefined') {
            this[internalName] = value;
            if (updater && value !== oldValue) {
              updater.call(this, value, oldValue);
            }
          }
          return this;
        };
      }
      if (!(getName in prototype) || data.hasOwnProperty(getName)) {
        customGetter = data[getName] || false;
        if (customGetter) {
          optimizedGetter = function() {
            return customGetter.apply(this, arguments);
          };
        } else {
          optimizedGetter = function() {
            return this[internalName];
          };
        }
        data[getName] = function() {
          var currentGetter;
          if (!this[initializedName]) {
            this[initializedName] = true;
            this[setName](this.config[name]);
          }
          currentGetter = this[getName];
          if ('$previous' in currentGetter) {
            currentGetter.$previous = optimizedGetter;
          } else {
            this[getName] = optimizedGetter;
          }
          return optimizedGetter.apply(this, arguments);
        };
      }
    });
    Class.addConfig(config, true);
  });
  ExtClass.registerPreprocessor('mixins', function(Class, data, hooks) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(Class, 'Ext.Class#mixinsPreprocessor', arguments);
    var mixins = data.mixins, name, mixin, i, ln;
    delete data.mixins;
    Ext.Function.interceptBefore(hooks, 'onCreated', function() {
      Ext.classSystemMonitor && Ext.classSystemMonitor(Class, 'Ext.Class#mixinsPreprocessor#beforeCreated', arguments);
      if (mixins instanceof Array) {
        for (i = 0, ln = mixins.length; i < ln; i++) {
          mixin = mixins[i];
          name = mixin.prototype.mixinId || mixin.$className;
          Class.mixin(name, mixin);
        }
      } else {
        for (var mixinName in mixins) {
          if (mixins.hasOwnProperty(mixinName)) {
            Class.mixin(mixinName, mixins[mixinName]);
          }
        }
      }
    });
  });
  Ext.extend = function(Class, Parent, members) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(Class, 'Ext.Class#extend-backwards-compatible', arguments);
    if (arguments.length === 2 && Ext.isObject(Parent)) {
      members = Parent;
      Parent = Class;
      Class = null;
    }
    var cls;
    if (!Parent) {
      throw new Error('[Ext.extend] Attempting to extend from a class which has not been loaded on the page.');
    }
    members.extend = Parent;
    members.preprocessors = ['extend', 'statics', 'inheritableStatics', 'mixins', 'config'];
    if (Class) {
      cls = new ExtClass(Class, members);
      cls.prototype.constructor = Class;
    } else {
      cls = new ExtClass(members);
    }
    cls.prototype.override = function(o) {
      for (var m in o) {
        if (o.hasOwnProperty(m)) {
          this[m] = o[m];
        }
      }
    };
    return cls;
  };
})();
(function(Class, alias, arraySlice, arrayFrom, global) {
  function makeCtor() {
    function constructor() {
      return this.constructor.apply(this, arguments) || null;
    }
    return constructor;
  }
  var Manager = Ext.ClassManager = {classes:{}, existCache:{}, namespaceRewrites:[{from:'Ext.', to:Ext}], maps:{alternateToName:{}, aliasToName:{}, nameToAliases:{}, nameToAlternates:{}}, enableNamespaceParseCache:true, namespaceParseCache:{}, instantiators:[], isCreated:function(className) {
    var existCache = this.existCache, i, ln, part, root, parts;
    if (typeof className != 'string' || className.length < 1) {
      throw new Error('[Ext.ClassManager] Invalid classname, must be a string and must not be empty');
    }
    if (this.classes[className] || existCache[className]) {
      return true;
    }
    root = global;
    parts = this.parseNamespace(className);
    for (i = 0, ln = parts.length; i < ln; i++) {
      part = parts[i];
      if (typeof part != 'string') {
        root = part;
      } else {
        if (!root || !root[part]) {
          return false;
        }
        root = root[part];
      }
    }
    existCache[className] = true;
    this.triggerCreated(className);
    return true;
  }, createdListeners:[], nameCreatedListeners:{}, triggerCreated:function(className) {
    var listeners = this.createdListeners, nameListeners = this.nameCreatedListeners, alternateNames = this.maps.nameToAlternates[className], names = [className], i, ln, j, subLn, listener, name;
    for (i = 0, ln = listeners.length; i < ln; i++) {
      listener = listeners[i];
      listener.fn.call(listener.scope, className);
    }
    if (alternateNames) {
      names.push.apply(names, alternateNames);
    }
    for (i = 0, ln = names.length; i < ln; i++) {
      name = names[i];
      listeners = nameListeners[name];
      if (listeners) {
        for (j = 0, subLn = listeners.length; j < subLn; j++) {
          listener = listeners[j];
          listener.fn.call(listener.scope, name);
        }
        delete nameListeners[name];
      }
    }
  }, onCreated:function(fn, scope, className) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(className, 'Ext.ClassManager#onCreated', arguments);
    var listeners = this.createdListeners, nameListeners = this.nameCreatedListeners, listener = {fn:fn, scope:scope};
    if (className) {
      if (this.isCreated(className)) {
        fn.call(scope, className);
        return;
      }
      if (!nameListeners[className]) {
        nameListeners[className] = [];
      }
      nameListeners[className].push(listener);
    } else {
      listeners.push(listener);
    }
  }, parseNamespace:function(namespace) {
    if (typeof namespace != 'string') {
      throw new Error('[Ext.ClassManager] Invalid namespace, must be a string');
    }
    var cache = this.namespaceParseCache, parts, rewrites, root, name, rewrite, from, to, i, ln;
    if (this.enableNamespaceParseCache) {
      if (cache.hasOwnProperty(namespace)) {
        return cache[namespace];
      }
    }
    parts = [];
    rewrites = this.namespaceRewrites;
    root = global;
    name = namespace;
    for (i = 0, ln = rewrites.length; i < ln; i++) {
      rewrite = rewrites[i];
      from = rewrite.from;
      to = rewrite.to;
      if (name === from || name.substring(0, from.length) === from) {
        name = name.substring(from.length);
        if (typeof to != 'string') {
          root = to;
        } else {
          parts = parts.concat(to.split('.'));
        }
        break;
      }
    }
    parts.push(root);
    parts = parts.concat(name.split('.'));
    if (this.enableNamespaceParseCache) {
      cache[namespace] = parts;
    }
    return parts;
  }, setNamespace:function(name, value) {
    var root = global, parts = this.parseNamespace(name), ln = parts.length - 1, leaf = parts[ln], i, part;
    for (i = 0; i < ln; i++) {
      part = parts[i];
      if (typeof part != 'string') {
        root = part;
      } else {
        if (!root[part]) {
          root[part] = {};
        }
        root = root[part];
      }
    }
    root[leaf] = value;
    return root[leaf];
  }, createNamespaces:function() {
    var root = global, parts, part, i, j, ln, subLn;
    for (i = 0, ln = arguments.length; i < ln; i++) {
      parts = this.parseNamespace(arguments[i]);
      for (j = 0, subLn = parts.length; j < subLn; j++) {
        part = parts[j];
        if (typeof part != 'string') {
          root = part;
        } else {
          if (!root[part]) {
            root[part] = {};
          }
          root = root[part];
        }
      }
    }
    return root;
  }, set:function(name, value) {
    var me = this, maps = me.maps, nameToAlternates = maps.nameToAlternates, targetName = me.getName(value), alternates;
    me.classes[name] = me.setNamespace(name, value);
    if (targetName && targetName !== name) {
      maps.alternateToName[name] = targetName;
      alternates = nameToAlternates[targetName] || (nameToAlternates[targetName] = []);
      alternates.push(name);
    }
    return this;
  }, get:function(name) {
    var classes = this.classes, root, parts, part, i, ln;
    if (classes[name]) {
      return classes[name];
    }
    root = global;
    parts = this.parseNamespace(name);
    for (i = 0, ln = parts.length; i < ln; i++) {
      part = parts[i];
      if (typeof part != 'string') {
        root = part;
      } else {
        if (!root || !root[part]) {
          return null;
        }
        root = root[part];
      }
    }
    return root;
  }, setAlias:function(cls, alias) {
    var aliasToNameMap = this.maps.aliasToName, nameToAliasesMap = this.maps.nameToAliases, className;
    if (typeof cls == 'string') {
      className = cls;
    } else {
      className = this.getName(cls);
    }
    if (alias && aliasToNameMap[alias] !== className) {
      if (aliasToNameMap[alias] && Ext.isDefined(global.console)) {
        global.console.log("[Ext.ClassManager] Overriding existing alias: '" + alias + "' " + "of: '" + aliasToNameMap[alias] + "' with: '" + className + "'. Be sure it's intentional.");
      }
      aliasToNameMap[alias] = className;
    }
    if (!nameToAliasesMap[className]) {
      nameToAliasesMap[className] = [];
    }
    if (alias) {
      Ext.Array.include(nameToAliasesMap[className], alias);
    }
    return this;
  }, addNameAliasMappings:function(aliases) {
    var aliasToNameMap = this.maps.aliasToName, nameToAliasesMap = this.maps.nameToAliases, className, aliasList, alias, i;
    for (className in aliases) {
      aliasList = nameToAliasesMap[className] || (nameToAliasesMap[className] = []);
      for (i = 0; i < aliases[className].length; i++) {
        alias = aliases[className][i];
        if (!aliasToNameMap[alias]) {
          aliasToNameMap[alias] = className;
          aliasList.push(alias);
        }
      }
    }
    return this;
  }, addNameAlternateMappings:function(alternates) {
    var alternateToName = this.maps.alternateToName, nameToAlternates = this.maps.nameToAlternates, className, aliasList, alternate, i;
    for (className in alternates) {
      aliasList = nameToAlternates[className] || (nameToAlternates[className] = []);
      for (i = 0; i < alternates[className].length; i++) {
        alternate = alternates[className][i];
        if (!alternateToName[alternate]) {
          alternateToName[alternate] = className;
          aliasList.push(alternate);
        }
      }
    }
    return this;
  }, getByAlias:function(alias) {
    return this.get(this.getNameByAlias(alias));
  }, getNameByAlias:function(alias) {
    return this.maps.aliasToName[alias] || '';
  }, getNameByAlternate:function(alternate) {
    return this.maps.alternateToName[alternate] || '';
  }, getAliasesByName:function(name) {
    return this.maps.nameToAliases[name] || [];
  }, getName:function(object) {
    return object && object.$className || '';
  }, getClass:function(object) {
    return object && object.self || null;
  }, create:function(className, data, createdFn) {
    if (className != null && typeof className != 'string') {
      throw new Error("[Ext.define] Invalid class name '" + className + "' specified, must be a non-empty string");
    }
    var ctor = makeCtor();
    if (typeof data == 'function') {
      data = data(ctor);
    }
    if (className) {
      ctor.displayName = className;
    }
    data.$className = className;
    return new Class(ctor, data, function() {
      var postprocessorStack = data.postprocessors || Manager.defaultPostprocessors, registeredPostprocessors = Manager.postprocessors, postprocessors = [], postprocessor, i, ln, j, subLn, postprocessorProperties, postprocessorProperty;
      delete data.postprocessors;
      for (i = 0, ln = postprocessorStack.length; i < ln; i++) {
        postprocessor = postprocessorStack[i];
        if (typeof postprocessor == 'string') {
          postprocessor = registeredPostprocessors[postprocessor];
          postprocessorProperties = postprocessor.properties;
          if (postprocessorProperties === true) {
            postprocessors.push(postprocessor.fn);
          } else {
            if (postprocessorProperties) {
              for (j = 0, subLn = postprocessorProperties.length; j < subLn; j++) {
                postprocessorProperty = postprocessorProperties[j];
                if (data.hasOwnProperty(postprocessorProperty)) {
                  postprocessors.push(postprocessor.fn);
                  break;
                }
              }
            }
          }
        } else {
          postprocessors.push(postprocessor);
        }
      }
      data.postprocessors = postprocessors;
      data.createdFn = createdFn;
      Manager.processCreate(className, this, data);
    });
  }, processCreate:function(className, cls, clsData) {
    var me = this, postprocessor = clsData.postprocessors.shift(), createdFn = clsData.createdFn;
    if (!postprocessor) {
      Ext.classSystemMonitor && Ext.classSystemMonitor(className, 'Ext.ClassManager#classCreated', arguments);
      if (className) {
        me.set(className, cls);
      }
      if (createdFn) {
        createdFn.call(cls, cls);
      }
      if (className) {
        me.triggerCreated(className);
      }
      return;
    }
    if (postprocessor.call(me, className, cls, clsData, me.processCreate) !== false) {
      me.processCreate(className, cls, clsData);
    }
  }, createOverride:function(className, data, createdFn) {
    var me = this, overriddenClassName = data.override, requires = data.requires, uses = data.uses, classReady = function() {
      var cls, temp;
      if (requires) {
        temp = requires;
        requires = null;
        Ext.Loader.require(temp, classReady);
      } else {
        cls = me.get(overriddenClassName);
        delete data.override;
        delete data.requires;
        delete data.uses;
        Ext.override(cls, data);
        me.triggerCreated(className);
        if (uses) {
          Ext.Loader.addUsedClasses(uses);
        }
        if (createdFn) {
          createdFn.call(cls);
        }
      }
    };
    me.existCache[className] = true;
    me.onCreated(classReady, me, overriddenClassName);
    return me;
  }, instantiateByAlias:function() {
    var alias = arguments[0], args = arraySlice.call(arguments), className = this.getNameByAlias(alias);
    if (!className) {
      className = this.maps.aliasToName[alias];
      if (!className) {
        throw new Error('[Ext.createByAlias] Cannot create an instance of unrecognized alias: ' + alias);
      }
      if (global.console) {
        global.console.warn("[Ext.Loader] Synchronously loading '" + className + "'; consider adding " + "Ext.require('" + alias + "') above Ext.onReady");
      }
      Ext.syncRequire(className);
    }
    args[0] = className;
    return this.instantiate.apply(this, args);
  }, instantiate:function() {
    var name = arguments[0], nameType = typeof name, args = arraySlice.call(arguments, 1), alias = name, possibleName, cls;
    if (nameType != 'function') {
      if (nameType != 'string' && args.length === 0) {
        args = [name];
        name = name.xclass;
      }
      if (typeof name != 'string' || name.length < 1) {
        throw new Error("[Ext.create] Invalid class name or alias '" + name + "' specified, must be a non-empty string");
      }
      cls = this.get(name);
    } else {
      cls = name;
    }
    if (!cls) {
      possibleName = this.getNameByAlias(name);
      if (possibleName) {
        name = possibleName;
        cls = this.get(name);
      }
    }
    if (!cls) {
      possibleName = this.getNameByAlternate(name);
      if (possibleName) {
        name = possibleName;
        cls = this.get(name);
      }
    }
    if (!cls) {
      if (global.console) {
        global.console.warn("[Ext.Loader] Synchronously loading '" + name + "'; consider adding " + "Ext.require('" + (possibleName ? alias : name) + "') above Ext.onReady");
      }
      Ext.syncRequire(name);
      cls = this.get(name);
    }
    if (!cls) {
      throw new Error('[Ext.create] Cannot create an instance of unrecognized class name / alias: ' + alias);
    }
    if (typeof cls != 'function') {
      throw new Error("[Ext.create] '" + name + "' is a singleton and cannot be instantiated");
    }
    return this.getInstantiator(args.length)(cls, args);
  }, dynInstantiate:function(name, args) {
    args = arrayFrom(args, true);
    args.unshift(name);
    return this.instantiate.apply(this, args);
  }, getInstantiator:function(length) {
    var instantiators = this.instantiators, instantiator, i, args;
    instantiator = instantiators[length];
    if (!instantiator) {
      i = length;
      args = [];
      for (i = 0; i < length; i++) {
        args.push('a[' + i + ']');
      }
      instantiator = instantiators[length] = new Function('c', 'a', 'return new c(' + args.join(',') + ')');
      instantiator.displayName = 'Ext.ClassManager.instantiate' + length;
    }
    return instantiator;
  }, postprocessors:{}, defaultPostprocessors:[], registerPostprocessor:function(name, fn, properties, position, relativeTo) {
    if (!position) {
      position = 'last';
    }
    if (!properties) {
      properties = [name];
    }
    this.postprocessors[name] = {name:name, properties:properties || false, fn:fn};
    this.setDefaultPostprocessorPosition(name, position, relativeTo);
    return this;
  }, setDefaultPostprocessors:function(postprocessors) {
    this.defaultPostprocessors = arrayFrom(postprocessors);
    return this;
  }, setDefaultPostprocessorPosition:function(name, offset, relativeName) {
    var defaultPostprocessors = this.defaultPostprocessors, index;
    if (typeof offset == 'string') {
      if (offset === 'first') {
        defaultPostprocessors.unshift(name);
        return this;
      } else {
        if (offset === 'last') {
          defaultPostprocessors.push(name);
          return this;
        }
      }
      offset = offset === 'after' ? 1 : -1;
    }
    index = Ext.Array.indexOf(defaultPostprocessors, relativeName);
    if (index !== -1) {
      Ext.Array.splice(defaultPostprocessors, Math.max(0, index + offset), 0, name);
    }
    return this;
  }, getNamesByExpression:function(expression) {
    var nameToAliasesMap = this.maps.nameToAliases, names = [], name, alias, aliases, possibleName, regex, i, ln;
    if (typeof expression != 'string' || expression.length < 1) {
      throw new Error('[Ext.ClassManager.getNamesByExpression] Expression ' + expression + ' is invalid, must be a non-empty string');
    }
    if (expression.indexOf('*') !== -1) {
      expression = expression.replace(/\*/g, '(.*?)');
      regex = new RegExp('^' + expression + '$');
      for (name in nameToAliasesMap) {
        if (nameToAliasesMap.hasOwnProperty(name)) {
          aliases = nameToAliasesMap[name];
          if (name.search(regex) !== -1) {
            names.push(name);
          } else {
            for (i = 0, ln = aliases.length; i < ln; i++) {
              alias = aliases[i];
              if (alias.search(regex) !== -1) {
                names.push(name);
                break;
              }
            }
          }
        }
      }
    } else {
      possibleName = this.getNameByAlias(expression);
      if (possibleName) {
        names.push(possibleName);
      } else {
        possibleName = this.getNameByAlternate(expression);
        if (possibleName) {
          names.push(possibleName);
        } else {
          names.push(expression);
        }
      }
    }
    return names;
  }};
  Manager.registerPostprocessor('alias', function(name, cls, data) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(name, 'Ext.ClassManager#aliasPostProcessor', arguments);
    var aliases = data.alias, i, ln;
    for (i = 0, ln = aliases.length; i < ln; i++) {
      alias = aliases[i];
      this.setAlias(cls, alias);
    }
  }, ['xtype', 'alias']);
  Manager.registerPostprocessor('singleton', function(name, cls, data, fn) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(name, 'Ext.ClassManager#singletonPostProcessor', arguments);
    if (data.singleton) {
      fn.call(this, name, new cls, data);
    } else {
      return true;
    }
    return false;
  });
  Manager.registerPostprocessor('alternateClassName', function(name, cls, data) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(name, 'Ext.ClassManager#alternateClassNamePostprocessor', arguments);
    var alternates = data.alternateClassName, i, ln, alternate;
    if (!(alternates instanceof Array)) {
      alternates = [alternates];
    }
    for (i = 0, ln = alternates.length; i < ln; i++) {
      alternate = alternates[i];
      if (typeof alternate != 'string') {
        throw new Error("[Ext.define] Invalid alternate of: '" + alternate + "' for class: '" + name + "'; must be a valid string");
      }
      this.set(alternate, cls);
    }
  });
  Ext.apply(Ext, {create:alias(Manager, 'instantiate'), widget:function(name, config) {
    var xtype = name, alias, className, T, load;
    if (typeof xtype != 'string') {
      config = name;
      xtype = config.xtype;
    } else {
      config = config || {};
    }
    if (config.isComponent) {
      return config;
    }
    alias = 'widget.' + xtype;
    className = Manager.getNameByAlias(alias);
    if (!className) {
      load = true;
    }
    T = Manager.get(className);
    if (load || !T) {
      return Manager.instantiateByAlias(alias, config);
    }
    return new T(config);
  }, createByAlias:alias(Manager, 'instantiateByAlias'), define:function(className, data, createdFn) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(className, 'ClassManager#define', arguments);
    if (data.override) {
      return Manager.createOverride.apply(Manager, arguments);
    }
    return Manager.create.apply(Manager, arguments);
  }, undefine:function(className) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(className, 'Ext.ClassManager#undefine', arguments);
    var classes = Manager.classes, maps = Manager.maps, aliasToName = maps.aliasToName, nameToAliases = maps.nameToAliases, alternateToName = maps.alternateToName, nameToAlternates = maps.nameToAlternates, aliases = nameToAliases[className], alternates = nameToAlternates[className], parts, partCount, namespace, i;
    delete Manager.namespaceParseCache[className];
    delete nameToAliases[className];
    delete nameToAlternates[className];
    delete classes[className];
    if (aliases) {
      for (i = aliases.length; i--;) {
        delete aliasToName[aliases[i]];
      }
    }
    if (alternates) {
      for (i = alternates.length; i--;) {
        delete alternateToName[alternates[i]];
      }
    }
    parts = Manager.parseNamespace(className);
    partCount = parts.length - 1;
    namespace = parts[0];
    for (i = 1; i < partCount; i++) {
      namespace = namespace[parts[i]];
      if (!namespace) {
        return;
      }
    }
    try {
      delete namespace[parts[partCount]];
    } catch (e$1) {
      namespace[parts[partCount]] = undefined;
    }
  }, getClassName:alias(Manager, 'getName'), getDisplayName:function(object) {
    if (object) {
      if (object.displayName) {
        return object.displayName;
      }
      if (object.$name && object.$class) {
        return Ext.getClassName(object.$class) + '#' + object.$name;
      }
      if (object.$className) {
        return object.$className;
      }
    }
    return 'Anonymous';
  }, getClass:alias(Manager, 'getClass'), namespace:alias(Manager, 'createNamespaces')});
  Ext.createWidget = Ext.widget;
  Ext.ns = Ext.namespace;
  Class.registerPreprocessor('className', function(cls, data) {
    if (data.$className) {
      cls.$className = data.$className;
      cls.displayName = cls.$className;
    }
    Ext.classSystemMonitor && Ext.classSystemMonitor(cls, 'Ext.ClassManager#classNamePreprocessor', arguments);
  }, true, 'first');
  Class.registerPreprocessor('alias', function(cls, data) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(cls, 'Ext.ClassManager#aliasPreprocessor', arguments);
    var prototype = cls.prototype, xtypes = arrayFrom(data.xtype), aliases = arrayFrom(data.alias), widgetPrefix = 'widget.', widgetPrefixLength = widgetPrefix.length, xtypesChain = Array.prototype.slice.call(prototype.xtypesChain || []), xtypesMap = Ext.merge({}, prototype.xtypesMap || {}), i, ln, alias, xtype;
    for (i = 0, ln = aliases.length; i < ln; i++) {
      alias = aliases[i];
      if (typeof alias != 'string' || alias.length < 1) {
        throw new Error("[Ext.define] Invalid alias of: '" + alias + "' for class: '" + name + "'; must be a valid string");
      }
      if (alias.substring(0, widgetPrefixLength) === widgetPrefix) {
        xtype = alias.substring(widgetPrefixLength);
        Ext.Array.include(xtypes, xtype);
      }
    }
    cls.xtype = data.xtype = xtypes[0];
    data.xtypes = xtypes;
    for (i = 0, ln = xtypes.length; i < ln; i++) {
      xtype = xtypes[i];
      if (!xtypesMap[xtype]) {
        xtypesMap[xtype] = true;
        xtypesChain.push(xtype);
      }
    }
    data.xtypesChain = xtypesChain;
    data.xtypesMap = xtypesMap;
    Ext.Function.interceptAfter(data, 'onClassCreated', function() {
      Ext.classSystemMonitor && Ext.classSystemMonitor(cls, 'Ext.ClassManager#aliasPreprocessor#afterClassCreated', arguments);
      var mixins = prototype.mixins, key, mixin;
      for (key in mixins) {
        if (mixins.hasOwnProperty(key)) {
          mixin = mixins[key];
          xtypes = mixin.xtypes;
          if (xtypes) {
            for (i = 0, ln = xtypes.length; i < ln; i++) {
              xtype = xtypes[i];
              if (!xtypesMap[xtype]) {
                xtypesMap[xtype] = true;
                xtypesChain.push(xtype);
              }
            }
          }
        }
      }
    });
    for (i = 0, ln = xtypes.length; i < ln; i++) {
      xtype = xtypes[i];
      if (typeof xtype != 'string' || xtype.length < 1) {
        throw new Error("[Ext.define] Invalid xtype of: '" + xtype + "' for class: '" + name + "'; must be a valid non-empty string");
      }
      Ext.Array.include(aliases, widgetPrefix + xtype);
    }
    data.alias = aliases;
  }, ['xtype', 'alias']);
})(Ext.Class, Ext.Function.alias, Array.prototype.slice, Ext.Array.from, Ext.global);
if (Ext._alternatesMetadata) {
  Ext.ClassManager.addNameAlternateMappings(Ext._alternatesMetadata);
  Ext._alternatesMetadata = null;
}
if (Ext._aliasMetadata) {
  Ext.ClassManager.addNameAliasMappings(Ext._aliasMetadata);
  Ext._aliasMetadata = null;
}
Ext.Loader = new function() {
  var Loader = this, Manager = Ext.ClassManager, Class = Ext.Class, flexSetter = Ext.Function.flexSetter, alias = Ext.Function.alias, pass = Ext.Function.pass, defer = Ext.Function.defer, arrayErase = Ext.Array.erase, dependencyProperties = ['extend', 'mixins', 'requires'], isInHistory = {}, history = [], slashDotSlashRe = /\/\.\//g, dotRe = /\./g, setPathCount = 0;
  Ext.apply(Loader, {isInHistory:isInHistory, history:history, config:{enabled:false, scriptChainDelay:false, disableCaching:true, disableCachingParam:'_dc', garbageCollect:false, paths:{'Ext':'.'}, preserveScripts:true, scriptCharset:undefined}, setConfig:function(name, value) {
    if (Ext.isObject(name) && arguments.length === 1) {
      Ext.merge(Loader.config, name);
      if ('paths' in name) {
        Ext.app.collectNamespaces(name.paths);
      }
    } else {
      Loader.config[name] = Ext.isObject(value) ? Ext.merge(Loader.config[name], value) : value;
      if (name === 'paths') {
        Ext.app.collectNamespaces(value);
      }
    }
    return Loader;
  }, getConfig:function(name) {
    if (name) {
      return Loader.config[name];
    }
    return Loader.config;
  }, setPath:flexSetter(function(name, path) {
    Loader.config.paths[name] = path;
    Ext.app.namespaces[name] = true;
    setPathCount++;
    return Loader;
  }), addClassPathMappings:function(paths) {
    var name;
    if (setPathCount == 0) {
      Loader.config.paths = paths;
    } else {
      for (name in paths) {
        Loader.config.paths[name] = paths[name];
      }
    }
    setPathCount++;
    return Loader;
  }, getPath:function(className) {
    var path = '', paths = Loader.config.paths, prefix = Loader.getPrefix(className);
    if (prefix.length > 0) {
      if (prefix === className) {
        return paths[prefix];
      }
      path = paths[prefix];
      className = className.substring(prefix.length + 1);
    }
    if (path.length > 0) {
      path += '/';
    }
    return path.replace(slashDotSlashRe, '/') + className.replace(dotRe, '/') + '.js';
  }, getPrefix:function(className) {
    var paths = Loader.config.paths, prefix, deepestPrefix = '';
    if (paths.hasOwnProperty(className)) {
      return className;
    }
    for (prefix in paths) {
      if (paths.hasOwnProperty(prefix) && prefix + '.' === className.substring(0, prefix.length + 1)) {
        if (prefix.length > deepestPrefix.length) {
          deepestPrefix = prefix;
        }
      }
    }
    return deepestPrefix;
  }, isAClassNameWithAKnownPrefix:function(className) {
    var prefix = Loader.getPrefix(className);
    return prefix !== '' && prefix !== className;
  }, require:function(expressions, fn, scope, excludes) {
    if (fn) {
      fn.call(scope);
    }
  }, syncRequire:function() {
  }, exclude:function(excludes) {
    return {require:function(expressions, fn, scope) {
      return Loader.require(expressions, fn, scope, excludes);
    }, syncRequire:function(expressions, fn, scope) {
      return Loader.syncRequire(expressions, fn, scope, excludes);
    }};
  }, onReady:function(fn, scope, withDomReady, options) {
    var oldFn;
    if (withDomReady !== false && Ext.onDocumentReady) {
      oldFn = fn;
      fn = function() {
        Ext.onDocumentReady(oldFn, scope, options);
      };
    }
    fn.call(scope);
  }});
  var queue = [], isClassFileLoaded = {}, isFileLoaded = {}, classNameToFilePathMap = {}, scriptElements = {}, readyListeners = [], usedClasses = [], requiresMap = {}, comparePriority = function(listenerA, listenerB) {
    return listenerB.priority - listenerA.priority;
  };
  Ext.apply(Loader, {documentHead:typeof document != 'undefined' && (document.head || document.getElementsByTagName('head')[0]), isLoading:false, queue:queue, isClassFileLoaded:isClassFileLoaded, isFileLoaded:isFileLoaded, readyListeners:readyListeners, optionalRequires:usedClasses, requiresMap:requiresMap, numPendingFiles:0, numLoadedFiles:0, hasFileLoadError:false, classNameToFilePathMap:classNameToFilePathMap, scriptsLoading:0, syncModeEnabled:false, scriptElements:scriptElements, refreshQueue:function() {
    var ln = queue.length, i, item, j, requires;
    if (!ln && !Loader.scriptsLoading) {
      return Loader.triggerReady();
    }
    for (i = 0; i < ln; i++) {
      item = queue[i];
      if (item) {
        requires = item.requires;
        if (requires.length > Loader.numLoadedFiles) {
          continue;
        }
        for (j = 0; j < requires.length;) {
          if (Manager.isCreated(requires[j])) {
            arrayErase(requires, j, 1);
          } else {
            j++;
          }
        }
        if (item.requires.length === 0) {
          arrayErase(queue, i, 1);
          item.callback.call(item.scope);
          Loader.refreshQueue();
          break;
        }
      }
    }
    return Loader;
  }, injectScriptElement:function(url, onLoad, onError, scope, charset) {
    var script = document.createElement('script'), dispatched = false, config = Loader.config, onLoadFn = function() {
      if (!dispatched) {
        dispatched = true;
        script.onload = script.onreadystatechange = script.onerror = null;
        if (typeof config.scriptChainDelay == 'number') {
          defer(onLoad, config.scriptChainDelay, scope);
        } else {
          onLoad.call(scope);
        }
        Loader.cleanupScriptElement(script, config.preserveScripts === false, config.garbageCollect);
      }
    }, onErrorFn = function(arg) {
      defer(onError, 1, scope);
      Loader.cleanupScriptElement(script, config.preserveScripts === false, config.garbageCollect);
    };
    script.type = 'text/javascript';
    script.onerror = onErrorFn;
    charset = charset || config.scriptCharset;
    if (charset) {
      script.charset = charset;
    }
    if ('addEventListener' in script) {
      script.onload = onLoadFn;
    } else {
      if ('readyState' in script) {
        script.onreadystatechange = function() {
          if (this.readyState == 'loaded' || this.readyState == 'complete') {
            onLoadFn();
          }
        };
      } else {
        script.onload = onLoadFn;
      }
    }
    script.src = url;
    (Loader.documentHead || document.getElementsByTagName('head')[0]).appendChild(script);
    return script;
  }, removeScriptElement:function(url) {
    if (scriptElements[url]) {
      Loader.cleanupScriptElement(scriptElements[url], true, !!Loader.getConfig('garbageCollect'));
      delete scriptElements[url];
    }
    return Loader;
  }, cleanupScriptElement:function(script, remove, collect) {
    var prop;
    script.onload = script.onreadystatechange = script.onerror = null;
    if (remove) {
      Ext.removeNode(script);
      if (collect) {
        for (prop in script) {
          try {
            if (prop != 'src') {
              script[prop] = null;
            }
            delete script[prop];
          } catch (cleanEx) {
          }
        }
      }
    }
    return Loader;
  }, loadScript:function(options) {
    var config = Loader.getConfig(), isString = typeof options == 'string', url = isString ? options : options.url, onError = !isString && options.onError, onLoad = !isString && options.onLoad, scope = !isString && options.scope, onScriptError = function() {
      Loader.numPendingFiles--;
      Loader.scriptsLoading--;
      if (onError) {
        onError.call(scope, "Failed loading '" + url + "', please verify that the file exists");
      }
      if (Loader.numPendingFiles + Loader.scriptsLoading === 0) {
        Loader.refreshQueue();
      }
    }, onScriptLoad = function() {
      Loader.numPendingFiles--;
      Loader.scriptsLoading--;
      if (onLoad) {
        onLoad.call(scope);
      }
      if (Loader.numPendingFiles + Loader.scriptsLoading === 0) {
        Loader.refreshQueue();
      }
    }, src;
    Loader.isLoading = true;
    Loader.numPendingFiles++;
    Loader.scriptsLoading++;
    src = config.disableCaching ? url + '?' + config.disableCachingParam + '\x3d' + Ext.Date.now() : url;
    scriptElements[url] = Loader.injectScriptElement(src, onScriptLoad, onScriptError);
  }, loadScriptFile:function(url, onLoad, onError, scope, synchronous) {
    if (isFileLoaded[url]) {
      return Loader;
    }
    var config = Loader.getConfig(), noCacheUrl = url + (config.disableCaching ? '?' + config.disableCachingParam + '\x3d' + Ext.Date.now() : ''), isCrossOriginRestricted = false, xhr, status, onScriptError, debugSourceURL = '';
    scope = scope || Loader;
    Loader.isLoading = true;
    if (!synchronous) {
      onScriptError = function() {
        onError.call(scope, "Failed loading '" + url + "', please verify that the file exists", synchronous);
      };
      scriptElements[url] = Loader.injectScriptElement(noCacheUrl, onLoad, onScriptError, scope);
    } else {
      if (typeof XMLHttpRequest != 'undefined') {
        xhr = new XMLHttpRequest;
      } else {
        xhr = new ActiveXObject('Microsoft.XMLHTTP');
      }
      try {
        xhr.open('GET', noCacheUrl, false);
        xhr.send(null);
      } catch (e$2) {
        isCrossOriginRestricted = true;
      }
      status = xhr.status === 1223 ? 204 : xhr.status === 0 && ((self.location || {}).protocol == 'file:' || (self.location || {}).protocol == 'ionp:') ? 200 : xhr.status;
      isCrossOriginRestricted = isCrossOriginRestricted || status === 0;
      if (isCrossOriginRestricted) {
        onError.call(Loader, "Failed loading synchronously via XHR: '" + url + "'; It's likely that the file is either " + 'being loaded from a different domain or from the local file system whereby cross origin ' + 'requests are not allowed due to security reasons. Use asynchronous loading with ' + 'Ext.require instead.', synchronous);
      } else {
        if (status >= 200 && status < 300 || status === 304) {
          if (!Ext.isIE) {
            debugSourceURL = '\n//@ sourceURL\x3d' + url;
          }
          Ext.globalEval(xhr.responseText + debugSourceURL);
          onLoad.call(scope);
        } else {
          onError.call(Loader, "Failed loading synchronously via XHR: '" + url + "'; please " + 'verify that the file exists. ' + 'XHR status code: ' + status, synchronous);
        }
      }
      xhr = null;
    }
  }, syncRequire:function() {
    var syncModeEnabled = Loader.syncModeEnabled;
    if (!syncModeEnabled) {
      Loader.syncModeEnabled = true;
    }
    Loader.require.apply(Loader, arguments);
    if (!syncModeEnabled) {
      Loader.syncModeEnabled = false;
    }
    Loader.refreshQueue();
  }, require:function(expressions, fn, scope, excludes) {
    var excluded = {}, included = {}, excludedClassNames = [], possibleClassNames = [], classNames = [], references = [], callback, syncModeEnabled, filePath, expression, exclude, className, possibleClassName, i, j, ln, subLn;
    if (excludes) {
      excludes = typeof excludes === 'string' ? [excludes] : excludes;
      for (i = 0, ln = excludes.length; i < ln; i++) {
        exclude = excludes[i];
        if (typeof exclude == 'string' && exclude.length > 0) {
          excludedClassNames = Manager.getNamesByExpression(exclude);
          for (j = 0, subLn = excludedClassNames.length; j < subLn; j++) {
            excluded[excludedClassNames[j]] = true;
          }
        }
      }
    }
    expressions = typeof expressions === 'string' ? [expressions] : expressions ? expressions : [];
    if (fn) {
      if (fn.length > 0) {
        callback = function() {
          var classes = [], i, ln;
          for (i = 0, ln = references.length; i < ln; i++) {
            classes.push(Manager.get(references[i]));
          }
          return fn.apply(this, classes);
        };
      } else {
        callback = fn;
      }
    } else {
      callback = Ext.emptyFn;
    }
    scope = scope || Ext.global;
    for (i = 0, ln = expressions.length; i < ln; i++) {
      expression = expressions[i];
      if (typeof expression == 'string' && expression.length > 0) {
        possibleClassNames = Manager.getNamesByExpression(expression);
        subLn = possibleClassNames.length;
        for (j = 0; j < subLn; j++) {
          possibleClassName = possibleClassNames[j];
          if (excluded[possibleClassName] !== true) {
            references.push(possibleClassName);
            if (!Manager.isCreated(possibleClassName) && !included[possibleClassName]) {
              included[possibleClassName] = true;
              classNames.push(possibleClassName);
            }
          }
        }
      }
    }
    if (classNames.length > 0) {
      if (!Loader.config.enabled) {
        throw new Error('Ext.Loader is not enabled, so dependencies cannot be resolved dynamically. ' + 'Missing required class' + (classNames.length > 1 ? 'es' : '') + ': ' + classNames.join(', '));
      }
    } else {
      callback.call(scope);
      return Loader;
    }
    syncModeEnabled = Loader.syncModeEnabled;
    if (!syncModeEnabled) {
      queue.push({requires:classNames.slice(), callback:callback, scope:scope});
    }
    ln = classNames.length;
    for (i = 0; i < ln; i++) {
      className = classNames[i];
      filePath = Loader.getPath(className);
      if (syncModeEnabled && isClassFileLoaded.hasOwnProperty(className)) {
        if (!isClassFileLoaded[className]) {
          Loader.numPendingFiles--;
          Loader.removeScriptElement(filePath);
          delete isClassFileLoaded[className];
        }
      }
      if (!isClassFileLoaded.hasOwnProperty(className)) {
        isClassFileLoaded[className] = false;
        classNameToFilePathMap[className] = filePath;
        Loader.numPendingFiles++;
        Loader.loadScriptFile(filePath, pass(Loader.onFileLoaded, [className, filePath], Loader), pass(Loader.onFileLoadError, [className, filePath], Loader), Loader, syncModeEnabled);
      }
    }
    if (syncModeEnabled) {
      callback.call(scope);
      if (ln === 1) {
        return Manager.get(className);
      }
    }
    return Loader;
  }, onFileLoaded:function(className, filePath) {
    var loaded = isClassFileLoaded[className];
    Loader.numLoadedFiles++;
    isClassFileLoaded[className] = true;
    isFileLoaded[filePath] = true;
    if (!loaded) {
      Loader.numPendingFiles--;
    }
    if (Loader.numPendingFiles === 0) {
      Loader.refreshQueue();
    }
    if (!Loader.syncModeEnabled && Loader.numPendingFiles === 0 && Loader.isLoading && !Loader.hasFileLoadError) {
      var missingClasses = [], missingPaths = [], requires, i, ln, j, subLn;
      for (i = 0, ln = queue.length; i < ln; i++) {
        requires = queue[i].requires;
        for (j = 0, subLn = requires.length; j < subLn; j++) {
          if (isClassFileLoaded[requires[j]]) {
            missingClasses.push(requires[j]);
          }
        }
      }
      if (missingClasses.length < 1) {
        return;
      }
      missingClasses = Ext.Array.filter(Ext.Array.unique(missingClasses), function(item) {
        return !requiresMap.hasOwnProperty(item);
      }, Loader);
      if (missingClasses.length < 1) {
        return;
      }
      for (i = 0, ln = missingClasses.length; i < ln; i++) {
        missingPaths.push(classNameToFilePathMap[missingClasses[i]]);
      }
      throw new Error('The following classes are not declared even if their files have been ' + "loaded: '" + missingClasses.join("', '") + "'. Please check the source code of their " + "corresponding files for possible typos: '" + missingPaths.join("', '"));
    }
  }, onFileLoadError:function(className, filePath, errorMessage, isSynchronous) {
    Loader.numPendingFiles--;
    Loader.hasFileLoadError = true;
    throw new Error('[Ext.Loader] ' + errorMessage);
  }, addUsedClasses:function(classes) {
    var cls, i, ln;
    if (classes) {
      classes = typeof classes == 'string' ? [classes] : classes;
      for (i = 0, ln = classes.length; i < ln; i++) {
        cls = classes[i];
        if (typeof cls == 'string' && !Ext.Array.contains(usedClasses, cls)) {
          usedClasses.push(cls);
        }
      }
    }
    return Loader;
  }, triggerReady:function() {
    var listener, refClasses = usedClasses;
    if (Loader.isLoading) {
      Loader.isLoading = false;
      if (refClasses.length !== 0) {
        refClasses = refClasses.slice();
        usedClasses.length = 0;
        Loader.require(refClasses, Loader.triggerReady, Loader);
        return Loader;
      }
    }
    Ext.Array.sort(readyListeners, comparePriority);
    while (readyListeners.length && !Loader.isLoading) {
      listener = readyListeners.shift();
      listener.fn.call(listener.scope);
    }
    return Loader;
  }, onReady:function(fn, scope, withDomReady, options) {
    var oldFn;
    if (withDomReady !== false && Ext.onDocumentReady) {
      oldFn = fn;
      fn = function() {
        Ext.onDocumentReady(oldFn, scope, options);
      };
    }
    if (!Loader.isLoading) {
      fn.call(scope);
    } else {
      readyListeners.push({fn:fn, scope:scope, priority:options && options.priority || 0});
    }
  }, historyPush:function(className) {
    if (className && isClassFileLoaded.hasOwnProperty(className) && !isInHistory[className]) {
      isInHistory[className] = true;
      history.push(className);
    }
    return Loader;
  }});
  Ext.disableCacheBuster = function(disable, path) {
    var date = new Date;
    date.setTime(date.getTime() + (disable ? 10 * 365 : -1) * 24 * 60 * 60 * 1000);
    date = date.toGMTString();
    document.cookie = 'ext-cache\x3d1; expires\x3d' + date + '; path\x3d' + (path || '/');
  };
  Ext.require = alias(Loader, 'require');
  Ext.syncRequire = alias(Loader, 'syncRequire');
  Ext.exclude = alias(Loader, 'exclude');
  Ext.onReady = function(fn, scope, options) {
    Loader.onReady(fn, scope, true, options);
  };
  Class.registerPreprocessor('loader', function(cls, data, hooks, continueFn) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(cls, 'Ext.Loader#loaderPreprocessor', arguments);
    var me = this, dependencies = [], dependency, className = Manager.getName(cls), i, j, ln, subLn, value, propertyName, propertyValue, requiredMap, requiredDep;
    for (i = 0, ln = dependencyProperties.length; i < ln; i++) {
      propertyName = dependencyProperties[i];
      if (data.hasOwnProperty(propertyName)) {
        propertyValue = data[propertyName];
        if (typeof propertyValue == 'string') {
          dependencies.push(propertyValue);
        } else {
          if (propertyValue instanceof Array) {
            for (j = 0, subLn = propertyValue.length; j < subLn; j++) {
              value = propertyValue[j];
              if (typeof value == 'string') {
                dependencies.push(value);
              }
            }
          } else {
            if (typeof propertyValue != 'function') {
              for (j in propertyValue) {
                if (propertyValue.hasOwnProperty(j)) {
                  value = propertyValue[j];
                  if (typeof value == 'string') {
                    dependencies.push(value);
                  }
                }
              }
            }
          }
        }
      }
    }
    if (dependencies.length === 0) {
      return;
    }
    var deadlockPath = [], detectDeadlock;
    if (className) {
      requiresMap[className] = dependencies;
      requiredMap = Loader.requiredByMap || (Loader.requiredByMap = {});
      for (i = 0, ln = dependencies.length; i < ln; i++) {
        dependency = dependencies[i];
        (requiredMap[dependency] || (requiredMap[dependency] = [])).push(className);
      }
      detectDeadlock = function(cls) {
        deadlockPath.push(cls);
        if (requiresMap[cls]) {
          if (Ext.Array.contains(requiresMap[cls], className)) {
            throw new Error("Deadlock detected while loading dependencies! '" + className + "' and '" + deadlockPath[1] + "' " + 'mutually require each other. Path: ' + deadlockPath.join(' -\x3e ') + ' -\x3e ' + deadlockPath[0]);
          }
          for (i = 0, ln = requiresMap[cls].length; i < ln; i++) {
            detectDeadlock(requiresMap[cls][i]);
          }
        }
      };
      detectDeadlock(className);
    }
    Loader.require(dependencies, function() {
      for (i = 0, ln = dependencyProperties.length; i < ln; i++) {
        propertyName = dependencyProperties[i];
        if (data.hasOwnProperty(propertyName)) {
          propertyValue = data[propertyName];
          if (typeof propertyValue == 'string') {
            data[propertyName] = Manager.get(propertyValue);
          } else {
            if (propertyValue instanceof Array) {
              for (j = 0, subLn = propertyValue.length; j < subLn; j++) {
                value = propertyValue[j];
                if (typeof value == 'string') {
                  data[propertyName][j] = Manager.get(value);
                }
              }
            } else {
              if (typeof propertyValue != 'function') {
                for (var k in propertyValue) {
                  if (propertyValue.hasOwnProperty(k)) {
                    value = propertyValue[k];
                    if (typeof value == 'string') {
                      data[propertyName][k] = Manager.get(value);
                    }
                  }
                }
              }
            }
          }
        }
      }
      continueFn.call(me, cls, data, hooks);
    });
    return false;
  }, true, 'after', 'className');
  Manager.registerPostprocessor('uses', function(name, cls, data) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(cls, 'Ext.Loader#usesPostprocessor', arguments);
    var uses = data.uses;
    if (uses) {
      Loader.addUsedClasses(uses);
    }
  });
  Manager.onCreated(Loader.historyPush);
};
if (Ext._classPathMetadata) {
  Ext.Loader.addClassPathMappings(Ext._classPathMetadata);
  Ext._classPathMetadata = null;
}
(function() {
  var scripts = document.getElementsByTagName('script'), currentScript = scripts[scripts.length - 1], src = currentScript.src, path = src.substring(0, src.lastIndexOf('/') + 1), Loader = Ext.Loader;
  if (src.indexOf('/platform/core/src/class/') != -1) {
    path = path + '../../../../extjs/';
  } else {
    if (src.indexOf('/core/src/class/') != -1) {
      path = path + '../../../';
    }
  }
  Loader.setConfig({enabled:true, disableCaching:/[?&](?:cache|disableCacheBuster)\b/i.test(location.search) || /(^|[ ;])ext-cache=1/.test(document.cookie) ? false : true, paths:{'Ext':path + 'src'}});
})();
Ext._endTime = (new Date).getTime();
if (Ext._beforereadyhandler) {
  Ext._beforereadyhandler();
}
Ext.Error = Ext.extend(Error, {statics:{ignore:false, raise:function(err) {
  err = err || {};
  if (Ext.isString(err)) {
    err = {msg:err};
  }
  var method = this.raise.caller, msg;
  if (method) {
    if (method.$name) {
      err.sourceMethod = method.$name;
    }
    if (method.$owner) {
      err.sourceClass = method.$owner.$className;
    }
  }
  if (Ext.Error.handle(err) !== true) {
    msg = Ext.Error.prototype.toString.call(err);
    Ext.log({msg:msg, level:'error', dump:err, stack:true});
    throw new Ext.Error(err);
  }
}, handle:function() {
  return Ext.Error.ignore;
}}, name:'Ext.Error', constructor:function(config) {
  if (Ext.isString(config)) {
    config = {msg:config};
  }
  var me = this;
  Ext.apply(me, config);
  me.message = me.message || me.msg;
}, toString:function() {
  var me = this, className = me.sourceClass ? me.sourceClass : '', methodName = me.sourceMethod ? '.' + me.sourceMethod + '(): ' : '', msg = me.msg || '(No description provided)';
  return className + methodName + msg;
}});
Ext.deprecated = function(suggestion) {
  if (!suggestion) {
    suggestion = '';
  }
  function fail() {
    Ext.Error.raise('The method "' + fail.$owner.$className + '.' + fail.$name + '" has been removed. ' + suggestion);
  }
  return fail;
  return Ext.emptyFn;
};
(function() {
  var timer, errors = 0, win = Ext.global, msg;
  if (typeof window === 'undefined') {
    return;
  }
  function notify() {
    var counters = Ext.log.counters, supports = Ext.supports, hasOnError = supports && supports.WindowOnError;
    if (counters && counters.error + counters.warn + counters.info + counters.log) {
      msg = ['Logged Errors:', counters.error, 'Warnings:', counters.warn, 'Info:', counters.info, 'Log:', counters.log].join(' ');
      if (errors) {
        msg = '*** Errors: ' + errors + ' - ' + msg;
      } else {
        if (counters.error) {
          msg = '*** ' + msg;
        }
      }
      win.status = msg;
    }
    if (!Ext.isDefined(Ext.Error.notify)) {
      Ext.Error.notify = Ext.isIE6 || Ext.isIE7;
    }
    if (Ext.Error.notify && (hasOnError ? errors : counters && counters.error)) {
      Ext.Error.notify = false;
      if (timer) {
        win.clearInterval(timer);
        timer = null;
      }
      alert('Unhandled error on page: See console or log');
      poll();
    }
  }
  function poll() {
    timer = win.setInterval(notify, 1000);
  }
  poll();
})();
Ext.JSON = new function() {
  var me = this, encodingFunction, decodingFunction, useNative = null, useHasOwn = !!{}.hasOwnProperty, isNative = function() {
    if (useNative === null) {
      useNative = Ext.USE_NATIVE_JSON && window.JSON && JSON.toString() == '[object JSON]';
    }
    return useNative;
  }, pad = function(n) {
    return n < 10 ? '0' + n : n;
  }, doDecode = function(json) {
    return eval('(' + json + ')');
  }, doEncode = function(o, newline) {
    if (o === null || o === undefined) {
      return 'null';
    } else {
      if (Ext.isDate(o)) {
        return Ext.JSON.encodeDate(o);
      } else {
        if (Ext.isString(o)) {
          return Ext.JSON.encodeString(o);
        } else {
          if (typeof o == 'number') {
            return isFinite(o) ? String(o) : 'null';
          } else {
            if (Ext.isBoolean(o)) {
              return String(o);
            } else {
              if (o.toJSON) {
                return o.toJSON();
              } else {
                if (Ext.isArray(o)) {
                  return encodeArray(o, newline);
                } else {
                  if (Ext.isObject(o)) {
                    return encodeObject(o, newline);
                  } else {
                    if (typeof o === 'function') {
                      return 'null';
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    return 'undefined';
  }, m = {'\b':'\\b', '\t':'\\t', '\n':'\\n', '\f':'\\f', '\r':'\\r', '"':'\\"', '\\':'\\\\', '\x0B':'\\u000b'}, charToReplace = /[\\"\x00-\x1f\x7f-\uffff]/g, encodeString = function(s) {
    return '"' + s.replace(charToReplace, function(a) {
      var c = m[a];
      return typeof c === 'string' ? c : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    }) + '"';
  }, encodeArrayPretty = function(o, newline) {
    var len = o.length, cnewline = newline + '   ', sep = ',' + cnewline, a = ['[', cnewline], i;
    for (i = 0; i < len; i += 1) {
      a.push(Ext.JSON.encodeValue(o[i], cnewline), sep);
    }
    a[a.length - 1] = newline + ']';
    return a.join('');
  }, encodeObjectPretty = function(o, newline) {
    var cnewline = newline + '   ', sep = ',' + cnewline, a = ['{', cnewline], i, val;
    for (i in o) {
      val = o[i];
      if (!useHasOwn || o.hasOwnProperty(i)) {
        if (typeof val === 'function' || val === undefined) {
          continue;
        }
        a.push(Ext.JSON.encodeValue(i) + ': ' + Ext.JSON.encodeValue(val, cnewline), sep);
      }
    }
    a[a.length - 1] = newline + '}';
    return a.join('');
  }, encodeArray = function(o, newline) {
    if (newline) {
      return encodeArrayPretty(o, newline);
    }
    var a = ['[', ''], len = o.length, i;
    for (i = 0; i < len; i += 1) {
      a.push(Ext.JSON.encodeValue(o[i]), ',');
    }
    a[a.length - 1] = ']';
    return a.join('');
  }, encodeObject = function(o, newline) {
    if (newline) {
      return encodeObjectPretty(o, newline);
    }
    var a = ['{', ''], i, val;
    for (i in o) {
      val = o[i];
      if (!useHasOwn || o.hasOwnProperty(i)) {
        if (typeof val === 'function' || val === undefined) {
          continue;
        }
        a.push(Ext.JSON.encodeValue(i), ':', Ext.JSON.encodeValue(val), ',');
      }
    }
    a[a.length - 1] = '}';
    return a.join('');
  };
  me.encodeString = encodeString;
  me.encodeValue = doEncode;
  me.encodeDate = function(o) {
    return '"' + o.getFullYear() + '-' + pad(o.getMonth() + 1) + '-' + pad(o.getDate()) + 'T' + pad(o.getHours()) + ':' + pad(o.getMinutes()) + ':' + pad(o.getSeconds()) + '"';
  };
  me.encode = function(o) {
    if (!encodingFunction) {
      encodingFunction = isNative() ? JSON.stringify : me.encodeValue;
    }
    return encodingFunction(o);
  };
  me.decode = function(json, safe) {
    if (!decodingFunction) {
      decodingFunction = isNative() ? JSON.parse : doDecode;
    }
    try {
      return decodingFunction(json);
    } catch (e$3) {
      if (safe === true) {
        return null;
      }
      Ext.Error.raise({sourceClass:'Ext.JSON', sourceMethod:'decode', msg:"You're trying to decode an invalid JSON String: " + json});
    }
  };
};
Ext.encode = Ext.JSON.encode;
Ext.decode = Ext.JSON.decode;
Ext.apply(Ext, {userAgent:navigator.userAgent.toLowerCase(), cache:{}, idSeed:1000, windowId:'ext-window', documentId:'ext-document', isReady:false, enableGarbageCollector:true, enableListenerCollection:true, rootHierarchyState:{}, addCacheEntry:function(id, el, dom) {
  dom = dom || el.dom;
  if (!dom) {
    Ext.Error.raise('Cannot add an entry to the element cache without the DOM node');
  }
  var cache = Ext.cache, key = id || el && el.id || dom.id, entry = cache[key] || (cache[key] = {data:{}, events:{}, dom:dom, skipGarbageCollection:!!(dom.getElementById || dom.navigator)});
  if (el) {
    el.$cache = entry;
    entry.el = el;
  }
  return entry;
}, updateCacheEntry:function(cacheItem, dom) {
  cacheItem.dom = dom;
  if (cacheItem.el) {
    cacheItem.el.dom = dom;
  }
  return cacheItem;
}, id:function(el, prefix) {
  var me = this, sandboxPrefix = '';
  el = Ext.getDom(el, true) || {};
  if (el === document) {
    el.id = me.documentId;
  } else {
    if (el === window) {
      el.id = me.windowId;
    }
  }
  if (!el.id) {
    if (me.isSandboxed) {
      sandboxPrefix = Ext.sandboxName.toLowerCase() + '-';
    }
    el.id = sandboxPrefix + (prefix || 'ext-gen') + ++Ext.idSeed;
  }
  return el.id;
}, escapeId:function() {
  var validIdRe = /^[a-zA-Z_][a-zA-Z0-9_\-]*$/i, escapeRx = /([\W]{1})/g, leadingNumRx = /^(\d)/g, escapeFn = function(match, capture) {
    return '\\' + capture;
  }, numEscapeFn = function(match, capture) {
    return '\\00' + capture.charCodeAt(0).toString(16) + ' ';
  };
  return function(id) {
    return validIdRe.test(id) ? id : id.replace(escapeRx, escapeFn).replace(leadingNumRx, numEscapeFn);
  };
}(), getBody:function() {
  var body;
  return function() {
    return body || (body = Ext.get(document.body));
  };
}(), getHead:function() {
  var head;
  return function() {
    return head || (head = Ext.get(document.getElementsByTagName('head')[0]));
  };
}(), getDoc:function() {
  var doc;
  return function() {
    return doc || (doc = Ext.get(document));
  };
}(), getOrientation:function() {
  return window.innerHeight > window.innerWidth ? 'portrait' : 'landscape';
}, destroy:function() {
  var ln = arguments.length, i, arg;
  for (i = 0; i < ln; i++) {
    arg = arguments[i];
    if (arg) {
      if (Ext.isArray(arg)) {
        this.destroy.apply(this, arg);
      } else {
        if (arg.isStore) {
          arg.destroyStore();
        } else {
          if (Ext.isFunction(arg.destroy)) {
            arg.destroy();
          } else {
            if (arg.dom) {
              arg.remove();
            }
          }
        }
      }
    }
  }
}, callback:function(callback, scope, args, delay) {
  var fn, ret;
  if (Ext.isFunction(callback)) {
    fn = callback;
  } else {
    if (scope && Ext.isString(callback)) {
      fn = scope[callback];
      if (!fn) {
        Ext.Error.raise('No method named "' + callback + '"');
      }
    }
  }
  if (fn) {
    args = args || [];
    scope = scope || window;
    if (delay) {
      Ext.defer(fn, delay, scope, args);
    } else {
      ret = fn.apply(scope, args);
    }
  }
  return ret;
}, resolveMethod:function(fn, scope) {
  if (Ext.isFunction(fn)) {
    return fn;
  }
  if (!Ext.isObject(scope) || !Ext.isFunction(scope[fn])) {
    Ext.Error.raise('No method named "' + fn + '"');
  }
  return scope[fn];
}, htmlEncode:function(value) {
  return Ext.String.htmlEncode(value);
}, htmlDecode:function(value) {
  return Ext.String.htmlDecode(value);
}, urlAppend:function(url, s) {
  return Ext.String.urlAppend(url, s);
}});
Ext.ns = Ext.namespace;
window.undefined = window.undefined;
(function() {
  var check = function(regex) {
    return regex.test(Ext.userAgent);
  }, isStrict = document.compatMode == 'CSS1Compat', version = function(is, regex) {
    var m;
    return is && (m = regex.exec(Ext.userAgent)) ? parseFloat(m[1]) : 0;
  }, docMode = document.documentMode, isOpera = check(/opera/), isOpera10_5 = isOpera && check(/version\/10\.5/), isChrome = check(/\bchrome\b/), isWebKit = check(/webkit/), isSafari = !isChrome && check(/safari/), isSafari2 = isSafari && check(/applewebkit\/4/), isSafari3 = isSafari && check(/version\/3/), isSafari4 = isSafari && check(/version\/4/), isSafari5_0 = isSafari && check(/version\/5\.0/), isSafari5 = isSafari && check(/version\/5/), isIE = !isOpera && check(/msie/), isIE7 = isIE && (check(/msie 7/) && 
  docMode != 8 && docMode != 9 && docMode != 10 || docMode == 7), isIE8 = isIE && (check(/msie 8/) && docMode != 7 && docMode != 9 && docMode != 10 || docMode == 8), isIE9 = isIE && (check(/msie 9/) && docMode != 7 && docMode != 8 && docMode != 10 || docMode == 9), isIE10 = isIE && (check(/msie 10/) && docMode != 7 && docMode != 8 && docMode != 9 || docMode == 10), isIE6 = isIE && check(/msie 6/), isGecko = !isWebKit && check(/gecko/), isGecko3 = isGecko && check(/rv:1\.9/), isGecko4 = isGecko && 
  check(/rv:2\.0/), isGecko5 = isGecko && check(/rv:5\./), isGecko10 = isGecko && check(/rv:10\./), isFF3_0 = isGecko3 && check(/rv:1\.9\.0/), isFF3_5 = isGecko3 && check(/rv:1\.9\.1/), isFF3_6 = isGecko3 && check(/rv:1\.9\.2/), isWindows = check(/windows|win32/), isMac = check(/macintosh|mac os x/), isLinux = check(/linux/), scrollbarSize = null, chromeVersion = version(true, /\bchrome\/(\d+\.\d+)/), firefoxVersion = version(true, /\bfirefox\/(\d+\.\d+)/), ieVersion = version(isIE, /msie (\d+\.\d+)/), 
  operaVersion = version(isOpera, /version\/(\d+\.\d+)/), safariVersion = version(isSafari, /version\/(\d+\.\d+)/), webKitVersion = version(isWebKit, /webkit\/(\d+\.\d+)/), isSecure = /^https/i.test(window.location.protocol), nullLog;
  try {
    document.execCommand('BackgroundImageCache', false, true);
  } catch (e$4) {
  }
  var primitiveRe = /string|number|boolean/;
  function dumpObject(object) {
    var member, type, value, name, members = [];
    for (name in object) {
      if (object.hasOwnProperty(name)) {
        value = object[name];
        type = typeof value;
        if (type == 'function') {
          continue;
        }
        if (type == 'undefined') {
          member = type;
        } else {
          if (value === null || primitiveRe.test(type) || Ext.isDate(value)) {
            member = Ext.encode(value);
          } else {
            if (Ext.isArray(value)) {
              member = '[ ]';
            } else {
              if (Ext.isObject(value)) {
                member = '{ }';
              } else {
                member = type;
              }
            }
          }
        }
        members.push(Ext.encode(name) + ': ' + member);
      }
    }
    if (members.length) {
      return ' \nData: {\n  ' + members.join(',\n  ') + '\n}';
    }
    return '';
  }
  function log(message) {
    var options, dump, con = Ext.global.console, level = 'log', indent = log.indent || 0, stack, out, max;
    log.indent = indent;
    if (typeof message != 'string') {
      options = message;
      message = options.msg || '';
      level = options.level || level;
      dump = options.dump;
      stack = options.stack;
      if (options.indent) {
        ++log.indent;
      } else {
        if (options.outdent) {
          log.indent = indent = Math.max(indent - 1, 0);
        }
      }
      if (dump && !(con && con.dir)) {
        message += dumpObject(dump);
        dump = null;
      }
    }
    if (arguments.length > 1) {
      message += Array.prototype.slice.call(arguments, 1).join('');
    }
    message = indent ? Ext.String.repeat(' ', log.indentSize * indent) + message : message;
    if (level != 'log') {
      message = '[' + level.charAt(0).toUpperCase() + '] ' + message;
    }
    if (con) {
      if (con[level]) {
        con[level](message);
      } else {
        con.log(message);
      }
      if (dump) {
        con.dir(dump);
      }
      if (stack && con.trace) {
        if (!con.firebug || level != 'error') {
          con.trace();
        }
      }
    } else {
      if (Ext.isOpera) {
        opera.postError(message);
      } else {
        out = log.out;
        max = log.max;
        if (out.length >= max) {
          Ext.Array.erase(out, 0, out.length - 3 * Math.floor(max / 4));
        }
        out.push(message);
      }
    }
    ++log.count;
    ++log.counters[level];
  }
  function logx(level, args) {
    if (typeof args[0] == 'string') {
      args.unshift({});
    }
    args[0].level = level;
    log.apply(this, args);
  }
  log.error = function() {
    logx('error', Array.prototype.slice.call(arguments));
  };
  log.info = function() {
    logx('info', Array.prototype.slice.call(arguments));
  };
  log.warn = function() {
    logx('warn', Array.prototype.slice.call(arguments));
  };
  log.count = 0;
  log.counters = {error:0, warn:0, info:0, log:0};
  log.indentSize = 2;
  log.out = [];
  log.max = 750;
  log.show = function() {
    window.open('', 'extlog').document.write(['\x3chtml\x3e\x3chead\x3e\x3cscript type\x3d"text/javascript"\x3e', 'var lastCount \x3d 0;', 'function update () {', 'var ext \x3d window.opener.Ext,', 'extlog \x3d ext \x26\x26 ext.log;', 'if (extlog \x26\x26 extlog.out \x26\x26 lastCount !\x3d extlog.count) {', 'lastCount \x3d extlog.count;', 'var s \x3d "\x3ctt\x3e" + extlog.out.join("~~~").replace(/[\x26]/g, "\x26amp;").replace(/[\x3c]/g, "\x26lt;").replace(/[ ]/g, "\x26#160;").replace(/\\~\\~\\~/g, "\x3cbr/\x3e") + "\x3c/tt\x3e";', 
    'document.body.innerHTML \x3d s;', '}', 'setTimeout(update, 1000);', '}', 'setTimeout(update, 1000);', '\x3c/script\x3e\x3c/head\x3e\x3cbody\x3e\x3c/body\x3e\x3c/html\x3e'].join(''));
  };
  nullLog = function() {
  };
  nullLog.info = nullLog.warn = nullLog.error = Ext.emptyFn;
  Ext.setVersion('extjs', '4.2.1.883');
  Ext.apply(Ext, {SSL_SECURE_URL:isSecure && isIE ? "javascript:''" : 'about:blank', plainTableCls:Ext.buildSettings.baseCSSPrefix + 'table-plain', plainListCls:Ext.buildSettings.baseCSSPrefix + 'list-plain', enableNestedListenerRemoval:false, USE_NATIVE_JSON:false, getDom:function(el, strict) {
    if (!el || !document) {
      return null;
    }
    if (el.dom) {
      return el.dom;
    } else {
      if (typeof el == 'string') {
        var e = Ext.getElementById(el);
        if (e && isIE && strict) {
          if (el == e.getAttribute('id')) {
            return e;
          } else {
            return null;
          }
        }
        return e;
      } else {
        return el;
      }
    }
  }, removeNode:isIE6 || isIE7 || isIE8 ? function() {
    var d;
    return function(n) {
      if (n && n.tagName.toUpperCase() != 'BODY') {
        Ext.enableNestedListenerRemoval ? Ext.EventManager.purgeElement(n) : Ext.EventManager.removeAll(n);
        var cache = Ext.cache, id = n.id;
        if (cache[id]) {
          delete cache[id].dom;
          delete cache[id];
        }
        if (isIE8 && n.parentNode) {
          n.parentNode.removeChild(n);
        }
        d = d || document.createElement('div');
        d.appendChild(n);
        d.innerHTML = '';
      }
    };
  }() : function(n) {
    if (n && n.parentNode && n.tagName.toUpperCase() != 'BODY') {
      Ext.enableNestedListenerRemoval ? Ext.EventManager.purgeElement(n) : Ext.EventManager.removeAll(n);
      var cache = Ext.cache, id = n.id;
      if (cache[id]) {
        delete cache[id].dom;
        delete cache[id];
      }
      n.parentNode.removeChild(n);
    }
  }, isStrict:isStrict, isIEQuirks:isIE && (!isStrict && (isIE6 || isIE7 || isIE8 || isIE9)), isOpera:isOpera, isOpera10_5:isOpera10_5, isWebKit:isWebKit, isChrome:isChrome, isSafari:isSafari, isSafari3:isSafari3, isSafari4:isSafari4, isSafari5:isSafari5, isSafari5_0:isSafari5_0, isSafari2:isSafari2, isIE:isIE, isIE6:isIE6, isIE7:isIE7, isIE7m:isIE6 || isIE7, isIE7p:isIE && !isIE6, isIE8:isIE8, isIE8m:isIE6 || isIE7 || isIE8, isIE8p:isIE && !(isIE6 || isIE7), isIE9:isIE9, isIE9m:isIE6 || isIE7 || 
  isIE8 || isIE9, isIE9p:isIE && !(isIE6 || isIE7 || isIE8), isIE10:isIE10, isIE10m:isIE6 || isIE7 || isIE8 || isIE9 || isIE10, isIE10p:isIE && !(isIE6 || isIE7 || isIE8 || isIE9), isGecko:isGecko, isGecko3:isGecko3, isGecko4:isGecko4, isGecko5:isGecko5, isGecko10:isGecko10, isFF3_0:isFF3_0, isFF3_5:isFF3_5, isFF3_6:isFF3_6, isFF4:4 <= firefoxVersion && firefoxVersion < 5, isFF5:5 <= firefoxVersion && firefoxVersion < 6, isFF10:10 <= firefoxVersion && firefoxVersion < 11, isLinux:isLinux, isWindows:isWindows, 
  isMac:isMac, chromeVersion:chromeVersion, firefoxVersion:firefoxVersion, ieVersion:ieVersion, operaVersion:operaVersion, safariVersion:safariVersion, webKitVersion:webKitVersion, isSecure:isSecure, BLANK_IMAGE_URL:isIE6 || isIE7 ? '/' + '/www.sencha.com/s.gif' : 'data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw\x3d\x3d', value:function(v, defaultValue, allowBlank) {
    return Ext.isEmpty(v, allowBlank) ? defaultValue : v;
  }, escapeRe:function(s) {
    return s.replace(/([-.*+?\^${}()|\[\]\/\\])/g, '\\$1');
  }, addBehaviors:function(o) {
    if (!Ext.isReady) {
      Ext.onReady(function() {
        Ext.addBehaviors(o);
      });
    } else {
      var cache = {}, parts, b, s;
      for (b in o) {
        if ((parts = b.split('@'))[1]) {
          s = parts[0];
          if (!cache[s]) {
            cache[s] = Ext.select(s);
          }
          cache[s].on(parts[1], o[b]);
        }
      }
      cache = null;
    }
  }, getScrollbarSize:function(force) {
    if (!Ext.isReady) {
      return {};
    }
    if (force || !scrollbarSize) {
      var db = document.body, div = document.createElement('div');
      div.style.width = div.style.height = '100px';
      div.style.overflow = 'scroll';
      div.style.position = 'absolute';
      db.appendChild(div);
      scrollbarSize = {width:div.offsetWidth - div.clientWidth, height:div.offsetHeight - div.clientHeight};
      db.removeChild(div);
    }
    return scrollbarSize;
  }, getScrollBarWidth:function(force) {
    var size = Ext.getScrollbarSize(force);
    return size.width + 2;
  }, copyTo:function(dest, source, names, usePrototypeKeys) {
    if (typeof names == 'string') {
      names = names.split(/[,;\s]/);
    }
    var n, nLen = names ? names.length : 0, name;
    for (n = 0; n < nLen; n++) {
      name = names[n];
      if (usePrototypeKeys || source.hasOwnProperty(name)) {
        dest[name] = source[name];
      }
    }
    return dest;
  }, destroyMembers:function(o) {
    for (var i = 1, a = arguments, len = a.length; i < len; i++) {
      Ext.destroy(o[a[i]]);
      delete o[a[i]];
    }
  }, log:log || nullLog, partition:function(arr, truth) {
    var ret = [[], []], a, v, aLen = arr.length;
    for (a = 0; a < aLen; a++) {
      v = arr[a];
      ret[truth && truth(v, a, arr) || !truth && v ? 0 : 1].push(v);
    }
    return ret;
  }, invoke:function(arr, methodName) {
    var ret = [], args = Array.prototype.slice.call(arguments, 2), a, v, aLen = arr.length;
    for (a = 0; a < aLen; a++) {
      v = arr[a];
      if (v && typeof v[methodName] == 'function') {
        ret.push(v[methodName].apply(v, args));
      } else {
        ret.push(undefined);
      }
    }
    return ret;
  }, zip:function() {
    var parts = Ext.partition(arguments, function(val) {
      return typeof val != 'function';
    }), arrs = parts[0], fn = parts[1][0], len = Ext.max(Ext.pluck(arrs, 'length')), ret = [], i, j, aLen;
    for (i = 0; i < len; i++) {
      ret[i] = [];
      if (fn) {
        ret[i] = fn.apply(fn, Ext.pluck(arrs, i));
      } else {
        for (j = 0, aLen = arrs.length; j < aLen; j++) {
          ret[i].push(arrs[j][i]);
        }
      }
    }
    return ret;
  }, toSentence:function(items, connector) {
    var length = items.length, head, tail;
    if (length <= 1) {
      return items[0];
    } else {
      head = items.slice(0, length - 1);
      tail = items[length - 1];
      return Ext.util.Format.format('{0} {1} {2}', head.join(', '), connector || 'and', tail);
    }
  }, setGlyphFontFamily:function(fontFamily) {
    Ext._glyphFontFamily = fontFamily;
  }, useShims:isIE6});
})();
Ext.application = function(config) {
  var App, paths, ns;
  if (typeof config === 'string') {
    Ext.require(config, function() {
      App = Ext.ClassManager.get(config);
    });
  } else {
    Ext.Loader.setPath(config.name, config.appFolder || 'app');
    if (paths = config.paths) {
      for (ns in paths) {
        if (paths.hasOwnProperty(ns)) {
          Ext.Loader.setPath(ns, paths[ns]);
        }
      }
    }
    config['paths processed'] = true;
    Ext.define(config.name + '.$application', Ext.apply({extend:'Ext.app.Application'}, config), function() {
      App = this;
    });
  }
  Ext.onReady(function() {
    Ext.app.Application.instance = new App;
  });
};
(function() {
  Ext.ns('Ext.util');
  var UtilFormat = Ext.util.Format = {}, stripTagsRE = /<\/?[^>]+>/gi, stripScriptsRe = /(?:<script.*?>)((\n|\r|.)*?)(?:<\/script>)/ig, nl2brRe = /\r?\n/g, allHashes = /^#+$/, formatPattern = /[\d,\.#]+/, formatCleanRe = /[^\d\.#]/g, I18NFormatCleanRe, formatFns = {};
  Ext.apply(UtilFormat, {thousandSeparator:',', decimalSeparator:'.', currencyPrecision:2, currencySign:'$', currencyAtEnd:false, undef:function(value) {
    return value !== undefined ? value : '';
  }, defaultValue:function(value, defaultValue) {
    return value !== undefined && value !== '' ? value : defaultValue;
  }, substr:'ab'.substr(-1) != 'b' ? function(value, start, length) {
    var str = String(value);
    return start < 0 ? str.substr(Math.max(str.length + start, 0), length) : str.substr(start, length);
  } : function(value, start, length) {
    return String(value).substr(start, length);
  }, lowercase:function(value) {
    return String(value).toLowerCase();
  }, uppercase:function(value) {
    return String(value).toUpperCase();
  }, usMoney:function(v) {
    return UtilFormat.currency(v, '$', 2);
  }, currency:function(v, currencySign, decimals, end) {
    var negativeSign = '', format = ',0', i = 0;
    v = v - 0;
    if (v < 0) {
      v = -v;
      negativeSign = '-';
    }
    decimals = Ext.isDefined(decimals) ? decimals : UtilFormat.currencyPrecision;
    format += decimals > 0 ? '.' : '';
    for (; i < decimals; i++) {
      format += '0';
    }
    v = UtilFormat.number(v, format);
    if ((end || UtilFormat.currencyAtEnd) === true) {
      return Ext.String.format('{0}{1}{2}', negativeSign, v, currencySign || UtilFormat.currencySign);
    } else {
      return Ext.String.format('{0}{1}{2}', negativeSign, currencySign || UtilFormat.currencySign, v);
    }
  }, date:function(v, format) {
    if (!v) {
      return '';
    }
    if (!Ext.isDate(v)) {
      v = new Date(Date.parse(v));
    }
    return Ext.Date.dateFormat(v, format || Ext.Date.defaultFormat);
  }, dateRenderer:function(format) {
    return function(v) {
      return UtilFormat.date(v, format);
    };
  }, stripTags:function(v) {
    return !v ? v : String(v).replace(stripTagsRE, '');
  }, stripScripts:function(v) {
    return !v ? v : String(v).replace(stripScriptsRe, '');
  }, fileSize:function() {
    var byteLimit = 1024, kbLimit = 1048576, mbLimit = 1073741824;
    return function(size) {
      var out;
      if (size < byteLimit) {
        if (size === 1) {
          out = '1 byte';
        } else {
          out = size + ' bytes';
        }
      } else {
        if (size < kbLimit) {
          out = Math.round(size * 10 / byteLimit) / 10 + ' KB';
        } else {
          if (size < mbLimit) {
            out = Math.round(size * 10 / kbLimit) / 10 + ' MB';
          } else {
            out = Math.round(size * 10 / mbLimit) / 10 + ' GB';
          }
        }
      }
      return out;
    };
  }(), math:function() {
    var fns = {};
    return function(v, a) {
      if (!fns[a]) {
        fns[a] = Ext.functionFactory('v', 'return v ' + a + ';');
      }
      return fns[a](v);
    };
  }(), round:function(value, precision) {
    var result = Number(value);
    if (typeof precision == 'number') {
      precision = Math.pow(10, precision);
      result = Math.round(value * precision) / precision;
    }
    return result;
  }, number:function(v, formatString) {
    if (!formatString) {
      return v;
    }
    var formatFn = formatFns[formatString];
    if (!formatFn) {
      var originalFormatString = formatString, comma = UtilFormat.thousandSeparator, decimalSeparator = UtilFormat.decimalSeparator, hasComma, splitFormat, extraChars, precision = 0, multiplier, trimTrailingZeroes, code;
      if (formatString.substr(formatString.length - 2) == '/i') {
        if (!I18NFormatCleanRe) {
          I18NFormatCleanRe = new RegExp('[^\\d\\' + UtilFormat.decimalSeparator + ']', 'g');
        }
        formatString = formatString.substr(0, formatString.length - 2);
        hasComma = formatString.indexOf(comma) != -1;
        splitFormat = formatString.replace(I18NFormatCleanRe, '').split(decimalSeparator);
      } else {
        hasComma = formatString.indexOf(',') != -1;
        splitFormat = formatString.replace(formatCleanRe, '').split('.');
      }
      extraChars = formatString.replace(formatPattern, '');
      if (splitFormat.length > 2) {
        Ext.Error.raise({sourceClass:'Ext.util.Format', sourceMethod:'number', value:v, formatString:formatString, msg:'Invalid number format, should have no more than 1 decimal'});
      } else {
        if (splitFormat.length === 2) {
          precision = splitFormat[1].length;
          trimTrailingZeroes = allHashes.test(splitFormat[1]);
        }
      }
      code = ['var utilFormat\x3dExt.util.Format,extNumber\x3dExt.Number,neg,fnum,parts' + (hasComma ? ',thousandSeparator,thousands\x3d[],j,n,i' : '') + (extraChars ? ',formatString\x3d"' + formatString + '",formatPattern\x3d/[\\d,\\.#]+/' : '') + (trimTrailingZeroes ? ',trailingZeroes\x3d/\\.?0+$/;' : ';') + 'return function(v){' + 'if(typeof v!\x3d\x3d"number"\x26\x26isNaN(v\x3dextNumber.from(v,NaN)))return"";' + 'neg\x3dv\x3c0;', 'fnum\x3dExt.Number.toFixed(Math.abs(v), ' + precision + ');'];
      if (hasComma) {
        if (precision) {
          code[code.length] = 'parts\x3dfnum.split(".");';
          code[code.length] = 'fnum\x3dparts[0];';
        }
        code[code.length] = 'if(v\x3e\x3d1000) {';
        code[code.length] = 'thousandSeparator\x3dutilFormat.thousandSeparator;' + 'thousands.length\x3d0;' + 'j\x3dfnum.length;' + 'n\x3dfnum.length%3||3;' + 'for(i\x3d0;i\x3cj;i+\x3dn){' + 'if(i!\x3d\x3d0){' + 'n\x3d3;' + '}' + 'thousands[thousands.length]\x3dfnum.substr(i,n);' + '}' + 'fnum\x3dthousands.join(thousandSeparator);' + '}';
        if (precision) {
          code[code.length] = 'fnum +\x3d utilFormat.decimalSeparator+parts[1];';
        }
      } else {
        if (precision) {
          code[code.length] = 'if(utilFormat.decimalSeparator!\x3d\x3d"."){' + 'parts\x3dfnum.split(".");' + 'fnum\x3dparts[0]+utilFormat.decimalSeparator+parts[1];' + '}';
        }
      }
      if (trimTrailingZeroes) {
        code[code.length] = 'fnum\x3dfnum.replace(trailingZeroes,"");';
      }
      code[code.length] = 'if(neg\x26\x26fnum!\x3d\x3d"' + (precision ? '0.' + Ext.String.repeat('0', precision) : '0') + '")fnum\x3d"-"+fnum;';
      code[code.length] = 'return ';
      if (extraChars) {
        code[code.length] = 'formatString.replace(formatPattern, fnum);';
      } else {
        code[code.length] = 'fnum;';
      }
      code[code.length] = '};';
      formatFn = formatFns[originalFormatString] = Ext.functionFactory('Ext', code.join(''))(Ext);
    }
    return formatFn(v);
  }, numberRenderer:function(format) {
    return function(v) {
      return UtilFormat.number(v, format);
    };
  }, attributes:function(attributes) {
    if (typeof attributes === 'object') {
      var result = [], name;
      for (name in attributes) {
        result.push(name, '\x3d"', name === 'style' ? Ext.DomHelper.generateStyles(attributes[name]) : Ext.htmlEncode(attributes[name]), '"');
      }
      attributes = result.join('');
    }
    return attributes || '';
  }, plural:function(v, s, p) {
    return v + ' ' + (v == 1 ? s : p ? p : s + 's');
  }, nl2br:function(v) {
    return Ext.isEmpty(v) ? '' : v.replace(nl2brRe, '\x3cbr/\x3e');
  }, capitalize:Ext.String.capitalize, ellipsis:Ext.String.ellipsis, format:Ext.String.format, htmlDecode:Ext.String.htmlDecode, htmlEncode:Ext.String.htmlEncode, leftPad:Ext.String.leftPad, trim:Ext.String.trim, parseBox:function(box) {
    box = box || 0;
    if (typeof box === 'number') {
      return {top:box, right:box, bottom:box, left:box};
    }
    var parts = box.split(' '), ln = parts.length;
    if (ln == 1) {
      parts[1] = parts[2] = parts[3] = parts[0];
    } else {
      if (ln == 2) {
        parts[2] = parts[0];
        parts[3] = parts[1];
      } else {
        if (ln == 3) {
          parts[3] = parts[1];
        }
      }
    }
    return {top:parseInt(parts[0], 10) || 0, right:parseInt(parts[1], 10) || 0, bottom:parseInt(parts[2], 10) || 0, left:parseInt(parts[3], 10) || 0};
  }, escapeRegex:function(s) {
    return s.replace(/([\-.*+?\^${}()|\[\]\/\\])/g, '\\$1');
  }});
})();
Ext.define('Ext.util.TaskRunner', {interval:10, timerId:null, constructor:function(interval) {
  var me = this;
  if (typeof interval == 'number') {
    me.interval = interval;
  } else {
    if (interval) {
      Ext.apply(me, interval);
    }
  }
  me.tasks = [];
  me.timerFn = Ext.Function.bind(me.onTick, me);
}, newTask:function(config) {
  var task = new Ext.util.TaskRunner.Task(config);
  task.manager = this;
  return task;
}, start:function(task) {
  var me = this, now = Ext.Date.now();
  if (!task.pending) {
    me.tasks.push(task);
    task.pending = true;
  }
  task.stopped = false;
  task.taskStartTime = now;
  task.taskRunTime = task.fireOnStart !== false ? 0 : task.taskStartTime;
  task.taskRunCount = 0;
  if (!me.firing) {
    if (task.fireOnStart !== false) {
      me.startTimer(0, now);
    } else {
      me.startTimer(task.interval, now);
    }
  }
  return task;
}, stop:function(task) {
  if (!task.stopped) {
    task.stopped = true;
    if (task.onStop) {
      task.onStop.call(task.scope || task, task);
    }
  }
  return task;
}, stopAll:function() {
  Ext.each(this.tasks, this.stop, this);
}, firing:false, nextExpires:1.0E99, onTick:function() {
  var me = this, tasks = me.tasks, now = Ext.Date.now(), nextExpires = 1.0E99, len = tasks.length, expires, newTasks, i, task, rt, remove;
  me.timerId = null;
  me.firing = true;
  for (i = 0; i < len || i < (len = tasks.length); ++i) {
    task = tasks[i];
    if (!(remove = task.stopped)) {
      expires = task.taskRunTime + task.interval;
      if (expires <= now) {
        rt = 1;
        try {
          rt = task.run.apply(task.scope || task, task.args || [++task.taskRunCount]);
        } catch (taskError) {
          try {
            Ext.log({msg:taskError, level:'error'});
            if (task.onError) {
              rt = task.onError.call(task.scope || task, task, taskError);
            }
          } catch (ignore) {
          }
        }
        task.taskRunTime = now;
        if (rt === false || task.taskRunCount === task.repeat) {
          me.stop(task);
          remove = true;
        } else {
          remove = task.stopped;
          expires = now + task.interval;
        }
      }
      if (!remove && task.duration && task.duration <= now - task.taskStartTime) {
        me.stop(task);
        remove = true;
      }
    }
    if (remove) {
      task.pending = false;
      if (!newTasks) {
        newTasks = tasks.slice(0, i);
      }
    } else {
      if (newTasks) {
        newTasks.push(task);
      }
      if (nextExpires > expires) {
        nextExpires = expires;
      }
    }
  }
  if (newTasks) {
    me.tasks = newTasks;
  }
  me.firing = false;
  if (me.tasks.length) {
    me.startTimer(nextExpires - now, Ext.Date.now());
  }
  if (me.fireIdleEvent !== false) {
    Ext.EventManager.idleEvent.fire();
  }
}, startTimer:function(timeout, now) {
  var me = this, expires = now + timeout, timerId = me.timerId;
  if (timerId && me.nextExpires - expires > me.interval) {
    clearTimeout(timerId);
    timerId = null;
  }
  if (!timerId) {
    if (timeout < me.interval) {
      timeout = me.interval;
    }
    me.timerId = setTimeout(me.timerFn, timeout);
    me.nextExpires = expires;
  }
}}, function() {
  var me = this, proto = me.prototype;
  proto.destroy = proto.stopAll;
  Ext.util.TaskManager = Ext.TaskManager = new me;
  me.Task = new Ext.Class({isTask:true, stopped:true, fireOnStart:false, constructor:function(config) {
    Ext.apply(this, config);
  }, restart:function(interval) {
    if (interval !== undefined) {
      this.interval = interval;
    }
    this.manager.start(this);
  }, start:function(interval) {
    if (this.stopped) {
      this.restart(interval);
    }
  }, stop:function() {
    this.manager.stop(this);
  }});
  proto = me.Task.prototype;
  proto.destroy = proto.stop;
});
Ext.define('Ext.util.TaskManager', {extend:Ext.util.TaskRunner, alternateClassName:['Ext.TaskManager'], singleton:true});
Ext.define('Ext.perf.Accumulator', function() {
  var currentFrame = null, khrome = Ext.global['chrome'], formatTpl, getTimestamp = function() {
    getTimestamp = function() {
      return (new Date).getTime();
    };
    var interval, toolbox;
    if (Ext.isChrome && khrome && khrome.Interval) {
      interval = new khrome.Interval;
      interval.start();
      getTimestamp = function() {
        return interval.microseconds() / 1000;
      };
    } else {
      if (window.ActiveXObject) {
        try {
          toolbox = new ActiveXObject('SenchaToolbox.Toolbox');
          Ext.senchaToolbox = toolbox;
          getTimestamp = function() {
            return toolbox.milliseconds;
          };
        } catch (e$5) {
        }
      } else {
        if (Date.now) {
          getTimestamp = Date.now;
        }
      }
    }
    Ext.perf.getTimestamp = Ext.perf.Accumulator.getTimestamp = getTimestamp;
    return getTimestamp();
  };
  function adjustSet(set, time) {
    set.sum += time;
    set.min = Math.min(set.min, time);
    set.max = Math.max(set.max, time);
  }
  function leaveFrame(time) {
    var totalTime = time ? time : getTimestamp() - this.time, me = this, accum = me.accum;
    ++accum.count;
    if (!--accum.depth) {
      adjustSet(accum.total, totalTime);
    }
    adjustSet(accum.pure, totalTime - me.childTime);
    currentFrame = me.parent;
    if (currentFrame) {
      ++currentFrame.accum.childCount;
      currentFrame.childTime += totalTime;
    }
  }
  function makeSet() {
    return {min:Number.MAX_VALUE, max:0, sum:0};
  }
  function makeTap(me, fn) {
    return function() {
      var frame = me.enter(), ret = fn.apply(this, arguments);
      frame.leave();
      return ret;
    };
  }
  function round(x) {
    return Math.round(x * 100) / 100;
  }
  function setToJSON(count, childCount, calibration, set) {
    var data = {avg:0, min:set.min, max:set.max, sum:0};
    if (count) {
      calibration = calibration || 0;
      data.sum = set.sum - childCount * calibration;
      data.avg = data.sum / count;
    }
    return data;
  }
  return {constructor:function(name) {
    var me = this;
    me.count = me.childCount = me.depth = me.maxDepth = 0;
    me.pure = makeSet();
    me.total = makeSet();
    me.name = name;
  }, statics:{getTimestamp:getTimestamp}, format:function(calibration) {
    if (!formatTpl) {
      formatTpl = new Ext.XTemplate(['{name} - {count} call(s)', '\x3ctpl if\x3d"count"\x3e', '\x3ctpl if\x3d"childCount"\x3e', ' ({childCount} children)', '\x3c/tpl\x3e', '\x3ctpl if\x3d"depth - 1"\x3e', ' ({depth} deep)', '\x3c/tpl\x3e', '\x3ctpl for\x3d"times"\x3e', ', {type}: {[this.time(values.sum)]} msec (', 'avg\x3d{[this.time(values.sum / parent.count)]}', ')', '\x3c/tpl\x3e', '\x3c/tpl\x3e'].join(''), {time:function(t) {
        return Math.round(t * 100) / 100;
      }});
    }
    var data = this.getData(calibration);
    data.name = this.name;
    data.pure.type = 'Pure';
    data.total.type = 'Total';
    data.times = [data.pure, data.total];
    return formatTpl.apply(data);
  }, getData:function(calibration) {
    var me = this;
    return {count:me.count, childCount:me.childCount, depth:me.maxDepth, pure:setToJSON(me.count, me.childCount, calibration, me.pure), total:setToJSON(me.count, me.childCount, calibration, me.total)};
  }, enter:function() {
    var me = this, frame = {accum:me, leave:leaveFrame, childTime:0, parent:currentFrame};
    ++me.depth;
    if (me.maxDepth < me.depth) {
      me.maxDepth = me.depth;
    }
    currentFrame = frame;
    frame.time = getTimestamp();
    return frame;
  }, monitor:function(fn, scope, args) {
    var frame = this.enter();
    if (args) {
      fn.apply(scope, args);
    } else {
      fn.call(scope);
    }
    frame.leave();
  }, report:function() {
    Ext.log(this.format());
  }, tap:function(className, methodName) {
    var me = this, methods = typeof methodName == 'string' ? [methodName] : methodName, klass, statik, i, parts, length, name, src, tapFunc;
    tapFunc = function() {
      if (typeof className == 'string') {
        klass = Ext.global;
        parts = className.split('.');
        for (i = 0, length = parts.length; i < length; ++i) {
          klass = klass[parts[i]];
        }
      } else {
        klass = className;
      }
      for (i = 0, length = methods.length; i < length; ++i) {
        name = methods[i];
        statik = name.charAt(0) == '!';
        if (statik) {
          name = name.substring(1);
        } else {
          statik = !(name in klass.prototype);
        }
        src = statik ? klass : klass.prototype;
        src[name] = makeTap(me, src[name]);
      }
    };
    Ext.ClassManager.onCreated(tapFunc, me, className);
    return me;
  }};
}(), function() {
  Ext.perf.getTimestamp = this.getTimestamp;
});
Ext.define('Ext.perf.Monitor', {singleton:true, alternateClassName:'Ext.Perf', constructor:function() {
  this.accumulators = [];
  this.accumulatorsByName = {};
}, calibrate:function() {
  var accum = new Ext.perf.Accumulator('$'), total = accum.total, getTimestamp = Ext.perf.Accumulator.getTimestamp, count = 0, frame, endTime, startTime;
  startTime = getTimestamp();
  do {
    frame = accum.enter();
    frame.leave();
    ++count;
  } while (total.sum < 100);
  endTime = getTimestamp();
  return (endTime - startTime) / count;
}, get:function(name) {
  var me = this, accum = me.accumulatorsByName[name];
  if (!accum) {
    me.accumulatorsByName[name] = accum = new Ext.perf.Accumulator(name);
    me.accumulators.push(accum);
  }
  return accum;
}, enter:function(name) {
  return this.get(name).enter();
}, monitor:function(name, fn, scope) {
  this.get(name).monitor(fn, scope);
}, report:function() {
  var me = this, accumulators = me.accumulators, calibration = me.calibrate();
  accumulators.sort(function(a, b) {
    return a.name < b.name ? -1 : b.name < a.name ? 1 : 0;
  });
  me.updateGC();
  Ext.log('Calibration: ' + Math.round(calibration * 100) / 100 + ' msec/sample');
  Ext.each(accumulators, function(accum) {
    Ext.log(accum.format(calibration));
  });
}, getData:function(all) {
  var ret = {}, accumulators = this.accumulators;
  Ext.each(accumulators, function(accum) {
    if (all || accum.count) {
      ret[accum.name] = accum.getData();
    }
  });
  return ret;
}, reset:function() {
  Ext.each(this.accumulators, function(accum) {
    var me = accum;
    me.count = me.childCount = me.depth = me.maxDepth = 0;
    me.pure = {min:Number.MAX_VALUE, max:0, sum:0};
    me.total = {min:Number.MAX_VALUE, max:0, sum:0};
  });
}, updateGC:function() {
  var accumGC = this.accumulatorsByName.GC, toolbox = Ext.senchaToolbox, bucket;
  if (accumGC) {
    accumGC.count = toolbox.garbageCollectionCounter || 0;
    if (accumGC.count) {
      bucket = accumGC.pure;
      accumGC.total.sum = bucket.sum = toolbox.garbageCollectionMilliseconds;
      bucket.min = bucket.max = bucket.sum / accumGC.count;
      bucket = accumGC.total;
      bucket.min = bucket.max = bucket.sum / accumGC.count;
    }
  }
}, watchGC:function() {
  Ext.perf.getTimestamp();
  var toolbox = Ext.senchaToolbox;
  if (toolbox) {
    this.get('GC');
    toolbox.watchGarbageCollector(false);
  }
}, setup:function(config) {
  if (!config) {
    config = {render:{'Ext.AbstractComponent':'render'}, layout:{'Ext.layout.Context':'run'}};
  }
  this.currentConfig = config;
  var key, prop, accum, className, methods;
  for (key in config) {
    if (config.hasOwnProperty(key)) {
      prop = config[key];
      accum = Ext.Perf.get(key);
      for (className in prop) {
        if (prop.hasOwnProperty(className)) {
          methods = prop[className];
          accum.tap(className, methods);
        }
      }
    }
  }
  this.watchGC();
}});
Ext.is = {init:function(navigator) {
  var platforms = this.platforms, ln = platforms.length, i, platform;
  navigator = navigator || window.navigator;
  for (i = 0; i < ln; i++) {
    platform = platforms[i];
    this[platform.identity] = platform.regex.test(navigator[platform.property]);
  }
  this.Desktop = this.Mac || this.Windows || this.Linux && !this.Android;
  this.Tablet = this.iPad;
  this.Phone = !this.Desktop && !this.Tablet;
  this.iOS = this.iPhone || this.iPad || this.iPod;
  this.Standalone = !!window.navigator.standalone;
}, platforms:[{property:'platform', regex:/iPhone/i, identity:'iPhone'}, {property:'platform', regex:/iPod/i, identity:'iPod'}, {property:'userAgent', regex:/iPad/i, identity:'iPad'}, {property:'userAgent', regex:/Blackberry/i, identity:'Blackberry'}, {property:'userAgent', regex:/Android/i, identity:'Android'}, {property:'platform', regex:/Mac/i, identity:'Mac'}, {property:'platform', regex:/Win/i, identity:'Windows'}, {property:'platform', regex:/Linux/i, identity:'Linux'}]};
Ext.is.init();
(function() {
  var getStyle = function(element, styleName) {
    var view = element.ownerDocument.defaultView, style = (view ? view.getComputedStyle(element, null) : element.currentStyle) || element.style;
    return style[styleName];
  }, supportsVectors = {'IE6-quirks':[0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0], 'IE6-strict':[0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0], 'IE7-quirks':[0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0], 'IE7-strict':[0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0], 'IE8-quirks':[0, 
  1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0], 'IE8-strict':[0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1], 'IE9-quirks':[0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0], 'IE9-strict':[0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1], 'IE10-quirks':[1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 
  1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1], 'IE10-strict':[1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1]};
  function getBrowserKey() {
    var browser = Ext.isIE6 ? 'IE6' : Ext.isIE7 ? 'IE7' : Ext.isIE8 ? 'IE8' : Ext.isIE9 ? 'IE9' : Ext.isIE10 ? 'IE10' : '';
    return browser ? browser + (Ext.isStrict ? '-strict' : '-quirks') : '';
  }
  Ext.supports = {init:function() {
    var me = this, doc = document, toRun = me.toRun || me.tests, n = toRun.length, div = n && Ext.isReady && doc.createElement('div'), notRun = [], browserKey = getBrowserKey(), test, vector, value;
    if (div) {
      div.innerHTML = ['\x3cdiv style\x3d"height:30px;width:50px;"\x3e', '\x3cdiv style\x3d"height:20px;width:20px;"\x3e\x3c/div\x3e', '\x3c/div\x3e', '\x3cdiv style\x3d"width: 200px; height: 200px; position: relative; padding: 5px;"\x3e', '\x3cdiv style\x3d"position: absolute; top: 0; left: 0; width: 100%; height: 100%;"\x3e\x3c/div\x3e', '\x3c/div\x3e', '\x3cdiv style\x3d"position: absolute; left: 10%; top: 10%;"\x3e\x3c/div\x3e', '\x3cdiv style\x3d"float:left; background-color:transparent;"\x3e\x3c/div\x3e'].join('');
      doc.body.appendChild(div);
    }
    vector = supportsVectors[browserKey];
    while (n--) {
      test = toRun[n];
      value = vector && vector[n];
      if (value !== undefined) {
        me[test.identity] = value;
      } else {
        if (div || test.early) {
          me[test.identity] = test.fn.call(me, doc, div);
        } else {
          notRun.push(test);
        }
      }
    }
    if (div) {
      doc.body.removeChild(div);
    }
    me.toRun = notRun;
  }, generateVector:function() {
    var tests = this.tests, vector = [], i = 0, ln = tests.length, test;
    for (; i < ln; i++) {
      test = tests[i];
      vector.push(this[test.identity] ? 1 : 0);
    }
    return vector;
  }, PointerEvents:'pointerEvents' in document.documentElement.style, LocalStorage:function() {
    try {
      return 'localStorage' in window && window['localStorage'] !== null;
    } catch (e$6) {
      return false;
    }
  }(), CSS3BoxShadow:'boxShadow' in document.documentElement.style || 'WebkitBoxShadow' in document.documentElement.style || 'MozBoxShadow' in document.documentElement.style, ClassList:!!document.documentElement.classList, OrientationChange:typeof window.orientation != 'undefined' && 'onorientationchange' in window, DeviceMotion:'ondevicemotion' in window, Touch:'ontouchstart' in window && !Ext.is.Desktop, TimeoutActualLateness:function() {
    setTimeout(function() {
      Ext.supports.TimeoutActualLateness = arguments.length !== 0;
    }, 0);
  }(), tests:[{identity:'Transitions', fn:function(doc, div) {
    var prefix = ['webkit', 'Moz', 'o', 'ms', 'khtml'], TE = 'TransitionEnd', transitionEndName = [prefix[0] + TE, 'transitionend', prefix[2] + TE, prefix[3] + TE, prefix[4] + TE], ln = prefix.length, i = 0, out = false;
    for (; i < ln; i++) {
      if (getStyle(div, prefix[i] + 'TransitionProperty')) {
        Ext.supports.CSS3Prefix = prefix[i];
        Ext.supports.CSS3TransitionEnd = transitionEndName[i];
        out = true;
        break;
      }
    }
    return out;
  }}, {identity:'RightMargin', fn:function(doc, div) {
    var view = doc.defaultView;
    return !(view && view.getComputedStyle(div.firstChild.firstChild, null).marginRight != '0px');
  }}, {identity:'DisplayChangeInputSelectionBug', early:true, fn:function() {
    var webKitVersion = Ext.webKitVersion;
    return 0 < webKitVersion && webKitVersion < 533;
  }}, {identity:'DisplayChangeTextAreaSelectionBug', early:true, fn:function() {
    var webKitVersion = Ext.webKitVersion;
    return 0 < webKitVersion && webKitVersion < 534.24;
  }}, {identity:'TransparentColor', fn:function(doc, div, view) {
    view = doc.defaultView;
    return !(view && view.getComputedStyle(div.lastChild, null).backgroundColor != 'transparent');
  }}, {identity:'ComputedStyle', fn:function(doc, div, view) {
    view = doc.defaultView;
    return view && view.getComputedStyle;
  }}, {identity:'Svg', fn:function(doc) {
    return !!doc.createElementNS && !!doc.createElementNS('http:/' + '/www.w3.org/2000/svg', 'svg').createSVGRect;
  }}, {identity:'Canvas', fn:function(doc) {
    return !!doc.createElement('canvas').getContext;
  }}, {identity:'Vml', fn:function(doc) {
    var d = doc.createElement('div');
    d.innerHTML = '\x3c!--[if vml]\x3e\x3cbr/\x3e\x3cbr/\x3e\x3c![endif]--\x3e';
    return d.childNodes.length == 2;
  }}, {identity:'Float', fn:function(doc, div) {
    return !!div.lastChild.style.cssFloat;
  }}, {identity:'AudioTag', fn:function(doc) {
    return !!doc.createElement('audio').canPlayType;
  }}, {identity:'History', fn:function() {
    var history = window.history;
    return !!(history && history.pushState);
  }}, {identity:'CSS3DTransform', fn:function() {
    return typeof WebKitCSSMatrix != 'undefined' && (new WebKitCSSMatrix).hasOwnProperty('m41');
  }}, {identity:'CSS3LinearGradient', fn:function(doc, div) {
    var property = 'background-image:', webkit = '-webkit-gradient(linear, left top, right bottom, from(black), to(white))', w3c = 'linear-gradient(left top, black, white)', moz = '-moz-' + w3c, ms = '-ms-' + w3c, opera = '-o-' + w3c, options = [property + webkit, property + w3c, property + moz, property + ms, property + opera];
    div.style.cssText = options.join(';');
    return ('' + div.style.backgroundImage).indexOf('gradient') !== -1 && !Ext.isIE9;
  }}, {identity:'CSS3BorderRadius', fn:function(doc, div) {
    var domPrefixes = ['borderRadius', 'BorderRadius', 'MozBorderRadius', 'WebkitBorderRadius', 'OBorderRadius', 'KhtmlBorderRadius'], pass = false, i;
    for (i = 0; i < domPrefixes.length; i++) {
      if (document.body.style[domPrefixes[i]] !== undefined) {
        return true;
      }
    }
    return pass;
  }}, {identity:'GeoLocation', fn:function() {
    return typeof navigator != 'undefined' && 'geolocation' in navigator || typeof google != 'undefined' && typeof google.gears != 'undefined';
  }}, {identity:'MouseEnterLeave', fn:function(doc, div) {
    return 'onmouseenter' in div && 'onmouseleave' in div;
  }}, {identity:'MouseWheel', fn:function(doc, div) {
    return 'onmousewheel' in div;
  }}, {identity:'Opacity', fn:function(doc, div) {
    if (Ext.isIE6 || Ext.isIE7 || Ext.isIE8) {
      return false;
    }
    div.firstChild.style.cssText = 'opacity:0.73';
    return div.firstChild.style.opacity == '0.73';
  }}, {identity:'Placeholder', fn:function(doc) {
    return 'placeholder' in doc.createElement('input');
  }}, {identity:'Direct2DBug', fn:function() {
    return Ext.isString(document.body.style.msTransformOrigin) && Ext.isIE10m;
  }}, {identity:'BoundingClientRect', fn:function(doc, div) {
    return Ext.isFunction(div.getBoundingClientRect);
  }}, {identity:'RotatedBoundingClientRect', fn:function() {
    var body = document.body, supports = false, el = document.createElement('div'), style = el.style;
    if (el.getBoundingClientRect) {
      style.WebkitTransform = style.MozTransform = style.OTransform = style.transform = 'rotate(90deg)';
      style.width = '100px';
      style.height = '30px';
      body.appendChild(el);
      supports = el.getBoundingClientRect().height !== 100;
      body.removeChild(el);
    }
    return supports;
  }}, {identity:'IncludePaddingInWidthCalculation', fn:function(doc, div) {
    return div.childNodes[1].firstChild.offsetWidth == 210;
  }}, {identity:'IncludePaddingInHeightCalculation', fn:function(doc, div) {
    return div.childNodes[1].firstChild.offsetHeight == 210;
  }}, {identity:'ArraySort', fn:function() {
    var a = [1, 2, 3, 4, 5].sort(function() {
      return 0;
    });
    return a[0] === 1 && a[1] === 2 && a[2] === 3 && a[3] === 4 && a[4] === 5;
  }}, {identity:'Range', fn:function() {
    return !!document.createRange;
  }}, {identity:'CreateContextualFragment', fn:function() {
    var range = Ext.supports.Range ? document.createRange() : false;
    return range && !!range.createContextualFragment;
  }}, {identity:'WindowOnError', fn:function() {
    return Ext.isIE || Ext.isGecko || Ext.webKitVersion >= 534.16;
  }}, {identity:'TextAreaMaxLength', fn:function() {
    var el = document.createElement('textarea');
    return 'maxlength' in el;
  }}, {identity:'GetPositionPercentage', fn:function(doc, div) {
    return getStyle(div.childNodes[2], 'left') == '10%';
  }}, {identity:'PercentageHeightOverflowBug', fn:function(doc) {
    var hasBug = false, style, el;
    if (Ext.getScrollbarSize().height) {
      el = doc.createElement('div');
      style = el.style;
      style.height = '50px';
      style.width = '50px';
      style.overflow = 'auto';
      style.position = 'absolute';
      el.innerHTML = ['\x3cdiv style\x3d"display:table;height:100%;"\x3e', '\x3cdiv style\x3d"width:51px;"\x3e\x3c/div\x3e', '\x3c/div\x3e'].join('');
      doc.body.appendChild(el);
      if (el.firstChild.offsetHeight === 50) {
        hasBug = true;
      }
      doc.body.removeChild(el);
    }
    return hasBug;
  }}, {identity:'xOriginBug', fn:function(doc, div) {
    div.innerHTML = '\x3cdiv id\x3d"b1" style\x3d"height:100px;width:100px;direction:rtl;position:relative;overflow:scroll"\x3e' + '\x3cdiv id\x3d"b2" style\x3d"position:relative;width:100%;height:20px;"\x3e\x3c/div\x3e' + '\x3cdiv id\x3d"b3" style\x3d"position:absolute;width:20px;height:20px;top:0px;right:0px"\x3e\x3c/div\x3e' + '\x3c/div\x3e';
    var outerBox = document.getElementById('b1').getBoundingClientRect(), b2 = document.getElementById('b2').getBoundingClientRect(), b3 = document.getElementById('b3').getBoundingClientRect();
    return b2.left !== outerBox.left && b3.right !== outerBox.right;
  }}, {identity:'ScrollWidthInlinePaddingBug', fn:function(doc) {
    var hasBug = false, style, el;
    el = doc.createElement('div');
    style = el.style;
    style.height = '50px';
    style.width = '50px';
    style.padding = '10px';
    style.overflow = 'hidden';
    style.position = 'absolute';
    el.innerHTML = '\x3cspan style\x3d"display:inline-block;zoom:1;height:60px;width:60px;"\x3e\x3c/span\x3e';
    doc.body.appendChild(el);
    if (el.scrollWidth === 70) {
      hasBug = true;
    }
    doc.body.removeChild(el);
    return hasBug;
  }}]};
})();
Ext.supports.init();
Ext.util.DelayedTask = function(fn, scope, args, cancelOnDelay) {
  var me = this, delay, call = function() {
    clearInterval(me.id);
    me.id = null;
    fn.apply(scope, args || []);
    Ext.EventManager.idleEvent.fire();
  };
  cancelOnDelay = typeof cancelOnDelay === 'boolean' ? cancelOnDelay : true;
  me.id = null;
  me.delay = function(newDelay, newFn, newScope, newArgs) {
    if (cancelOnDelay) {
      me.cancel();
    }
    delay = newDelay || delay, fn = newFn || fn;
    scope = newScope || scope;
    args = newArgs || args;
    if (!me.id) {
      me.id = setInterval(call, delay);
    }
  };
  me.cancel = function() {
    if (me.id) {
      clearInterval(me.id);
      me.id = null;
    }
  };
};
Ext.define('Ext.util.Event', function() {
  var arraySlice = Array.prototype.slice, arrayInsert = Ext.Array.insert, toArray = Ext.Array.toArray, DelayedTask = Ext.util.DelayedTask;
  return {isEvent:true, suspended:0, noOptions:{}, constructor:function(observable, name) {
    this.name = name;
    this.observable = observable;
    this.listeners = [];
  }, addListener:function(fn, scope, options) {
    var me = this, listeners, listener, priority, isNegativePriority, highestNegativePriorityIndex, hasNegativePriorityIndex, length, index, i, listenerPriority;
    scope = scope || me.observable;
    if (!fn) {
      Ext.Error.raise({sourceClass:Ext.getClassName(this.observable), sourceMethod:'addListener', msg:'The specified callback function is undefined'});
    }
    if (!me.isListening(fn, scope)) {
      listener = me.createListener(fn, scope, options);
      if (me.firing) {
        me.listeners = me.listeners.slice(0);
      }
      listeners = me.listeners;
      index = length = listeners.length;
      priority = options && options.priority;
      highestNegativePriorityIndex = me._highestNegativePriorityIndex;
      hasNegativePriorityIndex = highestNegativePriorityIndex !== undefined;
      if (priority) {
        isNegativePriority = priority < 0;
        if (!isNegativePriority || hasNegativePriorityIndex) {
          for (i = isNegativePriority ? highestNegativePriorityIndex : 0; i < length; i++) {
            listenerPriority = listeners[i].o ? listeners[i].o.priority || 0 : 0;
            if (listenerPriority < priority) {
              index = i;
              break;
            }
          }
        } else {
          me._highestNegativePriorityIndex = index;
        }
      } else {
        if (hasNegativePriorityIndex) {
          index = highestNegativePriorityIndex;
        }
      }
      if (!isNegativePriority && index <= highestNegativePriorityIndex) {
        me._highestNegativePriorityIndex++;
      }
      if (index === length) {
        me.listeners[length] = listener;
      } else {
        arrayInsert(me.listeners, index, [listener]);
      }
    }
  }, createListener:function(fn, scope, o) {
    scope = scope || this.observable;
    var me = this, listener = {fn:fn, scope:scope, ev:me}, handler = fn;
    if (o) {
      listener.o = o;
      if (o.single) {
        handler = me.createSingle(handler, listener, o, scope);
      }
      if (o.target) {
        handler = me.createTargeted(handler, listener, o, scope);
      }
      if (o.delay) {
        handler = me.createDelayed(handler, listener, o, scope);
      }
      if (o.buffer) {
        handler = me.createBuffered(handler, listener, o, scope);
      }
    }
    listener.fireFn = handler;
    return listener;
  }, findListener:function(fn, scope) {
    var listeners = this.listeners, i = listeners.length, listener, s;
    while (i--) {
      listener = listeners[i];
      if (listener) {
        s = listener.scope;
        if (listener.fn == fn && s == (scope || this.observable)) {
          return i;
        }
      }
    }
    return -1;
  }, isListening:function(fn, scope) {
    return this.findListener(fn, scope) !== -1;
  }, removeListener:function(fn, scope) {
    var me = this, index, listener, highestNegativePriorityIndex, k;
    index = me.findListener(fn, scope);
    if (index != -1) {
      listener = me.listeners[index];
      highestNegativePriorityIndex = me._highestNegativePriorityIndex;
      if (me.firing) {
        me.listeners = me.listeners.slice(0);
      }
      if (listener.task) {
        listener.task.cancel();
        delete listener.task;
      }
      k = listener.tasks && listener.tasks.length;
      if (k) {
        while (k--) {
          listener.tasks[k].cancel();
        }
        delete listener.tasks;
      }
      me.listeners.splice(index, 1);
      if (highestNegativePriorityIndex) {
        if (index < highestNegativePriorityIndex) {
          me._highestNegativePriorityIndex--;
        } else {
          if (index === highestNegativePriorityIndex && index === me.listeners.length) {
            delete me._highestNegativePriorityIndex;
          }
        }
      }
      return true;
    }
    return false;
  }, clearListeners:function() {
    var listeners = this.listeners, i = listeners.length;
    while (i--) {
      this.removeListener(listeners[i].fn, listeners[i].scope);
    }
  }, suspend:function() {
    this.suspended += 1;
  }, resume:function() {
    if (this.suspended) {
      this.suspended--;
    }
  }, fire:function() {
    var me = this, listeners = me.listeners, count = listeners.length, i, args, listener, len;
    if (!me.suspended && count > 0) {
      me.firing = true;
      args = arguments.length ? arraySlice.call(arguments, 0) : [];
      len = args.length;
      for (i = 0; i < count; i++) {
        listener = listeners[i];
        if (listener.o) {
          args[len] = listener.o;
        }
        if (listener && listener.fireFn.apply(listener.scope || me.observable, args) === false) {
          return me.firing = false;
        }
      }
    }
    me.firing = false;
    return true;
  }, createTargeted:function(handler, listener, o, scope) {
    return function() {
      if (o.target === arguments[0]) {
        handler.apply(scope, arguments);
      }
    };
  }, createBuffered:function(handler, listener, o, scope) {
    listener.task = new DelayedTask;
    return function() {
      listener.task.delay(o.buffer, handler, scope, toArray(arguments));
    };
  }, createDelayed:function(handler, listener, o, scope) {
    return function() {
      var task = new DelayedTask;
      if (!listener.tasks) {
        listener.tasks = [];
      }
      listener.tasks.push(task);
      task.delay(o.delay || 10, handler, scope, toArray(arguments));
    };
  }, createSingle:function(handler, listener, o, scope) {
    return function() {
      var event = listener.ev;
      if (event.removeListener(listener.fn, scope) && event.observable) {
        event.observable.hasListeners[event.name]--;
      }
      return handler.apply(scope, arguments);
    };
  }};
});
Ext.EventManager = new function() {
  var EventManager = this, doc = document, win = window, escapeRx = /\\/g, prefix = Ext.baseCSSPrefix, supportsAddEventListener = !Ext.isIE9 && 'addEventListener' in doc, readyEvent, initExtCss = function() {
    var bd = doc.body || doc.getElementsByTagName('body')[0], cls = [prefix + 'body'], htmlCls = [], supportsLG = Ext.supports.CSS3LinearGradient, supportsBR = Ext.supports.CSS3BorderRadius, html;
    if (!bd) {
      return false;
    }
    html = bd.parentNode;
    function add(c) {
      cls.push(prefix + c);
    }
    if (Ext.isIE && Ext.isIE9m) {
      add('ie');
      if (Ext.isIE6) {
        add('ie6');
      } else {
        add('ie7p');
        if (Ext.isIE7) {
          add('ie7');
        } else {
          add('ie8p');
          if (Ext.isIE8) {
            add('ie8');
          } else {
            add('ie9p');
            if (Ext.isIE9) {
              add('ie9');
            }
          }
        }
      }
      if (Ext.isIE7m) {
        add('ie7m');
      }
      if (Ext.isIE8m) {
        add('ie8m');
      }
      if (Ext.isIE9m) {
        add('ie9m');
      }
      if (Ext.isIE7 || Ext.isIE8) {
        add('ie78');
      }
    }
    if (Ext.isIE10) {
      add('ie10');
    }
    if (Ext.isGecko) {
      add('gecko');
      if (Ext.isGecko3) {
        add('gecko3');
      }
      if (Ext.isGecko4) {
        add('gecko4');
      }
      if (Ext.isGecko5) {
        add('gecko5');
      }
    }
    if (Ext.isOpera) {
      add('opera');
    }
    if (Ext.isWebKit) {
      add('webkit');
    }
    if (Ext.isSafari) {
      add('safari');
      if (Ext.isSafari2) {
        add('safari2');
      }
      if (Ext.isSafari3) {
        add('safari3');
      }
      if (Ext.isSafari4) {
        add('safari4');
      }
      if (Ext.isSafari5) {
        add('safari5');
      }
      if (Ext.isSafari5_0) {
        add('safari5_0');
      }
    }
    if (Ext.isChrome) {
      add('chrome');
    }
    if (Ext.isMac) {
      add('mac');
    }
    if (Ext.isLinux) {
      add('linux');
    }
    if (!supportsBR) {
      add('nbr');
    }
    if (!supportsLG) {
      add('nlg');
    }
    if (html) {
      if (Ext.isStrict && (Ext.isIE6 || Ext.isIE7)) {
        Ext.isBorderBox = false;
      } else {
        Ext.isBorderBox = true;
      }
      if (!Ext.isBorderBox) {
        htmlCls.push(prefix + 'content-box');
      }
      if (Ext.isStrict) {
        htmlCls.push(prefix + 'strict');
      } else {
        htmlCls.push(prefix + 'quirks');
      }
      Ext.fly(html, '_internal').addCls(htmlCls);
    }
    Ext.fly(bd, '_internal').addCls(cls);
    return true;
  };
  Ext.apply(EventManager, {hasBoundOnReady:false, hasFiredReady:false, deferReadyEvent:1, onReadyChain:[], readyEvent:function() {
    readyEvent = new Ext.util.Event;
    readyEvent.fire = function() {
      Ext._beforeReadyTime = Ext._beforeReadyTime || (new Date).getTime();
      readyEvent.self.prototype.fire.apply(readyEvent, arguments);
      Ext._afterReadytime = (new Date).getTime();
    };
    return readyEvent;
  }(), idleEvent:new Ext.util.Event, isReadyPaused:function() {
    return /[?&]ext-pauseReadyFire\b/i.test(location.search) && !Ext._continueFireReady;
  }, bindReadyEvent:function() {
    if (EventManager.hasBoundOnReady) {
      return;
    }
    if (doc.readyState == 'complete') {
      EventManager.onReadyEvent({type:doc.readyState || 'body'});
    } else {
      doc.addEventListener('DOMContentLoaded', EventManager.onReadyEvent, false);
      win.addEventListener('load', EventManager.onReadyEvent, false);
      EventManager.hasBoundOnReady = true;
    }
  }, onReadyEvent:function(e) {
    if (e && e.type) {
      EventManager.onReadyChain.push(e.type);
    }
    if (EventManager.hasBoundOnReady) {
      doc.removeEventListener('DOMContentLoaded', EventManager.onReadyEvent, false);
      win.removeEventListener('load', EventManager.onReadyEvent, false);
    }
    if (!Ext.isReady) {
      EventManager.fireDocReady();
    }
  }, fireDocReady:function() {
    if (!Ext.isReady) {
      Ext._readyTime = (new Date).getTime();
      Ext.isReady = true;
      Ext.supports.init();
      EventManager.onWindowUnload();
      readyEvent.onReadyChain = EventManager.onReadyChain;
      if (Ext.isNumber(EventManager.deferReadyEvent)) {
        Ext.Function.defer(EventManager.fireReadyEvent, EventManager.deferReadyEvent);
        EventManager.hasDocReadyTimer = true;
      } else {
        EventManager.fireReadyEvent();
      }
    }
  }, fireReadyEvent:function() {
    EventManager.hasDocReadyTimer = false;
    EventManager.isFiring = true;
    while (readyEvent.listeners.length && !EventManager.isReadyPaused()) {
      readyEvent.fire();
    }
    EventManager.isFiring = false;
    EventManager.hasFiredReady = true;
    Ext.EventManager.idleEvent.fire();
  }, onDocumentReady:function(fn, scope, options) {
    options = options || {};
    options.single = true;
    readyEvent.addListener(fn, scope, options);
    if (!(EventManager.isFiring || EventManager.hasDocReadyTimer)) {
      if (Ext.isReady) {
        EventManager.fireReadyEvent();
      } else {
        EventManager.bindReadyEvent();
      }
    }
  }, stoppedMouseDownEvent:new Ext.util.Event, propRe:/^(?:scope|delay|buffer|single|stopEvent|preventDefault|stopPropagation|normalized|args|delegate|freezeEvent)$/, getId:function(element) {
    var id;
    element = Ext.getDom(element);
    if (element === doc || element === win) {
      id = element === doc ? Ext.documentId : Ext.windowId;
    } else {
      id = Ext.id(element);
    }
    if (!Ext.cache[id]) {
      Ext.addCacheEntry(id, null, element);
    }
    return id;
  }, prepareListenerConfig:function(element, config, isRemove) {
    var propRe = EventManager.propRe, key, value, args;
    for (key in config) {
      if (config.hasOwnProperty(key)) {
        if (!propRe.test(key)) {
          value = config[key];
          if (typeof value == 'function') {
            args = [element, key, value, config.scope, config];
          } else {
            args = [element, key, value.fn, value.scope, value];
          }
          if (isRemove) {
            EventManager.removeListener.apply(EventManager, args);
          } else {
            EventManager.addListener.apply(EventManager, args);
          }
        }
      }
    }
  }, mouseEnterLeaveRe:/mouseenter|mouseleave/, normalizeEvent:function(eventName, fn) {
    if (EventManager.mouseEnterLeaveRe.test(eventName) && !Ext.supports.MouseEnterLeave) {
      if (fn) {
        fn = Ext.Function.createInterceptor(fn, EventManager.contains);
      }
      eventName = eventName == 'mouseenter' ? 'mouseover' : 'mouseout';
    } else {
      if (eventName == 'mousewheel' && !Ext.supports.MouseWheel && !Ext.isOpera) {
        eventName = 'DOMMouseScroll';
      }
    }
    return {eventName:eventName, fn:fn};
  }, contains:function(event) {
    event = event.browserEvent || event;
    var parent = event.currentTarget, child = EventManager.getRelatedTarget(event);
    if (parent && parent.firstChild) {
      while (child) {
        if (child === parent) {
          return false;
        }
        child = child.parentNode;
        if (child && child.nodeType != 1) {
          child = null;
        }
      }
    }
    return true;
  }, addListener:function(element, eventName, fn, scope, options) {
    if (typeof eventName !== 'string') {
      EventManager.prepareListenerConfig(element, eventName);
      return;
    }
    var dom = element.dom || Ext.getDom(element), hasAddEventListener, bind, wrap, cache, id, cacheItem, capture;
    if (typeof fn === 'string') {
      fn = Ext.resolveMethod(fn, scope || element);
    }
    if (!fn) {
      Ext.Error.raise({sourceClass:'Ext.EventManager', sourceMethod:'addListener', targetElement:element, eventName:eventName, msg:'Error adding "' + eventName + '" listener. The handler function is undefined.'});
    }
    options = options || {};
    bind = EventManager.normalizeEvent(eventName, fn);
    wrap = EventManager.createListenerWrap(dom, eventName, bind.fn, scope, options);
    cache = EventManager.getEventListenerCache(element.dom ? element : dom, eventName);
    eventName = bind.eventName;
    hasAddEventListener = supportsAddEventListener || Ext.isIE9 && !dom.attachEvent;
    if (!hasAddEventListener) {
      id = EventManager.normalizeId(dom);
      if (id) {
        cacheItem = Ext.cache[id][eventName];
        if (cacheItem && cacheItem.firing) {
          cache = EventManager.cloneEventListenerCache(dom, eventName);
        }
      }
    }
    capture = !!options.capture;
    cache.push({fn:fn, wrap:wrap, scope:scope, capture:capture});
    if (!hasAddEventListener) {
      if (cache.length === 1) {
        id = EventManager.normalizeId(dom, true);
        fn = Ext.Function.bind(EventManager.handleSingleEvent, EventManager, [id, eventName], true);
        Ext.cache[id][eventName] = {firing:false, fn:fn};
        dom.attachEvent('on' + eventName, fn);
      }
    } else {
      dom.addEventListener(eventName, wrap, capture);
    }
    if (dom == doc && eventName == 'mousedown') {
      EventManager.stoppedMouseDownEvent.addListener(wrap);
    }
  }, normalizeId:function(dom, force) {
    var id;
    if (dom === document) {
      id = Ext.documentId;
    } else {
      if (dom === window) {
        id = Ext.windowId;
      } else {
        id = dom.id;
      }
    }
    if (!id && force) {
      id = EventManager.getId(dom);
    }
    return id;
  }, handleSingleEvent:function(e, id, eventName) {
    var listenerCache = EventManager.getEventListenerCache(id, eventName), attachItem = Ext.cache[id][eventName], len, i;
    if (attachItem.firing) {
      return;
    }
    attachItem.firing = true;
    for (i = 0, len = listenerCache.length; i < len; ++i) {
      listenerCache[i].wrap(e);
    }
    attachItem.firing = false;
  }, removeListener:function(element, eventName, fn, scope) {
    if (typeof eventName !== 'string') {
      EventManager.prepareListenerConfig(element, eventName, true);
      return;
    }
    var dom = Ext.getDom(element), id, el = element.dom ? element : Ext.get(dom), cache = EventManager.getEventListenerCache(el, eventName), bindName = EventManager.normalizeEvent(eventName).eventName, i = cache.length, j, cacheItem, hasRemoveEventListener, listener, wrap;
    if (!dom) {
      return;
    }
    hasRemoveEventListener = supportsAddEventListener || Ext.isIE9 && !dom.detachEvent;
    if (typeof fn === 'string') {
      fn = Ext.resolveMethod(fn, scope || element);
    }
    while (i--) {
      listener = cache[i];
      if (listener && (!fn || listener.fn == fn) && (!scope || listener.scope === scope)) {
        wrap = listener.wrap;
        if (wrap.task) {
          clearTimeout(wrap.task);
          delete wrap.task;
        }
        j = wrap.tasks && wrap.tasks.length;
        if (j) {
          while (j--) {
            clearTimeout(wrap.tasks[j]);
          }
          delete wrap.tasks;
        }
        if (!hasRemoveEventListener) {
          id = EventManager.normalizeId(dom, true);
          cacheItem = Ext.cache[id][bindName];
          if (cacheItem && cacheItem.firing) {
            cache = EventManager.cloneEventListenerCache(dom, bindName);
          }
          if (cache.length === 1) {
            fn = cacheItem.fn;
            delete Ext.cache[id][bindName];
            dom.detachEvent('on' + bindName, fn);
          }
        } else {
          dom.removeEventListener(bindName, wrap, listener.capture);
        }
        if (wrap && dom == doc && eventName == 'mousedown') {
          EventManager.stoppedMouseDownEvent.removeListener(wrap);
        }
        Ext.Array.erase(cache, i, 1);
      }
    }
  }, removeAll:function(element) {
    var id = typeof element === 'string' ? element : element.id, cache, events, eventName;
    if (id && (cache = Ext.cache[id])) {
      events = cache.events;
      for (eventName in events) {
        if (events.hasOwnProperty(eventName)) {
          EventManager.removeListener(element, eventName);
        }
      }
      cache.events = {};
    }
  }, purgeElement:function(element, eventName) {
    var dom = Ext.getDom(element), i = 0, len, childNodes;
    if (eventName) {
      EventManager.removeListener(element, eventName);
    } else {
      EventManager.removeAll(element);
    }
    if (dom && dom.childNodes) {
      childNodes = dom.childNodes;
      for (len = childNodes.length; i < len; i++) {
        EventManager.purgeElement(childNodes[i], eventName);
      }
    }
  }, createListenerWrap:function(dom, ename, fn, scope, options) {
    options = options || {};
    var f, gen, wrap = function(e, args) {
      if (!gen) {
        f = ['if(!' + Ext.name + ') {return;}'];
        if (options.buffer || options.delay || options.freezeEvent) {
          if (options.freezeEvent) {
            f.push('e \x3d X.EventObject.setEvent(e);');
          }
          f.push('e \x3d new X.EventObjectImpl(e, ' + (options.freezeEvent ? 'true' : 'false') + ');');
        } else {
          f.push('e \x3d X.EventObject.setEvent(e);');
        }
        if (options.delegate) {
          f.push('var result, t \x3d e.getTarget("' + (options.delegate + '').replace(escapeRx, '\\\\') + '", this);');
          f.push('if(!t) {return;}');
        } else {
          f.push('var t \x3d e.target, result;');
        }
        if (options.target) {
          f.push('if(e.target !\x3d\x3d options.target) {return;}');
        }
        if (options.stopEvent) {
          f.push('e.stopEvent();');
        } else {
          if (options.preventDefault) {
            f.push('e.preventDefault();');
          }
          if (options.stopPropagation) {
            f.push('e.stopPropagation();');
          }
        }
        if (options.normalized === false) {
          f.push('e \x3d e.browserEvent;');
        }
        if (options.buffer) {
          f.push('(wrap.task \x26\x26 clearTimeout(wrap.task));');
          f.push('wrap.task \x3d setTimeout(function() {');
        }
        if (options.delay) {
          f.push('wrap.tasks \x3d wrap.tasks || [];');
          f.push('wrap.tasks.push(setTimeout(function() {');
        }
        f.push('result \x3d fn.call(scope || dom, e, t, options);');
        if (options.single) {
          f.push('evtMgr.removeListener(dom, ename, fn, scope);');
        }
        if (ename !== 'mousemove' && ename !== 'unload') {
          f.push('if (evtMgr.idleEvent.listeners.length) {');
          f.push('evtMgr.idleEvent.fire();');
          f.push('}');
        }
        if (options.delay) {
          f.push('}, ' + options.delay + '));');
        }
        if (options.buffer) {
          f.push('}, ' + options.buffer + ');');
        }
        f.push('return result;');
        gen = Ext.cacheableFunctionFactory('e', 'options', 'fn', 'scope', 'ename', 'dom', 'wrap', 'args', 'X', 'evtMgr', f.join('\n'));
      }
      return gen.call(dom, e, options, fn, scope, ename, dom, wrap, args, Ext, EventManager);
    };
    return wrap;
  }, getEventCache:function(element) {
    var elementCache, eventCache, id;
    if (!element) {
      return [];
    }
    if (element.$cache) {
      elementCache = element.$cache;
    } else {
      if (typeof element === 'string') {
        id = element;
      } else {
        id = EventManager.getId(element);
      }
      elementCache = Ext.cache[id];
    }
    eventCache = elementCache.events || (elementCache.events = {});
    return eventCache;
  }, getEventListenerCache:function(element, eventName) {
    var eventCache = EventManager.getEventCache(element);
    return eventCache[eventName] || (eventCache[eventName] = []);
  }, cloneEventListenerCache:function(element, eventName) {
    var eventCache = EventManager.getEventCache(element), out;
    if (eventCache[eventName]) {
      out = eventCache[eventName].slice(0);
    } else {
      out = [];
    }
    eventCache[eventName] = out;
    return out;
  }, mouseLeaveRe:/(mouseout|mouseleave)/, mouseEnterRe:/(mouseover|mouseenter)/, stopEvent:function(event) {
    EventManager.stopPropagation(event);
    EventManager.preventDefault(event);
  }, stopPropagation:function(event) {
    event = event.browserEvent || event;
    if (event.stopPropagation) {
      event.stopPropagation();
    } else {
      event.cancelBubble = true;
    }
  }, preventDefault:function(event) {
    event = event.browserEvent || event;
    if (event.preventDefault) {
      event.preventDefault();
    } else {
      event.returnValue = false;
      try {
        if (event.ctrlKey || event.keyCode > 111 && event.keyCode < 124) {
          event.keyCode = -1;
        }
      } catch (e$7) {
      }
    }
  }, getRelatedTarget:function(event) {
    event = event.browserEvent || event;
    var target = event.relatedTarget;
    if (!target) {
      if (EventManager.mouseLeaveRe.test(event.type)) {
        target = event.toElement;
      } else {
        if (EventManager.mouseEnterRe.test(event.type)) {
          target = event.fromElement;
        }
      }
    }
    return EventManager.resolveTextNode(target);
  }, getPageX:function(event) {
    return EventManager.getPageXY(event)[0];
  }, getPageY:function(event) {
    return EventManager.getPageXY(event)[1];
  }, getPageXY:function(event) {
    event = event.browserEvent || event;
    var x = event.pageX, y = event.pageY, docEl = doc.documentElement, body = doc.body;
    if (!x && x !== 0) {
      x = event.clientX + (docEl && docEl.scrollLeft || body && body.scrollLeft || 0) - (docEl && docEl.clientLeft || body && body.clientLeft || 0);
      y = event.clientY + (docEl && docEl.scrollTop || body && body.scrollTop || 0) - (docEl && docEl.clientTop || body && body.clientTop || 0);
    }
    return [x, y];
  }, getTarget:function(event) {
    event = event.browserEvent || event;
    return EventManager.resolveTextNode(event.target || event.srcElement);
  }, resolveTextNode:Ext.isGecko ? function(node) {
    if (node) {
      var s = HTMLElement.prototype.toString.call(node);
      if (s !== '[xpconnect wrapped native prototype]' && s !== '[object XULElement]') {
        return node.nodeType == 3 ? node.parentNode : node;
      }
    }
  } : function(node) {
    return node && node.nodeType == 3 ? node.parentNode : node;
  }, curWidth:0, curHeight:0, onWindowResize:function(fn, scope, options) {
    var resize = EventManager.resizeEvent;
    if (!resize) {
      EventManager.resizeEvent = resize = new Ext.util.Event;
      EventManager.on(win, 'resize', EventManager.fireResize, null, {buffer:100});
    }
    resize.addListener(fn, scope, options);
  }, fireResize:function() {
    var w = Ext.Element.getViewWidth(), h = Ext.Element.getViewHeight();
    if (EventManager.curHeight != h || EventManager.curWidth != w) {
      EventManager.curHeight = h;
      EventManager.curWidth = w;
      EventManager.resizeEvent.fire(w, h);
    }
  }, removeResizeListener:function(fn, scope) {
    var resize = EventManager.resizeEvent;
    if (resize) {
      resize.removeListener(fn, scope);
    }
  }, onWindowUnload:function(fn, scope, options) {
    var unload = EventManager.unloadEvent;
    if (!unload) {
      EventManager.unloadEvent = unload = new Ext.util.Event;
      EventManager.addListener(win, 'unload', EventManager.fireUnload);
    }
    if (fn) {
      unload.addListener(fn, scope, options);
    }
  }, fireUnload:function() {
    try {
      doc = win = undefined;
      var gridviews, i, ln, el, cache;
      EventManager.unloadEvent.fire();
      if (Ext.isGecko3) {
        gridviews = Ext.ComponentQuery.query('gridview');
        i = 0;
        ln = gridviews.length;
        for (; i < ln; i++) {
          gridviews[i].scrollToTop();
        }
      }
      cache = Ext.cache;
      for (el in cache) {
        if (cache.hasOwnProperty(el)) {
          EventManager.removeAll(el);
        }
      }
    } catch (e$8) {
    }
  }, removeUnloadListener:function(fn, scope) {
    var unload = EventManager.unloadEvent;
    if (unload) {
      unload.removeListener(fn, scope);
    }
  }, useKeyDown:Ext.isWebKit ? parseInt(navigator.userAgent.match(/AppleWebKit\/(\d+)/)[1], 10) >= 525 : !(Ext.isGecko && !Ext.isWindows || Ext.isOpera), getKeyEvent:function() {
    return EventManager.useKeyDown ? 'keydown' : 'keypress';
  }});
  if (!supportsAddEventListener && document.attachEvent) {
    Ext.apply(EventManager, {pollScroll:function() {
      var scrollable = true;
      try {
        document.documentElement.doScroll('left');
      } catch (e$9) {
        scrollable = false;
      }
      if (scrollable && document.body) {
        EventManager.onReadyEvent({type:'doScroll'});
      } else {
        EventManager.scrollTimeout = setTimeout(EventManager.pollScroll, 20);
      }
      return scrollable;
    }, scrollTimeout:null, readyStatesRe:/complete/i, checkReadyState:function() {
      var state = document.readyState;
      if (EventManager.readyStatesRe.test(state)) {
        EventManager.onReadyEvent({type:state});
      }
    }, bindReadyEvent:function() {
      var topContext = true;
      if (EventManager.hasBoundOnReady) {
        return;
      }
      try {
        topContext = window.frameElement === undefined;
      } catch (e$10) {
        topContext = false;
      }
      if (!topContext || !doc.documentElement.doScroll) {
        EventManager.pollScroll = Ext.emptyFn;
      }
      if (EventManager.pollScroll() === true) {
        return;
      }
      if (doc.readyState == 'complete') {
        EventManager.onReadyEvent({type:'already ' + (doc.readyState || 'body')});
      } else {
        doc.attachEvent('onreadystatechange', EventManager.checkReadyState);
        window.attachEvent('onload', EventManager.onReadyEvent);
        EventManager.hasBoundOnReady = true;
      }
    }, onReadyEvent:function(e) {
      if (e && e.type) {
        EventManager.onReadyChain.push(e.type);
      }
      if (EventManager.hasBoundOnReady) {
        document.detachEvent('onreadystatechange', EventManager.checkReadyState);
        window.detachEvent('onload', EventManager.onReadyEvent);
      }
      if (Ext.isNumber(EventManager.scrollTimeout)) {
        clearTimeout(EventManager.scrollTimeout);
        delete EventManager.scrollTimeout;
      }
      if (!Ext.isReady) {
        EventManager.fireDocReady();
      }
    }, onReadyChain:[]});
  }
  Ext.onReady = function(fn, scope, options) {
    Ext.Loader.onReady(fn, scope, true, options);
  };
  Ext.onDocumentReady = EventManager.onDocumentReady;
  EventManager.on = EventManager.addListener;
  EventManager.un = EventManager.removeListener;
  Ext.onReady(initExtCss);
};
Ext.setVersion('ext-theme-base', '4.2.1');
Ext.setVersion('ext-theme-neutral', '4.2.1');
Ext.setVersion('ext-theme-classic', '4.2.1');
Ext.setVersion('ext-theme-gray', '4.2.1');
Ext.define('Ext.util.Observable', function(Observable) {
  var emptyArray = [], arrayProto = Array.prototype, arraySlice = arrayProto.slice, ExtEvent = Ext.util.Event, ListenerRemover = function(observable) {
    if (observable instanceof ListenerRemover) {
      return observable;
    }
    this.observable = observable;
    if (arguments[1].isObservable) {
      this.managedListeners = true;
    }
    this.args = arraySlice.call(arguments, 1);
  };
  ListenerRemover.prototype.destroy = function() {
    this.observable[this.managedListeners ? 'mun' : 'un'].apply(this.observable, this.args);
  };
  return {statics:{releaseCapture:function(o) {
    o.fireEventArgs = this.prototype.fireEventArgs;
  }, capture:function(o, fn, scope) {
    var newFn = function(eventName, args) {
      return fn.apply(scope, [eventName].concat(args));
    };
    this.captureArgs(o, newFn, scope);
  }, captureArgs:function(o, fn, scope) {
    o.fireEventArgs = Ext.Function.createInterceptor(o.fireEventArgs, fn, scope);
  }, observe:function(cls, listeners) {
    if (cls) {
      if (!cls.isObservable) {
        Ext.applyIf(cls, new this);
        this.captureArgs(cls.prototype, cls.fireEventArgs, cls);
      }
      if (Ext.isObject(listeners)) {
        cls.on(listeners);
      }
    }
    return cls;
  }, prepareClass:function(T, mixin) {
    if (!T.HasListeners) {
      var HasListeners = function() {
      }, SuperHL = T.superclass.HasListeners || mixin && mixin.HasListeners || Observable.HasListeners;
      T.prototype.HasListeners = T.HasListeners = HasListeners;
      HasListeners.prototype = T.hasListeners = new SuperHL;
    }
  }}, isObservable:true, eventsSuspended:0, constructor:function(config) {
    var me = this;
    Ext.apply(me, config);
    if (!me.hasListeners) {
      me.hasListeners = new me.HasListeners;
    }
    me.events = me.events || {};
    if (me.listeners) {
      me.on(me.listeners);
      me.listeners = null;
    }
    if (me.bubbleEvents) {
      me.enableBubble(me.bubbleEvents);
    }
  }, onClassExtended:function(T) {
    if (!T.HasListeners) {
      Observable.prepareClass(T);
    }
  }, eventOptionsRe:/^(?:scope|delay|buffer|single|stopEvent|preventDefault|stopPropagation|normalized|args|delegate|element|destroyable|vertical|horizontal|freezeEvent|priority)$/, addManagedListener:function(item, ename, fn, scope, options, noDestroy) {
    var me = this, managedListeners = me.managedListeners = me.managedListeners || [], config, passedOptions;
    if (typeof ename !== 'string') {
      passedOptions = arguments.length > 4 ? options : ename;
      options = ename;
      for (ename in options) {
        if (options.hasOwnProperty(ename)) {
          config = options[ename];
          if (!me.eventOptionsRe.test(ename)) {
            me.addManagedListener(item, ename, config.fn || config, config.scope || options.scope || scope, config.fn ? config : passedOptions, true);
          }
        }
      }
      if (options && options.destroyable) {
        return new ListenerRemover(me, item, options);
      }
    } else {
      if (typeof fn === 'string') {
        scope = scope || me;
        fn = Ext.resolveMethod(fn, scope);
      }
      managedListeners.push({item:item, ename:ename, fn:fn, scope:scope, options:options});
      item.on(ename, fn, scope, options);
      if (!noDestroy && options && options.destroyable) {
        return new ListenerRemover(me, item, ename, fn, scope);
      }
    }
  }, removeManagedListener:function(item, ename, fn, scope) {
    var me = this, options, config, managedListeners, length, i, func;
    if (typeof ename !== 'string') {
      options = ename;
      for (ename in options) {
        if (options.hasOwnProperty(ename)) {
          config = options[ename];
          if (!me.eventOptionsRe.test(ename)) {
            me.removeManagedListener(item, ename, config.fn || config, config.scope || options.scope || scope);
          }
        }
      }
    } else {
      managedListeners = me.managedListeners ? me.managedListeners.slice() : [];
      if (typeof fn === 'string') {
        scope = scope || me;
        fn = Ext.resolveMethod(fn, scope);
      }
      for (i = 0, length = managedListeners.length; i < length; i++) {
        me.removeManagedListenerItem(false, managedListeners[i], item, ename, fn, scope);
      }
    }
  }, fireEvent:function(eventName) {
    return this.fireEventArgs(eventName, arraySlice.call(arguments, 1));
  }, fireEventArgs:function(eventName, args) {
    eventName = eventName.toLowerCase();
    var me = this, events = me.events, event = events && events[eventName], ret = true;
    if (event && me.hasListeners[eventName]) {
      ret = me.continueFireEvent(eventName, args || emptyArray, event.bubble);
    }
    return ret;
  }, continueFireEvent:function(eventName, args, bubbles) {
    var target = this, queue, event, ret = true;
    do {
      if (target.eventsSuspended) {
        if (queue = target.eventQueue) {
          queue.push([eventName, args, bubbles]);
        }
        return ret;
      } else {
        event = target.events[eventName];
        if (event && event !== true) {
          if ((ret = event.fire.apply(event, args)) === false) {
            break;
          }
        }
      }
    } while (bubbles && (target = target.getBubbleParent()));
    return ret;
  }, getBubbleParent:function() {
    var me = this, parent = me.getBubbleTarget && me.getBubbleTarget();
    if (parent && parent.isObservable) {
      return parent;
    }
    return null;
  }, addListener:function(ename, fn, scope, options) {
    var me = this, config, event, prevListenerCount = 0;
    if (typeof ename !== 'string') {
      options = ename;
      for (ename in options) {
        if (options.hasOwnProperty(ename)) {
          config = options[ename];
          if (!me.eventOptionsRe.test(ename)) {
            me.addListener(ename, config.fn || config, config.scope || options.scope, config.fn ? config : options);
          }
        }
      }
      if (options && options.destroyable) {
        return new ListenerRemover(me, options);
      }
    } else {
      ename = ename.toLowerCase();
      event = me.events[ename];
      if (event && event.isEvent) {
        prevListenerCount = event.listeners.length;
      } else {
        me.events[ename] = event = new ExtEvent(me, ename);
      }
      if (!fn) {
        Ext.Error.raise('No function passed for event ' + me.$className + '.' + ename);
      }
      if (typeof fn === 'string') {
        scope = scope || me;
        fn = Ext.resolveMethod(fn, scope);
      }
      event.addListener(fn, scope, options);
      if (event.listeners.length !== prevListenerCount) {
        me.hasListeners._incr_(ename);
      }
      if (options && options.destroyable) {
        return new ListenerRemover(me, ename, fn, scope, options);
      }
    }
  }, removeListener:function(ename, fn, scope) {
    var me = this, config, event, options;
    if (typeof ename !== 'string') {
      options = ename;
      for (ename in options) {
        if (options.hasOwnProperty(ename)) {
          config = options[ename];
          if (!me.eventOptionsRe.test(ename)) {
            me.removeListener(ename, config.fn || config, config.scope || options.scope);
          }
        }
      }
    } else {
      ename = ename.toLowerCase();
      event = me.events[ename];
      if (event && event.isEvent) {
        if (typeof fn === 'string') {
          scope = scope || me;
          fn = Ext.resolveMethod(fn, scope);
        }
        if (event.removeListener(fn, scope)) {
          me.hasListeners._decr_(ename);
        }
      }
    }
  }, clearListeners:function() {
    var events = this.events, hasListeners = this.hasListeners, event, key;
    for (key in events) {
      if (events.hasOwnProperty(key)) {
        event = events[key];
        if (event.isEvent) {
          delete hasListeners[key];
          event.clearListeners();
        }
      }
    }
    this.clearManagedListeners();
  }, purgeListeners:function() {
    if (Ext.global.console) {
      Ext.global.console.warn('Observable: purgeListeners has been deprecated. Please use clearListeners.');
    }
    return this.clearListeners.apply(this, arguments);
  }, clearManagedListeners:function() {
    var managedListeners = this.managedListeners || [], i = 0, len = managedListeners.length;
    for (; i < len; i++) {
      this.removeManagedListenerItem(true, managedListeners[i]);
    }
    this.managedListeners = [];
  }, removeManagedListenerItem:function(isClear, managedListener, item, ename, fn, scope) {
    if (isClear || managedListener.item === item && managedListener.ename === ename && (!fn || managedListener.fn === fn) && (!scope || managedListener.scope === scope)) {
      managedListener.item.un(managedListener.ename, managedListener.fn, managedListener.scope);
      if (!isClear) {
        Ext.Array.remove(this.managedListeners, managedListener);
      }
    }
  }, purgeManagedListeners:function() {
    if (Ext.global.console) {
      Ext.global.console.warn('Observable: purgeManagedListeners has been deprecated. Please use clearManagedListeners.');
    }
    return this.clearManagedListeners.apply(this, arguments);
  }, addEvents:function(o) {
    var me = this, events = me.events || (me.events = {}), arg, args, i;
    if (typeof o == 'string') {
      for (args = arguments, i = args.length; i--;) {
        arg = args[i];
        if (!events[arg]) {
          events[arg] = true;
        }
      }
    } else {
      Ext.applyIf(me.events, o);
    }
  }, hasListener:function(ename) {
    return !!this.hasListeners[ename.toLowerCase()];
  }, suspendEvents:function(queueSuspended) {
    this.eventsSuspended += 1;
    if (queueSuspended && !this.eventQueue) {
      this.eventQueue = [];
    }
  }, suspendEvent:function(eventName) {
    var len = arguments.length, i, event;
    for (i = 0; i < len; i++) {
      event = this.events[arguments[i]];
      if (event && event.suspend) {
        event.suspend();
      }
    }
  }, resumeEvent:function() {
    var len = arguments.length, i, event;
    for (i = 0; i < len; i++) {
      event = this.events[arguments[i]];
      if (event && event.resume) {
        event.resume();
      }
    }
  }, resumeEvents:function() {
    var me = this, queued = me.eventQueue, qLen, q;
    if (me.eventsSuspended && !--me.eventsSuspended) {
      delete me.eventQueue;
      if (queued) {
        qLen = queued.length;
        for (q = 0; q < qLen; q++) {
          me.continueFireEvent.apply(me, queued[q]);
        }
      }
    }
  }, relayEvents:function(origin, events, prefix) {
    var me = this, len = events.length, i = 0, oldName, relayers = {};
    for (; i < len; i++) {
      oldName = events[i];
      relayers[oldName] = me.createRelayer(prefix ? prefix + oldName : oldName);
    }
    me.mon(origin, relayers, null, null, undefined);
    return new ListenerRemover(me, origin, relayers);
  }, createRelayer:function(newName, beginEnd) {
    var me = this;
    return function() {
      return me.fireEventArgs.call(me, newName, beginEnd ? arraySlice.apply(arguments, beginEnd) : arguments);
    };
  }, enableBubble:function(eventNames) {
    if (eventNames) {
      var me = this, names = typeof eventNames == 'string' ? arguments : eventNames, length = names.length, events = me.events, ename, event, i;
      for (i = 0; i < length; ++i) {
        ename = names[i].toLowerCase();
        event = events[ename];
        if (!event || typeof event == 'boolean') {
          events[ename] = event = new ExtEvent(me, ename);
        }
        me.hasListeners._incr_(ename);
        event.bubble = true;
      }
    }
  }};
}, function() {
  var Observable = this, proto = Observable.prototype, HasListeners = function() {
  }, prepareMixin = function(T) {
    if (!T.HasListeners) {
      var proto = T.prototype;
      Observable.prepareClass(T, this);
      T.onExtended(function(U) {
        Ext.classSystemMonitor && Ext.classSystemMonitor('extend mixin', arguments);
        Observable.prepareClass(U);
      });
      if (proto.onClassMixedIn) {
        Ext.override(T, {onClassMixedIn:function(U) {
          prepareMixin.call(this, U);
          this.callParent(arguments);
        }});
      } else {
        proto.onClassMixedIn = function(U) {
          prepareMixin.call(this, U);
        };
      }
    }
  }, globalEvents;
  HasListeners.prototype = {_decr_:function(ev) {
    if (!--this[ev]) {
      delete this[ev];
    }
  }, _incr_:function(ev) {
    if (this.hasOwnProperty(ev)) {
      ++this[ev];
    } else {
      this[ev] = 1;
    }
  }};
  proto.HasListeners = Observable.HasListeners = HasListeners;
  Observable.createAlias({on:'addListener', un:'removeListener', mon:'addManagedListener', mun:'removeManagedListener'});
  Observable.observeClass = Observable.observe;
  Ext.globalEvents = globalEvents = new Observable({events:{idle:Ext.EventManager.idleEvent, ready:Ext.EventManager.readyEvent}});
  Ext.on = function() {
    return globalEvents.addListener.apply(globalEvents, arguments);
  };
  Ext.un = function() {
    return globalEvents.removeListener.apply(globalEvents, arguments);
  };
  function getMethodEvent(method) {
    var e = (this.methodEvents = this.methodEvents || {})[method], returnValue, v, cancel, obj = this, makeCall;
    if (!e) {
      this.methodEvents[method] = e = {};
      e.originalFn = this[method];
      e.methodName = method;
      e.before = [];
      e.after = [];
      makeCall = function(fn, scope, args) {
        if ((v = fn.apply(scope || obj, args)) !== undefined) {
          if (typeof v == 'object') {
            if (v.returnValue !== undefined) {
              returnValue = v.returnValue;
            } else {
              returnValue = v;
            }
            cancel = !!v.cancel;
          } else {
            if (v === false) {
              cancel = true;
            } else {
              returnValue = v;
            }
          }
        }
      };
      this[method] = function() {
        var args = Array.prototype.slice.call(arguments, 0), b, i, len;
        returnValue = v = undefined;
        cancel = false;
        for (i = 0, len = e.before.length; i < len; i++) {
          b = e.before[i];
          makeCall(b.fn, b.scope, args);
          if (cancel) {
            return returnValue;
          }
        }
        if ((v = e.originalFn.apply(obj, args)) !== undefined) {
          returnValue = v;
        }
        for (i = 0, len = e.after.length; i < len; i++) {
          b = e.after[i];
          makeCall(b.fn, b.scope, args);
          if (cancel) {
            return returnValue;
          }
        }
        return returnValue;
      };
    }
    return e;
  }
  Ext.apply(proto, {onClassMixedIn:prepareMixin, beforeMethod:function(method, fn, scope) {
    getMethodEvent.call(this, method).before.push({fn:fn, scope:scope});
  }, afterMethod:function(method, fn, scope) {
    getMethodEvent.call(this, method).after.push({fn:fn, scope:scope});
  }, removeMethodListener:function(method, fn, scope) {
    var e = this.getMethodEvent(method), i, len;
    for (i = 0, len = e.before.length; i < len; i++) {
      if (e.before[i].fn == fn && e.before[i].scope == scope) {
        Ext.Array.erase(e.before, i, 1);
        return;
      }
    }
    for (i = 0, len = e.after.length; i < len; i++) {
      if (e.after[i].fn == fn && e.after[i].scope == scope) {
        Ext.Array.erase(e.after, i, 1);
        return;
      }
    }
  }, toggleEventLogging:function(toggle) {
    Ext.util.Observable[toggle ? 'capture' : 'releaseCapture'](this, function(en) {
      if (Ext.isDefined(Ext.global.console)) {
        Ext.global.console.log(en, arguments);
      }
    });
  }});
});
Ext.define('Ext.EventObjectImpl', {BACKSPACE:8, TAB:9, NUM_CENTER:12, ENTER:13, RETURN:13, SHIFT:16, CTRL:17, ALT:18, PAUSE:19, CAPS_LOCK:20, ESC:27, SPACE:32, PAGE_UP:33, PAGE_DOWN:34, END:35, HOME:36, LEFT:37, UP:38, RIGHT:39, DOWN:40, PRINT_SCREEN:44, INSERT:45, DELETE:46, ZERO:48, ONE:49, TWO:50, THREE:51, FOUR:52, FIVE:53, SIX:54, SEVEN:55, EIGHT:56, NINE:57, A:65, B:66, C:67, D:68, E:69, F:70, G:71, H:72, I:73, J:74, K:75, L:76, M:77, N:78, O:79, P:80, Q:81, R:82, S:83, T:84, U:85, V:86, W:87, 
X:88, Y:89, Z:90, CONTEXT_MENU:93, NUM_ZERO:96, NUM_ONE:97, NUM_TWO:98, NUM_THREE:99, NUM_FOUR:100, NUM_FIVE:101, NUM_SIX:102, NUM_SEVEN:103, NUM_EIGHT:104, NUM_NINE:105, NUM_MULTIPLY:106, NUM_PLUS:107, NUM_MINUS:109, NUM_PERIOD:110, NUM_DIVISION:111, F1:112, F2:113, F3:114, F4:115, F5:116, F6:117, F7:118, F8:119, F9:120, F10:121, F11:122, F12:123, WHEEL_SCALE:function() {
  var scale;
  if (Ext.isGecko) {
    scale = 3;
  } else {
    if (Ext.isMac) {
      if (Ext.isSafari && Ext.webKitVersion >= 532) {
        scale = 120;
      } else {
        scale = 12;
      }
      scale *= 3;
    } else {
      scale = 120;
    }
  }
  return scale;
}(), clickRe:/(dbl)?click/, safariKeys:{3:13, 63234:37, 63235:39, 63232:38, 63233:40, 63276:33, 63277:34, 63272:46, 63273:36, 63275:35}, btnMap:Ext.isIE ? {1:0, 4:1, 2:2} : {0:0, 1:1, 2:2}, constructor:function(event, freezeEvent) {
  if (event) {
    this.setEvent(event.browserEvent || event, freezeEvent);
  }
}, setEvent:function(event, freezeEvent) {
  var me = this, button, options;
  if (event === me || event && event.browserEvent) {
    return event;
  }
  me.browserEvent = event;
  if (event) {
    button = event.button ? me.btnMap[event.button] : event.which ? event.which - 1 : -1;
    if (me.clickRe.test(event.type) && button == -1) {
      button = 0;
    }
    options = {type:event.type, button:button, shiftKey:event.shiftKey, ctrlKey:event.ctrlKey || event.metaKey || false, altKey:event.altKey, keyCode:event.keyCode, charCode:event.charCode, target:Ext.EventManager.getTarget(event), relatedTarget:Ext.EventManager.getRelatedTarget(event), currentTarget:event.currentTarget, xy:freezeEvent ? me.getXY() : null};
  } else {
    options = {button:-1, shiftKey:false, ctrlKey:false, altKey:false, keyCode:0, charCode:0, target:null, xy:[0, 0]};
  }
  Ext.apply(me, options);
  return me;
}, stopEvent:function() {
  this.stopPropagation();
  this.preventDefault();
}, preventDefault:function() {
  if (this.browserEvent) {
    Ext.EventManager.preventDefault(this.browserEvent);
  }
}, stopPropagation:function() {
  var browserEvent = this.browserEvent;
  if (browserEvent) {
    if (browserEvent.type == 'mousedown') {
      Ext.EventManager.stoppedMouseDownEvent.fire(this);
    }
    Ext.EventManager.stopPropagation(browserEvent);
  }
}, getCharCode:function() {
  return this.charCode || this.keyCode;
}, getKey:function() {
  return this.normalizeKey(this.keyCode || this.charCode);
}, normalizeKey:function(key) {
  return Ext.isWebKit ? this.safariKeys[key] || key : key;
}, getPageX:function() {
  return this.getX();
}, getPageY:function() {
  return this.getY();
}, getX:function() {
  return this.getXY()[0];
}, getY:function() {
  return this.getXY()[1];
}, getXY:function() {
  if (!this.xy) {
    this.xy = Ext.EventManager.getPageXY(this.browserEvent);
  }
  return this.xy;
}, getTarget:function(selector, maxDepth, returnEl) {
  if (selector) {
    return Ext.fly(this.target).findParent(selector, maxDepth, returnEl);
  }
  return returnEl ? Ext.get(this.target) : this.target;
}, getRelatedTarget:function(selector, maxDepth, returnEl) {
  if (selector && this.relatedTarget) {
    return Ext.fly(this.relatedTarget).findParent(selector, maxDepth, returnEl);
  }
  return returnEl ? Ext.get(this.relatedTarget) : this.relatedTarget;
}, correctWheelDelta:function(delta) {
  var scale = this.WHEEL_SCALE, ret = Math.round(delta / scale);
  if (!ret && delta) {
    ret = delta < 0 ? -1 : 1;
  }
  return ret;
}, getWheelDeltas:function() {
  var me = this, event = me.browserEvent, dx = 0, dy = 0;
  if (Ext.isDefined(event.wheelDeltaX)) {
    dx = event.wheelDeltaX;
    dy = event.wheelDeltaY;
  } else {
    if (event.wheelDelta) {
      dy = event.wheelDelta;
    } else {
      if (event.detail) {
        dy = -event.detail;
        if (dy > 100) {
          dy = 3;
        } else {
          if (dy < -100) {
            dy = -3;
          }
        }
        if (Ext.isDefined(event.axis) && event.axis === event.HORIZONTAL_AXIS) {
          dx = dy;
          dy = 0;
        }
      }
    }
  }
  return {x:me.correctWheelDelta(dx), y:me.correctWheelDelta(dy)};
}, getWheelDelta:function() {
  var deltas = this.getWheelDeltas();
  return deltas.y;
}, within:function(el, related, allowEl) {
  if (el) {
    var t = related ? this.getRelatedTarget() : this.getTarget(), result;
    if (t) {
      result = Ext.fly(el, '_internal').contains(t);
      if (!result && allowEl) {
        result = t == Ext.getDom(el);
      }
      return result;
    }
  }
  return false;
}, isNavKeyPress:function() {
  var me = this, k = this.normalizeKey(me.keyCode);
  return k >= 33 && k <= 40 || k == me.RETURN || k == me.TAB || k == me.ESC;
}, isSpecialKey:function() {
  var k = this.normalizeKey(this.keyCode);
  return this.type == 'keypress' && this.ctrlKey || this.isNavKeyPress() || k == this.BACKSPACE || k >= 16 && k <= 20 || k >= 44 && k <= 46;
}, getPoint:function() {
  var xy = this.getXY();
  return new Ext.util.Point(xy[0], xy[1]);
}, hasModifier:function() {
  return this.ctrlKey || this.altKey || this.shiftKey || this.metaKey;
}, injectEvent:function() {
  var API, dispatchers = {}, crazyIEButtons;
  if (!Ext.isIE9m && document.createEvent) {
    API = {createHtmlEvent:function(doc, type, bubbles, cancelable) {
      var event = doc.createEvent('HTMLEvents');
      event.initEvent(type, bubbles, cancelable);
      return event;
    }, createMouseEvent:function(doc, type, bubbles, cancelable, detail, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget) {
      var event = doc.createEvent('MouseEvents'), view = doc.defaultView || window;
      if (event.initMouseEvent) {
        event.initMouseEvent(type, bubbles, cancelable, view, detail, clientX, clientY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget);
      } else {
        event = doc.createEvent('UIEvents');
        event.initEvent(type, bubbles, cancelable);
        event.view = view;
        event.detail = detail;
        event.screenX = clientX;
        event.screenY = clientY;
        event.clientX = clientX;
        event.clientY = clientY;
        event.ctrlKey = ctrlKey;
        event.altKey = altKey;
        event.metaKey = metaKey;
        event.shiftKey = shiftKey;
        event.button = button;
        event.relatedTarget = relatedTarget;
      }
      return event;
    }, createUIEvent:function(doc, type, bubbles, cancelable, detail) {
      var event = doc.createEvent('UIEvents'), view = doc.defaultView || window;
      event.initUIEvent(type, bubbles, cancelable, view, detail);
      return event;
    }, fireEvent:function(target, type, event) {
      target.dispatchEvent(event);
    }, fixTarget:function(target) {
      if (target == window && !target.dispatchEvent) {
        return document;
      }
      return target;
    }};
  } else {
    if (document.createEventObject) {
      crazyIEButtons = {0:1, 1:4, 2:2};
      API = {createHtmlEvent:function(doc, type, bubbles, cancelable) {
        var event = doc.createEventObject();
        event.bubbles = bubbles;
        event.cancelable = cancelable;
        return event;
      }, createMouseEvent:function(doc, type, bubbles, cancelable, detail, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget) {
        var event = doc.createEventObject();
        event.bubbles = bubbles;
        event.cancelable = cancelable;
        event.detail = detail;
        event.screenX = clientX;
        event.screenY = clientY;
        event.clientX = clientX;
        event.clientY = clientY;
        event.ctrlKey = ctrlKey;
        event.altKey = altKey;
        event.shiftKey = shiftKey;
        event.metaKey = metaKey;
        event.button = crazyIEButtons[button] || button;
        event.relatedTarget = relatedTarget;
        return event;
      }, createUIEvent:function(doc, type, bubbles, cancelable, detail) {
        var event = doc.createEventObject();
        event.bubbles = bubbles;
        event.cancelable = cancelable;
        return event;
      }, fireEvent:function(target, type, event) {
        target.fireEvent('on' + type, event);
      }, fixTarget:function(target) {
        if (target == document) {
          return document.documentElement;
        }
        return target;
      }};
    }
  }
  Ext.Object.each({load:[false, false], unload:[false, false], select:[true, false], change:[true, false], submit:[true, true], reset:[true, false], resize:[true, false], scroll:[true, false]}, function(name, value) {
    var bubbles = value[0], cancelable = value[1];
    dispatchers[name] = function(targetEl, srcEvent) {
      var e = API.createHtmlEvent(name, bubbles, cancelable);
      API.fireEvent(targetEl, name, e);
    };
  });
  function createMouseEventDispatcher(type, detail) {
    var cancelable = type != 'mousemove';
    return function(targetEl, srcEvent) {
      var xy = srcEvent.getXY(), e = API.createMouseEvent(targetEl.ownerDocument, type, true, cancelable, detail, xy[0], xy[1], srcEvent.ctrlKey, srcEvent.altKey, srcEvent.shiftKey, srcEvent.metaKey, srcEvent.button, srcEvent.relatedTarget);
      API.fireEvent(targetEl, type, e);
    };
  }
  Ext.each(['click', 'dblclick', 'mousedown', 'mouseup', 'mouseover', 'mousemove', 'mouseout'], function(eventName) {
    dispatchers[eventName] = createMouseEventDispatcher(eventName, 1);
  });
  Ext.Object.each({focusin:[true, false], focusout:[true, false], activate:[true, true], focus:[false, false], blur:[false, false]}, function(name, value) {
    var bubbles = value[0], cancelable = value[1];
    dispatchers[name] = function(targetEl, srcEvent) {
      var e = API.createUIEvent(targetEl.ownerDocument, name, bubbles, cancelable, 1);
      API.fireEvent(targetEl, name, e);
    };
  });
  if (!API) {
    dispatchers = {};
    API = {fixTarget:Ext.identityFn};
  }
  function cannotInject(target, srcEvent) {
  }
  return function(target) {
    var me = this, dispatcher = dispatchers[me.type] || cannotInject, t = target ? target.dom || target : me.getTarget();
    t = API.fixTarget(t);
    dispatcher(t, me);
  };
}()}, function() {
  Ext.EventObject = new Ext.EventObjectImpl;
});
Ext.define('Ext.dom.AbstractQuery', {select:function(q, root) {
  var results = [], nodes, i, j, qlen, nlen;
  root = root || document;
  if (typeof root == 'string') {
    root = document.getElementById(root);
  }
  q = q.split(',');
  for (i = 0, qlen = q.length; i < qlen; i++) {
    if (typeof q[i] == 'string') {
      if (typeof q[i][0] == '@') {
        nodes = root.getAttributeNode(q[i].substring(1));
        results.push(nodes);
      } else {
        nodes = root.querySelectorAll(q[i]);
        for (j = 0, nlen = nodes.length; j < nlen; j++) {
          results.push(nodes[j]);
        }
      }
    }
  }
  return results;
}, selectNode:function(q, root) {
  return this.select(q, root)[0];
}, is:function(el, q) {
  if (typeof el == 'string') {
    el = document.getElementById(el);
  }
  return this.select(q).indexOf(el) !== -1;
}});
Ext.define('Ext.dom.AbstractHelper', {emptyTags:/^(?:br|frame|hr|img|input|link|meta|range|spacer|wbr|area|param|col)$/i, confRe:/^(?:tag|children|cn|html|tpl|tplData)$/i, endRe:/end/i, styleSepRe:/\s*(?::|;)\s*/, attributeTransform:{cls:'class', htmlFor:'for'}, closeTags:{}, decamelizeName:function() {
  var camelCaseRe = /([a-z])([A-Z])/g, cache = {};
  function decamel(match, p1, p2) {
    return p1 + '-' + p2.toLowerCase();
  }
  return function(s) {
    return cache[s] || (cache[s] = s.replace(camelCaseRe, decamel));
  };
}(), generateMarkup:function(spec, buffer) {
  var me = this, specType = typeof spec, attr, val, tag, i, closeTags;
  if (specType == 'string' || specType == 'number') {
    buffer.push(spec);
  } else {
    if (Ext.isArray(spec)) {
      for (i = 0; i < spec.length; i++) {
        if (spec[i]) {
          me.generateMarkup(spec[i], buffer);
        }
      }
    } else {
      tag = spec.tag || 'div';
      buffer.push('\x3c', tag);
      for (attr in spec) {
        if (spec.hasOwnProperty(attr)) {
          val = spec[attr];
          if (!me.confRe.test(attr)) {
            if (typeof val == 'object') {
              buffer.push(' ', attr, '\x3d"');
              me.generateStyles(val, buffer).push('"');
            } else {
              buffer.push(' ', me.attributeTransform[attr] || attr, '\x3d"', val, '"');
            }
          }
        }
      }
      if (me.emptyTags.test(tag)) {
        buffer.push('/\x3e');
      } else {
        buffer.push('\x3e');
        if (val = spec.tpl) {
          val.applyOut(spec.tplData, buffer);
        }
        if (val = spec.html) {
          buffer.push(val);
        }
        if (val = spec.cn || spec.children) {
          me.generateMarkup(val, buffer);
        }
        closeTags = me.closeTags;
        buffer.push(closeTags[tag] || (closeTags[tag] = '\x3c/' + tag + '\x3e'));
      }
    }
  }
  return buffer;
}, generateStyles:function(styles, buffer) {
  var a = buffer || [], name;
  for (name in styles) {
    if (styles.hasOwnProperty(name)) {
      a.push(this.decamelizeName(name), ':', styles[name], ';');
    }
  }
  return buffer || a.join('');
}, markup:function(spec) {
  if (typeof spec == 'string') {
    return spec;
  }
  var buf = this.generateMarkup(spec, []);
  return buf.join('');
}, applyStyles:function(el, styles) {
  if (styles) {
    var i = 0, len;
    el = Ext.fly(el, '_applyStyles');
    if (typeof styles == 'function') {
      styles = styles.call();
    }
    if (typeof styles == 'string') {
      styles = Ext.util.Format.trim(styles).split(this.styleSepRe);
      for (len = styles.length; i < len;) {
        el.setStyle(styles[i++], styles[i++]);
      }
    } else {
      if (Ext.isObject(styles)) {
        el.setStyle(styles);
      }
    }
  }
}, insertHtml:function(where, el, html) {
  var hash = {}, setStart, range, frag, rangeEl;
  where = where.toLowerCase();
  hash['beforebegin'] = ['BeforeBegin', 'previousSibling'];
  hash['afterend'] = ['AfterEnd', 'nextSibling'];
  range = el.ownerDocument.createRange();
  setStart = 'setStart' + (this.endRe.test(where) ? 'After' : 'Before');
  if (hash[where]) {
    range[setStart](el);
    frag = range.createContextualFragment(html);
    el.parentNode.insertBefore(frag, where == 'beforebegin' ? el : el.nextSibling);
    return el[(where == 'beforebegin' ? 'previous' : 'next') + 'Sibling'];
  } else {
    rangeEl = (where == 'afterbegin' ? 'first' : 'last') + 'Child';
    if (el.firstChild) {
      range[setStart](el[rangeEl]);
      frag = range.createContextualFragment(html);
      if (where == 'afterbegin') {
        el.insertBefore(frag, el.firstChild);
      } else {
        el.appendChild(frag);
      }
    } else {
      el.innerHTML = html;
    }
    return el[rangeEl];
  }
  throw 'Illegal insertion point -\x3e "' + where + '"';
}, insertBefore:function(el, o, returnElement) {
  return this.doInsert(el, o, returnElement, 'beforebegin');
}, insertAfter:function(el, o, returnElement) {
  return this.doInsert(el, o, returnElement, 'afterend', 'nextSibling');
}, insertFirst:function(el, o, returnElement) {
  return this.doInsert(el, o, returnElement, 'afterbegin', 'firstChild');
}, append:function(el, o, returnElement) {
  return this.doInsert(el, o, returnElement, 'beforeend', '', true);
}, overwrite:function(el, o, returnElement) {
  el = Ext.getDom(el);
  el.innerHTML = this.markup(o);
  return returnElement ? Ext.get(el.firstChild) : el.firstChild;
}, doInsert:function(el, o, returnElement, pos, sibling, append) {
  var newNode = this.insertHtml(pos, Ext.getDom(el), this.markup(o));
  return returnElement ? Ext.get(newNode, true) : newNode;
}});
Ext.define('Ext.dom.AbstractElement_static', {override:'Ext.dom.AbstractElement', inheritableStatics:{unitRe:/\d+(px|em|%|en|ex|pt|in|cm|mm|pc)$/i, camelRe:/(-[a-z])/gi, msRe:/^-ms-/, cssRe:/([a-z0-9\-]+)\s*:\s*([^;\s]+(?:\s*[^;\s]+)*)?;?/gi, opacityRe:/alpha\(opacity=(.*)\)/i, propertyCache:{}, defaultUnit:'px', borders:{l:'border-left-width', r:'border-right-width', t:'border-top-width', b:'border-bottom-width'}, paddings:{l:'padding-left', r:'padding-right', t:'padding-top', b:'padding-bottom'}, 
margins:{l:'margin-left', r:'margin-right', t:'margin-top', b:'margin-bottom'}, addUnits:function(size, units) {
  if (typeof size == 'number') {
    return size + (units || this.defaultUnit || 'px');
  }
  if (size === '' || size == 'auto' || size === undefined || size === null) {
    return size || '';
  }
  if (!this.unitRe.test(size)) {
    if (Ext.isDefined(Ext.global.console)) {
      Ext.global.console.warn('Warning, size detected as NaN on Element.addUnits.');
    }
    return size || '';
  }
  return size;
}, isAncestor:function(p, c) {
  var ret = false;
  p = Ext.getDom(p);
  c = Ext.getDom(c);
  if (p && c) {
    if (p.contains) {
      return p.contains(c);
    } else {
      if (p.compareDocumentPosition) {
        return !!(p.compareDocumentPosition(c) & 16);
      } else {
        while (c = c.parentNode) {
          ret = c == p || ret;
        }
      }
    }
  }
  return ret;
}, parseBox:function(box) {
  box = box || 0;
  var type = typeof box, parts, ln;
  if (type === 'number') {
    return {top:box, right:box, bottom:box, left:box};
  } else {
    if (type !== 'string') {
      return box;
    }
  }
  parts = box.split(' ');
  ln = parts.length;
  if (ln == 1) {
    parts[1] = parts[2] = parts[3] = parts[0];
  } else {
    if (ln == 2) {
      parts[2] = parts[0];
      parts[3] = parts[1];
    } else {
      if (ln == 3) {
        parts[3] = parts[1];
      }
    }
  }
  return {top:parseFloat(parts[0]) || 0, right:parseFloat(parts[1]) || 0, bottom:parseFloat(parts[2]) || 0, left:parseFloat(parts[3]) || 0};
}, unitizeBox:function(box, units) {
  var a = this.addUnits, b = this.parseBox(box);
  return a(b.top, units) + ' ' + a(b.right, units) + ' ' + a(b.bottom, units) + ' ' + a(b.left, units);
}, camelReplaceFn:function(m, a) {
  return a.charAt(1).toUpperCase();
}, normalize:function(prop) {
  if (prop == 'float') {
    prop = Ext.supports.Float ? 'cssFloat' : 'styleFloat';
  }
  return this.propertyCache[prop] || (this.propertyCache[prop] = prop.replace(this.msRe, 'ms-').replace(this.camelRe, this.camelReplaceFn));
}, getDocumentHeight:function() {
  return Math.max(!Ext.isStrict ? document.body.scrollHeight : document.documentElement.scrollHeight, this.getViewportHeight());
}, getDocumentWidth:function() {
  return Math.max(!Ext.isStrict ? document.body.scrollWidth : document.documentElement.scrollWidth, this.getViewportWidth());
}, getViewportHeight:function() {
  return window.innerHeight;
}, getViewportWidth:function() {
  return window.innerWidth;
}, getViewSize:function() {
  return {width:window.innerWidth, height:window.innerHeight};
}, getOrientation:function() {
  if (Ext.supports.OrientationChange) {
    return window.orientation == 0 ? 'portrait' : 'landscape';
  }
  return window.innerHeight > window.innerWidth ? 'portrait' : 'landscape';
}, fromPoint:function(x, y) {
  return Ext.get(document.elementFromPoint(x, y));
}, parseStyles:function(styles) {
  var out = {}, cssRe = this.cssRe, matches;
  if (styles) {
    cssRe.lastIndex = 0;
    while (matches = cssRe.exec(styles)) {
      out[matches[1]] = matches[2] || '';
    }
  }
  return out;
}}}, function() {
  var doc = document, activeElement = null, isCSS1 = doc.compatMode == 'CSS1Compat';
  if (!('activeElement' in doc) && doc.addEventListener) {
    doc.addEventListener('focus', function(ev) {
      if (ev && ev.target) {
        activeElement = ev.target == doc ? null : ev.target;
      }
    }, true);
  }
  function makeSelectionRestoreFn(activeEl, start, end) {
    return function() {
      activeEl.selectionStart = start;
      activeEl.selectionEnd = end;
    };
  }
  this.addInheritableStatics({getActiveElement:function() {
    var active;
    try {
      active = doc.activeElement;
    } catch (e$11) {
    }
    active = active || activeElement;
    if (!active) {
      active = activeElement = document.body;
    }
    return active;
  }, getRightMarginFixCleaner:function(target) {
    var supports = Ext.supports, hasInputBug = supports.DisplayChangeInputSelectionBug, hasTextAreaBug = supports.DisplayChangeTextAreaSelectionBug, activeEl, tag, start, end;
    if (hasInputBug || hasTextAreaBug) {
      activeEl = doc.activeElement || activeElement;
      tag = activeEl && activeEl.tagName;
      if (hasTextAreaBug && tag == 'TEXTAREA' || hasInputBug && tag == 'INPUT' && activeEl.type == 'text') {
        if (Ext.dom.Element.isAncestor(target, activeEl)) {
          start = activeEl.selectionStart;
          end = activeEl.selectionEnd;
          if (Ext.isNumber(start) && Ext.isNumber(end)) {
            return makeSelectionRestoreFn(activeEl, start, end);
          }
        }
      }
    }
    return Ext.emptyFn;
  }, getViewWidth:function(full) {
    return full ? Ext.dom.Element.getDocumentWidth() : Ext.dom.Element.getViewportWidth();
  }, getViewHeight:function(full) {
    return full ? Ext.dom.Element.getDocumentHeight() : Ext.dom.Element.getViewportHeight();
  }, getDocumentHeight:function() {
    return Math.max(!isCSS1 ? doc.body.scrollHeight : doc.documentElement.scrollHeight, Ext.dom.Element.getViewportHeight());
  }, getDocumentWidth:function() {
    return Math.max(!isCSS1 ? doc.body.scrollWidth : doc.documentElement.scrollWidth, Ext.dom.Element.getViewportWidth());
  }, getViewportHeight:function() {
    return Ext.isIE9m ? Ext.isStrict ? doc.documentElement.clientHeight : doc.body.clientHeight : self.innerHeight;
  }, getViewportWidth:function() {
    return !Ext.isStrict && !Ext.isOpera ? doc.body.clientWidth : Ext.isIE9m ? doc.documentElement.clientWidth : self.innerWidth;
  }, serializeForm:function(form) {
    var fElements = form.elements || (document.forms[form] || Ext.getDom(form)).elements, hasSubmit = false, encoder = encodeURIComponent, data = '', eLen = fElements.length, element, name, type, options, hasValue, e, o, oLen, opt;
    for (e = 0; e < eLen; e++) {
      element = fElements[e];
      name = element.name;
      type = element.type;
      options = element.options;
      if (!element.disabled && name) {
        if (/select-(one|multiple)/i.test(type)) {
          oLen = options.length;
          for (o = 0; o < oLen; o++) {
            opt = options[o];
            if (opt.selected) {
              hasValue = opt.hasAttribute ? opt.hasAttribute('value') : opt.getAttributeNode('value').specified;
              data += Ext.String.format('{0}\x3d{1}\x26', encoder(name), encoder(hasValue ? opt.value : opt.text));
            }
          }
        } else {
          if (!/file|undefined|reset|button/i.test(type)) {
            if (!(/radio|checkbox/i.test(type) && !element.checked) && !(type == 'submit' && hasSubmit)) {
              data += encoder(name) + '\x3d' + encoder(element.value) + '\x26';
              hasSubmit = /submit/i.test(type);
            }
          }
        }
      }
    }
    return data.substr(0, data.length - 1);
  }});
});
Ext.define('Ext.dom.AbstractElement_insertion', {override:'Ext.dom.AbstractElement', appendChild:function(el, returnDom) {
  var me = this, insertEl, eLen, e, oldUseDom;
  if (el.nodeType || el.dom || typeof el == 'string') {
    el = Ext.getDom(el);
    me.dom.appendChild(el);
    return !returnDom ? Ext.get(el) : el;
  } else {
    if (el.length) {
      insertEl = Ext.fly(document.createDocumentFragment(), '_internal');
      eLen = el.length;
      Ext.DomHelper.useDom = true;
      for (e = 0; e < eLen; e++) {
        insertEl.appendChild(el[e], returnDom);
      }
      Ext.DomHelper.useDom = oldUseDom;
      me.dom.appendChild(insertEl.dom);
      return returnDom ? insertEl.dom : insertEl;
    } else {
      return me.createChild(el, null, returnDom);
    }
  }
}, appendTo:function(el) {
  Ext.getDom(el).appendChild(this.dom);
  return this;
}, insertBefore:function(el) {
  el = Ext.getDom(el);
  el.parentNode.insertBefore(this.dom, el);
  return this;
}, insertAfter:function(el) {
  el = Ext.getDom(el);
  el.parentNode.insertBefore(this.dom, el.nextSibling);
  return this;
}, insertFirst:function(el, returnDom) {
  el = el || {};
  if (el.nodeType || el.dom || typeof el == 'string') {
    el = Ext.getDom(el);
    this.dom.insertBefore(el, this.dom.firstChild);
    return !returnDom ? Ext.get(el) : el;
  } else {
    return this.createChild(el, this.dom.firstChild, returnDom);
  }
}, insertSibling:function(el, where, returnDom) {
  var me = this, DomHelper = Ext.core.DomHelper, oldUseDom = DomHelper.useDom, isAfter = (where || 'before').toLowerCase() == 'after', rt, insertEl, eLen, e;
  if (Ext.isArray(el)) {
    insertEl = Ext.fly(document.createDocumentFragment(), '_internal');
    eLen = el.length;
    DomHelper.useDom = true;
    for (e = 0; e < eLen; e++) {
      rt = insertEl.appendChild(el[e], returnDom);
    }
    DomHelper.useDom = oldUseDom;
    me.dom.parentNode.insertBefore(insertEl.dom, isAfter ? me.dom.nextSibling : me.dom);
    return rt;
  }
  el = el || {};
  if (el.nodeType || el.dom) {
    rt = me.dom.parentNode.insertBefore(Ext.getDom(el), isAfter ? me.dom.nextSibling : me.dom);
    if (!returnDom) {
      rt = Ext.get(rt);
    }
  } else {
    if (isAfter && !me.dom.nextSibling) {
      rt = DomHelper.append(me.dom.parentNode, el, !returnDom);
    } else {
      rt = DomHelper[isAfter ? 'insertAfter' : 'insertBefore'](me.dom, el, !returnDom);
    }
  }
  return rt;
}, replace:function(el) {
  el = Ext.get(el);
  this.insertBefore(el);
  el.remove();
  return this;
}, replaceWith:function(el) {
  var me = this;
  if (el.nodeType || el.dom || typeof el == 'string') {
    el = Ext.get(el);
    me.dom.parentNode.insertBefore(el.dom, me.dom);
  } else {
    el = Ext.core.DomHelper.insertBefore(me.dom, el);
  }
  delete Ext.cache[me.id];
  Ext.removeNode(me.dom);
  me.id = Ext.id(me.dom = el);
  Ext.dom.AbstractElement.addToCache(me.isFlyweight ? new Ext.dom.AbstractElement(me.dom) : me);
  return me;
}, createChild:function(config, insertBefore, returnDom) {
  config = config || {tag:'div'};
  if (insertBefore) {
    return Ext.core.DomHelper.insertBefore(insertBefore, config, returnDom !== true);
  } else {
    return Ext.core.DomHelper.append(this.dom, config, returnDom !== true);
  }
}, wrap:function(config, returnDom, selector) {
  var newEl = Ext.core.DomHelper.insertBefore(this.dom, config || {tag:'div'}, true), target = newEl;
  if (selector) {
    target = Ext.DomQuery.selectNode(selector, newEl.dom);
  }
  target.appendChild(this.dom);
  return returnDom ? newEl.dom : newEl;
}, insertHtml:function(where, html, returnEl) {
  var el = Ext.core.DomHelper.insertHtml(where, this.dom, html);
  return returnEl ? Ext.get(el) : el;
}});
Ext.define('Ext.dom.AbstractElement_style', {override:'Ext.dom.AbstractElement'}, function() {
  var Element = this, wordsRe = /\w/g, spacesRe = /\s+/, transparentRe = /^(?:transparent|(?:rgba[(](?:\s*\d+\s*[,]){3}\s*0\s*[)]))$/i, hasClassList = Ext.supports.ClassList, PADDING = 'padding', MARGIN = 'margin', BORDER = 'border', LEFT_SUFFIX = '-left', RIGHT_SUFFIX = '-right', TOP_SUFFIX = '-top', BOTTOM_SUFFIX = '-bottom', WIDTH = '-width', borders = {l:BORDER + LEFT_SUFFIX + WIDTH, r:BORDER + RIGHT_SUFFIX + WIDTH, t:BORDER + TOP_SUFFIX + WIDTH, b:BORDER + BOTTOM_SUFFIX + WIDTH}, paddings = 
  {l:PADDING + LEFT_SUFFIX, r:PADDING + RIGHT_SUFFIX, t:PADDING + TOP_SUFFIX, b:PADDING + BOTTOM_SUFFIX}, margins = {l:MARGIN + LEFT_SUFFIX, r:MARGIN + RIGHT_SUFFIX, t:MARGIN + TOP_SUFFIX, b:MARGIN + BOTTOM_SUFFIX}, internalFly = new Element.Fly;
  Ext.override(Element, {styleHooks:{}, addStyles:function(sides, styles) {
    var totalSize = 0, sidesArr = (sides || '').match(wordsRe), i, len = sidesArr.length, side, styleSides = [];
    if (len == 1) {
      totalSize = Math.abs(parseFloat(this.getStyle(styles[sidesArr[0]])) || 0);
    } else {
      if (len) {
        for (i = 0; i < len; i++) {
          side = sidesArr[i];
          styleSides.push(styles[side]);
        }
        styleSides = this.getStyle(styleSides);
        for (i = 0; i < len; i++) {
          side = sidesArr[i];
          totalSize += Math.abs(parseFloat(styleSides[styles[side]]) || 0);
        }
      }
    }
    return totalSize;
  }, addCls:function() {
    var addWithClassList = function(className) {
      if (String(className).indexOf('undefined') > -1) {
        Ext.Logger.warn('called with an undefined className: ' + className);
      }
      var me = this, dom = me.dom, trimRe = me.trimRe, origClassName = className, classList, newCls, i, len, cls;
      if (typeof className == 'string') {
        className = className.replace(trimRe, '').split(spacesRe);
      }
      if (dom && className && !!(len = className.length)) {
        if (!dom.className) {
          dom.className = className.join(' ');
        } else {
          classList = dom.classList;
          if (classList) {
            for (i = 0; i < len; ++i) {
              cls = className[i];
              if (cls) {
                if (!classList.contains(cls)) {
                  if (newCls) {
                    newCls.push(cls);
                  } else {
                    newCls = dom.className.replace(trimRe, '');
                    newCls = newCls ? [newCls, cls] : [cls];
                  }
                }
              }
            }
            if (newCls) {
              dom.className = newCls.join(' ');
            }
          } else {
            addWithoutClassList(origClassName);
          }
        }
      }
      return me;
    }, addWithoutClassList = function(className) {
      if (String(className).indexOf('undefined') > -1) {
        Ext.Logger.warn("called with an undefined className: '" + className + "'");
      }
      var me = this, dom = me.dom, elClasses;
      if (dom && className && className.length) {
        elClasses = Ext.Element.mergeClsList(dom.className, className);
        if (elClasses.changed) {
          dom.className = elClasses.join(' ');
        }
      }
      return me;
    };
    return hasClassList ? addWithClassList : addWithoutClassList;
  }(), removeCls:function(className) {
    var me = this, dom = me.dom, classList, len, elClasses;
    if (typeof className == 'string') {
      className = className.replace(me.trimRe, '').split(spacesRe);
    }
    if (dom && dom.className && className && !!(len = className.length)) {
      classList = dom.classList;
      if (len === 1 && classList) {
        if (className[0]) {
          classList.remove(className[0]);
        }
      } else {
        elClasses = Ext.Element.removeCls(dom.className, className);
        if (elClasses.changed) {
          dom.className = elClasses.join(' ');
        }
      }
    }
    return me;
  }, radioCls:function(className) {
    var cn = this.dom.parentNode.childNodes, v, i, len;
    className = Ext.isArray(className) ? className : [className];
    for (i = 0, len = cn.length; i < len; i++) {
      v = cn[i];
      if (v && v.nodeType == 1) {
        internalFly.attach(v).removeCls(className);
      }
    }
    return this.addCls(className);
  }, toggleCls:function() {
    var toggleWithClassList = function(className) {
      var me = this, dom = me.dom, classList;
      if (dom) {
        className = className.replace(me.trimRe, '');
        if (className) {
          classList = dom.classList;
          if (classList) {
            classList.toggle(className);
          } else {
            toggleWithoutClassList(className);
          }
        }
      }
      return me;
    }, toggleWithoutClassList = function(className) {
      return this.hasCls(className) ? this.removeCls(className) : this.addCls(className);
    };
    return hasClassList ? toggleWithClassList : toggleWithoutClassList;
  }(), hasCls:function() {
    var hasClsWithClassList = function(className) {
      var dom = this.dom, out = false, classList;
      if (dom && className) {
        classList = dom.classList;
        if (classList) {
          out = classList.contains(className);
        } else {
          out = hasClsWithoutClassList(className);
        }
      }
      return out;
    }, hasClsWithoutClassList = function(className) {
      var dom = this.dom;
      return dom ? className && (' ' + dom.className + ' ').indexOf(' ' + className + ' ') !== -1 : false;
    };
    return hasClassList ? hasClsWithClassList : hasClsWithoutClassList;
  }(), replaceCls:function(oldClassName, newClassName) {
    return this.removeCls(oldClassName).addCls(newClassName);
  }, isStyle:function(style, val) {
    return this.getStyle(style) == val;
  }, getStyle:function(property, inline) {
    var me = this, dom = me.dom, multiple = typeof property != 'string', hooks = me.styleHooks, prop = property, props = prop, len = 1, domStyle, camel, values, hook, out, style, i;
    if (multiple) {
      values = {};
      prop = props[0];
      i = 0;
      if (!(len = props.length)) {
        return values;
      }
    }
    if (!dom || dom.documentElement) {
      return values || '';
    }
    domStyle = dom.style;
    if (inline) {
      style = domStyle;
    } else {
      style = dom.ownerDocument.defaultView.getComputedStyle(dom, null);
      if (!style) {
        inline = true;
        style = domStyle;
      }
    }
    do {
      hook = hooks[prop];
      if (!hook) {
        hooks[prop] = hook = {name:Element.normalize(prop)};
      }
      if (hook.get) {
        out = hook.get(dom, me, inline, style);
      } else {
        camel = hook.name;
        out = style[camel];
      }
      if (!multiple) {
        return out;
      }
      values[prop] = out;
      prop = props[++i];
    } while (i < len);
    return values;
  }, getStyles:function() {
    var props = Ext.Array.slice(arguments), len = props.length, inline;
    if (len && typeof props[len - 1] == 'boolean') {
      inline = props.pop();
    }
    return this.getStyle(props, inline);
  }, isTransparent:function(prop) {
    var value = this.getStyle(prop);
    return value ? transparentRe.test(value) : false;
  }, setStyle:function(prop, value) {
    var me = this, dom = me.dom, hooks = me.styleHooks, style = dom.style, name = prop, hook;
    if (typeof name == 'string') {
      hook = hooks[name];
      if (!hook) {
        hooks[name] = hook = {name:Element.normalize(name)};
      }
      value = value == null ? '' : value;
      if (hook.set) {
        hook.set(dom, value, me);
      } else {
        style[hook.name] = value;
      }
      if (hook.afterSet) {
        hook.afterSet(dom, value, me);
      }
    } else {
      for (name in prop) {
        if (prop.hasOwnProperty(name)) {
          hook = hooks[name];
          if (!hook) {
            hooks[name] = hook = {name:Element.normalize(name)};
          }
          value = prop[name];
          value = value == null ? '' : value;
          if (hook.set) {
            hook.set(dom, value, me);
          } else {
            style[hook.name] = value;
          }
          if (hook.afterSet) {
            hook.afterSet(dom, value, me);
          }
        }
      }
    }
    return me;
  }, getHeight:function(contentHeight) {
    var dom = this.dom, height = contentHeight ? dom.clientHeight - this.getPadding('tb') : dom.offsetHeight;
    return height > 0 ? height : 0;
  }, getWidth:function(contentWidth) {
    var dom = this.dom, width = contentWidth ? dom.clientWidth - this.getPadding('lr') : dom.offsetWidth;
    return width > 0 ? width : 0;
  }, setWidth:function(width) {
    var me = this;
    me.dom.style.width = Element.addUnits(width);
    return me;
  }, setHeight:function(height) {
    var me = this;
    me.dom.style.height = Element.addUnits(height);
    return me;
  }, getBorderWidth:function(side) {
    return this.addStyles(side, borders);
  }, getPadding:function(side) {
    return this.addStyles(side, paddings);
  }, margins:margins, applyStyles:function(styles) {
    if (styles) {
      var i, len, dom = this.dom;
      if (typeof styles == 'function') {
        styles = styles.call();
      }
      if (typeof styles == 'string') {
        styles = Ext.util.Format.trim(styles).split(/\s*(?::|;)\s*/);
        for (i = 0, len = styles.length; i < len;) {
          dom.style[Element.normalize(styles[i++])] = styles[i++];
        }
      } else {
        if (typeof styles == 'object') {
          this.setStyle(styles);
        }
      }
    }
  }, setSize:function(width, height) {
    var me = this, style = me.dom.style;
    if (Ext.isObject(width)) {
      height = width.height;
      width = width.width;
    }
    style.width = Element.addUnits(width);
    style.height = Element.addUnits(height);
    return me;
  }, getViewSize:function() {
    var doc = document, dom = this.dom;
    if (dom == doc || dom == doc.body) {
      return {width:Element.getViewportWidth(), height:Element.getViewportHeight()};
    } else {
      return {width:dom.clientWidth, height:dom.clientHeight};
    }
  }, getSize:function(contentSize) {
    var dom = this.dom;
    return {width:Math.max(0, contentSize ? dom.clientWidth - this.getPadding('lr') : dom.offsetWidth), height:Math.max(0, contentSize ? dom.clientHeight - this.getPadding('tb') : dom.offsetHeight)};
  }, repaint:function() {
    var dom = this.dom;
    this.addCls(Ext.baseCSSPrefix + 'repaint');
    setTimeout(function() {
      internalFly.attach(dom).removeCls(Ext.baseCSSPrefix + 'repaint');
    }, 1);
    return this;
  }, getMargin:function(side) {
    var me = this, hash = {t:'top', l:'left', r:'right', b:'bottom'}, key, o, margins;
    if (!side) {
      margins = [];
      for (key in me.margins) {
        if (me.margins.hasOwnProperty(key)) {
          margins.push(me.margins[key]);
        }
      }
      o = me.getStyle(margins);
      if (o && typeof o == 'object') {
        for (key in me.margins) {
          if (me.margins.hasOwnProperty(key)) {
            o[hash[key]] = parseFloat(o[me.margins[key]]) || 0;
          }
        }
      }
      return o;
    } else {
      return me.addStyles(side, me.margins);
    }
  }, mask:function(msg, msgCls, transparent) {
    var me = this, dom = me.dom, data = (me.$cache || me.getCache()).data, el = data.mask, mask, size, cls = '', prefix = Ext.baseCSSPrefix;
    me.addCls(prefix + 'masked');
    if (me.getStyle('position') == 'static') {
      me.addCls(prefix + 'masked-relative');
    }
    if (el) {
      el.remove();
    }
    if (msgCls && typeof msgCls == 'string') {
      cls = ' ' + msgCls;
    } else {
      cls = ' ' + prefix + 'mask-gray';
    }
    mask = me.createChild({cls:prefix + 'mask' + (transparent !== false ? '' : ' ' + prefix + 'mask-gray'), html:msg ? '\x3cdiv class\x3d"' + (msgCls || prefix + 'mask-message') + '"\x3e' + msg + '\x3c/div\x3e' : ''});
    size = me.getSize();
    data.mask = mask;
    if (dom === document.body) {
      size.height = window.innerHeight;
      if (me.orientationHandler) {
        Ext.EventManager.unOrientationChange(me.orientationHandler, me);
      }
      me.orientationHandler = function() {
        size = me.getSize();
        size.height = window.innerHeight;
        mask.setSize(size);
      };
      Ext.EventManager.onOrientationChange(me.orientationHandler, me);
    }
    mask.setSize(size);
    if (Ext.is.iPad) {
      Ext.repaint();
    }
  }, unmask:function() {
    var me = this, data = (me.$cache || me.getCache()).data, mask = data.mask, prefix = Ext.baseCSSPrefix;
    if (mask) {
      mask.remove();
      delete data.mask;
    }
    me.removeCls([prefix + 'masked', prefix + 'masked-relative']);
    if (me.dom === document.body) {
      Ext.EventManager.unOrientationChange(me.orientationHandler, me);
      delete me.orientationHandler;
    }
  }});
  Ext.onReady(function() {
    var supports = Ext.supports, styleHooks, colorStyles, i, name, camel;
    function fixTransparent(dom, el, inline, style) {
      var value = style[this.name] || '';
      return transparentRe.test(value) ? 'transparent' : value;
    }
    function fixRightMargin(dom, el, inline, style) {
      var result = style.marginRight, domStyle, display;
      if (result != '0px') {
        domStyle = dom.style;
        display = domStyle.display;
        domStyle.display = 'inline-block';
        result = (inline ? style : dom.ownerDocument.defaultView.getComputedStyle(dom, null)).marginRight;
        domStyle.display = display;
      }
      return result;
    }
    function fixRightMarginAndInputFocus(dom, el, inline, style) {
      var result = style.marginRight, domStyle, cleaner, display;
      if (result != '0px') {
        domStyle = dom.style;
        cleaner = Element.getRightMarginFixCleaner(dom);
        display = domStyle.display;
        domStyle.display = 'inline-block';
        result = (inline ? style : dom.ownerDocument.defaultView.getComputedStyle(dom, '')).marginRight;
        domStyle.display = display;
        cleaner();
      }
      return result;
    }
    styleHooks = Element.prototype.styleHooks;
    if (supports.init) {
      supports.init();
    }
    if (!supports.RightMargin) {
      styleHooks.marginRight = styleHooks['margin-right'] = {name:'marginRight', get:supports.DisplayChangeInputSelectionBug || supports.DisplayChangeTextAreaSelectionBug ? fixRightMarginAndInputFocus : fixRightMargin};
    }
    if (!supports.TransparentColor) {
      colorStyles = ['background-color', 'border-color', 'color', 'outline-color'];
      for (i = colorStyles.length; i--;) {
        name = colorStyles[i];
        camel = Element.normalize(name);
        styleHooks[name] = styleHooks[camel] = {name:camel, get:fixTransparent};
      }
    }
  });
});
Ext.define('Ext.dom.AbstractElement_traversal', {override:'Ext.dom.AbstractElement', findParent:function(simpleSelector, limit, returnEl) {
  var target = this.dom, topmost = document.documentElement, depth = 0, stopEl;
  limit = limit || 50;
  if (isNaN(limit)) {
    stopEl = Ext.getDom(limit);
    limit = Number.MAX_VALUE;
  }
  while (target && target.nodeType == 1 && depth < limit && target != topmost && target != stopEl) {
    if (Ext.DomQuery.is(target, simpleSelector)) {
      return returnEl ? Ext.get(target) : target;
    }
    depth++;
    target = target.parentNode;
  }
  return null;
}, findParentNode:function(simpleSelector, limit, returnEl) {
  var p = Ext.fly(this.dom.parentNode, '_internal');
  return p ? p.findParent(simpleSelector, limit, returnEl) : null;
}, up:function(simpleSelector, limit, returnDom) {
  return this.findParentNode(simpleSelector, limit, !returnDom);
}, select:function(selector, composite) {
  return Ext.dom.Element.select(selector, this.dom, composite);
}, query:function(selector) {
  return Ext.DomQuery.select(selector, this.dom);
}, down:function(selector, returnDom) {
  var n = Ext.DomQuery.selectNode(selector, this.dom);
  return returnDom ? n : Ext.get(n);
}, child:function(selector, returnDom) {
  var node, me = this, id;
  id = Ext.id(me.dom);
  id = Ext.escapeId(id);
  node = Ext.DomQuery.selectNode('#' + id + ' \x3e ' + selector, me.dom);
  return returnDom ? node : Ext.get(node);
}, parent:function(selector, returnDom) {
  return this.matchNode('parentNode', 'parentNode', selector, returnDom);
}, next:function(selector, returnDom) {
  return this.matchNode('nextSibling', 'nextSibling', selector, returnDom);
}, prev:function(selector, returnDom) {
  return this.matchNode('previousSibling', 'previousSibling', selector, returnDom);
}, first:function(selector, returnDom) {
  return this.matchNode('nextSibling', 'firstChild', selector, returnDom);
}, last:function(selector, returnDom) {
  return this.matchNode('previousSibling', 'lastChild', selector, returnDom);
}, matchNode:function(dir, start, selector, returnDom) {
  if (!this.dom) {
    return null;
  }
  var n = this.dom[start];
  while (n) {
    if (n.nodeType == 1 && (!selector || Ext.DomQuery.is(n, selector))) {
      return !returnDom ? Ext.get(n) : n;
    }
    n = n[dir];
  }
  return null;
}, isAncestor:function(element) {
  return this.self.isAncestor.call(this.self, this.dom, element);
}});
Ext.define('Ext.dom.AbstractElement', {trimRe:/^\s+|\s+$/g, whitespaceRe:/\s/, inheritableStatics:{trimRe:/^\s+|\s+$/g, whitespaceRe:/\s/, get:function(el) {
  var me = this, document = window.document, El = Ext.dom.Element, cacheItem, docEl, extEl, dom, id;
  if (!el) {
    return null;
  }
  if (el.isFly) {
    el = el.dom;
  }
  if (typeof el == 'string') {
    if (el == Ext.windowId) {
      return El.get(window);
    } else {
      if (el == Ext.documentId) {
        return El.get(document);
      }
    }
    cacheItem = Ext.cache[el];
    if (cacheItem && cacheItem.skipGarbageCollection) {
      extEl = cacheItem.el;
      return extEl;
    }
    if (!(dom = document.getElementById(el))) {
      return null;
    }
    if (cacheItem && cacheItem.el) {
      extEl = Ext.updateCacheEntry(cacheItem, dom).el;
    } else {
      extEl = new El(dom, !!cacheItem);
    }
    return extEl;
  } else {
    if (el.tagName) {
      if (!(id = el.id)) {
        id = Ext.id(el);
      }
      cacheItem = Ext.cache[id];
      if (cacheItem && cacheItem.el) {
        extEl = Ext.updateCacheEntry(cacheItem, el).el;
      } else {
        extEl = new El(el, !!cacheItem);
      }
      return extEl;
    } else {
      if (el instanceof me) {
        if (el != me.docEl && el != me.winEl) {
          id = el.id;
          cacheItem = Ext.cache[id];
          if (cacheItem) {
            Ext.updateCacheEntry(cacheItem, document.getElementById(id) || el.dom);
          }
        }
        return el;
      } else {
        if (el.isComposite) {
          return el;
        } else {
          if (Ext.isArray(el)) {
            return me.select(el);
          } else {
            if (el === document) {
              if (!me.docEl) {
                docEl = me.docEl = Ext.Object.chain(El.prototype);
                docEl.dom = document;
                docEl.el = docEl;
                docEl.id = Ext.id(document);
                me.addToCache(docEl);
              }
              return me.docEl;
            } else {
              if (el === window) {
                if (!me.winEl) {
                  me.winEl = Ext.Object.chain(El.prototype);
                  me.winEl.dom = window;
                  me.winEl.id = Ext.id(window);
                  me.addToCache(me.winEl);
                }
                return me.winEl;
              }
            }
          }
        }
      }
    }
  }
  return null;
}, addToCache:function(el, id) {
  if (el) {
    Ext.addCacheEntry(id, el);
  }
  return el;
}, addMethods:function() {
  this.override.apply(this, arguments);
}, mergeClsList:function() {
  var clsList, clsHash = {}, i, length, j, listLength, clsName, result = [], changed = false, trimRe = this.trimRe, whitespaceRe = this.whitespaceRe;
  for (i = 0, length = arguments.length; i < length; i++) {
    clsList = arguments[i];
    if (Ext.isString(clsList)) {
      clsList = clsList.replace(trimRe, '').split(whitespaceRe);
    }
    if (clsList) {
      for (j = 0, listLength = clsList.length; j < listLength; j++) {
        clsName = clsList[j];
        if (!clsHash[clsName]) {
          if (i) {
            changed = true;
          }
          clsHash[clsName] = true;
        }
      }
    }
  }
  for (clsName in clsHash) {
    result.push(clsName);
  }
  result.changed = changed;
  return result;
}, removeCls:function(existingClsList, removeClsList) {
  var clsHash = {}, i, length, clsName, result = [], changed = false, whitespaceRe = this.whitespaceRe;
  if (existingClsList) {
    if (Ext.isString(existingClsList)) {
      existingClsList = existingClsList.replace(this.trimRe, '').split(whitespaceRe);
    }
    for (i = 0, length = existingClsList.length; i < length; i++) {
      clsHash[existingClsList[i]] = true;
    }
  }
  if (removeClsList) {
    if (Ext.isString(removeClsList)) {
      removeClsList = removeClsList.split(whitespaceRe);
    }
    for (i = 0, length = removeClsList.length; i < length; i++) {
      clsName = removeClsList[i];
      if (clsHash[clsName]) {
        changed = true;
        delete clsHash[clsName];
      }
    }
  }
  for (clsName in clsHash) {
    result.push(clsName);
  }
  result.changed = changed;
  return result;
}, VISIBILITY:1, DISPLAY:2, OFFSETS:3, ASCLASS:4}, constructor:function(element, forceNew) {
  var me = this, dom = typeof element == 'string' ? document.getElementById(element) : element, id;
  me.el = me;
  if (!dom) {
    return null;
  }
  id = dom.id;
  if (!forceNew && id && Ext.cache[id]) {
    return Ext.cache[id].el;
  }
  me.dom = dom;
  me.id = id || Ext.id(dom);
  me.self.addToCache(me);
}, set:function(o, useSet) {
  var el = this.dom, attr, value;
  for (attr in o) {
    if (o.hasOwnProperty(attr)) {
      value = o[attr];
      if (attr == 'style') {
        this.applyStyles(value);
      } else {
        if (attr == 'cls') {
          el.className = value;
        } else {
          if (useSet !== false) {
            if (value === undefined) {
              el.removeAttribute(attr);
            } else {
              el.setAttribute(attr, value);
            }
          } else {
            el[attr] = value;
          }
        }
      }
    }
  }
  return this;
}, defaultUnit:'px', is:function(simpleSelector) {
  return Ext.DomQuery.is(this.dom, simpleSelector);
}, getValue:function(asNumber) {
  var val = this.dom.value;
  return asNumber ? parseInt(val, 10) : val;
}, remove:function() {
  var me = this, dom = me.dom;
  if (me.isAnimate) {
    me.stopAnimation();
  }
  if (dom) {
    Ext.removeNode(dom);
    delete me.dom;
  }
}, contains:function(el) {
  if (!el) {
    return false;
  }
  var me = this, dom = el.dom || el;
  return dom === me.dom || Ext.dom.AbstractElement.isAncestor(me.dom, dom);
}, getAttribute:function(name, ns) {
  var dom = this.dom;
  return dom.getAttributeNS(ns, name) || dom.getAttribute(ns + ':' + name) || dom.getAttribute(name) || dom[name];
}, update:function(html) {
  if (this.dom) {
    this.dom.innerHTML = html;
  }
  return this;
}, setHTML:function(html) {
  if (this.dom) {
    this.dom.innerHTML = html;
  }
  return this;
}, getHTML:function() {
  return this.dom ? this.dom.innerHTML : '';
}, hide:function() {
  this.setVisible(false);
  return this;
}, show:function() {
  this.setVisible(true);
  return this;
}, setVisible:function(visible, animate) {
  var me = this, statics = me.self, mode = me.getVisibilityMode(), prefix = Ext.baseCSSPrefix;
  switch(mode) {
    case statics.VISIBILITY:
      me.removeCls([prefix + 'hidden-display', prefix + 'hidden-offsets']);
      me[visible ? 'removeCls' : 'addCls'](prefix + 'hidden-visibility');
      break;
    case statics.DISPLAY:
      me.removeCls([prefix + 'hidden-visibility', prefix + 'hidden-offsets']);
      me[visible ? 'removeCls' : 'addCls'](prefix + 'hidden-display');
      break;
    case statics.OFFSETS:
      me.removeCls([prefix + 'hidden-visibility', prefix + 'hidden-display']);
      me[visible ? 'removeCls' : 'addCls'](prefix + 'hidden-offsets');
      break;
  }
  return me;
}, getVisibilityMode:function() {
  var data = (this.$cache || this.getCache()).data, visMode = data.visibilityMode;
  if (visMode === undefined) {
    data.visibilityMode = visMode = this.self.DISPLAY;
  }
  return visMode;
}, setVisibilityMode:function(mode) {
  (this.$cache || this.getCache()).data.visibilityMode = mode;
  return this;
}, getCache:function() {
  var me = this, id = me.dom.id || Ext.id(me.dom);
  me.$cache = Ext.cache[id] || Ext.addCacheEntry(id, null, me.dom);
  return me.$cache;
}}, function() {
  var AbstractElement = this;
  Ext.getDetachedBody = function() {
    var detachedEl = AbstractElement.detachedBodyEl;
    if (!detachedEl) {
      detachedEl = document.createElement('div');
      AbstractElement.detachedBodyEl = detachedEl = new AbstractElement.Fly(detachedEl);
      detachedEl.isDetachedBody = true;
    }
    return detachedEl;
  };
  Ext.getElementById = function(id) {
    var el = document.getElementById(id), detachedBodyEl;
    if (!el && (detachedBodyEl = AbstractElement.detachedBodyEl)) {
      el = detachedBodyEl.dom.querySelector('#' + Ext.escapeId(id));
    }
    return el;
  };
  Ext.get = function(el) {
    return Ext.dom.Element.get(el);
  };
  this.addStatics({Fly:new Ext.Class({extend:AbstractElement, isFly:true, constructor:function(dom) {
    this.dom = dom;
    this.el = this;
  }, attach:function(dom) {
    this.dom = dom;
    this.$cache = dom.id ? Ext.cache[dom.id] : null;
    return this;
  }}), _flyweights:{}, fly:function(dom, named) {
    var fly = null, _flyweights = AbstractElement._flyweights;
    named = named || '_global';
    dom = Ext.getDom(dom);
    if (dom) {
      fly = _flyweights[named] || (_flyweights[named] = new AbstractElement.Fly);
      fly.dom = dom;
      fly.$cache = dom.id ? Ext.cache[dom.id] : null;
    }
    return fly;
  }});
  Ext.fly = function() {
    return AbstractElement.fly.apply(AbstractElement, arguments);
  };
  (function(proto) {
    proto.destroy = proto.remove;
    if (document.querySelector) {
      proto.getById = function(id, asDom) {
        var dom = document.getElementById(id) || this.dom.querySelector('#' + Ext.escapeId(id));
        return asDom ? dom : dom ? Ext.get(dom) : null;
      };
    } else {
      proto.getById = function(id, asDom) {
        var dom = document.getElementById(id);
        return asDom ? dom : dom ? Ext.get(dom) : null;
      };
    }
  })(this.prototype);
});
Ext.define('Ext.dom.Helper', function() {
  var afterbegin = 'afterbegin', afterend = 'afterend', beforebegin = 'beforebegin', beforeend = 'beforeend', ts = '\x3ctable\x3e', te = '\x3c/table\x3e', tbs = ts + '\x3ctbody\x3e', tbe = '\x3c/tbody\x3e' + te, trs = tbs + '\x3ctr\x3e', tre = '\x3c/tr\x3e' + tbe, detachedDiv = document.createElement('div'), bbValues = ['BeforeBegin', 'previousSibling'], aeValues = ['AfterEnd', 'nextSibling'], bb_ae_PositionHash = {beforebegin:bbValues, afterend:aeValues}, fullPositionHash = {beforebegin:bbValues, 
  afterend:aeValues, afterbegin:['AfterBegin', 'firstChild'], beforeend:['BeforeEnd', 'lastChild']};
  return {extend:Ext.dom.AbstractHelper, tableRe:/^(?:table|thead|tbody|tr|td)$/i, tableElRe:/td|tr|tbody|thead/i, useDom:false, createDom:function(o, parentNode) {
    var el, doc = document, useSet, attr, val, cn, i, l;
    if (Ext.isArray(o)) {
      el = doc.createDocumentFragment();
      for (i = 0, l = o.length; i < l; i++) {
        this.createDom(o[i], el);
      }
    } else {
      if (typeof o == 'string') {
        el = doc.createTextNode(o);
      } else {
        el = doc.createElement(o.tag || 'div');
        useSet = !!el.setAttribute;
        for (attr in o) {
          if (!this.confRe.test(attr)) {
            val = o[attr];
            if (attr == 'cls') {
              el.className = val;
            } else {
              if (useSet) {
                el.setAttribute(attr, val);
              } else {
                el[attr] = val;
              }
            }
          }
        }
        Ext.DomHelper.applyStyles(el, o.style);
        if (cn = o.children || o.cn) {
          this.createDom(cn, el);
        } else {
          if (o.html) {
            el.innerHTML = o.html;
          }
        }
      }
    }
    if (parentNode) {
      parentNode.appendChild(el);
    }
    return el;
  }, ieTable:function(depth, openingTags, htmlContent, closingTags) {
    detachedDiv.innerHTML = [openingTags, htmlContent, closingTags].join('');
    var i = -1, el = detachedDiv, ns;
    while (++i < depth) {
      el = el.firstChild;
    }
    ns = el.nextSibling;
    if (ns) {
      ns = el;
      el = document.createDocumentFragment();
      while (ns) {
        nx = ns.nextSibling;
        el.appendChild(ns);
        ns = nx;
      }
    }
    return el;
  }, insertIntoTable:function(tag, where, destinationEl, html) {
    var node, before, bb = where == beforebegin, ab = where == afterbegin, be = where == beforeend, ae = where == afterend;
    if (tag == 'td' && (ab || be) || !this.tableElRe.test(tag) && (bb || ae)) {
      return null;
    }
    before = bb ? destinationEl : ae ? destinationEl.nextSibling : ab ? destinationEl.firstChild : null;
    if (bb || ae) {
      destinationEl = destinationEl.parentNode;
    }
    if (tag == 'td' || tag == 'tr' && (be || ab)) {
      node = this.ieTable(4, trs, html, tre);
    } else {
      if ((tag == 'tbody' || tag == 'thead') && (be || ab) || tag == 'tr' && (bb || ae)) {
        node = this.ieTable(3, tbs, html, tbe);
      } else {
        node = this.ieTable(2, ts, html, te);
      }
    }
    destinationEl.insertBefore(node, before);
    return node;
  }, createContextualFragment:function(html) {
    var fragment = document.createDocumentFragment(), length, childNodes;
    detachedDiv.innerHTML = html;
    childNodes = detachedDiv.childNodes;
    length = childNodes.length;
    while (length--) {
      fragment.appendChild(childNodes[0]);
    }
    return fragment;
  }, applyStyles:function(el, styles) {
    if (styles) {
      if (typeof styles == 'function') {
        styles = styles.call();
      }
      if (typeof styles == 'string') {
        styles = Ext.dom.Element.parseStyles(styles);
      }
      if (typeof styles == 'object') {
        Ext.fly(el, '_applyStyles').setStyle(styles);
      }
    }
  }, createHtml:function(spec) {
    return this.markup(spec);
  }, doInsert:function(el, o, returnElement, pos, sibling, append) {
    el = el.dom || Ext.getDom(el);
    var newNode;
    if (this.useDom) {
      newNode = this.createDom(o, null);
      if (append) {
        el.appendChild(newNode);
      } else {
        (sibling == 'firstChild' ? el : el.parentNode).insertBefore(newNode, el[sibling] || el);
      }
    } else {
      newNode = this.insertHtml(pos, el, this.markup(o));
    }
    return returnElement ? Ext.get(newNode, true) : newNode;
  }, overwrite:function(el, html, returnElement) {
    var newNode;
    el = Ext.getDom(el);
    html = this.markup(html);
    if (Ext.isIE && this.tableRe.test(el.tagName)) {
      while (el.firstChild) {
        el.removeChild(el.firstChild);
      }
      if (html) {
        newNode = this.insertHtml('afterbegin', el, html);
        return returnElement ? Ext.get(newNode) : newNode;
      }
      return null;
    }
    el.innerHTML = html;
    return returnElement ? Ext.get(el.firstChild) : el.firstChild;
  }, insertHtml:function(where, el, html) {
    var hashVal, range, rangeEl, setStart, frag;
    where = where.toLowerCase();
    if (el.insertAdjacentHTML) {
      if (Ext.isIE && this.tableRe.test(el.tagName) && (frag = this.insertIntoTable(el.tagName.toLowerCase(), where, el, html))) {
        return frag;
      }
      if (hashVal = fullPositionHash[where]) {
        if (Ext.global.MSApp && Ext.global.MSApp.execUnsafeLocalFunction) {
          MSApp.execUnsafeLocalFunction(function() {
            el.insertAdjacentHTML(hashVal[0], html);
          });
        } else {
          el.insertAdjacentHTML(hashVal[0], html);
        }
        return el[hashVal[1]];
      }
    } else {
      if (el.nodeType === 3) {
        where = where === 'afterbegin' ? 'beforebegin' : where;
        where = where === 'beforeend' ? 'afterend' : where;
      }
      range = Ext.supports.CreateContextualFragment ? el.ownerDocument.createRange() : undefined;
      setStart = 'setStart' + (this.endRe.test(where) ? 'After' : 'Before');
      if (bb_ae_PositionHash[where]) {
        if (range) {
          range[setStart](el);
          frag = range.createContextualFragment(html);
        } else {
          frag = this.createContextualFragment(html);
        }
        el.parentNode.insertBefore(frag, where == beforebegin ? el : el.nextSibling);
        return el[(where == beforebegin ? 'previous' : 'next') + 'Sibling'];
      } else {
        rangeEl = (where == afterbegin ? 'first' : 'last') + 'Child';
        if (el.firstChild) {
          if (range) {
            range[setStart](el[rangeEl]);
            frag = range.createContextualFragment(html);
          } else {
            frag = this.createContextualFragment(html);
          }
          if (where == afterbegin) {
            el.insertBefore(frag, el.firstChild);
          } else {
            el.appendChild(frag);
          }
        } else {
          el.innerHTML = html;
        }
        return el[rangeEl];
      }
    }
    Ext.Error.raise({sourceClass:'Ext.DomHelper', sourceMethod:'insertHtml', htmlToInsert:html, targetElement:el, msg:'Illegal insertion point reached: "' + where + '"'});
  }, createTemplate:function(o) {
    var html = this.markup(o);
    return new Ext.Template(html);
  }};
}(), function() {
  Ext.ns('Ext.core');
  Ext.DomHelper = Ext.core.DomHelper = new this;
});
Ext.define('Ext.Template', {inheritableStatics:{from:function(el, config) {
  el = Ext.getDom(el);
  return new this(el.value || el.innerHTML, config || '');
}}, constructor:function(html) {
  var me = this, args = arguments, buffer = [], i = 0, length = args.length, value;
  me.initialConfig = {};
  if (length === 1 && Ext.isArray(html)) {
    args = html;
    length = args.length;
  }
  if (length > 1) {
    for (; i < length; i++) {
      value = args[i];
      if (typeof value == 'object') {
        Ext.apply(me.initialConfig, value);
        Ext.apply(me, value);
      } else {
        buffer.push(value);
      }
    }
  } else {
    buffer.push(html);
  }
  me.html = buffer.join('');
  if (me.compiled) {
    me.compile();
  }
}, isTemplate:true, disableFormats:false, re:/\{([\w\-]+)(?::([\w\.]*)(?:\((.*?)?\))?)?\}/g, apply:function(values) {
  var me = this, useFormat = me.disableFormats !== true, fm = Ext.util.Format, tpl = me, ret;
  if (me.compiled) {
    return me.compiled(values).join('');
  }
  function fn(m, name, format, args) {
    if (format && useFormat) {
      if (args) {
        args = [values[name]].concat(Ext.functionFactory('return [' + args + '];')());
      } else {
        args = [values[name]];
      }
      if (format.substr(0, 5) == 'this.') {
        return tpl[format.substr(5)].apply(tpl, args);
      } else {
        return fm[format].apply(fm, args);
      }
    } else {
      return values[name] !== undefined ? values[name] : '';
    }
  }
  ret = me.html.replace(me.re, fn);
  return ret;
}, applyOut:function(values, out) {
  var me = this;
  if (me.compiled) {
    out.push.apply(out, me.compiled(values));
  } else {
    out.push(me.apply(values));
  }
  return out;
}, applyTemplate:function() {
  return this.apply.apply(this, arguments);
}, set:function(html, compile) {
  var me = this;
  me.html = html;
  me.compiled = null;
  return compile ? me.compile() : me;
}, compileARe:/\\/g, compileBRe:/(\r\n|\n)/g, compileCRe:/'/g, compile:function() {
  var me = this, fm = Ext.util.Format, useFormat = me.disableFormats !== true, body, bodyReturn;
  function fn(m, name, format, args) {
    if (format && useFormat) {
      args = args ? ',' + args : '';
      if (format.substr(0, 5) != 'this.') {
        format = 'fm.' + format + '(';
      } else {
        format = 'this.' + format.substr(5) + '(';
      }
    } else {
      args = '';
      format = "(values['" + name + "'] \x3d\x3d undefined ? '' : ";
    }
    return "'," + format + "values['" + name + "']" + args + ") ,'";
  }
  bodyReturn = me.html.replace(me.compileARe, '\\\\').replace(me.compileBRe, '\\n').replace(me.compileCRe, "\\'").replace(me.re, fn);
  body = "this.compiled \x3d function(values){ return ['" + bodyReturn + "'];};";
  eval(body);
  return me;
}, insertFirst:function(el, values, returnElement) {
  return this.doInsert('afterBegin', el, values, returnElement);
}, insertBefore:function(el, values, returnElement) {
  return this.doInsert('beforeBegin', el, values, returnElement);
}, insertAfter:function(el, values, returnElement) {
  return this.doInsert('afterEnd', el, values, returnElement);
}, append:function(el, values, returnElement) {
  return this.doInsert('beforeEnd', el, values, returnElement);
}, doInsert:function(where, el, values, returnElement) {
  var newNode = Ext.DomHelper.insertHtml(where, Ext.getDom(el), this.apply(values));
  return returnElement ? Ext.get(newNode) : newNode;
}, overwrite:function(el, values, returnElement) {
  var newNode = Ext.DomHelper.overwrite(Ext.getDom(el), this.apply(values));
  return returnElement ? Ext.get(newNode) : newNode;
}});
Ext.define('Ext.XTemplateParser', {constructor:function(config) {
  Ext.apply(this, config);
}, doTpl:Ext.emptyFn, parse:function(str) {
  var me = this, len = str.length, aliases = {elseif:'elif'}, topRe = me.topRe, actionsRe = me.actionsRe, index, stack, s, m, t, prev, frame, subMatch, begin, end, actions, prop;
  me.level = 0;
  me.stack = stack = [];
  for (index = 0; index < len; index = end) {
    topRe.lastIndex = index;
    m = topRe.exec(str);
    if (!m) {
      me.doText(str.substring(index, len));
      break;
    }
    begin = m.index;
    end = topRe.lastIndex;
    if (index < begin) {
      me.doText(str.substring(index, begin));
    }
    if (m[1]) {
      end = str.indexOf('%}', begin + 2);
      me.doEval(str.substring(begin + 2, end));
      end += 2;
    } else {
      if (m[2]) {
        end = str.indexOf(']}', begin + 2);
        me.doExpr(str.substring(begin + 2, end));
        end += 2;
      } else {
        if (m[3]) {
          me.doTag(m[3]);
        } else {
          if (m[4]) {
            actions = null;
            while ((subMatch = actionsRe.exec(m[4])) !== null) {
              s = subMatch[2] || subMatch[3];
              if (s) {
                s = Ext.String.htmlDecode(s);
                t = subMatch[1];
                t = aliases[t] || t;
                actions = actions || {};
                prev = actions[t];
                if (typeof prev == 'string') {
                  actions[t] = [prev, s];
                } else {
                  if (prev) {
                    actions[t].push(s);
                  } else {
                    actions[t] = s;
                  }
                }
              }
            }
            if (!actions) {
              if (me.elseRe.test(m[4])) {
                me.doElse();
              } else {
                if (me.defaultRe.test(m[4])) {
                  me.doDefault();
                } else {
                  me.doTpl();
                  stack.push({type:'tpl'});
                }
              }
            } else {
              if (actions['if']) {
                me.doIf(actions['if'], actions);
                stack.push({type:'if'});
              } else {
                if (actions['switch']) {
                  me.doSwitch(actions['switch'], actions);
                  stack.push({type:'switch'});
                } else {
                  if (actions['case']) {
                    me.doCase(actions['case'], actions);
                  } else {
                    if (actions['elif']) {
                      me.doElseIf(actions['elif'], actions);
                    } else {
                      if (actions['for']) {
                        ++me.level;
                        if (prop = me.propRe.exec(m[4])) {
                          actions.propName = prop[1] || prop[2];
                        }
                        me.doFor(actions['for'], actions);
                        stack.push({type:'for', actions:actions});
                      } else {
                        if (actions['foreach']) {
                          ++me.level;
                          if (prop = me.propRe.exec(m[4])) {
                            actions.propName = prop[1] || prop[2];
                          }
                          me.doForEach(actions['foreach'], actions);
                          stack.push({type:'foreach', actions:actions});
                        } else {
                          if (actions.exec) {
                            me.doExec(actions.exec, actions);
                            stack.push({type:'exec', actions:actions});
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          } else {
            if (m[0].length === 5) {
              stack.push({type:'tpl'});
            } else {
              frame = stack.pop();
              me.doEnd(frame.type, frame.actions);
              if (frame.type == 'for' || frame.type == 'foreach') {
                --me.level;
              }
            }
          }
        }
      }
    }
  }
}, topRe:/(?:(\{%)|(\{\[)|\{([^{}]+)\})|(?:<tpl([^>]*)>)|(?:<\/tpl>)/g, actionsRe:/\s*(elif|elseif|if|for|foreach|exec|switch|case|eval|between)\s*=\s*(?:(?:"([^"]*)")|(?:'([^']*)'))\s*/g, propRe:/prop=(?:(?:"([^"]*)")|(?:'([^']*)'))/, defaultRe:/^\s*default\s*$/, elseRe:/^\s*else\s*$/});
Ext.define('Ext.XTemplateCompiler', {extend:Ext.XTemplateParser, useEval:Ext.isGecko, useIndex:Ext.isIE8m, useFormat:true, propNameRe:/^[\w\d\$]*$/, compile:function(tpl) {
  var me = this, code = me.generate(tpl);
  return me.useEval ? me.evalTpl(code) : (new Function('Ext', code))(Ext);
}, generate:function(tpl) {
  var me = this, definitions = 'var fm\x3dExt.util.Format,ts\x3dObject.prototype.toString;', code;
  me.maxLevel = 0;
  me.body = ['var c0\x3dvalues, a0\x3d' + me.createArrayTest(0) + ', p0\x3dparent, n0\x3dxcount, i0\x3dxindex, k0, v;\n'];
  if (me.definitions) {
    if (typeof me.definitions === 'string') {
      me.definitions = [me.definitions, definitions];
    } else {
      me.definitions.push(definitions);
    }
  } else {
    me.definitions = [definitions];
  }
  me.switches = [];
  me.parse(tpl);
  me.definitions.push((me.useEval ? '$\x3d' : 'return') + ' function (' + me.fnArgs + ') {', me.body.join(''), '}');
  code = me.definitions.join('\n');
  me.definitions.length = me.body.length = me.switches.length = 0;
  delete me.definitions;
  delete me.body;
  delete me.switches;
  return code;
}, doText:function(text) {
  var me = this, out = me.body;
  text = text.replace(me.aposRe, "\\'").replace(me.newLineRe, '\\n');
  if (me.useIndex) {
    out.push("out[out.length]\x3d'", text, "'\n");
  } else {
    out.push("out.push('", text, "')\n");
  }
}, doExpr:function(expr) {
  var out = this.body;
  out.push('if ((v\x3d' + expr + ') !\x3d null) out');
  if (this.useIndex) {
    out.push("[out.length]\x3dv+''\n");
  } else {
    out.push(".push(v+'')\n");
  }
}, doTag:function(tag) {
  var expr = this.parseTag(tag);
  if (expr) {
    this.doExpr(expr);
  } else {
    this.doText('{' + tag + '}');
  }
}, doElse:function() {
  this.body.push('} else {\n');
}, doEval:function(text) {
  this.body.push(text, '\n');
}, doIf:function(action, actions) {
  var me = this;
  if (action === '.') {
    me.body.push('if (values) {\n');
  } else {
    if (me.propNameRe.test(action)) {
      me.body.push('if (', me.parseTag(action), ') {\n');
    } else {
      me.body.push('if (', me.addFn(action), me.callFn, ') {\n');
    }
  }
  if (actions.exec) {
    me.doExec(actions.exec);
  }
}, doElseIf:function(action, actions) {
  var me = this;
  if (action === '.') {
    me.body.push('else if (values) {\n');
  } else {
    if (me.propNameRe.test(action)) {
      me.body.push('} else if (', me.parseTag(action), ') {\n');
    } else {
      me.body.push('} else if (', me.addFn(action), me.callFn, ') {\n');
    }
  }
  if (actions.exec) {
    me.doExec(actions.exec);
  }
}, doSwitch:function(action) {
  var me = this;
  if (action === '.') {
    me.body.push('switch (values) {\n');
  } else {
    if (me.propNameRe.test(action)) {
      me.body.push('switch (', me.parseTag(action), ') {\n');
    } else {
      me.body.push('switch (', me.addFn(action), me.callFn, ') {\n');
    }
  }
  me.switches.push(0);
}, doCase:function(action) {
  var me = this, cases = Ext.isArray(action) ? action : [action], n = me.switches.length - 1, match, i;
  if (me.switches[n]) {
    me.body.push('break;\n');
  } else {
    me.switches[n]++;
  }
  for (i = 0, n = cases.length; i < n; ++i) {
    match = me.intRe.exec(cases[i]);
    cases[i] = match ? match[1] : "'" + cases[i].replace(me.aposRe, "\\'") + "'";
  }
  me.body.push('case ', cases.join(': case '), ':\n');
}, doDefault:function() {
  var me = this, n = me.switches.length - 1;
  if (me.switches[n]) {
    me.body.push('break;\n');
  } else {
    me.switches[n]++;
  }
  me.body.push('default:\n');
}, doEnd:function(type, actions) {
  var me = this, L = me.level - 1;
  if (type == 'for' || type == 'foreach') {
    if (actions.exec) {
      me.doExec(actions.exec);
    }
    me.body.push('}\n');
    me.body.push('parent\x3dp', L, ';values\x3dr', L + 1, ';xcount\x3dn' + L + ';xindex\x3di', L, '+1;xkey\x3dk', L, ';\n');
  } else {
    if (type == 'if' || type == 'switch') {
      me.body.push('}\n');
    }
  }
}, doFor:function(action, actions) {
  var me = this, s, L = me.level, up = L - 1, parentAssignment;
  if (action === '.') {
    s = 'values';
  } else {
    if (me.propNameRe.test(action)) {
      s = me.parseTag(action);
    } else {
      s = me.addFn(action) + me.callFn;
    }
  }
  if (me.maxLevel < L) {
    me.maxLevel = L;
    me.body.push('var ');
  }
  if (action == '.') {
    parentAssignment = 'c' + L;
  } else {
    parentAssignment = 'a' + up + '?c' + up + '[i' + up + ']:c' + up;
  }
  me.body.push('i', L, '\x3d0,n', L, '\x3d0,c', L, '\x3d', s, ',a', L, '\x3d', me.createArrayTest(L), ',r', L, '\x3dvalues,p', L, ',k', L, ';\n', 'p', L, '\x3dparent\x3d', parentAssignment, '\n', 'if (c', L, '){if(a', L, '){n', L, '\x3dc', L, '.length;}else if (c', L, '.isMixedCollection){c', L, '\x3dc', L, '.items;n', L, '\x3dc', L, '.length;}else if(c', L, '.isStore){c', L, '\x3dc', L, '.data.items;n', L, '\x3dc', L, '.length;}else{c', L, '\x3d[c', L, '];n', L, '\x3d1;}}\n', 'for (xcount\x3dn', 
  L, ';i', L, '\x3cn' + L + ';++i', L, '){\n', 'values\x3dc', L, '[i', L, ']');
  if (actions.propName) {
    me.body.push('.', actions.propName);
  }
  me.body.push('\n', 'xindex\x3di', L, '+1\n');
  if (actions.between) {
    me.body.push('if(xindex\x3e1){ out.push("', actions.between, '"); } \n');
  }
}, doForEach:function(action, actions) {
  var me = this, s, L = me.level, up = L - 1, parentAssignment;
  if (action === '.') {
    s = 'values';
  } else {
    if (me.propNameRe.test(action)) {
      s = me.parseTag(action);
    } else {
      s = me.addFn(action) + me.callFn;
    }
  }
  if (me.maxLevel < L) {
    me.maxLevel = L;
    me.body.push('var ');
  }
  if (action == '.') {
    parentAssignment = 'c' + L;
  } else {
    parentAssignment = 'a' + up + '?c' + up + '[i' + up + ']:c' + up;
  }
  me.body.push('i', L, '\x3d-1,n', L, '\x3d0,c', L, '\x3d', s, ',a', L, '\x3d', me.createArrayTest(L), ',r', L, '\x3dvalues,p', L, ',k', L, ';\n', 'p', L, '\x3dparent\x3d', parentAssignment, '\n', 'for(k', L, ' in c', L, '){\n', 'xindex\x3d++i', L, '+1;\n', 'xkey\x3dk', L, ';\n', 'values\x3dc', L, '[k', L, '];');
  if (actions.propName) {
    me.body.push('.', actions.propName);
  }
  if (actions.between) {
    me.body.push('if(xindex\x3e1){ out.push("', actions.between, '"); } \n');
  }
}, createArrayTest:'isArray' in Array ? function(L) {
  return 'Array.isArray(c' + L + ')';
} : function(L) {
  return 'ts.call(c' + L + ')\x3d\x3d\x3d"[object Array]"';
}, doExec:function(action, actions) {
  var me = this, name = 'f' + me.definitions.length;
  me.definitions.push('function ' + name + '(' + me.fnArgs + ') {', ' try { with(values) {', '  ' + action, ' }} catch(e) {', 'Ext.log("XTemplate Error: " + e.message);', '}', '}');
  me.body.push(name + me.callFn + '\n');
}, addFn:function(body) {
  var me = this, name = 'f' + me.definitions.length;
  if (body === '.') {
    me.definitions.push('function ' + name + '(' + me.fnArgs + ') {', ' return values', '}');
  } else {
    if (body === '..') {
      me.definitions.push('function ' + name + '(' + me.fnArgs + ') {', ' return parent', '}');
    } else {
      me.definitions.push('function ' + name + '(' + me.fnArgs + ') {', ' try { with(values) {', '  return(' + body + ')', ' }} catch(e) {', 'Ext.log("XTemplate Error: " + e.message);', '}', '}');
    }
  }
  return name;
}, parseTag:function(tag) {
  var me = this, m = me.tagRe.exec(tag), name, format, args, math, v;
  if (!m) {
    return null;
  }
  name = m[1];
  format = m[2];
  args = m[3];
  math = m[4];
  if (name == '.') {
    if (!me.validTypes) {
      me.definitions.push('var validTypes\x3d{string:1,number:1,boolean:1};');
      me.validTypes = true;
    }
    v = 'validTypes[typeof values] || ts.call(values) \x3d\x3d\x3d "[object Date]" ? values : ""';
  } else {
    if (name == '#') {
      v = 'xindex';
    } else {
      if (name == '$') {
        v = 'xkey';
      } else {
        if (name.substr(0, 7) == 'parent.') {
          v = name;
        } else {
          if (isNaN(name) && name.indexOf('-') == -1 && name.indexOf('.') != -1) {
            v = 'values.' + name;
          } else {
            v = "values['" + name + "']";
          }
        }
      }
    }
  }
  if (math) {
    v = '(' + v + math + ')';
  }
  if (format && me.useFormat) {
    args = args ? ',' + args : '';
    if (format.substr(0, 5) != 'this.') {
      format = 'fm.' + format + '(';
    } else {
      format += '(';
    }
  } else {
    return v;
  }
  return format + v + args + ')';
}, evalTpl:function($) {
  eval($);
  return $;
}, newLineRe:/\r\n|\r|\n/g, aposRe:/[']/g, intRe:/^\s*(\d+)\s*$/, tagRe:/^([\w-\.#\$]+)(?::([\w\.]*)(?:\((.*?)?\))?)?(\s?[\+\-\*\/]\s?[\d\.\+\-\*\/\(\)]+)?$/}, function() {
  var proto = this.prototype;
  proto.fnArgs = 'out,values,parent,xindex,xcount,xkey';
  proto.callFn = '.call(this,' + proto.fnArgs + ')';
});
Ext.define('Ext.XTemplate', {extend:Ext.Template, emptyObj:{}, apply:function(values, parent) {
  return this.applyOut(values, [], parent).join('');
}, applyOut:function(values, out, parent) {
  var me = this, compiler;
  if (!me.fn) {
    compiler = new Ext.XTemplateCompiler({useFormat:me.disableFormats !== true, definitions:me.definitions});
    me.fn = compiler.compile(me.html);
  }
  try {
    me.fn(out, values, parent || me.emptyObj, 1, 1);
  } catch (e$12) {
    Ext.log('Error: ' + e$12.message);
  }
  return out;
}, compile:function() {
  return this;
}, statics:{getTpl:function(instance, name) {
  var tpl = instance[name], owner;
  if (tpl && !tpl.isTemplate) {
    tpl = Ext.ClassManager.dynInstantiate('Ext.XTemplate', tpl);
    if (instance.hasOwnProperty(name)) {
      owner = instance;
    } else {
      for (owner = instance.self.prototype; owner && !owner.hasOwnProperty(name); owner = owner.superclass) {
      }
    }
    owner[name] = tpl;
    tpl.owner = owner;
  }
  return tpl || null;
}}});
Ext.ns('Ext.core');
Ext.dom.Query = Ext.core.DomQuery = Ext.DomQuery = function() {
  var DQ, doc = document, cache = {}, simpleCache = {}, valueCache = {}, useClassList = !!doc.documentElement.classList, useElementPointer = !!doc.documentElement.firstElementChild, useChildrenCollection = function() {
    var d = doc.createElement('div');
    d.innerHTML = '\x3c!-- --\x3etext\x3c!-- --\x3e';
    return d.children && d.children.length === 0;
  }(), nonSpace = /\S/, trimRe = /^\s+|\s+$/g, tplRe = /\{(\d+)\}/g, modeRe = /^(\s?[\/>+~]\s?|\s|$)/, tagTokenRe = /^(#)?([\w\-\*\|\\]+)/, nthRe = /(\d*)n\+?(\d*)/, nthRe2 = /\D/, startIdRe = /^\s*#/, isIE = window.ActiveXObject ? true : false, key = 30803, longHex = /\\([0-9a-fA-F]{6})/g, shortHex = /\\([0-9a-fA-F]{1,6})\s{0,1}/g, nonHex = /\\([^0-9a-fA-F]{1})/g, escapes = /\\/g, num, hasEscapes, supportsColonNsSeparator = function() {
    var xmlDoc, xmlString = '\x3cr\x3e\x3ca:b xmlns:a\x3d"n"\x3e\x3c/a:b\x3e\x3c/r\x3e';
    if (window.DOMParser) {
      xmlDoc = (new DOMParser).parseFromString(xmlString, 'application/xml');
    } else {
      xmlDoc = new ActiveXObject('Microsoft.XMLDOM');
      xmlDoc.loadXML(xmlString);
    }
    return !!xmlDoc.getElementsByTagName('a:b').length;
  }(), longHexToChar = function($0, $1) {
    return String.fromCharCode(parseInt($1, 16));
  }, shortToLongHex = function($0, $1) {
    while ($1.length < 6) {
      $1 = '0' + $1;
    }
    return '\\' + $1;
  }, charToLongHex = function($0, $1) {
    num = $1.charCodeAt(0).toString(16);
    if (num.length === 1) {
      num = '0' + num;
    }
    return '\\0000' + num;
  }, unescapeCssSelector = function(selector) {
    return hasEscapes ? selector.replace(longHex, longHexToChar) : selector;
  }, setupEscapes = function(path) {
    hasEscapes = path.indexOf('\\') > -1;
    if (hasEscapes) {
      path = path.replace(shortHex, shortToLongHex).replace(nonHex, charToLongHex).replace(escapes, '\\\\');
    }
    return path;
  };
  eval('var batch \x3d 30803, child, next, prev, byClassName;');
  child = useChildrenCollection ? function child(parent, index) {
    return parent.children[index];
  } : function child(parent, index) {
    var i = 0, n = parent.firstChild;
    while (n) {
      if (n.nodeType == 1) {
        if (++i == index) {
          return n;
        }
      }
      n = n.nextSibling;
    }
    return null;
  };
  next = useElementPointer ? function(n) {
    return n.nextElementSibling;
  } : function(n) {
    while ((n = n.nextSibling) && n.nodeType != 1) {
    }
    return n;
  };
  prev = useElementPointer ? function(n) {
    return n.previousElementSibling;
  } : function(n) {
    while ((n = n.previousSibling) && n.nodeType != 1) {
    }
    return n;
  };
  function children(parent) {
    var n = parent.firstChild, nodeIndex = -1, nextNode;
    while (n) {
      nextNode = n.nextSibling;
      if (n.nodeType == 3 && !nonSpace.test(n.nodeValue)) {
        parent.removeChild(n);
      } else {
        n.nodeIndex = ++nodeIndex;
      }
      n = nextNode;
    }
    return this;
  }
  byClassName = useClassList ? function(nodeSet, cls) {
    cls = unescapeCssSelector(cls);
    if (!cls) {
      return nodeSet;
    }
    var result = [], ri = -1, i, ci, classList;
    for (i = 0; ci = nodeSet[i]; i++) {
      classList = ci.classList;
      if (classList) {
        if (classList.contains(cls)) {
          result[++ri] = ci;
        }
      } else {
        if ((' ' + ci.className + ' ').indexOf(cls) !== -1) {
          result[++ri] = ci;
        }
      }
    }
    return result;
  } : function(nodeSet, cls) {
    cls = unescapeCssSelector(cls);
    if (!cls) {
      return nodeSet;
    }
    var result = [], ri = -1, i, ci;
    for (i = 0; ci = nodeSet[i]; i++) {
      if ((' ' + ci.className + ' ').indexOf(cls) !== -1) {
        result[++ri] = ci;
      }
    }
    return result;
  };
  function attrValue(n, attr) {
    if (!n.tagName && typeof n.length != 'undefined') {
      n = n[0];
    }
    if (!n) {
      return null;
    }
    if (attr == 'for') {
      return n.htmlFor;
    }
    if (attr == 'class' || attr == 'className') {
      return n.className;
    }
    return n.getAttribute(attr) || n[attr];
  }
  function getNodes(ns, mode, tagName) {
    var result = [], ri = -1, cs, i, ni, j, ci, cn, utag, n, cj;
    if (!ns) {
      return result;
    }
    tagName = tagName.replace('|', ':') || '*';
    if (typeof ns.getElementsByTagName != 'undefined') {
      ns = [ns];
    }
    if (!mode) {
      tagName = unescapeCssSelector(tagName);
      if (!supportsColonNsSeparator && DQ.isXml(ns[0]) && tagName.indexOf(':') !== -1) {
        for (i = 0; ni = ns[i]; i++) {
          cs = ni.getElementsByTagName(tagName.split(':').pop());
          for (j = 0; ci = cs[j]; j++) {
            if (ci.tagName === tagName) {
              result[++ri] = ci;
            }
          }
        }
      } else {
        for (i = 0; ni = ns[i]; i++) {
          cs = ni.getElementsByTagName(tagName);
          for (j = 0; ci = cs[j]; j++) {
            result[++ri] = ci;
          }
        }
      }
    } else {
      if (mode == '/' || mode == '\x3e') {
        utag = tagName.toUpperCase();
        for (i = 0; ni = ns[i]; i++) {
          cn = ni.childNodes;
          for (j = 0; cj = cn[j]; j++) {
            if (cj.nodeName == utag || cj.nodeName == tagName || tagName == '*') {
              result[++ri] = cj;
            }
          }
        }
      } else {
        if (mode == '+') {
          utag = tagName.toUpperCase();
          for (i = 0; n = ns[i]; i++) {
            while ((n = n.nextSibling) && n.nodeType != 1) {
            }
            if (n && (n.nodeName == utag || n.nodeName == tagName || tagName == '*')) {
              result[++ri] = n;
            }
          }
        } else {
          if (mode == '~') {
            utag = tagName.toUpperCase();
            for (i = 0; n = ns[i]; i++) {
              while (n = n.nextSibling) {
                if (n.nodeName == utag || n.nodeName == tagName || tagName == '*') {
                  result[++ri] = n;
                }
              }
            }
          }
        }
      }
    }
    return result;
  }
  function concat(a, b) {
    a.push.apply(a, b);
    return a;
  }
  function byTag(cs, tagName) {
    if (cs.tagName || cs === doc) {
      cs = [cs];
    }
    if (!tagName) {
      return cs;
    }
    var result = [], ri = -1, i, ci;
    tagName = tagName.toLowerCase();
    for (i = 0; ci = cs[i]; i++) {
      if (ci.nodeType == 1 && ci.tagName.toLowerCase() == tagName) {
        result[++ri] = ci;
      }
    }
    return result;
  }
  function byId(cs, id) {
    id = unescapeCssSelector(id);
    if (cs.tagName || cs === doc) {
      cs = [cs];
    }
    if (!id) {
      return cs;
    }
    var result = [], ri = -1, i, ci;
    for (i = 0; ci = cs[i]; i++) {
      if (ci && ci.id == id) {
        result[++ri] = ci;
        return result;
      }
    }
    return result;
  }
  function byAttribute(cs, attr, value, op, custom) {
    var result = [], ri = -1, useGetStyle = custom == '{', fn = DQ.operators[op], a, xml, hasXml, i, ci;
    value = unescapeCssSelector(value);
    for (i = 0; ci = cs[i]; i++) {
      if (ci.nodeType === 1) {
        if (!hasXml) {
          xml = DQ.isXml(ci);
          hasXml = true;
        }
        if (!xml) {
          if (useGetStyle) {
            a = DQ.getStyle(ci, attr);
          } else {
            if (attr == 'class' || attr == 'className') {
              a = ci.className;
            } else {
              if (attr == 'for') {
                a = ci.htmlFor;
              } else {
                if (attr == 'href') {
                  a = ci.getAttribute('href', 2);
                } else {
                  a = ci.getAttribute(attr);
                }
              }
            }
          }
        } else {
          a = ci.getAttribute(attr);
        }
        if (fn && fn(a, value) || !fn && a) {
          result[++ri] = ci;
        }
      }
    }
    return result;
  }
  function byPseudo(cs, name, value) {
    value = unescapeCssSelector(value);
    return DQ.pseudos[name](cs, value);
  }
  function nodupIEXml(cs) {
    var d = ++key, r, i, len, c;
    cs[0].setAttribute('_nodup', d);
    r = [cs[0]];
    for (i = 1, len = cs.length; i < len; i++) {
      c = cs[i];
      if (!c.getAttribute('_nodup') != d) {
        c.setAttribute('_nodup', d);
        r[r.length] = c;
      }
    }
    for (i = 0, len = cs.length; i < len; i++) {
      cs[i].removeAttribute('_nodup');
    }
    return r;
  }
  function nodup(cs) {
    if (!cs) {
      return [];
    }
    var len = cs.length, c, i, r = cs, cj, ri = -1, d, j;
    if (!len || typeof cs.nodeType != 'undefined' || len == 1) {
      return cs;
    }
    if (isIE && typeof cs[0].selectSingleNode != 'undefined') {
      return nodupIEXml(cs);
    }
    d = ++key;
    cs[0]._nodup = d;
    for (i = 1; c = cs[i]; i++) {
      if (c._nodup != d) {
        c._nodup = d;
      } else {
        r = [];
        for (j = 0; j < i; j++) {
          r[++ri] = cs[j];
        }
        for (j = i + 1; cj = cs[j]; j++) {
          if (cj._nodup != d) {
            cj._nodup = d;
            r[++ri] = cj;
          }
        }
        return r;
      }
    }
    return r;
  }
  function quickDiffIEXml(c1, c2) {
    var d = ++key, r = [], i, len;
    for (i = 0, len = c1.length; i < len; i++) {
      c1[i].setAttribute('_qdiff', d);
    }
    for (i = 0, len = c2.length; i < len; i++) {
      if (c2[i].getAttribute('_qdiff') != d) {
        r[r.length] = c2[i];
      }
    }
    for (i = 0, len = c1.length; i < len; i++) {
      c1[i].removeAttribute('_qdiff');
    }
    return r;
  }
  function quickDiff(c1, c2) {
    var len1 = c1.length, d = ++key, r = [], i, len;
    if (!len1) {
      return c2;
    }
    if (isIE && typeof c1[0].selectSingleNode != 'undefined') {
      return quickDiffIEXml(c1, c2);
    }
    for (i = 0; i < len1; i++) {
      c1[i]._qdiff = d;
    }
    for (i = 0, len = c2.length; i < len; i++) {
      if (c2[i]._qdiff != d) {
        r[r.length] = c2[i];
      }
    }
    return r;
  }
  function quickId(ns, mode, root, id) {
    if (ns == root) {
      id = unescapeCssSelector(id);
      var d = root.ownerDocument || root;
      return d.getElementById(id);
    }
    ns = getNodes(ns, mode, '*');
    return byId(ns, id);
  }
  return DQ = {getStyle:function(el, name) {
    return Ext.fly(el, '_DomQuery').getStyle(name);
  }, compile:function(path, type) {
    type = type || 'select';
    var fn = ['var f \x3d function(root) {\n var mode; ++batch; var n \x3d root || document;\n'], lastPath, matchers = DQ.matchers, matchersLn = matchers.length, modeMatch, lmode = path.match(modeRe), tokenMatch, matched, j, t, m;
    path = setupEscapes(path);
    if (lmode && lmode[1]) {
      fn[fn.length] = 'mode\x3d"' + lmode[1].replace(trimRe, '') + '";';
      path = path.replace(lmode[1], '');
    }
    while (path.substr(0, 1) == '/') {
      path = path.substr(1);
    }
    while (path && lastPath != path) {
      lastPath = path;
      tokenMatch = path.match(tagTokenRe);
      if (type == 'select') {
        if (tokenMatch) {
          if (tokenMatch[1] == '#') {
            fn[fn.length] = 'n \x3d quickId(n, mode, root, "' + tokenMatch[2] + '");';
          } else {
            fn[fn.length] = 'n \x3d getNodes(n, mode, "' + tokenMatch[2] + '");';
          }
          path = path.replace(tokenMatch[0], '');
        } else {
          if (path.substr(0, 1) != '@') {
            fn[fn.length] = 'n \x3d getNodes(n, mode, "*");';
          }
        }
      } else {
        if (tokenMatch) {
          if (tokenMatch[1] == '#') {
            fn[fn.length] = 'n \x3d byId(n, "' + tokenMatch[2] + '");';
          } else {
            fn[fn.length] = 'n \x3d byTag(n, "' + tokenMatch[2] + '");';
          }
          path = path.replace(tokenMatch[0], '');
        }
      }
      while (!(modeMatch = path.match(modeRe))) {
        matched = false;
        for (j = 0; j < matchersLn; j++) {
          t = matchers[j];
          m = path.match(t.re);
          if (m) {
            fn[fn.length] = t.select.replace(tplRe, function(x, i) {
              return m[i];
            });
            path = path.replace(m[0], '');
            matched = true;
            break;
          }
        }
        if (!matched) {
          Ext.Error.raise({sourceClass:'Ext.DomQuery', sourceMethod:'compile', msg:'Error parsing selector. Parsing failed at "' + path + '"'});
        }
      }
      if (modeMatch[1]) {
        fn[fn.length] = 'mode\x3d"' + modeMatch[1].replace(trimRe, '') + '";';
        path = path.replace(modeMatch[1], '');
      }
    }
    fn[fn.length] = 'return nodup(n);\n}';
    eval(fn.join(''));
    return f;
  }, jsSelect:function(path, root, type) {
    root = root || doc;
    if (typeof root == 'string') {
      root = doc.getElementById(root);
    }
    var paths = path.split(','), results = [], i, len, subPath, result;
    for (i = 0, len = paths.length; i < len; i++) {
      subPath = paths[i].replace(trimRe, '');
      if (!cache[subPath]) {
        cache[subPath] = DQ.compile(subPath, type);
        if (!cache[subPath]) {
          Ext.Error.raise({sourceClass:'Ext.DomQuery', sourceMethod:'jsSelect', msg:subPath + ' is not a valid selector'});
        }
      } else {
        setupEscapes(subPath);
      }
      result = cache[subPath](root);
      if (result && result !== doc) {
        results = results.concat(result);
      }
    }
    if (paths.length > 1) {
      return nodup(results);
    }
    return results;
  }, isXml:function(el) {
    var docEl = (el ? el.ownerDocument || el : 0).documentElement;
    return docEl ? docEl.nodeName !== 'HTML' : false;
  }, select:doc.querySelectorAll ? function(path, root, type, single) {
    root = root || doc;
    if (!DQ.isXml(root)) {
      try {
        if (root.parentNode && root.nodeType !== 9 && path.indexOf(',') === -1 && !startIdRe.test(path)) {
          path = '#' + Ext.escapeId(Ext.id(root)) + ' ' + path;
          root = root.parentNode;
        }
        return single ? [root.querySelector(path)] : Ext.Array.toArray(root.querySelectorAll(path));
      } catch (e$13) {
      }
    }
    return DQ.jsSelect.call(this, path, root, type);
  } : function(path, root, type) {
    return DQ.jsSelect.call(this, path, root, type);
  }, selectNode:function(path, root) {
    return Ext.DomQuery.select(path, root, null, true)[0];
  }, selectValue:function(path, root, defaultValue) {
    path = path.replace(trimRe, '');
    if (!valueCache[path]) {
      valueCache[path] = DQ.compile(path, 'select');
    } else {
      setupEscapes(path);
    }
    var n = valueCache[path](root), v;
    n = n[0] ? n[0] : n;
    if (typeof n.normalize == 'function') {
      n.normalize();
    }
    v = n && n.firstChild ? n.firstChild.nodeValue : null;
    return v === null || v === undefined || v === '' ? defaultValue : v;
  }, selectNumber:function(path, root, defaultValue) {
    var v = DQ.selectValue(path, root, defaultValue || 0);
    return parseFloat(v);
  }, is:function(el, ss) {
    if (typeof el == 'string') {
      el = doc.getElementById(el);
    }
    var isArray = Ext.isArray(el), result = DQ.filter(isArray ? el : [el], ss);
    return isArray ? result.length == el.length : result.length > 0;
  }, filter:function(els, ss, nonMatches) {
    ss = ss.replace(trimRe, '');
    if (!simpleCache[ss]) {
      simpleCache[ss] = DQ.compile(ss, 'simple');
    } else {
      setupEscapes(ss);
    }
    var result = simpleCache[ss](els);
    return nonMatches ? quickDiff(result, els) : result;
  }, matchers:[{re:/^\.([\w\-\\]+)/, select:useClassList ? 'n \x3d byClassName(n, "{1}");' : 'n \x3d byClassName(n, " {1} ");'}, {re:/^:([\w\-]+)(?:\(((?:[^\s>\/]*|.*?))\))?/, select:'n \x3d byPseudo(n, "{1}", "{2}");'}, {re:/^(?:([\[\{])(?:@)?([\w\-]+)\s?(?:(=|.=)\s?['"]?(.*?)["']?)?[\]\}])/, select:'n \x3d byAttribute(n, "{2}", "{4}", "{3}", "{1}");'}, {re:/^#([\w\-\\]+)/, select:'n \x3d byId(n, "{1}");'}, {re:/^@([\w\-\.]+)/, select:'return {firstChild:{nodeValue:attrValue(n, "{1}")}};'}], operators:{'\x3d':function(a, 
  v) {
    return a == v;
  }, '!\x3d':function(a, v) {
    return a != v;
  }, '^\x3d':function(a, v) {
    return a && a.substr(0, v.length) == v;
  }, '$\x3d':function(a, v) {
    return a && a.substr(a.length - v.length) == v;
  }, '*\x3d':function(a, v) {
    return a && a.indexOf(v) !== -1;
  }, '%\x3d':function(a, v) {
    return a % v === 0;
  }, '|\x3d':function(a, v) {
    return a && (a == v || a.substr(0, v.length + 1) == v + '-');
  }, '~\x3d':function(a, v) {
    return a && (' ' + a + ' ').indexOf(' ' + v + ' ') != -1;
  }}, pseudos:{'first-child':function(c) {
    var r = [], ri = -1, n, i, ci;
    for (i = 0; ci = n = c[i]; i++) {
      while ((n = n.previousSibling) && n.nodeType != 1) {
      }
      if (!n) {
        r[++ri] = ci;
      }
    }
    return r;
  }, 'last-child':function(c) {
    var r = [], ri = -1, n, i, ci;
    for (i = 0; ci = n = c[i]; i++) {
      while ((n = n.nextSibling) && n.nodeType != 1) {
      }
      if (!n) {
        r[++ri] = ci;
      }
    }
    return r;
  }, 'nth-child':function(c, a) {
    var r = [], ri = -1, m = nthRe.exec(a == 'even' && '2n' || a == 'odd' && '2n+1' || !nthRe2.test(a) && 'n+' + a || a), f = (m[1] || 1) - 0, l = m[2] - 0, i, n, j, cn, pn;
    for (i = 0; n = c[i]; i++) {
      pn = n.parentNode;
      if (batch != pn._batch) {
        j = 0;
        for (cn = pn.firstChild; cn; cn = cn.nextSibling) {
          if (cn.nodeType == 1) {
            cn.nodeIndex = ++j;
          }
        }
        pn._batch = batch;
      }
      if (f == 1) {
        if (l === 0 || n.nodeIndex == l) {
          r[++ri] = n;
        }
      } else {
        if ((n.nodeIndex + l) % f === 0) {
          r[++ri] = n;
        }
      }
    }
    return r;
  }, 'only-child':function(c) {
    var r = [], ri = -1, i, ci;
    for (i = 0; ci = c[i]; i++) {
      if (!prev(ci) && !next(ci)) {
        r[++ri] = ci;
      }
    }
    return r;
  }, 'empty':function(c) {
    var r = [], ri = -1, i, ci, cns, j, cn, empty;
    for (i = 0; ci = c[i]; i++) {
      cns = ci.childNodes;
      j = 0;
      empty = true;
      while (cn = cns[j]) {
        ++j;
        if (cn.nodeType == 1 || cn.nodeType == 3) {
          empty = false;
          break;
        }
      }
      if (empty) {
        r[++ri] = ci;
      }
    }
    return r;
  }, 'contains':function(c, v) {
    var r = [], ri = -1, i, ci;
    for (i = 0; ci = c[i]; i++) {
      if ((ci.textContent || ci.innerText || ci.text || '').indexOf(v) != -1) {
        r[++ri] = ci;
      }
    }
    return r;
  }, 'nodeValue':function(c, v) {
    var r = [], ri = -1, i, ci;
    for (i = 0; ci = c[i]; i++) {
      if (ci.firstChild && ci.firstChild.nodeValue == v) {
        r[++ri] = ci;
      }
    }
    return r;
  }, 'checked':function(c) {
    var r = [], ri = -1, i, ci;
    for (i = 0; ci = c[i]; i++) {
      if (ci.checked === true) {
        r[++ri] = ci;
      }
    }
    return r;
  }, 'not':function(c, ss) {
    return DQ.filter(c, ss, true);
  }, 'any':function(c, selectors) {
    var ss = selectors.split('|'), r = [], ri = -1, s, i, ci, j;
    for (i = 0; ci = c[i]; i++) {
      for (j = 0; s = ss[j]; j++) {
        if (DQ.is(ci, s)) {
          r[++ri] = ci;
          break;
        }
      }
    }
    return r;
  }, 'odd':function(c) {
    return this['nth-child'](c, 'odd');
  }, 'even':function(c) {
    return this['nth-child'](c, 'even');
  }, 'nth':function(c, a) {
    return c[a - 1] || [];
  }, 'first':function(c) {
    return c[0] || [];
  }, 'last':function(c) {
    return c[c.length - 1] || [];
  }, 'has':function(c, ss) {
    var s = DQ.select, r = [], ri = -1, i, ci;
    for (i = 0; ci = c[i]; i++) {
      if (s(ss, ci).length > 0) {
        r[++ri] = ci;
      }
    }
    return r;
  }, 'next':function(c, ss) {
    var is = DQ.is, r = [], ri = -1, i, ci, n;
    for (i = 0; ci = c[i]; i++) {
      n = next(ci);
      if (n && is(n, ss)) {
        r[++ri] = ci;
      }
    }
    return r;
  }, 'prev':function(c, ss) {
    var is = DQ.is, r = [], ri = -1, i, ci, n;
    for (i = 0; ci = c[i]; i++) {
      n = prev(ci);
      if (n && is(n, ss)) {
        r[++ri] = ci;
      }
    }
    return r;
  }, focusable:function(candidates) {
    var len = candidates.length, results = [], i = 0, c;
    for (; i < len; i++) {
      c = candidates[i];
      if (Ext.fly(c, '_DomQuery').isFocusable()) {
        results.push(c);
      }
    }
    return results;
  }, visible:function(candidates, deep) {
    var len = candidates.length, results = [], i = 0, c;
    for (; i < len; i++) {
      c = candidates[i];
      if (Ext.fly(c, '_DomQuery').isVisible(deep)) {
        results.push(c);
      }
    }
    return results;
  }}};
}();
Ext.query = Ext.DomQuery.select;
Ext.define('Ext.dom.Element_anim', {override:'Ext.dom.Element', animate:function(config) {
  var me = this, listeners, anim, animId = me.dom.id || Ext.id(me.dom);
  if (!Ext.fx.Manager.hasFxBlock(animId)) {
    if (config.listeners) {
      listeners = config.listeners;
      delete config.listeners;
    }
    if (config.internalListeners) {
      config.listeners = config.internalListeners;
      delete config.internalListeners;
    }
    anim = new Ext.fx.Anim(me.anim(config));
    if (listeners) {
      anim.on(listeners);
    }
    Ext.fx.Manager.queueFx(anim);
  }
  return me;
}, anim:function(config) {
  if (!Ext.isObject(config)) {
    return config ? {} : false;
  }
  var me = this, duration = config.duration || Ext.fx.Anim.prototype.duration, easing = config.easing || 'ease', animConfig;
  if (config.stopAnimation) {
    me.stopAnimation();
  }
  Ext.applyIf(config, Ext.fx.Manager.getFxDefaults(me.id));
  Ext.fx.Manager.setFxDefaults(me.id, {delay:0});
  animConfig = {target:me.dom, remove:config.remove, alternate:config.alternate || false, duration:duration, easing:easing, callback:config.callback, listeners:config.listeners, iterations:config.iterations || 1, scope:config.scope, block:config.block, concurrent:config.concurrent, delay:config.delay || 0, paused:true, keyframes:config.keyframes, from:config.from || {}, to:Ext.apply({}, config)};
  Ext.apply(animConfig.to, config.to);
  delete animConfig.to.to;
  delete animConfig.to.from;
  delete animConfig.to.remove;
  delete animConfig.to.alternate;
  delete animConfig.to.keyframes;
  delete animConfig.to.iterations;
  delete animConfig.to.listeners;
  delete animConfig.to.target;
  delete animConfig.to.paused;
  delete animConfig.to.callback;
  delete animConfig.to.scope;
  delete animConfig.to.duration;
  delete animConfig.to.easing;
  delete animConfig.to.concurrent;
  delete animConfig.to.block;
  delete animConfig.to.stopAnimation;
  delete animConfig.to.delay;
  return animConfig;
}, slideIn:function(anchor, obj, slideOut) {
  var me = this, dom = me.dom, elStyle = dom.style, beforeAnim, wrapAnim, restoreScroll, wrapDomParentNode;
  anchor = anchor || 't';
  obj = obj || {};
  beforeAnim = function() {
    var animScope = this, listeners = obj.listeners, el = Ext.fly(dom, '_anim'), box, originalStyles, anim, wrap;
    if (!slideOut) {
      el.fixDisplay();
    }
    box = el.getBox();
    if ((anchor == 't' || anchor == 'b') && box.height === 0) {
      box.height = dom.scrollHeight;
    } else {
      if ((anchor == 'l' || anchor == 'r') && box.width === 0) {
        box.width = dom.scrollWidth;
      }
    }
    originalStyles = el.getStyles('width', 'height', 'left', 'right', 'top', 'bottom', 'position', 'z-index', true);
    el.setSize(box.width, box.height);
    if (obj.preserveScroll) {
      restoreScroll = el.cacheScrollValues();
    }
    wrap = el.wrap({id:Ext.id() + '-anim-wrap-for-' + el.dom.id, style:{visibility:slideOut ? 'visible' : 'hidden'}});
    wrapDomParentNode = wrap.dom.parentNode;
    wrap.setPositioning(el.getPositioning(true));
    if (wrap.isStyle('position', 'static')) {
      wrap.position('relative');
    }
    el.clearPositioning('auto');
    wrap.clip();
    if (restoreScroll) {
      restoreScroll();
    }
    el.setStyle({visibility:'', position:'absolute'});
    if (slideOut) {
      wrap.setSize(box.width, box.height);
    }
    switch(anchor) {
      case 't':
        anim = {from:{width:box.width + 'px', height:'0px'}, to:{width:box.width + 'px', height:box.height + 'px'}};
        elStyle.bottom = '0px';
        break;
      case 'l':
        anim = {from:{width:'0px', height:box.height + 'px'}, to:{width:box.width + 'px', height:box.height + 'px'}};
        me.anchorAnimX(anchor);
        break;
      case 'r':
        anim = {from:{x:box.x + box.width, width:'0px', height:box.height + 'px'}, to:{x:box.x, width:box.width + 'px', height:box.height + 'px'}};
        me.anchorAnimX(anchor);
        break;
      case 'b':
        anim = {from:{y:box.y + box.height, width:box.width + 'px', height:'0px'}, to:{y:box.y, width:box.width + 'px', height:box.height + 'px'}};
        break;
      case 'tl':
        anim = {from:{x:box.x, y:box.y, width:'0px', height:'0px'}, to:{width:box.width + 'px', height:box.height + 'px'}};
        elStyle.bottom = '0px';
        me.anchorAnimX('l');
        break;
      case 'bl':
        anim = {from:{y:box.y + box.height, width:'0px', height:'0px'}, to:{y:box.y, width:box.width + 'px', height:box.height + 'px'}};
        me.anchorAnimX('l');
        break;
      case 'br':
        anim = {from:{x:box.x + box.width, y:box.y + box.height, width:'0px', height:'0px'}, to:{x:box.x, y:box.y, width:box.width + 'px', height:box.height + 'px'}};
        me.anchorAnimX('r');
        break;
      case 'tr':
        anim = {from:{x:box.x + box.width, width:'0px', height:'0px'}, to:{x:box.x, width:box.width + 'px', height:box.height + 'px'}};
        elStyle.bottom = '0px';
        me.anchorAnimX('r');
        break;
    }
    wrap.show();
    wrapAnim = Ext.apply({}, obj);
    delete wrapAnim.listeners;
    wrapAnim = new Ext.fx.Anim(Ext.applyIf(wrapAnim, {target:wrap, duration:500, easing:'ease-out', from:slideOut ? anim.to : anim.from, to:slideOut ? anim.from : anim.to}));
    wrapAnim.on('afteranimate', function() {
      var el = Ext.fly(dom, '_anim');
      el.setStyle(originalStyles);
      if (slideOut) {
        if (obj.useDisplay) {
          el.setDisplayed(false);
        } else {
          el.hide();
        }
      }
      if (wrap.dom) {
        if (wrap.dom.parentNode) {
          wrap.dom.parentNode.insertBefore(el.dom, wrap.dom);
        } else {
          wrapDomParentNode.appendChild(el.dom);
        }
        wrap.remove();
      }
      if (restoreScroll) {
        restoreScroll();
      }
      animScope.end();
    });
    if (listeners) {
      wrapAnim.on(listeners);
    }
  };
  me.animate({duration:obj.duration ? Math.max(obj.duration, 500) * 2 : 1000, listeners:{beforeanimate:beforeAnim}});
  return me;
}, slideOut:function(anchor, o) {
  return this.slideIn(anchor, o, true);
}, puff:function(obj) {
  var me = this, dom = me.dom, beforeAnim, box = me.getBox(), originalStyles = me.getStyles('width', 'height', 'left', 'right', 'top', 'bottom', 'position', 'z-index', 'font-size', 'opacity', true);
  obj = Ext.applyIf(obj || {}, {easing:'ease-out', duration:500, useDisplay:false});
  beforeAnim = function() {
    var el = Ext.fly(dom, '_anim');
    el.clearOpacity();
    el.show();
    this.to = {width:box.width * 2, height:box.height * 2, x:box.x - box.width / 2, y:box.y - box.height / 2, opacity:0, fontSize:'200%'};
    this.on('afteranimate', function() {
      var el = Ext.fly(dom, '_anim');
      if (el) {
        if (obj.useDisplay) {
          el.setDisplayed(false);
        } else {
          el.hide();
        }
        el.setStyle(originalStyles);
        Ext.callback(obj.callback, obj.scope);
      }
    });
  };
  me.animate({duration:obj.duration, easing:obj.easing, listeners:{beforeanimate:{fn:beforeAnim}}});
  return me;
}, switchOff:function(obj) {
  var me = this, dom = me.dom, beforeAnim;
  obj = Ext.applyIf(obj || {}, {easing:'ease-in', duration:500, remove:false, useDisplay:false});
  beforeAnim = function() {
    var el = Ext.fly(dom, '_anim'), animScope = this, size = el.getSize(), xy = el.getXY(), keyframe, position;
    el.clearOpacity();
    el.clip();
    position = el.getPositioning();
    keyframe = new Ext.fx.Animator({target:dom, duration:obj.duration, easing:obj.easing, keyframes:{33:{opacity:0.3}, 66:{height:1, y:xy[1] + size.height / 2}, 100:{width:1, x:xy[0] + size.width / 2}}});
    keyframe.on('afteranimate', function() {
      var el = Ext.fly(dom, '_anim');
      if (obj.useDisplay) {
        el.setDisplayed(false);
      } else {
        el.hide();
      }
      el.clearOpacity();
      el.setPositioning(position);
      el.setSize(size);
      animScope.end();
    });
  };
  me.animate({duration:Math.max(obj.duration, 500) * 2, listeners:{beforeanimate:{fn:beforeAnim}}, callback:obj.callback, scope:obj.scope});
  return me;
}, frame:function(color, count, obj) {
  var me = this, dom = me.dom, beforeAnim;
  color = color || '#C3DAF9';
  count = count || 1;
  obj = obj || {};
  beforeAnim = function() {
    var el = Ext.fly(dom, '_anim'), animScope = this, box, proxy, proxyAnim;
    el.show();
    box = el.getBox();
    proxy = Ext.getBody().createChild({id:el.dom.id + '-anim-proxy', style:{position:'absolute', 'pointer-events':'none', 'z-index':35000, border:'0px solid ' + color}});
    proxyAnim = new Ext.fx.Anim({target:proxy, duration:obj.duration || 1000, iterations:count, from:{top:box.y, left:box.x, borderWidth:0, opacity:1, height:box.height, width:box.width}, to:{top:box.y - 20, left:box.x - 20, borderWidth:10, opacity:0, height:box.height + 40, width:box.width + 40}});
    proxyAnim.on('afteranimate', function() {
      proxy.remove();
      animScope.end();
    });
  };
  me.animate({duration:Math.max(obj.duration, 500) * 2 || 2000, listeners:{beforeanimate:{fn:beforeAnim}}, callback:obj.callback, scope:obj.scope});
  return me;
}, ghost:function(anchor, obj) {
  var me = this, dom = me.dom, beforeAnim;
  anchor = anchor || 'b';
  beforeAnim = function() {
    var el = Ext.fly(dom, '_anim'), width = el.getWidth(), height = el.getHeight(), xy = el.getXY(), position = el.getPositioning(), to = {opacity:0};
    switch(anchor) {
      case 't':
        to.y = xy[1] - height;
        break;
      case 'l':
        to.x = xy[0] - width;
        break;
      case 'r':
        to.x = xy[0] + width;
        break;
      case 'b':
        to.y = xy[1] + height;
        break;
      case 'tl':
        to.x = xy[0] - width;
        to.y = xy[1] - height;
        break;
      case 'bl':
        to.x = xy[0] - width;
        to.y = xy[1] + height;
        break;
      case 'br':
        to.x = xy[0] + width;
        to.y = xy[1] + height;
        break;
      case 'tr':
        to.x = xy[0] + width;
        to.y = xy[1] - height;
        break;
    }
    this.to = to;
    this.on('afteranimate', function() {
      var el = Ext.fly(dom, '_anim');
      if (el) {
        el.hide();
        el.clearOpacity();
        el.setPositioning(position);
      }
    });
  };
  me.animate(Ext.applyIf(obj || {}, {duration:500, easing:'ease-out', listeners:{beforeanimate:beforeAnim}}));
  return me;
}, highlight:function(color, o) {
  var me = this, dom = me.dom, from = {}, restore, to, attr, lns, event, fn;
  if (dom.tagName.match(me.tableTagRe)) {
    return me.select('div').highlight(color, o);
  }
  o = o || {};
  lns = o.listeners || {};
  attr = o.attr || 'backgroundColor';
  from[attr] = color || 'ffff9c';
  if (!o.to) {
    to = {};
    to[attr] = o.endColor || me.getColor(attr, 'ffffff', '');
  } else {
    to = o.to;
  }
  o.listeners = Ext.apply(Ext.apply({}, lns), {beforeanimate:function() {
    restore = dom.style[attr];
    var el = Ext.fly(dom, '_anim');
    el.clearOpacity();
    el.show();
    event = lns.beforeanimate;
    if (event) {
      fn = event.fn || event;
      return fn.apply(event.scope || lns.scope || window, arguments);
    }
  }, afteranimate:function() {
    if (dom) {
      dom.style[attr] = restore;
    }
    event = lns.afteranimate;
    if (event) {
      fn = event.fn || event;
      fn.apply(event.scope || lns.scope || window, arguments);
    }
  }});
  me.animate(Ext.apply({}, o, {duration:1000, easing:'ease-in', from:from, to:to}));
  return me;
}, pause:function(ms) {
  var me = this;
  Ext.fx.Manager.setFxDefaults(me.id, {delay:ms});
  return me;
}, fadeIn:function(o) {
  var me = this, dom = me.dom;
  me.animate(Ext.apply({}, o, {opacity:1, internalListeners:{beforeanimate:function(anim) {
    var el = Ext.fly(dom, '_anim');
    if (el.isStyle('display', 'none')) {
      el.setDisplayed('');
    } else {
      el.show();
    }
  }}}));
  return this;
}, fadeOut:function(o) {
  var me = this, dom = me.dom;
  o = Ext.apply({opacity:0, internalListeners:{afteranimate:function(anim) {
    if (dom && anim.to.opacity === 0) {
      var el = Ext.fly(dom, '_anim');
      if (o.useDisplay) {
        el.setDisplayed(false);
      } else {
        el.hide();
      }
    }
  }}}, o);
  me.animate(o);
  return me;
}, scale:function(w, h, o) {
  this.animate(Ext.apply({}, o, {width:w, height:h}));
  return this;
}, shift:function(config) {
  this.animate(config);
  return this;
}, anchorAnimX:function(anchor) {
  var xName = anchor === 'l' ? 'right' : 'left';
  this.dom.style[xName] = '0px';
}});
Ext.define('Ext.dom.Element_dd', {override:'Ext.dom.Element', initDD:function(group, config, overrides) {
  var dd = new Ext.dd.DD(Ext.id(this.dom), group, config);
  return Ext.apply(dd, overrides);
}, initDDProxy:function(group, config, overrides) {
  var dd = new Ext.dd.DDProxy(Ext.id(this.dom), group, config);
  return Ext.apply(dd, overrides);
}, initDDTarget:function(group, config, overrides) {
  var dd = new Ext.dd.DDTarget(Ext.id(this.dom), group, config);
  return Ext.apply(dd, overrides);
}});
Ext.define('Ext.dom.Element_fx', {override:'Ext.dom.Element'}, function() {
  var Element = Ext.dom.Element, VISIBILITY = 'visibility', DISPLAY = 'display', NONE = 'none', HIDDEN = 'hidden', VISIBLE = 'visible', OFFSETS = 'offsets', ASCLASS = 'asclass', NOSIZE = 'nosize', ORIGINALDISPLAY = 'originalDisplay', VISMODE = 'visibilityMode', ISVISIBLE = 'isVisible', OFFSETCLASS = Ext.baseCSSPrefix + 'hide-offsets', getDisplay = function(el) {
    var data = (el.$cache || el.getCache()).data, display = data[ORIGINALDISPLAY];
    if (display === undefined) {
      data[ORIGINALDISPLAY] = display = '';
    }
    return display;
  }, getVisMode = function(el) {
    var data = (el.$cache || el.getCache()).data, visMode = data[VISMODE];
    if (visMode === undefined) {
      data[VISMODE] = visMode = Element.VISIBILITY;
    }
    return visMode;
  };
  Element.override({originalDisplay:'', visibilityMode:1, setVisible:function(visible, animate) {
    var me = this, dom = me.dom, visMode = getVisMode(me);
    if (typeof animate == 'string') {
      switch(animate) {
        case DISPLAY:
          visMode = Element.DISPLAY;
          break;
        case VISIBILITY:
          visMode = Element.VISIBILITY;
          break;
        case OFFSETS:
          visMode = Element.OFFSETS;
          break;
        case NOSIZE:
        case ASCLASS:
          visMode = Element.ASCLASS;
          break;
      }
      me.setVisibilityMode(visMode);
      animate = false;
    }
    if (!animate || !me.anim) {
      if (visMode == Element.DISPLAY) {
        return me.setDisplayed(visible);
      } else {
        if (visMode == Element.OFFSETS) {
          me[visible ? 'removeCls' : 'addCls'](OFFSETCLASS);
        } else {
          if (visMode == Element.VISIBILITY) {
            me.fixDisplay();
            dom.style.visibility = visible ? '' : HIDDEN;
          } else {
            if (visMode == Element.ASCLASS) {
              me[visible ? 'removeCls' : 'addCls'](me.visibilityCls || Element.visibilityCls);
            }
          }
        }
      }
    } else {
      if (visible) {
        me.setOpacity(0.01);
        me.setVisible(true);
      }
      if (!Ext.isObject(animate)) {
        animate = {duration:350, easing:'ease-in'};
      }
      me.animate(Ext.applyIf({callback:function() {
        if (!visible) {
          Ext.fly(dom, '_internal').setVisible(false).setOpacity(1);
        }
      }, to:{opacity:visible ? 1 : 0}}, animate));
    }
    (me.$cache || me.getCache()).data[ISVISIBLE] = visible;
    return me;
  }, hasMetrics:function() {
    var visMode = getVisMode(this);
    return this.isVisible() || visMode == Element.OFFSETS || visMode == Element.VISIBILITY;
  }, toggle:function(animate) {
    var me = this;
    me.setVisible(!me.isVisible(), me.anim(animate));
    return me;
  }, setDisplayed:function(value) {
    if (typeof value == 'boolean') {
      value = value ? getDisplay(this) : NONE;
    }
    this.setStyle(DISPLAY, value);
    return this;
  }, fixDisplay:function() {
    var me = this;
    if (me.isStyle(DISPLAY, NONE)) {
      me.setStyle(VISIBILITY, HIDDEN);
      me.setStyle(DISPLAY, getDisplay(me));
      if (me.isStyle(DISPLAY, NONE)) {
        me.setStyle(DISPLAY, 'block');
      }
    }
  }, hide:function(animate) {
    if (typeof animate == 'string') {
      this.setVisible(false, animate);
      return this;
    }
    this.setVisible(false, this.anim(animate));
    return this;
  }, show:function(animate) {
    if (typeof animate == 'string') {
      this.setVisible(true, animate);
      return this;
    }
    this.setVisible(true, this.anim(animate));
    return this;
  }});
});
Ext.define('Ext.dom.Element_position', {override:'Ext.dom.Element'}, function() {
  var flyInstance, Element = this, LEFT = 'left', RIGHT = 'right', TOP = 'top', BOTTOM = 'bottom', POSITION = 'position', STATIC = 'static', RELATIVE = 'relative', ZINDEX = 'z-index', BODY = 'BODY', PADDING = 'padding', BORDER = 'border', SLEFT = '-left', SRIGHT = '-right', STOP = '-top', SBOTTOM = '-bottom', SWIDTH = '-width', borders = {l:BORDER + SLEFT + SWIDTH, r:BORDER + SRIGHT + SWIDTH, t:BORDER + STOP + SWIDTH, b:BORDER + SBOTTOM + SWIDTH}, paddings = {l:PADDING + SLEFT, r:PADDING + SRIGHT, 
  t:PADDING + STOP, b:PADDING + SBOTTOM}, paddingsTLRB = [paddings.l, paddings.r, paddings.t, paddings.b], bordersTLRB = [borders.l, borders.r, borders.t, borders.b], round = Math.round, doc = document, fly = function(el) {
    if (!flyInstance) {
      flyInstance = new Ext.Element.Fly;
    }
    flyInstance.attach(el);
    return flyInstance;
  };
  Element.override({pxRe:/^\d+(?:\.\d*)?px$/i, inheritableStatics:{getX:function(el) {
    return Element.getXY(el)[0];
  }, getXY:function(el) {
    var bd = doc.body, docEl = doc.documentElement, leftBorder = 0, topBorder = 0, ret = [0, 0], box, scroll;
    el = Ext.getDom(el);
    if (el != doc && el != bd) {
      if (Ext.isIE) {
        try {
          box = el.getBoundingClientRect();
          topBorder = docEl.clientTop || bd.clientTop;
          leftBorder = docEl.clientLeft || bd.clientLeft;
        } catch (ex) {
          box = {left:0, top:0};
        }
      } else {
        box = el.getBoundingClientRect();
      }
      scroll = fly(doc).getScroll();
      ret = [round(box.left + scroll.left - leftBorder), round(box.top + scroll.top - topBorder)];
    }
    return ret;
  }, getY:function(el) {
    return Element.getXY(el)[1];
  }, setX:function(el, x) {
    Element.setXY(el, [x, false]);
  }, setXY:function(el, xy) {
    (el = Ext.fly(el, '_setXY')).position();
    var pts = el.translatePoints(xy), style = el.dom.style, pos;
    style.right = 'auto';
    for (pos in pts) {
      if (!isNaN(pts[pos])) {
        style[pos] = pts[pos] + 'px';
      }
    }
  }, setY:function(el, y) {
    Element.setXY(el, [false, y]);
  }}, center:function(centerIn) {
    return this.alignTo(centerIn || doc, 'c-c');
  }, clearPositioning:function(value) {
    value = value || '';
    return this.setStyle({left:value, right:value, top:value, bottom:value, 'z-index':'', position:STATIC});
  }, getAnchorToXY:function(el, anchor, local, mySize) {
    return el.getAnchorXY(anchor, local, mySize);
  }, getBottom:function(local) {
    return (local ? this.getLocalY() : this.getY()) + this.getHeight();
  }, getBorderPadding:function() {
    var paddingWidth = this.getStyle(paddingsTLRB), bordersWidth = this.getStyle(bordersTLRB);
    return {beforeX:(parseFloat(bordersWidth[borders.l]) || 0) + (parseFloat(paddingWidth[paddings.l]) || 0), afterX:(parseFloat(bordersWidth[borders.r]) || 0) + (parseFloat(paddingWidth[paddings.r]) || 0), beforeY:(parseFloat(bordersWidth[borders.t]) || 0) + (parseFloat(paddingWidth[paddings.t]) || 0), afterY:(parseFloat(bordersWidth[borders.b]) || 0) + (parseFloat(paddingWidth[paddings.b]) || 0)};
  }, getCenterXY:function() {
    return this.getAlignToXY(doc, 'c-c');
  }, getLeft:function(local) {
    return local ? this.getLocalX() : this.getX();
  }, getLocalX:function() {
    var me = this, offsetParent = me.dom.offsetParent, x = me.getStyle('left');
    if (!x || x === 'auto') {
      x = 0;
    } else {
      if (me.pxRe.test(x)) {
        x = parseFloat(x);
      } else {
        x = me.getX();
        if (offsetParent) {
          x -= Element.getX(offsetParent);
        }
      }
    }
    return x;
  }, getLocalXY:function() {
    var me = this, offsetParent = me.dom.offsetParent, style = me.getStyle(['left', 'top']), x = style.left, y = style.top;
    if (!x || x === 'auto') {
      x = 0;
    } else {
      if (me.pxRe.test(x)) {
        x = parseFloat(x);
      } else {
        x = me.getX();
        if (offsetParent) {
          x -= Element.getX(offsetParent);
        }
      }
    }
    if (!y || y === 'auto') {
      y = 0;
    } else {
      if (me.pxRe.test(y)) {
        y = parseFloat(y);
      } else {
        y = me.getY();
        if (offsetParent) {
          y -= Element.getY(offsetParent);
        }
      }
    }
    return [x, y];
  }, getLocalY:function() {
    var me = this, offsetParent = me.dom.offsetParent, y = me.getStyle('top');
    if (!y || y === 'auto') {
      y = 0;
    } else {
      if (me.pxRe.test(y)) {
        y = parseFloat(y);
      } else {
        y = me.getY();
        if (offsetParent) {
          y -= Element.getY(offsetParent);
        }
      }
    }
    return y;
  }, getPageBox:function(getRegion) {
    var me = this, dom = me.dom, isDoc = dom.nodeName == BODY, w = isDoc ? Ext.Element.getViewWidth() : dom.offsetWidth, h = isDoc ? Ext.Element.getViewHeight() : dom.offsetHeight, xy = me.getXY(), t = xy[1], r = xy[0] + w, b = xy[1] + h, l = xy[0];
    if (getRegion) {
      return new Ext.util.Region(t, r, b, l);
    } else {
      return {left:l, top:t, width:w, height:h, right:r, bottom:b};
    }
  }, getPositioning:function(autoPx) {
    var styles = this.getStyle(['left', 'top', 'position', 'z-index']), dom = this.dom;
    if (autoPx) {
      if (styles.left === 'auto') {
        styles.left = dom.offsetLeft + 'px';
      }
      if (styles.top === 'auto') {
        styles.top = dom.offsetTop + 'px';
      }
    }
    return styles;
  }, getRight:function(local) {
    return (local ? this.getLocalX() : this.getX()) + this.getWidth();
  }, getTop:function(local) {
    return local ? this.getLocalY() : this.getY();
  }, getX:function() {
    return Element.getX(this.dom);
  }, getXY:function() {
    return Element.getXY(this.dom);
  }, getY:function() {
    return Element.getY(this.dom);
  }, moveTo:function(x, y, animate) {
    return this.setXY([x, y], animate);
  }, position:function(pos, zIndex, x, y) {
    var me = this;
    if (!pos && me.isStyle(POSITION, STATIC)) {
      me.setStyle(POSITION, RELATIVE);
    } else {
      if (pos) {
        me.setStyle(POSITION, pos);
      }
    }
    if (zIndex) {
      me.setStyle(ZINDEX, zIndex);
    }
    if (x || y) {
      me.setXY([x || false, y || false]);
    }
  }, setBottom:function(bottom) {
    this.dom.style[BOTTOM] = this.addUnits(bottom);
    return this;
  }, setBounds:function(x, y, width, height, animate) {
    return this.setBox({x:x, y:y, width:width, height:height}, animate);
  }, setLeft:function(left) {
    this.dom.style[LEFT] = this.addUnits(left);
    return this;
  }, setLeftTop:function(left, top) {
    var me = this, style = me.dom.style;
    style.left = me.addUnits(left);
    style.top = me.addUnits(top);
    return me;
  }, setLocalX:function(x) {
    var style = this.dom.style;
    style.right = 'auto';
    style.left = x === null ? 'auto' : x + 'px';
  }, setLocalXY:function(x, y) {
    var style = this.dom.style;
    style.right = 'auto';
    if (x && x.length) {
      y = x[1];
      x = x[0];
    }
    if (x === null) {
      style.left = 'auto';
    } else {
      if (x !== undefined) {
        style.left = x + 'px';
      }
    }
    if (y === null) {
      style.top = 'auto';
    } else {
      if (y !== undefined) {
        style.top = y + 'px';
      }
    }
  }, setLocalY:function(y) {
    this.dom.style.top = y === null ? 'auto' : y + 'px';
  }, setLocation:function(x, y, animate) {
    return this.setXY([x, y], animate);
  }, setPositioning:function(pc) {
    return this.setStyle(pc);
  }, setRight:function(right) {
    this.dom.style[RIGHT] = this.addUnits(right);
    return this;
  }, setTop:function(top) {
    this.dom.style[TOP] = this.addUnits(top);
    return this;
  }, setX:function(x, animate) {
    return this.setXY([x, this.getY()], animate);
  }, setXY:function(xy, animate) {
    var me = this;
    if (!animate || !me.anim) {
      Element.setXY(me.dom, xy);
    } else {
      if (!Ext.isObject(animate)) {
        animate = {};
      }
      me.animate(Ext.applyIf({to:{x:xy[0], y:xy[1]}}, animate));
    }
    return this;
  }, setY:function(y, animate) {
    return this.setXY([this.getX(), y], animate);
  }});
  Element.getTrueXY = Element.getXY;
});
Ext.define('Ext.dom.Element_scroll', {override:'Ext.dom.Element', isScrollable:function() {
  var dom = this.dom;
  return dom.scrollHeight > dom.clientHeight || dom.scrollWidth > dom.clientWidth;
}, getScroll:function() {
  var me = this, dom = me.dom, doc = document, body = doc.body, docElement = doc.documentElement, left, top;
  if (dom === doc || dom === body) {
    left = docElement.scrollLeft || (body ? body.scrollLeft : 0);
    top = docElement.scrollTop || (body ? body.scrollTop : 0);
  } else {
    left = dom.scrollLeft;
    top = dom.scrollTop;
  }
  return {left:left, top:top};
}, getScrollLeft:function() {
  var dom = this.dom, doc = document;
  if (dom === doc || dom === doc.body) {
    return this.getScroll().left;
  } else {
    return dom.scrollLeft;
  }
}, getScrollTop:function() {
  var dom = this.dom, doc = document;
  if (dom === doc || dom === doc.body) {
    return this.getScroll().top;
  } else {
    return dom.scrollTop;
  }
}, setScrollLeft:function(left) {
  this.dom.scrollLeft = left;
  return this;
}, setScrollTop:function(top) {
  this.dom.scrollTop = top;
  return this;
}, scrollBy:function(deltaX, deltaY, animate) {
  var me = this, dom = me.dom;
  if (deltaX.length) {
    animate = deltaY;
    deltaY = deltaX[1];
    deltaX = deltaX[0];
  } else {
    if (typeof deltaX != 'number') {
      animate = deltaY;
      deltaY = deltaX.y;
      deltaX = deltaX.x;
    }
  }
  if (deltaX) {
    me.scrollTo('left', me.constrainScrollLeft(dom.scrollLeft + deltaX), animate);
  }
  if (deltaY) {
    me.scrollTo('top', me.constrainScrollTop(dom.scrollTop + deltaY), animate);
  }
  return me;
}, scrollTo:function(side, value, animate) {
  var top = /top/i.test(side), me = this, prop = top ? 'scrollTop' : 'scrollLeft', dom = me.dom, animCfg;
  if (!animate || !me.anim) {
    dom[prop] = value;
    dom[prop] = value;
  } else {
    animCfg = {to:{}};
    animCfg.to[prop] = value;
    if (Ext.isObject(animate)) {
      Ext.applyIf(animCfg, animate);
    }
    me.animate(animCfg);
  }
  return me;
}, scrollIntoView:function(container, hscroll, animate, highlight) {
  var me = this, dom = me.dom, offsets = me.getOffsetsTo(container = Ext.getDom(container) || Ext.getBody().dom), left = offsets[0] + container.scrollLeft, top = offsets[1] + container.scrollTop, bottom = top + dom.offsetHeight, right = left + dom.offsetWidth, ctClientHeight = container.clientHeight, ctScrollTop = parseInt(container.scrollTop, 10), ctScrollLeft = parseInt(container.scrollLeft, 10), ctBottom = ctScrollTop + ctClientHeight, ctRight = ctScrollLeft + container.clientWidth, newPos;
  if (highlight) {
    if (animate) {
      animate = Ext.apply({listeners:{afteranimate:function() {
        me.scrollChildFly.attach(dom).highlight();
      }}}, animate);
    } else {
      me.scrollChildFly.attach(dom).highlight();
    }
  }
  if (dom.offsetHeight > ctClientHeight || top < ctScrollTop) {
    newPos = top;
  } else {
    if (bottom > ctBottom) {
      newPos = bottom - ctClientHeight;
    }
  }
  if (newPos != null) {
    me.scrollChildFly.attach(container).scrollTo('top', newPos, animate);
  }
  if (hscroll !== false) {
    newPos = null;
    if (dom.offsetWidth > container.clientWidth || left < ctScrollLeft) {
      newPos = left;
    } else {
      if (right > ctRight) {
        newPos = right - container.clientWidth;
      }
    }
    if (newPos != null) {
      me.scrollChildFly.attach(container).scrollTo('left', newPos, animate);
    }
  }
  return me;
}, scrollChildIntoView:function(child, hscroll) {
  this.scrollChildFly.attach(Ext.getDom(child)).scrollIntoView(this, hscroll);
}, scroll:function(direction, distance, animate) {
  if (!this.isScrollable()) {
    return false;
  }
  var me = this, dom = me.dom, side = direction === 'r' || direction === 'l' ? 'left' : 'top', scrolled = false, currentScroll, constrainedScroll;
  if (direction === 'r') {
    distance = -distance;
  }
  if (side === 'left') {
    currentScroll = dom.scrollLeft;
    constrainedScroll = me.constrainScrollLeft(currentScroll + distance);
  } else {
    currentScroll = dom.scrollTop;
    constrainedScroll = me.constrainScrollTop(currentScroll + distance);
  }
  if (constrainedScroll !== currentScroll) {
    this.scrollTo(side, constrainedScroll, animate);
    scrolled = true;
  }
  return scrolled;
}, constrainScrollLeft:function(left) {
  var dom = this.dom;
  return Math.max(Math.min(left, dom.scrollWidth - dom.clientWidth), 0);
}, constrainScrollTop:function(top) {
  var dom = this.dom;
  return Math.max(Math.min(top, dom.scrollHeight - dom.clientHeight), 0);
}}, function() {
  this.prototype.scrollChildFly = new this.Fly;
  this.prototype.scrolltoFly = new this.Fly;
});
Ext.define('Ext.dom.Element_style', {override:'Ext.dom.Element'}, function() {
  var Element = this, view = document.defaultView, adjustDirect2DTableRe = /table-row|table-.*-group/, INTERNAL = '_internal', HIDDEN = 'hidden', HEIGHT = 'height', WIDTH = 'width', ISCLIPPED = 'isClipped', OVERFLOW = 'overflow', OVERFLOWX = 'overflow-x', OVERFLOWY = 'overflow-y', ORIGINALCLIP = 'originalClip', DOCORBODYRE = /#document|body/i, styleHooks, verticalStyleHooks90, verticalStyleHooks270, edges, k, edge, borderWidth;
  if (!view || !view.getComputedStyle) {
    Element.prototype.getStyle = function(property, inline) {
      var me = this, dom = me.dom, multiple = typeof property != 'string', hooks = me.styleHooks, prop = property, props = prop, len = 1, isInline = inline, camel, domStyle, values, hook, out, style, i;
      if (multiple) {
        values = {};
        prop = props[0];
        i = 0;
        if (!(len = props.length)) {
          return values;
        }
      }
      if (!dom || dom.documentElement) {
        return values || '';
      }
      domStyle = dom.style;
      if (inline) {
        style = domStyle;
      } else {
        style = dom.currentStyle;
        if (!style) {
          isInline = true;
          style = domStyle;
        }
      }
      do {
        hook = hooks[prop];
        if (!hook) {
          hooks[prop] = hook = {name:Element.normalize(prop)};
        }
        if (hook.get) {
          out = hook.get(dom, me, isInline, style);
        } else {
          camel = hook.name;
          if (hook.canThrow) {
            try {
              out = style[camel];
            } catch (e$14) {
              out = '';
            }
          } else {
            out = style ? style[camel] : '';
          }
        }
        if (!multiple) {
          return out;
        }
        values[prop] = out;
        prop = props[++i];
      } while (i < len);
      return values;
    };
  }
  Element.override({getHeight:function(contentHeight, preciseHeight) {
    var me = this, hidden = me.isStyle('display', 'none'), height, floating;
    if (hidden) {
      return 0;
    }
    height = me.dom.offsetHeight;
    if (Ext.supports.Direct2DBug) {
      floating = me.adjustDirect2DDimension(HEIGHT);
      if (preciseHeight) {
        height += floating;
      } else {
        if (floating > 0 && floating < 0.5) {
          height++;
        }
      }
    }
    if (contentHeight) {
      height -= me.getBorderWidth('tb') + me.getPadding('tb');
    }
    return height < 0 ? 0 : height;
  }, getWidth:function(contentWidth, preciseWidth) {
    var me = this, dom = me.dom, hidden = me.isStyle('display', 'none'), rect, width, floating;
    if (hidden) {
      return 0;
    }
    if (preciseWidth && Ext.supports.BoundingClientRect) {
      rect = dom.getBoundingClientRect();
      width = me.vertical && !Ext.isIE9 && !Ext.supports.RotatedBoundingClientRect ? rect.bottom - rect.top : rect.right - rect.left;
    } else {
      width = dom.offsetWidth;
    }
    if (Ext.supports.Direct2DBug && !me.vertical) {
      floating = me.adjustDirect2DDimension(WIDTH);
      if (preciseWidth) {
        width += floating;
      } else {
        if (floating > 0 && floating < 0.5) {
          width++;
        }
      }
    }
    if (contentWidth) {
      width -= me.getBorderWidth('lr') + me.getPadding('lr');
    }
    return width < 0 ? 0 : width;
  }, setWidth:function(width, animate) {
    var me = this;
    width = me.adjustWidth(width);
    if (!animate || !me.anim) {
      me.dom.style.width = me.addUnits(width);
    } else {
      if (!Ext.isObject(animate)) {
        animate = {};
      }
      me.animate(Ext.applyIf({to:{width:width}}, animate));
    }
    return me;
  }, setHeight:function(height, animate) {
    var me = this;
    height = me.adjustHeight(height);
    if (!animate || !me.anim) {
      me.dom.style.height = me.addUnits(height);
    } else {
      if (!Ext.isObject(animate)) {
        animate = {};
      }
      me.animate(Ext.applyIf({to:{height:height}}, animate));
    }
    return me;
  }, applyStyles:function(style) {
    Ext.DomHelper.applyStyles(this.dom, style);
    return this;
  }, setSize:function(width, height, animate) {
    var me = this;
    if (Ext.isObject(width)) {
      animate = height;
      height = width.height;
      width = width.width;
    }
    width = me.adjustWidth(width);
    height = me.adjustHeight(height);
    if (!animate || !me.anim) {
      me.dom.style.width = me.addUnits(width);
      me.dom.style.height = me.addUnits(height);
    } else {
      if (animate === true) {
        animate = {};
      }
      me.animate(Ext.applyIf({to:{width:width, height:height}}, animate));
    }
    return me;
  }, getViewSize:function() {
    var me = this, dom = me.dom, isDoc = DOCORBODYRE.test(dom.nodeName), ret;
    if (isDoc) {
      ret = {width:Element.getViewWidth(), height:Element.getViewHeight()};
    } else {
      ret = {width:dom.clientWidth, height:dom.clientHeight};
    }
    return ret;
  }, getSize:function(contentSize) {
    return {width:this.getWidth(contentSize), height:this.getHeight(contentSize)};
  }, adjustWidth:function(width) {
    var me = this, isNum = typeof width == 'number';
    if (isNum && me.autoBoxAdjust && !me.isBorderBox()) {
      width -= me.getBorderWidth('lr') + me.getPadding('lr');
    }
    return isNum && width < 0 ? 0 : width;
  }, adjustHeight:function(height) {
    var me = this, isNum = typeof height == 'number';
    if (isNum && me.autoBoxAdjust && !me.isBorderBox()) {
      height -= me.getBorderWidth('tb') + me.getPadding('tb');
    }
    return isNum && height < 0 ? 0 : height;
  }, getColor:function(attr, defaultValue, prefix) {
    var v = this.getStyle(attr), color = prefix || prefix === '' ? prefix : '#', h, len, i = 0;
    if (!v || /transparent|inherit/.test(v)) {
      return defaultValue;
    }
    if (/^r/.test(v)) {
      v = v.slice(4, v.length - 1).split(',');
      len = v.length;
      for (; i < len; i++) {
        h = parseInt(v[i], 10);
        color += (h < 16 ? '0' : '') + h.toString(16);
      }
    } else {
      v = v.replace('#', '');
      color += v.length == 3 ? v.replace(/^(\w)(\w)(\w)$/, '$1$1$2$2$3$3') : v;
    }
    return color.length > 5 ? color.toLowerCase() : defaultValue;
  }, setOpacity:function(opacity, animate) {
    var me = this;
    if (!me.dom) {
      return me;
    }
    if (!animate || !me.anim) {
      me.setStyle('opacity', opacity);
    } else {
      if (typeof animate != 'object') {
        animate = {duration:350, easing:'ease-in'};
      }
      me.animate(Ext.applyIf({to:{opacity:opacity}}, animate));
    }
    return me;
  }, clearOpacity:function() {
    return this.setOpacity('');
  }, adjustDirect2DDimension:function(dimension) {
    var me = this, dom = me.dom, display = me.getStyle('display'), inlineDisplay = dom.style.display, inlinePosition = dom.style.position, originIndex = dimension === WIDTH ? 0 : 1, currentStyle = dom.currentStyle, floating;
    if (display === 'inline') {
      dom.style.display = 'inline-block';
    }
    dom.style.position = display.match(adjustDirect2DTableRe) ? 'absolute' : 'static';
    floating = (parseFloat(currentStyle[dimension]) || parseFloat(currentStyle.msTransformOrigin.split(' ')[originIndex]) * 2) % 1;
    dom.style.position = inlinePosition;
    if (display === 'inline') {
      dom.style.display = inlineDisplay;
    }
    return floating;
  }, clip:function() {
    var me = this, data = (me.$cache || me.getCache()).data, style;
    if (!data[ISCLIPPED]) {
      data[ISCLIPPED] = true;
      style = me.getStyle([OVERFLOW, OVERFLOWX, OVERFLOWY]);
      data[ORIGINALCLIP] = {o:style[OVERFLOW], x:style[OVERFLOWX], y:style[OVERFLOWY]};
      me.setStyle(OVERFLOW, HIDDEN);
      me.setStyle(OVERFLOWX, HIDDEN);
      me.setStyle(OVERFLOWY, HIDDEN);
    }
    return me;
  }, unclip:function() {
    var me = this, data = (me.$cache || me.getCache()).data, clip;
    if (data[ISCLIPPED]) {
      data[ISCLIPPED] = false;
      clip = data[ORIGINALCLIP];
      if (clip.o) {
        me.setStyle(OVERFLOW, clip.o);
      }
      if (clip.x) {
        me.setStyle(OVERFLOWX, clip.x);
      }
      if (clip.y) {
        me.setStyle(OVERFLOWY, clip.y);
      }
    }
    return me;
  }, boxWrap:function(cls) {
    cls = cls || Ext.baseCSSPrefix + 'box';
    var el = Ext.get(this.insertHtml('beforeBegin', "\x3cdiv class\x3d'" + cls + "'\x3e" + Ext.String.format(Element.boxMarkup, cls) + '\x3c/div\x3e'));
    Ext.DomQuery.selectNode('.' + cls + '-mc', el.dom).appendChild(this.dom);
    return el;
  }, getComputedHeight:function() {
    var me = this, h = Math.max(me.dom.offsetHeight, me.dom.clientHeight);
    if (!h) {
      h = parseFloat(me.getStyle(HEIGHT)) || 0;
      if (!me.isBorderBox()) {
        h += me.getFrameWidth('tb');
      }
    }
    return h;
  }, getComputedWidth:function() {
    var me = this, w = Math.max(me.dom.offsetWidth, me.dom.clientWidth);
    if (!w) {
      w = parseFloat(me.getStyle(WIDTH)) || 0;
      if (!me.isBorderBox()) {
        w += me.getFrameWidth('lr');
      }
    }
    return w;
  }, getFrameWidth:function(sides, onlyContentBox) {
    return onlyContentBox && this.isBorderBox() ? 0 : this.getPadding(sides) + this.getBorderWidth(sides);
  }, addClsOnOver:function(className, testFn, scope) {
    var me = this, dom = me.dom, hasTest = Ext.isFunction(testFn);
    me.hover(function() {
      if (hasTest && testFn.call(scope || me, me) === false) {
        return;
      }
      Ext.fly(dom, INTERNAL).addCls(className);
    }, function() {
      Ext.fly(dom, INTERNAL).removeCls(className);
    });
    return me;
  }, addClsOnFocus:function(className, testFn, scope) {
    var me = this, dom = me.dom, hasTest = Ext.isFunction(testFn);
    me.on('focus', function() {
      if (hasTest && testFn.call(scope || me, me) === false) {
        return false;
      }
      Ext.fly(dom, INTERNAL).addCls(className);
    });
    me.on('blur', function() {
      Ext.fly(dom, INTERNAL).removeCls(className);
    });
    return me;
  }, addClsOnClick:function(className, testFn, scope) {
    var me = this, dom = me.dom, hasTest = Ext.isFunction(testFn);
    me.on('mousedown', function() {
      if (hasTest && testFn.call(scope || me, me) === false) {
        return false;
      }
      Ext.fly(dom, INTERNAL).addCls(className);
      var d = Ext.getDoc(), fn = function() {
        Ext.fly(dom, INTERNAL).removeCls(className);
        d.removeListener('mouseup', fn);
      };
      d.on('mouseup', fn);
    });
    return me;
  }, getStyleSize:function() {
    var me = this, d = this.dom, isDoc = DOCORBODYRE.test(d.nodeName), s, w, h;
    if (isDoc) {
      return {width:Element.getViewWidth(), height:Element.getViewHeight()};
    }
    s = me.getStyle([HEIGHT, WIDTH], true);
    if (s.width && s.width != 'auto') {
      w = parseFloat(s.width);
      if (me.isBorderBox()) {
        w -= me.getFrameWidth('lr');
      }
    }
    if (s.height && s.height != 'auto') {
      h = parseFloat(s.height);
      if (me.isBorderBox()) {
        h -= me.getFrameWidth('tb');
      }
    }
    return {width:w || me.getWidth(true), height:h || me.getHeight(true)};
  }, statics:{selectableCls:Ext.baseCSSPrefix + 'selectable', unselectableCls:Ext.baseCSSPrefix + 'unselectable'}, selectable:function() {
    var me = this;
    me.dom.unselectable = '';
    me.removeCls(Element.unselectableCls);
    me.addCls(Element.selectableCls);
    return me;
  }, unselectable:function() {
    var me = this;
    if (Ext.isOpera) {
      me.dom.unselectable = 'on';
    }
    me.removeCls(Element.selectableCls);
    me.addCls(Element.unselectableCls);
    return me;
  }, setVertical:function(angle, cls) {
    var me = this, proto = Element.prototype, hooks;
    me.vertical = true;
    if (cls) {
      me.addCls(me.verticalCls = cls);
    }
    me.setWidth = proto.setHeight;
    me.setHeight = proto.setWidth;
    if (!Ext.isIE9m) {
      me.getWidth = proto.getHeight;
      me.getHeight = proto.getWidth;
    }
    me.styleHooks = angle === 270 ? Element.prototype.verticalStyleHooks270 : Element.prototype.verticalStyleHooks90;
  }, setHorizontal:function() {
    var me = this, cls = me.verticalCls;
    delete me.vertical;
    if (cls) {
      delete me.verticalCls;
      me.removeCls(cls);
    }
    delete me.setWidth;
    delete me.setHeight;
    if (!Ext.isIE9m) {
      delete me.getWidth;
      delete me.getHeight;
    }
    delete me.styleHooks;
  }});
  Element.prototype.styleHooks = styleHooks = Ext.dom.AbstractElement.prototype.styleHooks;
  Element.prototype.verticalStyleHooks90 = verticalStyleHooks90 = Ext.Object.chain(Element.prototype.styleHooks);
  Element.prototype.verticalStyleHooks270 = verticalStyleHooks270 = Ext.Object.chain(Element.prototype.styleHooks);
  verticalStyleHooks90.width = {name:'height'};
  verticalStyleHooks90.height = {name:'width'};
  verticalStyleHooks90['margin-top'] = {name:'marginLeft'};
  verticalStyleHooks90['margin-right'] = {name:'marginTop'};
  verticalStyleHooks90['margin-bottom'] = {name:'marginRight'};
  verticalStyleHooks90['margin-left'] = {name:'marginBottom'};
  verticalStyleHooks90['padding-top'] = {name:'paddingLeft'};
  verticalStyleHooks90['padding-right'] = {name:'paddingTop'};
  verticalStyleHooks90['padding-bottom'] = {name:'paddingRight'};
  verticalStyleHooks90['padding-left'] = {name:'paddingBottom'};
  verticalStyleHooks90['border-top'] = {name:'borderLeft'};
  verticalStyleHooks90['border-right'] = {name:'borderTop'};
  verticalStyleHooks90['border-bottom'] = {name:'borderRight'};
  verticalStyleHooks90['border-left'] = {name:'borderBottom'};
  verticalStyleHooks270.width = {name:'height'};
  verticalStyleHooks270.height = {name:'width'};
  verticalStyleHooks270['margin-top'] = {name:'marginRight'};
  verticalStyleHooks270['margin-right'] = {name:'marginBottom'};
  verticalStyleHooks270['margin-bottom'] = {name:'marginLeft'};
  verticalStyleHooks270['margin-left'] = {name:'marginTop'};
  verticalStyleHooks270['padding-top'] = {name:'paddingRight'};
  verticalStyleHooks270['padding-right'] = {name:'paddingBottom'};
  verticalStyleHooks270['padding-bottom'] = {name:'paddingLeft'};
  verticalStyleHooks270['padding-left'] = {name:'paddingTop'};
  verticalStyleHooks270['border-top'] = {name:'borderRight'};
  verticalStyleHooks270['border-right'] = {name:'borderBottom'};
  verticalStyleHooks270['border-bottom'] = {name:'borderLeft'};
  verticalStyleHooks270['border-left'] = {name:'borderTop'};
  if (Ext.isIE7m) {
    styleHooks.fontSize = styleHooks['font-size'] = {name:'fontSize', canThrow:true};
    styleHooks.fontStyle = styleHooks['font-style'] = {name:'fontStyle', canThrow:true};
    styleHooks.fontFamily = styleHooks['font-family'] = {name:'fontFamily', canThrow:true};
  }
  if (Ext.isIEQuirks || Ext.isIE && Ext.ieVersion <= 8) {
    var getBorderWidth = function(dom, el, inline, style) {
      if (style[this.styleName] == 'none') {
        return '0px';
      }
      return style[this.name];
    };
    edges = ['Top', 'Right', 'Bottom', 'Left'];
    k = edges.length;
    while (k--) {
      edge = edges[k];
      borderWidth = 'border' + edge + 'Width';
      styleHooks['border-' + edge.toLowerCase() + '-width'] = styleHooks[borderWidth] = {name:borderWidth, styleName:'border' + edge + 'Style', get:getBorderWidth};
    }
  }
  Ext.getDoc().on('selectstart', function(ev, dom) {
    var doc = document.documentElement, selectableCls = Element.selectableCls, unselectableCls = Element.unselectableCls, tagName = dom && dom.tagName;
    tagName = tagName && tagName.toLowerCase();
    if (tagName === 'input' || tagName === 'textarea') {
      return;
    }
    while (dom && dom.nodeType === 1 && dom !== doc) {
      var el = Ext.fly(dom);
      if (el.hasCls(selectableCls)) {
        return;
      }
      if (el.hasCls(unselectableCls)) {
        ev.stopEvent();
        return;
      }
      dom = dom.parentNode;
    }
  });
});
Ext.onReady(function() {
  var opacityRe = /alpha\(opacity=(.*)\)/i, trimRe = /^\s+|\s+$/g, hooks = Ext.dom.Element.prototype.styleHooks;
  hooks.opacity = {name:'opacity', afterSet:function(dom, value, el) {
    if (el.isLayer) {
      el.onOpacitySet(value);
    }
  }};
  if (!Ext.supports.Opacity && Ext.isIE) {
    Ext.apply(hooks.opacity, {get:function(dom) {
      var filter = dom.style.filter, match, opacity;
      if (filter.match) {
        match = filter.match(opacityRe);
        if (match) {
          opacity = parseFloat(match[1]);
          if (!isNaN(opacity)) {
            return opacity ? opacity / 100 : 0;
          }
        }
      }
      return 1;
    }, set:function(dom, value) {
      var style = dom.style, val = style.filter.replace(opacityRe, '').replace(trimRe, '');
      style.zoom = 1;
      if (typeof value == 'number' && value >= 0 && value < 1) {
        value *= 100;
        style.filter = val + (val.length ? ' ' : '') + 'alpha(opacity\x3d' + value + ')';
      } else {
        style.filter = val;
      }
    }});
  }
});
Ext.define('Ext.util.Positionable', {_positionTopLeft:['position', 'top', 'left'], _alignRe:/^([a-z]+)-([a-z]+)(\?)?$/, afterSetPosition:Ext.emptyFn, getAnchorToXY:function() {
  Ext.Error.raise('getAnchorToXY is not implemented in ' + this.$className);
}, getBorderPadding:function() {
  Ext.Error.raise('getBorderPadding is not implemented in ' + this.$className);
}, getLocalX:function() {
  Ext.Error.raise('getLocalX is not implemented in ' + this.$className);
}, getLocalXY:function() {
  Ext.Error.raise('getLocalXY is not implemented in ' + this.$className);
}, getLocalY:function() {
  Ext.Error.raise('getLocalY is not implemented in ' + this.$className);
}, getX:function() {
  Ext.Error.raise('getX is not implemented in ' + this.$className);
}, getXY:function() {
  Ext.Error.raise('getXY is not implemented in ' + this.$className);
}, getY:function() {
  Ext.Error.raise('getY is not implemented in ' + this.$className);
}, setLocalX:function() {
  Ext.Error.raise('setLocalX is not implemented in ' + this.$className);
}, setLocalXY:function() {
  Ext.Error.raise('setLocalXY is not implemented in ' + this.$className);
}, setLocalY:function() {
  Ext.Error.raise('setLocalY is not implemented in ' + this.$className);
}, setX:function() {
  Ext.Error.raise('setX is not implemented in ' + this.$className);
}, setXY:function() {
  Ext.Error.raise('setXY is not implemented in ' + this.$className);
}, setY:function() {
  Ext.Error.raise('setY is not implemented in ' + this.$className);
}, adjustForConstraints:function(xy, parent) {
  var vector = this.getConstrainVector(parent, xy);
  if (vector) {
    xy[0] += vector[0];
    xy[1] += vector[1];
  }
  return xy;
}, alignTo:function(element, position, offsets, animate) {
  var me = this, el = me.el;
  return me.setXY(me.getAlignToXY(element, position, offsets), el.anim && !!animate ? el.anim(animate) : false);
}, anchorTo:function(anchorToEl, alignment, offsets, animate, monitorScroll, callback) {
  var me = this, scroll = !Ext.isEmpty(monitorScroll), action = function() {
    me.alignTo(anchorToEl, alignment, offsets, animate);
    Ext.callback(callback, me);
  }, anchor = me.getAnchor();
  me.removeAnchor();
  Ext.apply(anchor, {fn:action, scroll:scroll});
  Ext.EventManager.onWindowResize(action, null);
  if (scroll) {
    Ext.EventManager.on(window, 'scroll', action, null, {buffer:!isNaN(monitorScroll) ? monitorScroll : 50});
  }
  action();
  return me;
}, calculateAnchorXY:function(anchor, extraX, extraY, mySize) {
  var me = this, el = me.el, doc = document, isViewport = el.dom == doc.body || el.dom == doc, round = Math.round, xy, myWidth, myHeight;
  anchor = (anchor || 'tl').toLowerCase();
  mySize = mySize || {};
  myWidth = mySize.width || isViewport ? Ext.Element.getViewWidth() : me.getWidth();
  myHeight = mySize.height || isViewport ? Ext.Element.getViewHeight() : me.getHeight();
  switch(anchor) {
    case 'tl':
      xy = [0, 0];
      break;
    case 'bl':
      xy = [0, myHeight];
      break;
    case 'tr':
      xy = [myWidth, 0];
      break;
    case 'c':
      xy = [round(myWidth * 0.5), round(myHeight * 0.5)];
      break;
    case 't':
      xy = [round(myWidth * 0.5), 0];
      break;
    case 'l':
      xy = [0, round(myHeight * 0.5)];
      break;
    case 'r':
      xy = [myWidth, round(myHeight * 0.5)];
      break;
    case 'b':
      xy = [round(myWidth * 0.5), myHeight];
      break;
    case 'tc':
      xy = [round(myWidth * 0.5), 0];
      break;
    case 'bc':
      xy = [round(myWidth * 0.5), myHeight];
      break;
    case 'br':
      xy = [myWidth, myHeight];
  }
  return [xy[0] + extraX, xy[1] + extraY];
}, convertPositionSpec:Ext.identityFn, getAlignToXY:function(alignToEl, posSpec, offset) {
  var me = this, viewportWidth = Ext.Element.getViewWidth() - 10, viewportHeight = Ext.Element.getViewHeight() - 10, doc = document, docElement = doc.documentElement, docBody = doc.body, scrollX = docElement.scrollLeft || docBody.scrollLeft || 0, scrollY = docElement.scrollTop || docBody.scrollTop || 0, alignMatch, myPosition, alignToElPosition, myWidth, myHeight, alignToElRegion, swapY, swapX, constrain, align1, align2, p1y, p1x, p2y, p2x, x, y;
  alignToEl = Ext.get(alignToEl.el || alignToEl);
  if (!alignToEl || !alignToEl.dom) {
    Ext.Error.raise({sourceClass:'Ext.util.Positionable', sourceMethod:'getAlignToXY', msg:"Attempted to align an element that doesn't exist"});
  }
  offset = offset || [0, 0];
  posSpec = (!posSpec || posSpec == '?' ? 'tl-bl?' : !/-/.test(posSpec) && posSpec !== '' ? 'tl-' + posSpec : posSpec || 'tl-bl').toLowerCase();
  posSpec = me.convertPositionSpec(posSpec);
  alignMatch = posSpec.match(me._alignRe);
  if (!alignMatch) {
    Ext.Error.raise({sourceClass:'Ext.util.Positionable', sourceMethod:'getAlignToXY', el:alignToEl, position:posSpec, offset:offset, msg:'Attemmpted to align an element with an invalid position: "' + posSpec + '"'});
  }
  align1 = alignMatch[1];
  align2 = alignMatch[2];
  constrain = !!alignMatch[3];
  myPosition = me.getAnchorXY(align1, true);
  alignToElPosition = me.getAnchorToXY(alignToEl, align2, false);
  x = alignToElPosition[0] - myPosition[0] + offset[0];
  y = alignToElPosition[1] - myPosition[1] + offset[1];
  if (constrain) {
    myWidth = me.getWidth();
    myHeight = me.getHeight();
    alignToElRegion = alignToEl.getRegion();
    p1y = align1.charAt(0);
    p1x = align1.charAt(align1.length - 1);
    p2y = align2.charAt(0);
    p2x = align2.charAt(align2.length - 1);
    swapY = p1y == 't' && p2y == 'b' || p1y == 'b' && p2y == 't';
    swapX = p1x == 'r' && p2x == 'l' || p1x == 'l' && p2x == 'r';
    if (x + myWidth > viewportWidth + scrollX) {
      x = swapX ? alignToElRegion.left - myWidth : viewportWidth + scrollX - myWidth;
    }
    if (x < scrollX) {
      x = swapX ? alignToElRegion.right : scrollX;
    }
    if (y + myHeight > viewportHeight + scrollY) {
      y = swapY ? alignToElRegion.top - myHeight : viewportHeight + scrollY - myHeight;
    }
    if (y < scrollY) {
      y = swapY ? alignToElRegion.bottom : scrollY;
    }
  }
  return [x, y];
}, getAnchor:function() {
  var el = this.el, data = (el.$cache || el.getCache()).data, anchor;
  if (!el.dom) {
    return;
  }
  anchor = data._anchor;
  if (!anchor) {
    anchor = data._anchor = {};
  }
  return anchor;
}, getAnchorXY:function(anchor, local, mySize) {
  var me = this, myPos = me.getXY(), el = me.el, doc = document, isViewport = el.dom == doc.body || el.dom == doc, scroll = el.getScroll(), extraX = isViewport ? scroll.left : local ? 0 : myPos[0], extraY = isViewport ? scroll.top : local ? 0 : myPos[1];
  return me.calculateAnchorXY(anchor, extraX, extraY, mySize);
}, getBox:function(contentBox, local) {
  var me = this, xy = local ? me.getLocalXY() : me.getXY(), x = xy[0], y = xy[1], w = me.getWidth(), h = me.getHeight(), borderPadding, beforeX, beforeY;
  if (contentBox) {
    borderPadding = me.getBorderPadding();
    beforeX = borderPadding.beforeX;
    beforeY = borderPadding.beforeY;
    x += beforeX;
    y += beforeY;
    w -= beforeX + borderPadding.afterX;
    h -= beforeY + borderPadding.afterY;
  }
  return {x:x, left:x, 0:x, y:y, top:y, 1:y, width:w, height:h, right:x + w, bottom:y + h};
}, calculateConstrainedPosition:function(constrainTo, proposedPosition, local, proposedSize) {
  var me = this, vector, fp = me.floatParent, parentNode = fp ? fp.getTargetEl() : null, parentOffset, borderPadding, proposedConstrainPosition, xy = false;
  if (local && fp) {
    parentOffset = parentNode.getXY();
    borderPadding = parentNode.getBorderPadding();
    parentOffset[0] += borderPadding.beforeX;
    parentOffset[1] += borderPadding.beforeY;
    if (proposedPosition) {
      proposedConstrainPosition = [proposedPosition[0] + parentOffset[0], proposedPosition[1] + parentOffset[1]];
    }
  } else {
    proposedConstrainPosition = proposedPosition;
  }
  constrainTo = constrainTo || me.constrainTo || parentNode || me.container || me.el.parent();
  vector = (me.constrainHeader ? me.header : me).getConstrainVector(constrainTo, proposedConstrainPosition, proposedSize);
  if (vector) {
    xy = proposedPosition || me.getPosition(local);
    xy[0] += vector[0];
    xy[1] += vector[1];
  }
  return xy;
}, getConstrainVector:function(constrainTo, proposedPosition, proposedSize) {
  var thisRegion = this.getRegion(), vector = [0, 0], shadowSize = this.shadow && this.constrainShadow && !this.shadowDisabled ? this.shadow.getShadowSize() : undefined, overflowed = false, constraintInsets = this.constraintInsets;
  if (!(constrainTo instanceof Ext.util.Region)) {
    constrainTo = Ext.get(constrainTo.el || constrainTo).getViewRegion();
  }
  if (constraintInsets) {
    constraintInsets = Ext.isObject(constraintInsets) ? constraintInsets : Ext.Element.parseBox(constraintInsets);
    constrainTo.adjust(constraintInsets.top, constraintInsets.right, constraintInsets.bottom, constraintInsets.length);
  }
  if (proposedPosition) {
    thisRegion.translateBy(proposedPosition[0] - thisRegion.x, proposedPosition[1] - thisRegion.y);
  }
  if (proposedSize) {
    thisRegion.right = thisRegion.left + proposedSize[0];
    thisRegion.bottom = thisRegion.top + proposedSize[1];
  }
  if (shadowSize) {
    constrainTo.adjust(shadowSize[0], -shadowSize[1], -shadowSize[2], shadowSize[3]);
  }
  if (thisRegion.right > constrainTo.right) {
    overflowed = true;
    vector[0] = constrainTo.right - thisRegion.right;
  }
  if (thisRegion.left + vector[0] < constrainTo.left) {
    overflowed = true;
    vector[0] = constrainTo.left - thisRegion.left;
  }
  if (thisRegion.bottom > constrainTo.bottom) {
    overflowed = true;
    vector[1] = constrainTo.bottom - thisRegion.bottom;
  }
  if (thisRegion.top + vector[1] < constrainTo.top) {
    overflowed = true;
    vector[1] = constrainTo.top - thisRegion.top;
  }
  return overflowed ? vector : false;
}, getOffsetsTo:function(offsetsTo) {
  var o = this.getXY(), e = Ext.fly(offsetsTo.el || offsetsTo, '_internal').getXY();
  return [o[0] - e[0], o[1] - e[1]];
}, getRegion:function() {
  var box = this.getBox();
  return new Ext.util.Region(box.top, box.right, box.bottom, box.left);
}, getViewRegion:function() {
  var me = this, el = me.el, isBody = el.dom.nodeName === 'BODY', borderPadding, scroll, pos, top, left, width, height;
  if (isBody) {
    scroll = el.getScroll();
    left = scroll.left;
    top = scroll.top;
    width = Ext.dom.AbstractElement.getViewportWidth();
    height = Ext.dom.AbstractElement.getViewportHeight();
  } else {
    borderPadding = me.getBorderPadding();
    pos = me.getXY();
    left = pos[0] + borderPadding.beforeX;
    top = pos[1] + borderPadding.beforeY;
    width = me.getWidth(true);
    height = me.getHeight(true);
  }
  return new Ext.util.Region(top, left + width, top + height, left);
}, move:function(direction, distance, animate) {
  var me = this, xy = me.getXY(), x = xy[0], y = xy[1], left = [x - distance, y], right = [x + distance, y], top = [x, y - distance], bottom = [x, y + distance], hash = {l:left, left:left, r:right, right:right, t:top, top:top, up:top, b:bottom, bottom:bottom, down:bottom};
  direction = direction.toLowerCase();
  me.setXY([hash[direction][0], hash[direction][1]], animate);
}, removeAnchor:function() {
  var anchor = this.getAnchor();
  if (anchor && anchor.fn) {
    Ext.EventManager.removeResizeListener(anchor.fn);
    if (anchor.scroll) {
      Ext.EventManager.un(window, 'scroll', anchor.fn);
    }
    delete anchor.fn;
  }
  return this;
}, setBox:function(box, animate) {
  var me = this, el = me.el, x = box.x, y = box.y, xy = [x, y], w = box.width, h = box.height, doConstrain = me.constrain || me.constrainHeader, constrainedPos = doConstrain && me.calculateConstrainedPosition(null, [x, y], false, [w, h]);
  if (constrainedPos) {
    x = constrainedPos[0];
    y = constrainedPos[1];
  }
  if (!animate || !el.anim) {
    me.setSize(w, h);
    me.setXY([x, y]);
    me.afterSetPosition(x, y);
  } else {
    me.animate(Ext.applyIf({to:{x:x, y:y, width:el.adjustWidth(w), height:el.adjustHeight(h)}, listeners:{afteranimate:Ext.Function.bind(me.afterSetPosition, me, [x, y])}}, animate));
  }
  return me;
}, setRegion:function(region, animate) {
  return this.setBox({x:region.left, y:region.top, width:region.right - region.left, height:region.bottom - region.top}, animate);
}, translatePoints:function(x, y) {
  var pos = this.translateXY(x, y);
  return {left:pos.x, top:pos.y};
}, translateXY:function(x, y) {
  var me = this, el = me.el, styles = el.getStyle(me._positionTopLeft), relative = styles.position == 'relative', left = parseFloat(styles.left), top = parseFloat(styles.top), xy = me.getXY();
  if (Ext.isArray(x)) {
    y = x[1];
    x = x[0];
  }
  if (isNaN(left)) {
    left = relative ? 0 : el.dom.offsetLeft;
  }
  if (isNaN(top)) {
    top = relative ? 0 : el.dom.offsetTop;
  }
  left = typeof x == 'number' ? x - xy[0] + left : undefined;
  top = typeof y == 'number' ? y - xy[1] + top : undefined;
  return {x:left, y:top};
}});
Ext.define('Ext.dom.Element', function(Element) {
  var HIDDEN = 'hidden', DOC = document, VISIBILITY = 'visibility', DISPLAY = 'display', NONE = 'none', XMASKED = Ext.baseCSSPrefix + 'masked', XMASKEDRELATIVE = Ext.baseCSSPrefix + 'masked-relative', EXTELMASKMSG = Ext.baseCSSPrefix + 'mask-msg', bodyRe = /^body/i, visFly, noBoxAdjust = Ext.isStrict ? {select:1} : {input:1, select:1, textarea:1}, isScrolled = function(c) {
    var r = [], ri = -1, i, ci;
    for (i = 0; ci = c[i]; i++) {
      if (ci.scrollTop > 0 || ci.scrollLeft > 0) {
        r[++ri] = ci;
      }
    }
    return r;
  };
  return {extend:Ext.dom.AbstractElement, alternateClassName:['Ext.Element', 'Ext.core.Element'], tableTagRe:/^(?:tr|td|table|tbody)$/i, mixins:[Ext.util.Positionable], addUnits:function() {
    return Element.addUnits.apply(Element, arguments);
  }, focus:function(defer, dom) {
    var me = this;
    dom = dom || me.dom;
    try {
      if (Number(defer)) {
        Ext.defer(me.focus, defer, me, [null, dom]);
      } else {
        dom.focus();
      }
    } catch (e$15) {
    }
    return me;
  }, blur:function() {
    var me = this, dom = me.dom;
    if (dom !== document.body) {
      try {
        dom.blur();
      } catch (e$16) {
      }
      return me;
    } else {
      return me.focus(undefined, dom);
    }
  }, isBorderBox:function() {
    var box = Ext.isBorderBox;
    if (box && Ext.isIE7m) {
      box = !((this.dom.tagName || '').toLowerCase() in noBoxAdjust);
    }
    return box;
  }, hover:function(overFn, outFn, scope, options) {
    var me = this;
    me.on('mouseenter', overFn, scope || me.dom, options);
    me.on('mouseleave', outFn, scope || me.dom, options);
    return me;
  }, getAttributeNS:function(ns, name) {
    return this.getAttribute(name, ns);
  }, getAttribute:Ext.isIE && !(Ext.isIE9p && DOC.documentMode >= 9) ? function(name, ns) {
    var d = this.dom, type;
    if (ns) {
      type = typeof d[ns + ':' + name];
      if (type != 'undefined' && type != 'unknown') {
        return d[ns + ':' + name] || null;
      }
      return null;
    }
    if (name === 'for') {
      name = 'htmlFor';
    }
    return d[name] || null;
  } : function(name, ns) {
    var d = this.dom;
    if (ns) {
      return d.getAttributeNS(ns, name) || d.getAttribute(ns + ':' + name);
    }
    return d.getAttribute(name) || d[name] || null;
  }, cacheScrollValues:function() {
    var me = this, scrolledDescendants, el, i, scrollValues = [], result = function() {
      for (i = 0; i < scrolledDescendants.length; i++) {
        el = scrolledDescendants[i];
        el.scrollLeft = scrollValues[i][0];
        el.scrollTop = scrollValues[i][1];
      }
    };
    if (!Ext.DomQuery.pseudos.isScrolled) {
      Ext.DomQuery.pseudos.isScrolled = isScrolled;
    }
    scrolledDescendants = me.query(':isScrolled');
    for (i = 0; i < scrolledDescendants.length; i++) {
      el = scrolledDescendants[i];
      scrollValues[i] = [el.scrollLeft, el.scrollTop];
    }
    return result;
  }, autoBoxAdjust:true, isVisible:function(deep) {
    var me = this, dom = me.dom, stopNode = dom.ownerDocument.documentElement;
    if (!visFly) {
      visFly = new Element.Fly;
    }
    while (dom !== stopNode) {
      if (!dom || dom.nodeType === 11 || visFly.attach(dom).isStyle(VISIBILITY, HIDDEN) || visFly.isStyle(DISPLAY, NONE)) {
        return false;
      }
      if (!deep) {
        break;
      }
      dom = dom.parentNode;
    }
    return true;
  }, isDisplayed:function() {
    return !this.isStyle(DISPLAY, NONE);
  }, enableDisplayMode:function(display) {
    var me = this;
    me.setVisibilityMode(Element.DISPLAY);
    if (!Ext.isEmpty(display)) {
      (me.$cache || me.getCache()).data.originalDisplay = display;
    }
    return me;
  }, mask:function(msg, msgCls, elHeight) {
    var me = this, dom = me.dom, setExpression = dom.style.setExpression, data = (me.$cache || me.getCache()).data, maskShimEl = data.maskShimEl, maskEl = data.maskEl, maskMsg = data.maskMsg, widthExpression, heightExpression;
    if (!(bodyRe.test(dom.tagName) && me.getStyle('position') == 'static')) {
      me.addCls(XMASKEDRELATIVE);
    }
    if (maskEl) {
      maskEl.remove();
    }
    if (maskMsg) {
      maskMsg.remove();
    }
    if (maskShimEl) {
      maskShimEl.remove();
    }
    if (Ext.isIE6) {
      maskShimEl = Ext.DomHelper.append(dom, {tag:'iframe', cls:Ext.baseCSSPrefix + 'shim ' + Ext.baseCSSPrefix + 'mask-shim'}, true);
      data.maskShimEl = maskShimEl;
      maskShimEl.setDisplayed(true);
    }
    Ext.DomHelper.append(dom, [{cls:Ext.baseCSSPrefix + 'mask', style:'top:0;left:0;'}, {cls:msgCls ? EXTELMASKMSG + ' ' + msgCls : EXTELMASKMSG, cn:{tag:'div', cls:Ext.baseCSSPrefix + 'mask-msg-inner', cn:{tag:'div', cls:Ext.baseCSSPrefix + 'mask-msg-text', html:msg || ''}}}]);
    maskMsg = Ext.get(dom.lastChild);
    maskEl = Ext.get(maskMsg.dom.previousSibling);
    data.maskMsg = maskMsg;
    data.maskEl = maskEl;
    me.addCls(XMASKED);
    maskEl.setDisplayed(true);
    if (typeof msg == 'string') {
      maskMsg.setDisplayed(true);
      maskMsg.center(me);
    } else {
      maskMsg.setDisplayed(false);
    }
    if (!Ext.supports.IncludePaddingInWidthCalculation && setExpression) {
      try {
        maskEl.dom.style.setExpression('width', 'this.parentNode.clientWidth + "px"');
        widthExpression = 'this.parentNode.clientWidth + "px"';
        if (maskShimEl) {
          maskShimEl.dom.style.setExpression('width', widthExpression);
        }
        maskEl.dom.style.setExpression('width', widthExpression);
      } catch (e$17) {
      }
    }
    if (!Ext.supports.IncludePaddingInHeightCalculation && setExpression) {
      try {
        heightExpression = 'this.parentNode.' + (dom == DOC.body ? 'scrollHeight' : 'offsetHeight') + ' + "px"';
        if (maskShimEl) {
          maskShimEl.dom.style.setExpression('height', heightExpression);
        }
        maskEl.dom.style.setExpression('height', heightExpression);
      } catch (e$18) {
      }
    } else {
      if (Ext.isIE9m && !(Ext.isIE7 && Ext.isStrict) && me.getStyle('height') == 'auto') {
        if (maskShimEl) {
          maskShimEl.setSize(undefined, elHeight || me.getHeight());
        }
        maskEl.setSize(undefined, elHeight || me.getHeight());
      }
    }
    return maskEl;
  }, unmask:function() {
    var me = this, data = (me.$cache || me.getCache()).data, maskEl = data.maskEl, maskShimEl = data.maskShimEl, maskMsg = data.maskMsg, style;
    if (maskEl) {
      style = maskEl.dom.style;
      if (style.clearExpression) {
        style.clearExpression('width');
        style.clearExpression('height');
      }
      if (maskEl) {
        maskEl.remove();
        delete data.maskEl;
      }
      if (maskMsg) {
        maskMsg.remove();
        delete data.maskMsg;
      }
      me.removeCls([XMASKED, XMASKEDRELATIVE]);
      if (maskShimEl) {
        style = maskShimEl.dom.style;
        if (style.clearExpression) {
          style.clearExpression('width');
          style.clearExpression('height');
        }
        maskShimEl.remove();
        delete data.maskShimEl;
      }
    }
  }, isMasked:function() {
    var me = this, data = (me.$cache || me.getCache()).data, maskEl = data.maskEl, maskMsg = data.maskMsg, hasMask = false;
    if (maskEl && maskEl.isVisible()) {
      if (maskMsg) {
        maskMsg.center(me);
      }
      hasMask = true;
    }
    return hasMask;
  }, createShim:function() {
    var el = DOC.createElement('iframe'), shim;
    el.frameBorder = '0';
    el.className = Ext.baseCSSPrefix + 'shim';
    el.src = Ext.SSL_SECURE_URL;
    shim = Ext.get(this.dom.parentNode.insertBefore(el, this.dom));
    shim.autoBoxAdjust = false;
    return shim;
  }, addKeyListener:function(key, fn, scope) {
    var config;
    if (typeof key != 'object' || Ext.isArray(key)) {
      config = {target:this, key:key, fn:fn, scope:scope};
    } else {
      config = {target:this, key:key.key, shift:key.shift, ctrl:key.ctrl, alt:key.alt, fn:fn, scope:scope};
    }
    return new Ext.util.KeyMap(config);
  }, addKeyMap:function(config) {
    return new Ext.util.KeyMap(Ext.apply({target:this}, config));
  }, on:function(eventName, fn, scope, options) {
    Ext.EventManager.on(this, eventName, fn, scope || this, options);
    return this;
  }, un:function(eventName, fn, scope) {
    Ext.EventManager.un(this, eventName, fn, scope || this);
    return this;
  }, removeAllListeners:function() {
    Ext.EventManager.removeAll(this);
    return this;
  }, purgeAllListeners:function() {
    Ext.EventManager.purgeElement(this);
    return this;
  }, select:function(selector) {
    return Element.select(selector, false, this.dom);
  }};
}, function() {
  var DOC = document, EC = Ext.cache, Element = this, AbstractElement = Ext.dom.AbstractElement, focusRe = /^a|button|embed|iframe|input|object|select|textarea$/i, nonSpaceRe = /\S/, scriptTagRe = /(?:<script([^>]*)?>)((\n|\r|.)*?)(?:<\/script>)/ig, replaceScriptTagRe = /(?:<script.*?>)((\n|\r|.)*?)(?:<\/script>)/ig, srcRe = /\ssrc=(['"])(.*?)\1/i, typeRe = /\stype=(['"])(.*?)\1/i, useDocForId = !Ext.isIE8m, internalFly;
  Element.boxMarkup = '\x3cdiv class\x3d"{0}-tl"\x3e\x3cdiv class\x3d"{0}-tr"\x3e\x3cdiv class\x3d"{0}-tc"\x3e\x3c/div\x3e\x3c/div\x3e\x3c/div\x3e\x3cdiv class\x3d"{0}-ml"\x3e\x3cdiv class\x3d"{0}-mr"\x3e\x3cdiv class\x3d"{0}-mc"\x3e\x3c/div\x3e\x3c/div\x3e\x3c/div\x3e\x3cdiv class\x3d"{0}-bl"\x3e\x3cdiv class\x3d"{0}-br"\x3e\x3cdiv class\x3d"{0}-bc"\x3e\x3c/div\x3e\x3c/div\x3e\x3c/div\x3e';
  function garbageCollect() {
    if (!Ext.enableGarbageCollector) {
      clearInterval(Element.collectorThreadId);
    } else {
      var eid, d, o, t;
      for (eid in EC) {
        if (!EC.hasOwnProperty(eid)) {
          continue;
        }
        o = EC[eid];
        if (o.skipGarbageCollection) {
          continue;
        }
        d = o.dom;
        if (!d) {
          Ext.Error.raise('Missing DOM node in element garbage collection: ' + eid);
        }
        if (d && (d.getElementById || d.navigator)) {
          Ext.Error.raise('Unexpected document or window element in element garbage collection');
        }
        if (d && (!d.parentNode || !d.offsetParent && !Ext.getElementById(eid))) {
          if (Ext.enableListenerCollection) {
            Ext.EventManager.removeAll(d);
          }
          delete EC[eid];
        }
      }
      if (Ext.isIE) {
        t = {};
        for (eid in EC) {
          if (!EC.hasOwnProperty(eid)) {
            continue;
          }
          t[eid] = EC[eid];
        }
        EC = Ext.cache = t;
      }
    }
  }
  Element.collectorThreadId = setInterval(garbageCollect, 30000);
  Element.addMethods({monitorMouseLeave:function(delay, handler, scope) {
    var me = this, timer, listeners = {mouseleave:function(e) {
      timer = setTimeout(Ext.Function.bind(handler, scope || me, [e]), delay);
    }, mouseenter:function() {
      clearTimeout(timer);
    }, freezeEvent:true};
    me.on(listeners);
    return listeners;
  }, swallowEvent:function(eventName, preventDefault) {
    var me = this, e, eLen, fn = function(e) {
      e.stopPropagation();
      if (preventDefault) {
        e.preventDefault();
      }
    };
    if (Ext.isArray(eventName)) {
      eLen = eventName.length;
      for (e = 0; e < eLen; e++) {
        me.on(eventName[e], fn);
      }
      return me;
    }
    me.on(eventName, fn);
    return me;
  }, relayEvent:function(eventName, observable) {
    this.on(eventName, function(e) {
      observable.fireEvent(eventName, e);
    });
  }, clean:function(forceReclean) {
    var me = this, dom = me.dom, data = (me.$cache || me.getCache()).data, n = dom.firstChild, ni = -1, nx;
    if (data.isCleaned && forceReclean !== true) {
      return me;
    }
    while (n) {
      nx = n.nextSibling;
      if (n.nodeType == 3) {
        if (!nonSpaceRe.test(n.nodeValue)) {
          dom.removeChild(n);
        } else {
          if (nx && nx.nodeType == 3) {
            n.appendData(Ext.String.trim(nx.data));
            dom.removeChild(nx);
            nx = n.nextSibling;
            n.nodeIndex = ++ni;
          }
        }
      } else {
        internalFly.attach(n).clean();
        n.nodeIndex = ++ni;
      }
      n = nx;
    }
    data.isCleaned = true;
    return me;
  }, load:function(options) {
    this.getLoader().load(options);
    return this;
  }, getLoader:function() {
    var me = this, data = (me.$cache || me.getCache()).data, loader = data.loader;
    if (!loader) {
      data.loader = loader = new Ext.ElementLoader({target:me});
    }
    return loader;
  }, syncContent:function(source) {
    source = Ext.getDom(source);
    var sourceNodes = source.childNodes, sourceLen = sourceNodes.length, dest = this.dom, destNodes = dest.childNodes, destLen = destNodes.length, i, destNode, sourceNode, nodeType, newAttrs, attLen, attName;
    if (Ext.isIE9m && dest.mergeAttributes) {
      dest.mergeAttributes(source, true);
      dest.src = source.src;
    } else {
      newAttrs = source.attributes;
      attLen = newAttrs.length;
      for (i = 0; i < attLen; i++) {
        attName = newAttrs[i].name;
        if (attName !== 'id') {
          dest.setAttribute(attName, newAttrs[i].value);
        }
      }
    }
    if (sourceLen !== destLen) {
      dest.innerHTML = source.innerHTML;
      return;
    }
    for (i = 0; i < sourceLen; i++) {
      sourceNode = sourceNodes[i];
      destNode = destNodes[i];
      nodeType = sourceNode.nodeType;
      if (nodeType !== destNode.nodeType || nodeType === 1 && sourceNode.tagName !== destNode.tagName) {
        dest.innerHTML = source.innerHTML;
        return;
      }
      if (nodeType === 3) {
        destNode.data = sourceNode.data;
      } else {
        if (sourceNode.id && destNode.id !== sourceNode.id) {
          destNode.id = sourceNode.id;
        }
        destNode.style.cssText = sourceNode.style.cssText;
        destNode.className = sourceNode.className;
        internalFly.attach(destNode).syncContent(sourceNode);
      }
    }
  }, update:function(html, loadScripts, callback) {
    var me = this, id, dom, interval;
    if (!me.dom) {
      return me;
    }
    html = html || '';
    dom = me.dom;
    if (loadScripts !== true) {
      dom.innerHTML = html;
      Ext.callback(callback, me);
      return me;
    }
    id = Ext.id();
    html += '\x3cspan id\x3d"' + id + '"\x3e\x3c/span\x3e';
    interval = setInterval(function() {
      var hd, match, attrs, srcMatch, typeMatch, el, s;
      if (!(el = DOC.getElementById(id))) {
        return false;
      }
      clearInterval(interval);
      Ext.removeNode(el);
      hd = Ext.getHead().dom;
      while (match = scriptTagRe.exec(html)) {
        attrs = match[1];
        srcMatch = attrs ? attrs.match(srcRe) : false;
        if (srcMatch && srcMatch[2]) {
          s = DOC.createElement('script');
          s.src = srcMatch[2];
          typeMatch = attrs.match(typeRe);
          if (typeMatch && typeMatch[2]) {
            s.type = typeMatch[2];
          }
          hd.appendChild(s);
        } else {
          if (match[2] && match[2].length > 0) {
            if (window.execScript) {
              window.execScript(match[2]);
            } else {
              window.eval(match[2]);
            }
          }
        }
      }
      Ext.callback(callback, me);
    }, 20);
    dom.innerHTML = html.replace(replaceScriptTagRe, '');
    return me;
  }, removeAllListeners:function() {
    this.removeAnchor();
    Ext.EventManager.removeAll(this.dom);
    return this;
  }, createProxy:function(config, renderTo, matchBox) {
    config = typeof config == 'object' ? config : {tag:'div', cls:config};
    var me = this, proxy = renderTo ? Ext.DomHelper.append(renderTo, config, true) : Ext.DomHelper.insertBefore(me.dom, config, true);
    proxy.setVisibilityMode(Element.DISPLAY);
    proxy.hide();
    if (matchBox && me.setBox && me.getBox) {
      proxy.setBox(me.getBox());
    }
    return proxy;
  }, needsTabIndex:function() {
    if (this.dom) {
      if (this.dom.nodeName === 'a' && !this.dom.href) {
        return true;
      }
      return !focusRe.test(this.dom.nodeName);
    }
  }, isFocusable:function(asFocusEl) {
    var dom = this.dom, tabIndexAttr = dom.getAttributeNode('tabIndex'), tabIndex, nodeName = dom.nodeName, canFocus = false;
    if (tabIndexAttr && tabIndexAttr.specified) {
      tabIndex = tabIndexAttr.value;
    }
    if (dom && !dom.disabled) {
      if (tabIndex == -1) {
        canFocus = Ext.FocusManager && Ext.FocusManager.enabled && asFocusEl;
      } else {
        if (focusRe.test(nodeName)) {
          if (nodeName !== 'a' || dom.href) {
            canFocus = true;
          }
        } else {
          canFocus = tabIndex != null && tabIndex >= 0;
        }
      }
      canFocus = canFocus && this.isVisible(true);
    }
    return canFocus;
  }});
  if (Ext.isIE) {
    Element.prototype.getById = function(id, asDom) {
      var dom = this.dom, cacheItem, el, ret;
      if (dom) {
        el = useDocForId && DOC.getElementById(id) || dom.all[id];
        if (el) {
          if (asDom) {
            ret = el;
          } else {
            cacheItem = EC[id];
            if (cacheItem && cacheItem.el) {
              ret = Ext.updateCacheEntry(cacheItem, el).el;
            } else {
              ret = new Element(el);
            }
          }
          return ret;
        }
      }
      return asDom ? Ext.getDom(id) : Element.get(id);
    };
  }
  Element.createAlias({addListener:'on', removeListener:'un', clearListeners:'removeAllListeners', focusable:'isFocusable'});
  Element.Fly = AbstractElement.Fly = new Ext.Class({extend:Element, isFly:true, constructor:function(dom) {
    this.dom = dom;
    this.el = this;
  }, attach:AbstractElement.Fly.prototype.attach});
  internalFly = new Element.Fly;
  if (Ext.isIE) {
    Ext.getElementById = function(id) {
      var el = DOC.getElementById(id), detachedBodyEl;
      if (!el && (detachedBodyEl = AbstractElement.detachedBodyEl)) {
        el = detachedBodyEl.dom.all[id];
      }
      return el;
    };
  } else {
    if (!DOC.querySelector) {
      Ext.getDetachedBody = Ext.getBody;
      Ext.getElementById = function(id) {
        return DOC.getElementById(id);
      };
    }
  }
});
Ext.define('Ext.dom.CompositeElementLite', {alternateClassName:'Ext.CompositeElementLite', statics:{importElementMethods:function() {
  var name, elementPrototype = Ext.dom.Element.prototype, prototype = this.prototype;
  for (name in elementPrototype) {
    if (typeof elementPrototype[name] == 'function') {
      (function(key) {
        prototype[key] = prototype[key] || function() {
          return this.invoke(key, arguments);
        };
      }).call(prototype, name);
    }
  }
}}, constructor:function(elements, root) {
  this.elements = [];
  this.add(elements, root);
  this.el = new Ext.dom.AbstractElement.Fly;
}, isComposite:true, getElement:function(el) {
  return this.el.attach(el);
}, transformElement:function(el) {
  return Ext.getDom(el);
}, getCount:function() {
  return this.elements.length;
}, add:function(els, root) {
  var elements = this.elements, i, ln;
  if (!els) {
    return this;
  }
  if (typeof els == 'string') {
    els = Ext.dom.Element.selectorFunction(els, root);
  } else {
    if (els.isComposite) {
      els = els.elements;
    } else {
      if (!Ext.isIterable(els)) {
        els = [els];
      }
    }
  }
  for (i = 0, ln = els.length; i < ln; ++i) {
    elements.push(this.transformElement(els[i]));
  }
  return this;
}, invoke:function(fn, args) {
  var elements = this.elements, ln = elements.length, element, i;
  fn = Ext.dom.Element.prototype[fn];
  for (i = 0; i < ln; i++) {
    element = elements[i];
    if (element) {
      fn.apply(this.getElement(element), args);
    }
  }
  return this;
}, item:function(index) {
  var el = this.elements[index], out = null;
  if (el) {
    out = this.getElement(el);
  }
  return out;
}, slice:function() {
  return this.elements.slice.apply(this.elements, arguments);
}, addListener:function(eventName, handler, scope, opt) {
  var els = this.elements, len = els.length, i, e;
  for (i = 0; i < len; i++) {
    e = els[i];
    if (e) {
      Ext.EventManager.on(e, eventName, handler, scope || e, opt);
    }
  }
  return this;
}, each:function(fn, scope) {
  var me = this, els = me.elements, len = els.length, i, e;
  for (i = 0; i < len; i++) {
    e = els[i];
    if (e) {
      e = this.getElement(e);
      if (fn.call(scope || e, e, me, i) === false) {
        break;
      }
    }
  }
  return me;
}, fill:function(els) {
  var me = this;
  me.elements = [];
  me.add(els);
  return me;
}, insert:function(index, nodes) {
  Ext.Array.insert(this.elements, index, nodes);
}, filter:function(selector) {
  var me = this, els = me.elements, len = els.length, out = [], i = 0, isFunc = typeof selector == 'function', add, el;
  for (; i < len; i++) {
    el = els[i];
    add = false;
    if (el) {
      el = me.getElement(el);
      if (isFunc) {
        add = selector.call(el, el, me, i) !== false;
      } else {
        add = el.is(selector);
      }
      if (add) {
        out.push(me.transformElement(el));
      }
    }
  }
  me.elements = out;
  return me;
}, indexOf:function(el) {
  return Ext.Array.indexOf(this.elements, this.transformElement(el));
}, replaceElement:function(el, replacement, domReplace) {
  var index = !isNaN(el) ? el : this.indexOf(el), d;
  if (index > -1) {
    replacement = Ext.getDom(replacement);
    if (domReplace) {
      d = this.elements[index];
      d.parentNode.insertBefore(replacement, d);
      Ext.removeNode(d);
    }
    Ext.Array.splice(this.elements, index, 1, replacement);
  }
  return this;
}, clear:function(removeDom) {
  var me = this, els = me.elements, i = els.length - 1;
  if (removeDom) {
    for (; i >= 0; i--) {
      Ext.removeNode(els[i]);
    }
  }
  this.elements = [];
}, addElements:function(els, root) {
  if (!els) {
    return this;
  }
  if (typeof els == 'string') {
    els = Ext.dom.Element.selectorFunction(els, root);
  }
  var yels = this.elements, eLen = els.length, e;
  for (e = 0; e < eLen; e++) {
    yels.push(Ext.get(els[e]));
  }
  return this;
}, first:function() {
  return this.item(0);
}, last:function() {
  return this.item(this.getCount() - 1);
}, contains:function(el) {
  return this.indexOf(el) != -1;
}, removeElement:function(keys, removeDom) {
  keys = [].concat(keys);
  var me = this, elements = me.elements, kLen = keys.length, val, el, k;
  for (k = 0; k < kLen; k++) {
    val = keys[k];
    if (el = elements[val] || elements[val = me.indexOf(val)]) {
      if (removeDom) {
        if (el.dom) {
          el.remove();
        } else {
          Ext.removeNode(el);
        }
      }
      Ext.Array.erase(elements, val, 1);
    }
  }
  return me;
}}, function() {
  this.importElementMethods();
  this.prototype.on = this.prototype.addListener;
  if (Ext.DomQuery) {
    Ext.dom.Element.selectorFunction = Ext.DomQuery.select;
  }
  Ext.dom.Element.select = function(selector, root) {
    var elements;
    if (typeof selector == 'string') {
      elements = Ext.dom.Element.selectorFunction(selector, root);
    } else {
      if (selector.length !== undefined) {
        elements = selector;
      } else {
        throw new Error('[Ext.select] Invalid selector specified: ' + selector);
      }
    }
    return new Ext.CompositeElementLite(elements);
  };
  Ext.select = function() {
    return Ext.dom.Element.select.apply(Ext.dom.Element, arguments);
  };
});
Ext.define('Ext.dom.CompositeElement', {alternateClassName:'Ext.CompositeElement', extend:Ext.dom.CompositeElementLite, getElement:function(el) {
  return el;
}, transformElement:function(el) {
  return Ext.get(el);
}}, function() {
  Ext.dom.Element.select = function(selector, unique, root) {
    var elements;
    if (typeof selector == 'string') {
      elements = Ext.dom.Element.selectorFunction(selector, root);
    } else {
      if (selector.length !== undefined) {
        elements = selector;
      } else {
        throw new Error('[Ext.select] Invalid selector specified: ' + selector);
      }
    }
    return unique === true ? new Ext.CompositeElement(elements) : new Ext.CompositeElementLite(elements);
  };
});
Ext.select = Ext.Element.select;
Ext.define('Ext.util.HashMap', {mixins:{observable:Ext.util.Observable}, generation:0, constructor:function(config) {
  config = config || {};
  var me = this, keyFn = config.keyFn;
  me.initialConfig = config;
  me.addEvents('add', 'clear', 'remove', 'replace');
  me.mixins.observable.constructor.call(me, config);
  me.clear(true);
  if (keyFn) {
    me.getKey = keyFn;
  }
}, getCount:function() {
  return this.length;
}, getData:function(key, value) {
  if (value === undefined) {
    value = key;
    key = this.getKey(value);
  }
  return [key, value];
}, getKey:function(o) {
  return o.id;
}, add:function(key, value) {
  var me = this;
  if (arguments.length === 1) {
    value = key;
    key = me.getKey(value);
  }
  if (me.containsKey(key)) {
    return me.replace(key, value);
  }
  me.map[key] = value;
  ++me.length;
  me.generation++;
  if (me.hasListeners.add) {
    me.fireEvent('add', me, key, value);
  }
  return value;
}, replace:function(key, value) {
  var me = this, map = me.map, old;
  if (arguments.length === 1) {
    value = key;
    key = me.getKey(value);
  }
  if (!me.containsKey(key)) {
    me.add(key, value);
  }
  old = map[key];
  map[key] = value;
  me.generation++;
  if (me.hasListeners.replace) {
    me.fireEvent('replace', me, key, value, old);
  }
  return value;
}, remove:function(o) {
  var key = this.findKey(o);
  if (key !== undefined) {
    return this.removeAtKey(key);
  }
  return false;
}, removeAtKey:function(key) {
  var me = this, value;
  if (me.containsKey(key)) {
    value = me.map[key];
    delete me.map[key];
    --me.length;
    me.generation++;
    if (me.hasListeners.remove) {
      me.fireEvent('remove', me, key, value);
    }
    return true;
  }
  return false;
}, get:function(key) {
  var map = this.map;
  return map.hasOwnProperty(key) ? map[key] : undefined;
}, clear:function(initial) {
  var me = this;
  if (initial || me.generation) {
    me.map = {};
    me.length = 0;
    me.generation = initial ? 0 : me.generation + 1;
  }
  if (initial !== true && me.hasListeners.clear) {
    me.fireEvent('clear', me);
  }
  return me;
}, containsKey:function(key) {
  var map = this.map;
  return map.hasOwnProperty(key) && map[key] !== undefined;
}, contains:function(value) {
  return this.containsKey(this.findKey(value));
}, getKeys:function() {
  return this.getArray(true);
}, getValues:function() {
  return this.getArray(false);
}, getArray:function(isKey) {
  var arr = [], key, map = this.map;
  for (key in map) {
    if (map.hasOwnProperty(key)) {
      arr.push(isKey ? key : map[key]);
    }
  }
  return arr;
}, each:function(fn, scope) {
  var items = Ext.apply({}, this.map), key, length = this.length;
  scope = scope || this;
  for (key in items) {
    if (items.hasOwnProperty(key)) {
      if (fn.call(scope, key, items[key], length) === false) {
        break;
      }
    }
  }
  return this;
}, clone:function() {
  var hash = new this.self(this.initialConfig), map = this.map, key;
  hash.suspendEvents();
  for (key in map) {
    if (map.hasOwnProperty(key)) {
      hash.add(key, map[key]);
    }
  }
  hash.resumeEvents();
  return hash;
}, findKey:function(value) {
  var key, map = this.map;
  for (key in map) {
    if (map.hasOwnProperty(key) && map[key] === value) {
      return key;
    }
  }
  return undefined;
}});
Ext.define('Ext.AbstractManager', {typeName:'type', constructor:function(config) {
  Ext.apply(this, config || {});
  this.all = new Ext.util.HashMap;
  this.types = {};
}, get:function(id) {
  return this.all.get(id);
}, register:function(item) {
  var all = this.all, key = all.getKey(item);
  if (all.containsKey(key)) {
    Ext.Error.raise('Registering duplicate id "' + key + '" with this manager');
  }
  this.all.add(item);
}, unregister:function(item) {
  this.all.remove(item);
}, registerType:function(type, cls) {
  this.types[type] = cls;
  cls[this.typeName] = type;
}, isRegistered:function(type) {
  return this.types[type] !== undefined;
}, create:function(config, defaultType) {
  var type = config[this.typeName] || config.type || defaultType, Constructor = this.types[type];
  if (Constructor === undefined) {
    Ext.Error.raise("The '" + type + "' type has not been registered with this manager");
  }
  return new Constructor(config);
}, onAvailable:function(id, fn, scope) {
  var all = this.all, item, callback;
  if (all.containsKey(id)) {
    item = all.get(id);
    fn.call(scope || item, item);
  } else {
    callback = function(map, key, item) {
      if (key == id) {
        fn.call(scope || item, item);
        all.un('add', callback);
      }
    };
    all.on('add', callback);
  }
}, each:function(fn, scope) {
  this.all.each(fn, scope || this);
}, getCount:function() {
  return this.all.getCount();
}});
Ext.define('Ext.ComponentManager', {extend:Ext.AbstractManager, alternateClassName:'Ext.ComponentMgr', singleton:true, typeName:'xtype', create:function(component, defaultType) {
  if (typeof component == 'string') {
    return Ext.widget(component);
  }
  if (component.isComponent) {
    return component;
  }
  return Ext.widget(component.xtype || defaultType, component);
}, registerType:function(type, cls) {
  this.types[type] = cls;
  cls[this.typeName] = type;
  cls.prototype[this.typeName] = type;
}}, function() {
  Ext.getCmp = function(id) {
    return Ext.ComponentManager.get(id);
  };
});
Ext.define('Ext.ComponentQuery', {singleton:true}, function() {
  var cq = this, domQueryOperators = Ext.dom.Query.operators, nthRe = /(\d*)n\+?(\d*)/, nthRe2 = /\D/, filterFnPattern = ['var r \x3d [],', 'i \x3d 0,', 'it \x3d items,', 'l \x3d it.length,', 'c;', 'for (; i \x3c l; i++) {', 'c \x3d it[i];', 'if (c.{0}) {', 'r.push(c);', '}', '}', 'return r;'].join(''), filterItems = function(items, operation) {
    return operation.method.apply(this, [items].concat(operation.args));
  }, getItems = function(items, mode) {
    var result = [], i = 0, length = items.length, candidate, deep = mode !== '\x3e';
    for (; i < length; i++) {
      candidate = items[i];
      if (candidate.getRefItems) {
        result = result.concat(candidate.getRefItems(deep));
      }
    }
    return result;
  }, getAncestors = function(items) {
    var result = [], i = 0, length = items.length, candidate;
    for (; i < length; i++) {
      candidate = items[i];
      while (!!(candidate = candidate.getRefOwner())) {
        result.push(candidate);
      }
    }
    return result;
  }, filterByXType = function(items, xtype, shallow) {
    if (xtype === '*') {
      return items.slice();
    } else {
      var result = [], i = 0, length = items.length, candidate;
      for (; i < length; i++) {
        candidate = items[i];
        if (candidate.isXType(xtype, shallow)) {
          result.push(candidate);
        }
      }
      return result;
    }
  }, filterByClassName = function(items, className) {
    var result = [], i = 0, length = items.length, candidate;
    for (; i < length; i++) {
      candidate = items[i];
      if (candidate.hasCls(className)) {
        result.push(candidate);
      }
    }
    return result;
  }, filterByAttribute = function(items, property, operator, compareTo) {
    var result = [], i = 0, length = items.length, mustBeOwnProperty, presenceOnly, candidate, propValue, j, propLen;
    if (property.charAt(0) === '@') {
      mustBeOwnProperty = true;
      property = property.substr(1);
    }
    if (property.charAt(0) === '?') {
      mustBeOwnProperty = true;
      presenceOnly = true;
      property = property.substr(1);
    }
    for (; i < length; i++) {
      candidate = items[i];
      if (!mustBeOwnProperty || candidate.hasOwnProperty(property)) {
        propValue = candidate[property];
        if (presenceOnly) {
          result.push(candidate);
        } else {
          if (operator === '~\x3d') {
            if (propValue) {
              if (!Ext.isArray(propValue)) {
                propValue = propValue.split(' ');
              }
              for (j = 0, propLen = propValue.length; j < propLen; j++) {
                if (domQueryOperators[operator](Ext.coerce(propValue[j], compareTo), compareTo)) {
                  result.push(candidate);
                  break;
                }
              }
            }
          } else {
            if (!compareTo ? !!candidate[property] : domQueryOperators[operator](Ext.coerce(propValue, compareTo), compareTo)) {
              result.push(candidate);
            }
          }
        }
      }
    }
    return result;
  }, filterById = function(items, id) {
    var result = [], i = 0, length = items.length, candidate;
    for (; i < length; i++) {
      candidate = items[i];
      if (candidate.getItemId() === id) {
        result.push(candidate);
      }
    }
    return result;
  }, filterByPseudo = function(items, name, value) {
    return cq.pseudos[name](items, value);
  }, modeRe = /^(\s?([>\^])\s?|\s|$)/, tokenRe = /^(#)?([\w\-]+|\*)(?:\((true|false)\))?/, matchers = [{re:/^\.([\w\-]+)(?:\((true|false)\))?/, method:filterByXType}, {re:/^(?:\[((?:@|\?)?[\w\-\$]*[^\^\$\*~%!])\s?(?:(=|.=)\s?['"]?(.*?)["']?)?\])/, method:filterByAttribute}, {re:/^#([\w\-]+)/, method:filterById}, {re:/^:([\w\-]+)(?:\(((?:\{[^\}]+\})|(?:(?!\{)[^\s>\/]*?(?!\})))\))?/, method:filterByPseudo}, {re:/^(?:\{([^\}]+)\})/, method:filterFnPattern}];
  cq.Query = Ext.extend(Object, {constructor:function(cfg) {
    cfg = cfg || {};
    Ext.apply(this, cfg);
  }, execute:function(root) {
    var operations = this.operations, i = 0, length = operations.length, operation, workingItems;
    if (!root) {
      workingItems = Ext.ComponentManager.all.getArray();
    } else {
      if (Ext.isIterable(root)) {
        workingItems = root;
      } else {
        if (root.isMixedCollection) {
          workingItems = root.items;
        }
      }
    }
    for (; i < length; i++) {
      operation = operations[i];
      if (operation.mode === '^') {
        workingItems = getAncestors(workingItems || [root]);
      } else {
        if (operation.mode) {
          workingItems = getItems(workingItems || [root], operation.mode);
        } else {
          workingItems = filterItems(workingItems || getItems([root]), operation);
        }
      }
      if (i === length - 1) {
        return workingItems;
      }
    }
    return [];
  }, is:function(component) {
    var operations = this.operations, components = Ext.isArray(component) ? component : [component], originalLength = components.length, lastOperation = operations[operations.length - 1], ln, i;
    components = filterItems(components, lastOperation);
    if (components.length === originalLength) {
      if (operations.length > 1) {
        for (i = 0, ln = components.length; i < ln; i++) {
          if (Ext.Array.indexOf(this.execute(), components[i]) === -1) {
            return false;
          }
        }
      }
      return true;
    }
    return false;
  }});
  Ext.apply(this, {cache:{}, pseudos:{not:function(components, selector) {
    var CQ = Ext.ComponentQuery, i = 0, length = components.length, results = [], index = -1, component;
    for (; i < length; ++i) {
      component = components[i];
      if (!CQ.is(component, selector)) {
        results[++index] = component;
      }
    }
    return results;
  }, first:function(components) {
    var ret = [];
    if (components.length > 0) {
      ret.push(components[0]);
    }
    return ret;
  }, last:function(components) {
    var len = components.length, ret = [];
    if (len > 0) {
      ret.push(components[len - 1]);
    }
    return ret;
  }, focusable:function(cmps) {
    var len = cmps.length, results = [], i = 0, c;
    for (; i < len; i++) {
      c = cmps[i];
      if (c.isFocusable()) {
        results.push(c);
      }
    }
    return results;
  }, 'nth-child':function(c, a) {
    var result = [], m = nthRe.exec(a == 'even' && '2n' || a == 'odd' && '2n+1' || !nthRe2.test(a) && 'n+' + a || a), f = (m[1] || 1) - 0, l = m[2] - 0, i, n, nodeIndex;
    for (i = 0; n = c[i]; i++) {
      nodeIndex = i + 1;
      if (f == 1) {
        if (l == 0 || nodeIndex == l) {
          result.push(n);
        }
      } else {
        if ((nodeIndex + l) % f == 0) {
          result.push(n);
        }
      }
    }
    return result;
  }}, query:function(selector, root) {
    var selectors = selector.split(','), length = selectors.length, i = 0, results = [], noDupResults = [], dupMatcher = {}, query, resultsLn, cmp;
    for (; i < length; i++) {
      selector = Ext.String.trim(selectors[i]);
      query = this.cache[selector] || (this.cache[selector] = this.parse(selector));
      results = results.concat(query.execute(root));
    }
    if (length > 1) {
      resultsLn = results.length;
      for (i = 0; i < resultsLn; i++) {
        cmp = results[i];
        if (!dupMatcher[cmp.id]) {
          noDupResults.push(cmp);
          dupMatcher[cmp.id] = true;
        }
      }
      results = noDupResults;
    }
    return results;
  }, is:function(component, selector) {
    if (!selector) {
      return true;
    }
    var selectors = selector.split(','), length = selectors.length, i = 0, query;
    for (; i < length; i++) {
      selector = Ext.String.trim(selectors[i]);
      query = this.cache[selector] || (this.cache[selector] = this.parse(selector));
      if (query.is(component)) {
        return true;
      }
    }
    return false;
  }, parse:function(selector) {
    var operations = [], length = matchers.length, lastSelector, tokenMatch, matchedChar, modeMatch, selectorMatch, i, matcher, method;
    while (selector && lastSelector !== selector) {
      lastSelector = selector;
      tokenMatch = selector.match(tokenRe);
      if (tokenMatch) {
        matchedChar = tokenMatch[1];
        if (matchedChar === '#') {
          operations.push({method:filterById, args:[Ext.String.trim(tokenMatch[2])]});
        } else {
          if (matchedChar === '.') {
            operations.push({method:filterByClassName, args:[Ext.String.trim(tokenMatch[2])]});
          } else {
            operations.push({method:filterByXType, args:[Ext.String.trim(tokenMatch[2]), Boolean(tokenMatch[3])]});
          }
        }
        selector = selector.replace(tokenMatch[0], '');
      }
      while (!(modeMatch = selector.match(modeRe))) {
        for (i = 0; selector && i < length; i++) {
          matcher = matchers[i];
          selectorMatch = selector.match(matcher.re);
          method = matcher.method;
          if (selectorMatch) {
            operations.push({method:Ext.isString(matcher.method) ? Ext.functionFactory('items', Ext.String.format.apply(Ext.String, [method].concat(selectorMatch.slice(1)))) : matcher.method, args:selectorMatch.slice(1)});
            selector = selector.replace(selectorMatch[0], '');
            break;
          }
          if (i === length - 1) {
            Ext.Error.raise('Invalid ComponentQuery selector: "' + arguments[0] + '"');
          }
        }
      }
      if (modeMatch[1]) {
        operations.push({mode:modeMatch[2] || modeMatch[1]});
        selector = selector.replace(modeMatch[0], '');
      }
    }
    return new cq.Query({operations:operations});
  }});
});
Ext.define('Ext.util.ProtoElement', function() {
  var splitWords = Ext.String.splitWords, toMap = Ext.Array.toMap;
  return {isProtoEl:true, clsProp:'cls', styleProp:'style', removedProp:'removed', styleIsText:false, constructor:function(config) {
    var me = this;
    Ext.apply(me, config);
    me.classList = splitWords(me.cls);
    me.classMap = toMap(me.classList);
    delete me.cls;
    if (Ext.isFunction(me.style)) {
      me.styleFn = me.style;
      delete me.style;
    } else {
      if (typeof me.style == 'string') {
        me.style = Ext.Element.parseStyles(me.style);
      } else {
        if (me.style) {
          me.style = Ext.apply({}, me.style);
        }
      }
    }
  }, flush:function() {
    this.flushClassList = [];
    this.removedClasses = {};
    delete this.style;
    delete this.unselectableAttr;
  }, addCls:function(cls) {
    var me = this, add = typeof cls === 'string' ? splitWords(cls) : cls, length = add.length, list = me.classList, map = me.classMap, flushList = me.flushClassList, i = 0, c;
    for (; i < length; ++i) {
      c = add[i];
      if (!map[c]) {
        map[c] = true;
        list.push(c);
        if (flushList) {
          flushList.push(c);
          delete me.removedClasses[c];
        }
      }
    }
    return me;
  }, hasCls:function(cls) {
    return cls in this.classMap;
  }, removeCls:function(cls) {
    var me = this, list = me.classList, newList = me.classList = [], remove = toMap(splitWords(cls)), length = list.length, map = me.classMap, removedClasses = me.removedClasses, i, c;
    for (i = 0; i < length; ++i) {
      c = list[i];
      if (remove[c]) {
        if (removedClasses) {
          if (map[c]) {
            removedClasses[c] = true;
            Ext.Array.remove(me.flushClassList, c);
          }
        }
        delete map[c];
      } else {
        newList.push(c);
      }
    }
    return me;
  }, setStyle:function(prop, value) {
    var me = this, style = me.style || (me.style = {});
    if (typeof prop == 'string') {
      if (arguments.length === 1) {
        me.setStyle(Ext.Element.parseStyles(prop));
      } else {
        style[prop] = value;
      }
    } else {
      Ext.apply(style, prop);
    }
    return me;
  }, unselectable:function() {
    this.addCls(Ext.dom.Element.unselectableCls);
    if (Ext.isOpera) {
      this.unselectableAttr = true;
    }
  }, writeTo:function(to) {
    var me = this, classList = me.flushClassList || me.classList, removedClasses = me.removedClasses, style;
    if (me.styleFn) {
      style = Ext.apply({}, me.styleFn());
      Ext.apply(style, me.style);
    } else {
      style = me.style;
    }
    to[me.clsProp] = classList.join(' ');
    if (style) {
      to[me.styleProp] = me.styleIsText ? Ext.DomHelper.generateStyles(style) : style;
    }
    if (removedClasses) {
      removedClasses = Ext.Object.getKeys(removedClasses);
      if (removedClasses.length) {
        to[me.removedProp] = removedClasses.join(' ');
      }
    }
    if (me.unselectableAttr) {
      to.unselectable = 'on';
    }
    return to;
  }};
}());
Ext.define('Ext.PluginManager', {extend:Ext.AbstractManager, alternateClassName:'Ext.PluginMgr', singleton:true, typeName:'ptype', create:function(config, defaultType, host) {
  var result;
  if (config.init) {
    result = config;
  } else {
    if (host) {
      config = Ext.apply({}, config);
      config.cmp = host;
    } else {
      host = config.cmp;
    }
    if (config.xclass) {
      result = Ext.create(config);
    } else {
      result = Ext.ClassManager.getByAlias('plugin.' + (config.ptype || defaultType));
      if (typeof result === 'function') {
        result = new result(config);
      }
    }
  }
  if (result && host && result.setCmp && !result.setCmpCalled) {
    result.setCmp(host);
    result.setCmpCalled = true;
  }
  return result;
}, findByType:function(type, defaultsOnly) {
  var matches = [], types = this.types, name, item;
  for (name in types) {
    if (!types.hasOwnProperty(name)) {
      continue;
    }
    item = types[name];
    if (item.type == type && (!defaultsOnly || defaultsOnly === true && item.isDefault)) {
      matches.push(item);
    }
  }
  return matches;
}}, function() {
  Ext.preg = function() {
    return Ext.PluginManager.registerType.apply(Ext.PluginManager, arguments);
  };
});
Ext.define('Ext.util.Filter', {id:null, anyMatch:false, exactMatch:false, caseSensitive:false, disabled:false, operator:null, statics:{createFilterFn:function(filters) {
  return filters && filters.length ? function(candidate) {
    var isMatch = true, length = filters.length, i, filter;
    for (i = 0; isMatch && i < length; i++) {
      filter = filters[i];
      if (!filter.disabled) {
        isMatch = isMatch && filter.filterFn.call(filter.scope || filter, candidate);
      }
    }
    return isMatch;
  } : function() {
    return true;
  };
}}, operatorFns:{'\x3c':function(candidate) {
  return Ext.coerce(this.getRoot(candidate)[this.property], this.value) < this.value;
}, '\x3c\x3d':function(candidate) {
  return Ext.coerce(this.getRoot(candidate)[this.property], this.value) <= this.value;
}, '\x3d':function(candidate) {
  return Ext.coerce(this.getRoot(candidate)[this.property], this.value) == this.value;
}, '\x3e\x3d':function(candidate) {
  return Ext.coerce(this.getRoot(candidate)[this.property], this.value) >= this.value;
}, '\x3e':function(candidate) {
  return Ext.coerce(this.getRoot(candidate)[this.property], this.value) > this.value;
}, '!\x3d':function(candidate) {
  return Ext.coerce(this.getRoot(candidate)[this.property], this.value) != this.value;
}}, constructor:function(config) {
  var me = this;
  me.initialConfig = config;
  Ext.apply(me, config);
  me.filter = me.filter || me.filterFn;
  if (me.filter === undefined) {
    me.setValue(config.value);
  }
}, setValue:function(value) {
  var me = this;
  me.value = value;
  if (me.property === undefined || me.value === undefined) {
  } else {
    me.filter = me.createFilterFn();
  }
  me.filterFn = me.filter;
}, setFilterFn:function(filterFn) {
  this.filterFn = this.filter = filterFn;
}, createFilterFn:function() {
  var me = this, matcher = me.createValueMatcher(), property = me.property;
  if (me.operator) {
    return me.operatorFns[me.operator];
  } else {
    return function(item) {
      var value = me.getRoot(item)[property];
      return matcher === null ? value === null : matcher.test(value);
    };
  }
}, getRoot:function(item) {
  var root = this.root;
  return root === undefined ? item : item[root];
}, createValueMatcher:function() {
  var me = this, value = me.value, anyMatch = me.anyMatch, exactMatch = me.exactMatch, caseSensitive = me.caseSensitive, escapeRe = Ext.String.escapeRegex;
  if (value === null) {
    return value;
  }
  if (!value.exec) {
    value = String(value);
    if (anyMatch === true) {
      value = escapeRe(value);
    } else {
      value = '^' + escapeRe(value);
      if (exactMatch === true) {
        value += '$';
      }
    }
    value = new RegExp(value, caseSensitive ? '' : 'i');
  }
  return value;
}, serialize:function() {
  var me = this, result = Ext.apply({}, me.initialConfig);
  result.value = me.value;
  return result;
}}, function() {
  this.prototype.operatorFns['\x3d\x3d'] = this.prototype.operatorFns['\x3d'];
});
Ext.define('Ext.util.AbstractMixedCollection', {mixins:{observable:Ext.util.Observable}, isMixedCollection:true, generation:0, indexGeneration:0, constructor:function(allowFunctions, keyFn) {
  var me = this;
  if (arguments.length === 1 && Ext.isObject(allowFunctions)) {
    me.initialConfig = allowFunctions;
    Ext.apply(me, allowFunctions);
  } else {
    me.allowFunctions = allowFunctions === true;
    if (keyFn) {
      me.getKey = keyFn;
    }
    me.initialConfig = {allowFunctions:me.allowFunctions, getKey:me.getKey};
  }
  me.items = [];
  me.map = {};
  me.keys = [];
  me.indexMap = {};
  me.length = 0;
  me.mixins.observable.constructor.call(me);
}, allowFunctions:false, add:function(key, obj) {
  var len = this.length, out;
  if (arguments.length === 1) {
    out = this.insert(len, key);
  } else {
    out = this.insert(len, key, obj);
  }
  return out;
}, getKey:function(o) {
  return o.id;
}, replace:function(key, o) {
  var me = this, old, index;
  if (arguments.length == 1) {
    o = arguments[0];
    key = me.getKey(o);
  }
  old = me.map[key];
  if (typeof key == 'undefined' || key === null || typeof old == 'undefined') {
    return me.add(key, o);
  }
  me.generation++;
  index = me.indexOfKey(key);
  me.items[index] = o;
  me.map[key] = o;
  if (me.hasListeners.replace) {
    me.fireEvent('replace', key, old, o);
  }
  return o;
}, updateKey:function(oldKey, newKey) {
  var me = this, map = me.map, indexMap = me.indexMap, index = me.indexOfKey(oldKey), item;
  if (index > -1) {
    item = map[oldKey];
    delete map[oldKey];
    delete indexMap[oldKey];
    map[newKey] = item;
    indexMap[newKey] = index;
    me.keys[index] = newKey;
    me.generation++;
  }
}, addAll:function(objs) {
  var me = this, key;
  if (arguments.length > 1 || Ext.isArray(objs)) {
    me.insert(me.length, arguments.length > 1 ? arguments : objs);
  } else {
    for (key in objs) {
      if (objs.hasOwnProperty(key)) {
        if (me.allowFunctions || typeof objs[key] != 'function') {
          me.add(key, objs[key]);
        }
      }
    }
  }
}, each:function(fn, scope) {
  var items = Ext.Array.push([], this.items), i = 0, len = items.length, item;
  for (; i < len; i++) {
    item = items[i];
    if (fn.call(scope || item, item, i, len) === false) {
      break;
    }
  }
}, eachKey:function(fn, scope) {
  var keys = this.keys, items = this.items, i = 0, len = keys.length;
  for (; i < len; i++) {
    fn.call(scope || window, keys[i], items[i], i, len);
  }
}, findBy:function(fn, scope) {
  var keys = this.keys, items = this.items, i = 0, len = items.length;
  for (; i < len; i++) {
    if (fn.call(scope || window, items[i], keys[i])) {
      return items[i];
    }
  }
  return null;
}, insert:function(index, key, obj) {
  var out;
  if (Ext.isIterable(key)) {
    out = this.doInsert(index, key, obj);
  } else {
    if (arguments.length > 2) {
      out = this.doInsert(index, [key], [obj]);
    } else {
      out = this.doInsert(index, [key]);
    }
    out = out[0];
  }
  return out;
}, doInsert:function(index, keys, objects) {
  var me = this, itemKey, removeIndex, i, len = keys.length, deDupedLen = len, fireAdd = me.hasListeners.add, syncIndices, newKeys = {}, passedDuplicates, oldKeys, oldObjects;
  if (objects != null) {
    me.useLinearSearch = true;
  } else {
    objects = keys;
    keys = new Array(len);
    for (i = 0; i < len; i++) {
      keys[i] = this.getKey(objects[i]);
    }
  }
  me.suspendEvents();
  for (i = 0; i < len; i++) {
    itemKey = keys[i];
    removeIndex = me.indexOfKey(itemKey);
    if (removeIndex !== -1) {
      if (removeIndex < index) {
        index--;
      }
      me.removeAt(removeIndex);
    }
    if (itemKey != null) {
      if (newKeys[itemKey] != null) {
        passedDuplicates = true;
        deDupedLen--;
      }
      newKeys[itemKey] = i;
    }
  }
  me.resumeEvents();
  if (passedDuplicates) {
    oldKeys = keys;
    oldObjects = objects;
    keys = new Array(deDupedLen);
    objects = new Array(deDupedLen);
    i = 0;
    for (itemKey in newKeys) {
      keys[i] = oldKeys[newKeys[itemKey]];
      objects[i] = oldObjects[newKeys[itemKey]];
      i++;
    }
    len = deDupedLen;
  }
  syncIndices = index === me.length && me.indexGeneration === me.generation;
  Ext.Array.insert(me.items, index, objects);
  Ext.Array.insert(me.keys, index, keys);
  me.length += len;
  me.generation++;
  if (syncIndices) {
    me.indexGeneration = me.generation;
  }
  for (i = 0; i < len; i++, index++) {
    itemKey = keys[i];
    if (itemKey != null) {
      me.map[itemKey] = objects[i];
      if (syncIndices) {
        me.indexMap[itemKey] = index;
      }
    }
    if (fireAdd) {
      me.fireEvent('add', index, objects[i], itemKey);
    }
  }
  return objects;
}, remove:function(o) {
  var me = this, removeKey, index;
  if (!me.useLinearSearch && (removeKey = me.getKey(o))) {
    index = me.indexOfKey(removeKey);
  } else {
    index = Ext.Array.indexOf(me.items, o);
  }
  return index === -1 ? false : me.removeAt(index);
}, removeAll:function(items) {
  var me = this, i;
  if (items || me.hasListeners.remove) {
    if (items) {
      for (i = items.length - 1; i >= 0; --i) {
        me.remove(items[i]);
      }
    } else {
      while (me.length) {
        me.removeAt(0);
      }
    }
  } else {
    me.length = me.items.length = me.keys.length = 0;
    me.map = {};
    me.indexMap = {};
    me.generation++;
    me.indexGeneration = me.generation;
  }
}, removeAt:function(index) {
  var me = this, o, key;
  if (index < me.length && index >= 0) {
    me.length--;
    o = me.items[index];
    Ext.Array.erase(me.items, index, 1);
    key = me.keys[index];
    if (typeof key != 'undefined') {
      delete me.map[key];
    }
    Ext.Array.erase(me.keys, index, 1);
    if (me.hasListeners.remove) {
      me.fireEvent('remove', o, key);
    }
    me.generation++;
    return o;
  }
  return false;
}, removeRange:function(index, removeCount) {
  var me = this, o, key, i, limit, syncIndices, trimming;
  if (index < me.length && index >= 0) {
    if (!removeCount) {
      removeCount = 1;
    }
    limit = Math.min(index + removeCount, me.length);
    removeCount = limit - index;
    trimming = limit === me.length;
    syncIndices = trimming && me.indexGeneration === me.generation;
    for (i = index; i < limit; i++) {
      key = me.keys[i];
      if (key != null) {
        delete me.map[key];
        if (syncIndices) {
          delete me.indexMap[key];
        }
      }
    }
    o = me.items[i - 1];
    me.length -= removeCount;
    me.generation++;
    if (syncIndices) {
      me.indexGeneration = me.generation;
    }
    if (trimming) {
      me.items.length = me.keys.length = me.length;
    } else {
      me.items.splice(index, removeCount);
      me.keys.splice(index, removeCount);
    }
    return o;
  }
  return false;
}, removeAtKey:function(key) {
  var me = this, keys = me.keys, i;
  if (key == null) {
    for (i = keys.length - 1; i >= 0; i--) {
      if (keys[i] == null) {
        me.removeAt(i);
      }
    }
  } else {
    return me.removeAt(me.indexOfKey(key));
  }
}, getCount:function() {
  return this.length;
}, indexOf:function(o) {
  var me = this, key;
  if (o != null) {
    if (!me.useLinearSearch && (key = me.getKey(o))) {
      return this.indexOfKey(key);
    }
    return Ext.Array.indexOf(me.items, o);
  }
  return -1;
}, indexOfKey:function(key) {
  if (!this.map.hasOwnProperty(key)) {
    return -1;
  }
  if (this.indexGeneration !== this.generation) {
    this.rebuildIndexMap();
  }
  return this.indexMap[key];
}, rebuildIndexMap:function() {
  var me = this, indexMap = me.indexMap = {}, keys = me.keys, len = keys.length, i;
  for (i = 0; i < len; i++) {
    indexMap[keys[i]] = i;
  }
  me.indexGeneration = me.generation;
}, get:function(key) {
  var me = this, mk = me.map[key], item = mk !== undefined ? mk : typeof key == 'number' ? me.items[key] : undefined;
  return typeof item != 'function' || me.allowFunctions ? item : null;
}, getAt:function(index) {
  return this.items[index];
}, getByKey:function(key) {
  return this.map[key];
}, contains:function(o) {
  var me = this, key;
  if (o != null) {
    if (!me.useLinearSearch && (key = me.getKey(o))) {
      return this.map[key] != null;
    }
    return Ext.Array.indexOf(this.items, o) !== -1;
  }
  return false;
}, containsKey:function(key) {
  return this.map.hasOwnProperty(key);
}, clear:function() {
  var me = this;
  if (me.generation) {
    me.length = 0;
    me.items = [];
    me.keys = [];
    me.map = {};
    me.indexMap = {};
    me.generation++;
    me.indexGeneration = me.generation;
  }
  if (me.hasListeners.clear) {
    me.fireEvent('clear');
  }
}, first:function() {
  return this.items[0];
}, last:function() {
  return this.items[this.length - 1];
}, sum:function(property, root, start, end) {
  var values = this.extractValues(property, root), length = values.length, sum = 0, i;
  start = start || 0;
  end = end || end === 0 ? end : length - 1;
  for (i = start; i <= end; i++) {
    sum += values[i];
  }
  return sum;
}, collect:function(property, root, allowNull) {
  var values = this.extractValues(property, root), length = values.length, hits = {}, unique = [], value, strValue, i;
  for (i = 0; i < length; i++) {
    value = values[i];
    strValue = String(value);
    if ((allowNull || !Ext.isEmpty(value)) && !hits[strValue]) {
      hits[strValue] = true;
      unique.push(value);
    }
  }
  return unique;
}, extractValues:function(property, root) {
  var values = this.items;
  if (root) {
    values = Ext.Array.pluck(values, root);
  }
  return Ext.Array.pluck(values, property);
}, hasRange:function(start, end) {
  return end < this.length;
}, getRange:function(start, end) {
  var me = this, items = me.items, range = [], len = items.length, tmp, reverse;
  if (len < 1) {
    return range;
  }
  if (start > end) {
    reverse = true;
    tmp = start;
    start = end;
    end = tmp;
  }
  if (start < 0) {
    start = 0;
  }
  if (end == null || end >= len) {
    end = len - 1;
  }
  range = items.slice(start, end + 1);
  if (reverse && range.length) {
    range.reverse();
  }
  return range;
}, filter:function(property, value, anyMatch, caseSensitive) {
  var filters = [];
  if (Ext.isString(property)) {
    filters.push(new Ext.util.Filter({property:property, value:value, anyMatch:anyMatch, caseSensitive:caseSensitive}));
  } else {
    if (Ext.isArray(property) || property instanceof Ext.util.Filter) {
      filters = filters.concat(property);
    }
  }
  return this.filterBy(Ext.util.Filter.createFilterFn(filters));
}, filterBy:function(fn, scope) {
  var me = this, newMC = new me.self(me.initialConfig), keys = me.keys, items = me.items, length = items.length, i;
  newMC.getKey = me.getKey;
  for (i = 0; i < length; i++) {
    if (fn.call(scope || me, items[i], keys[i])) {
      newMC.add(keys[i], items[i]);
    }
  }
  return newMC;
}, findIndex:function(property, value, start, anyMatch, caseSensitive) {
  if (Ext.isEmpty(value, false)) {
    return -1;
  }
  value = this.createValueMatcher(value, anyMatch, caseSensitive);
  return this.findIndexBy(function(o) {
    return o && value.test(o[property]);
  }, null, start);
}, findIndexBy:function(fn, scope, start) {
  var me = this, keys = me.keys, items = me.items, i = start || 0, len = items.length;
  for (; i < len; i++) {
    if (fn.call(scope || me, items[i], keys[i])) {
      return i;
    }
  }
  return -1;
}, createValueMatcher:function(value, anyMatch, caseSensitive, exactMatch) {
  if (!value.exec) {
    var er = Ext.String.escapeRegex;
    value = String(value);
    if (anyMatch === true) {
      value = er(value);
    } else {
      value = '^' + er(value);
      if (exactMatch === true) {
        value += '$';
      }
    }
    value = new RegExp(value, caseSensitive ? '' : 'i');
  }
  return value;
}, clone:function() {
  var me = this, copy = new this.self(me.initialConfig);
  copy.add(me.keys, me.items);
  return copy;
}});
Ext.define('Ext.util.Sorter', {direction:'ASC', constructor:function(config) {
  var me = this;
  Ext.apply(me, config);
  if (me.property === undefined && me.sorterFn === undefined) {
    Ext.Error.raise('A Sorter requires either a property or a sorter function');
  }
  me.updateSortFunction();
}, createSortFunction:function(sorterFn) {
  var me = this, direction = me.direction || 'ASC', modifier = direction.toUpperCase() == 'DESC' ? -1 : 1;
  return function(o1, o2) {
    return modifier * sorterFn.call(me, o1, o2);
  };
}, defaultSorterFn:function(o1, o2) {
  var me = this, transform = me.transform, v1 = me.getRoot(o1)[me.property], v2 = me.getRoot(o2)[me.property];
  if (transform) {
    v1 = transform(v1);
    v2 = transform(v2);
  }
  return v1 > v2 ? 1 : v1 < v2 ? -1 : 0;
}, getRoot:function(item) {
  return this.root === undefined ? item : item[this.root];
}, setDirection:function(direction) {
  var me = this;
  me.direction = direction ? direction.toUpperCase() : direction;
  me.updateSortFunction();
}, toggle:function() {
  var me = this;
  me.direction = Ext.String.toggle(me.direction, 'ASC', 'DESC');
  me.updateSortFunction();
}, updateSortFunction:function(fn) {
  var me = this;
  fn = fn || me.sorterFn || me.defaultSorterFn;
  me.sort = me.createSortFunction(fn);
}, serialize:function() {
  return {root:this.root, property:this.property, direction:this.direction};
}});
Ext.define('Ext.util.Sortable', {isSortable:true, defaultSortDirection:'ASC', statics:{createComparator:function(sorters) {
  return sorters && sorters.length ? function(r1, r2) {
    var result = sorters[0].sort(r1, r2), length = sorters.length, i = 1;
    for (; i < length; i++) {
      result = result || sorters[i].sort.call(this, r1, r2);
    }
    return result;
  } : function() {
    return 0;
  };
}}, initSortable:function() {
  var me = this, sorters = me.sorters;
  me.sorters = new Ext.util.AbstractMixedCollection(false, function(item) {
    return item.id || item.property;
  });
  if (sorters) {
    me.sorters.addAll(me.decodeSorters(sorters));
  }
}, sort:function(sorters, direction, where, doSort) {
  var me = this, sorter, newSorters;
  if (Ext.isArray(sorters)) {
    doSort = where;
    where = direction;
    newSorters = sorters;
  } else {
    if (Ext.isObject(sorters)) {
      doSort = where;
      where = direction;
      newSorters = [sorters];
    } else {
      if (Ext.isString(sorters)) {
        sorter = me.sorters.get(sorters);
        if (!sorter) {
          sorter = {property:sorters, direction:direction};
          newSorters = [sorter];
        } else {
          if (direction === undefined) {
            sorter.toggle();
          } else {
            sorter.setDirection(direction);
          }
        }
      }
    }
  }
  if (newSorters && newSorters.length) {
    newSorters = me.decodeSorters(newSorters);
    if (Ext.isString(where)) {
      if (where === 'prepend') {
        me.sorters.insert(0, newSorters);
      } else {
        me.sorters.addAll(newSorters);
      }
    } else {
      me.sorters.clear();
      me.sorters.addAll(newSorters);
    }
  }
  if (doSort !== false) {
    me.fireEvent('beforesort', me, newSorters);
    me.onBeforeSort(newSorters);
    sorters = me.sorters.items;
    if (sorters.length) {
      me.doSort(me.generateComparator());
    }
  }
  return sorters;
}, generateComparator:function() {
  var sorters = this.sorters.getRange();
  return sorters.length ? this.createComparator(sorters) : this.emptyComparator;
}, emptyComparator:function() {
  return 0;
}, onBeforeSort:Ext.emptyFn, decodeSorters:function(sorters) {
  if (!Ext.isArray(sorters)) {
    if (sorters === undefined) {
      sorters = [];
    } else {
      sorters = [sorters];
    }
  }
  var length = sorters.length, Sorter = Ext.util.Sorter, fields = this.model ? this.model.prototype.fields : null, field, config, i;
  for (i = 0; i < length; i++) {
    config = sorters[i];
    if (!(config instanceof Sorter)) {
      if (Ext.isString(config)) {
        config = {property:config};
      }
      Ext.applyIf(config, {root:this.sortRoot, direction:'ASC'});
      if (config.fn) {
        config.sorterFn = config.fn;
      }
      if (typeof config == 'function') {
        config = {sorterFn:config};
      }
      if (fields && !config.transform) {
        field = fields.get(config.property);
        config.transform = field && field.sortType !== Ext.identityFn ? field.sortType : undefined;
      }
      sorters[i] = new Ext.util.Sorter(config);
    }
  }
  return sorters;
}, getSorters:function() {
  return this.sorters.items;
}, getFirstSorter:function() {
  var sorters = this.sorters.items, len = sorters.length, i = 0, sorter;
  for (; i < len; ++i) {
    sorter = sorters[i];
    if (!sorter.isGrouper) {
      return sorter;
    }
  }
  return null;
}}, function() {
  this.prototype.createComparator = this.createComparator;
});
Ext.define('Ext.util.MixedCollection', {extend:Ext.util.AbstractMixedCollection, mixins:{sortable:Ext.util.Sortable}, constructor:function() {
  var me = this;
  me.callParent(arguments);
  me.addEvents('sort');
  me.mixins.sortable.initSortable.call(me);
}, doSort:function(sorterFn) {
  this.sortBy(sorterFn);
}, _sort:function(property, dir, fn) {
  var me = this, i, len, dsc = String(dir).toUpperCase() == 'DESC' ? -1 : 1, c = [], keys = me.keys, items = me.items, o;
  fn = fn || function(a, b) {
    return a - b;
  };
  for (i = 0, len = items.length; i < len; i++) {
    c[c.length] = {key:keys[i], value:items[i], index:i};
  }
  Ext.Array.sort(c, function(a, b) {
    return fn(a[property], b[property]) * dsc || (a.index < b.index ? -1 : 1);
  });
  for (i = 0, len = c.length; i < len; i++) {
    o = c[i];
    items[i] = o.value;
    keys[i] = o.key;
    me.indexMap[o.key] = i;
  }
  me.generation++;
  me.indexGeneration = me.generation;
  me.fireEvent('sort', me);
}, sortBy:function(sorterFn) {
  var me = this, items = me.items, item, keys = me.keys, key, length = items.length, i;
  for (i = 0; i < length; i++) {
    items[i].$extCollectionIndex = i;
  }
  Ext.Array.sort(items, function(a, b) {
    return sorterFn(a, b) || (a.$extCollectionIndex < b.$extCollectionIndex ? -1 : 1);
  });
  for (i = 0; i < length; i++) {
    item = items[i];
    key = me.getKey(item);
    keys[i] = key;
    me.indexMap[key] = i;
    delete items.$extCollectionIndex;
  }
  me.generation++;
  me.indexGeneration = me.generation;
  me.fireEvent('sort', me, items, keys);
}, findInsertionIndex:function(newItem, sorterFn) {
  var me = this, items = me.items, start = 0, end = items.length - 1, middle, comparison;
  if (!sorterFn) {
    sorterFn = me.generateComparator();
  }
  while (start <= end) {
    middle = start + end >> 1;
    comparison = sorterFn(newItem, items[middle]);
    if (comparison >= 0) {
      start = middle + 1;
    } else {
      if (comparison < 0) {
        end = middle - 1;
      }
    }
  }
  return start;
}, reorder:function(mapping) {
  var me = this, items = me.items, index = 0, length = items.length, order = [], remaining = [], oldIndex;
  me.suspendEvents();
  for (oldIndex in mapping) {
    order[mapping[oldIndex]] = items[oldIndex];
  }
  for (index = 0; index < length; index++) {
    if (mapping[index] == undefined) {
      remaining.push(items[index]);
    }
  }
  for (index = 0; index < length; index++) {
    if (order[index] == undefined) {
      order[index] = remaining.shift();
    }
  }
  me.clear();
  me.addAll(order);
  me.resumeEvents();
  me.fireEvent('sort', me);
}, sortByKey:function(dir, fn) {
  this._sort('key', dir, fn || function(a, b) {
    var v1 = String(a).toUpperCase(), v2 = String(b).toUpperCase();
    return v1 > v2 ? 1 : v1 < v2 ? -1 : 0;
  });
}});
Ext.define('Ext.fx.target.Target', {isAnimTarget:true, constructor:function(target) {
  this.target = target;
  this.id = this.getId();
}, getId:function() {
  return this.target.id;
}});
Ext.define('Ext.fx.target.Element', {extend:Ext.fx.target.Target, type:'element', getElVal:function(el, attr, val) {
  if (val == undefined) {
    if (attr === 'x') {
      val = el.getX();
    } else {
      if (attr === 'y') {
        val = el.getY();
      } else {
        if (attr === 'scrollTop') {
          val = el.getScroll().top;
        } else {
          if (attr === 'scrollLeft') {
            val = el.getScroll().left;
          } else {
            if (attr === 'height') {
              val = el.getHeight();
            } else {
              if (attr === 'width') {
                val = el.getWidth();
              } else {
                val = el.getStyle(attr);
              }
            }
          }
        }
      }
    }
  }
  return val;
}, getAttr:function(attr, val) {
  var el = this.target;
  return [[el, this.getElVal(el, attr, val)]];
}, setAttr:function(targetData) {
  var target = this.target, ln = targetData.length, attrs, attr, o, i, j, ln2;
  for (i = 0; i < ln; i++) {
    attrs = targetData[i].attrs;
    for (attr in attrs) {
      if (attrs.hasOwnProperty(attr)) {
        ln2 = attrs[attr].length;
        for (j = 0; j < ln2; j++) {
          o = attrs[attr][j];
          this.setElVal(o[0], attr, o[1]);
        }
      }
    }
  }
}, setElVal:function(element, attr, value) {
  if (attr === 'x') {
    element.setX(value);
  } else {
    if (attr === 'y') {
      element.setY(value);
    } else {
      if (attr === 'scrollTop') {
        element.scrollTo('top', value);
      } else {
        if (attr === 'scrollLeft') {
          element.scrollTo('left', value);
        } else {
          if (attr === 'width') {
            element.setWidth(value);
          } else {
            if (attr === 'height') {
              element.setHeight(value);
            } else {
              element.setStyle(attr, value);
            }
          }
        }
      }
    }
  }
}});
Ext.define('Ext.fx.target.ElementCSS', {extend:Ext.fx.target.Element, setAttr:function(targetData, isFirstFrame) {
  var cssArr = {attrs:[], duration:[], easing:[]}, ln = targetData.length, attributes, attrs, attr, easing, duration, o, i, j, ln2;
  for (i = 0; i < ln; i++) {
    attrs = targetData[i];
    duration = attrs.duration;
    easing = attrs.easing;
    attrs = attrs.attrs;
    for (attr in attrs) {
      if (Ext.Array.indexOf(cssArr.attrs, attr) == -1) {
        cssArr.attrs.push(attr.replace(/[A-Z]/g, function(v) {
          return '-' + v.toLowerCase();
        }));
        cssArr.duration.push(duration + 'ms');
        cssArr.easing.push(easing);
      }
    }
  }
  attributes = cssArr.attrs.join(',');
  duration = cssArr.duration.join(',');
  easing = cssArr.easing.join(', ');
  for (i = 0; i < ln; i++) {
    attrs = targetData[i].attrs;
    for (attr in attrs) {
      ln2 = attrs[attr].length;
      for (j = 0; j < ln2; j++) {
        o = attrs[attr][j];
        o[0].setStyle(Ext.supports.CSS3Prefix + 'TransitionProperty', isFirstFrame ? '' : attributes);
        o[0].setStyle(Ext.supports.CSS3Prefix + 'TransitionDuration', isFirstFrame ? '' : duration);
        o[0].setStyle(Ext.supports.CSS3Prefix + 'TransitionTimingFunction', isFirstFrame ? '' : easing);
        o[0].setStyle(attr, o[1]);
        if (isFirstFrame) {
          o = o[0].dom.offsetWidth;
        } else {
          o[0].on(Ext.supports.CSS3TransitionEnd, function() {
            this.setStyle(Ext.supports.CSS3Prefix + 'TransitionProperty', null);
            this.setStyle(Ext.supports.CSS3Prefix + 'TransitionDuration', null);
            this.setStyle(Ext.supports.CSS3Prefix + 'TransitionTimingFunction', null);
          }, o[0], {single:true});
        }
      }
    }
  }
}});
Ext.define('Ext.fx.target.CompositeElement', {extend:Ext.fx.target.Element, isComposite:true, constructor:function(target) {
  target.id = target.id || Ext.id(null, 'ext-composite-');
  this.callParent([target]);
}, getAttr:function(attr, val) {
  var out = [], target = this.target, elements = target.elements, length = elements.length, i, el;
  for (i = 0; i < length; i++) {
    el = elements[i];
    if (el) {
      el = target.getElement(el);
      out.push([el, this.getElVal(el, attr, val)]);
    }
  }
  return out;
}, setAttr:function(targetData) {
  var target = this.target, ln = targetData.length, elements = target.elements, ln3 = elements.length, value, k, attrs, attr, o, i, j, ln2;
  for (i = 0; i < ln; i++) {
    attrs = targetData[i].attrs;
    for (attr in attrs) {
      if (attrs.hasOwnProperty(attr)) {
        ln2 = attrs[attr].length;
        for (j = 0; j < ln2; j++) {
          value = attrs[attr][j][1];
          for (k = 0; k < ln3; ++k) {
            el = elements[k];
            if (el) {
              el = target.getElement(el);
              this.setElVal(el, attr, value);
            }
          }
        }
      }
    }
  }
}});
Ext.define('Ext.fx.target.CompositeElementCSS', {extend:Ext.fx.target.CompositeElement, setAttr:function() {
  return Ext.fx.target.ElementCSS.prototype.setAttr.apply(this, arguments);
}});
Ext.define('Ext.fx.target.Sprite', {extend:Ext.fx.target.Target, type:'draw', getFromPrim:function(sprite, attr) {
  var obj;
  switch(attr) {
    case 'rotate':
    case 'rotation':
      obj = sprite.attr.rotation;
      return {x:obj.x || 0, y:obj.y || 0, degrees:obj.degrees || 0};
    case 'scale':
    case 'scaling':
      obj = sprite.attr.scaling;
      return {x:obj.x || 1, y:obj.y || 1, cx:obj.cx || 0, cy:obj.cy || 0};
    case 'translate':
    case 'translation':
      obj = sprite.attr.translation;
      return {x:obj.x || 0, y:obj.y || 0};
    default:
      return sprite.attr[attr];
  }
}, getAttr:function(attr, val) {
  return [[this.target, val != undefined ? val : this.getFromPrim(this.target, attr)]];
}, setAttr:function(targetData) {
  var ln = targetData.length, spriteArr = [], attrsConf, attr, attrArr, attrs, sprite, idx, value, i, j, x, y, ln2;
  for (i = 0; i < ln; i++) {
    attrsConf = targetData[i].attrs;
    for (attr in attrsConf) {
      attrArr = attrsConf[attr];
      ln2 = attrArr.length;
      for (j = 0; j < ln2; j++) {
        sprite = attrArr[j][0];
        attrs = attrArr[j][1];
        if (attr === 'translate' || attr === 'translation') {
          value = {x:attrs.x, y:attrs.y};
        } else {
          if (attr === 'rotate' || attr === 'rotation') {
            x = attrs.x;
            if (isNaN(x)) {
              x = null;
            }
            y = attrs.y;
            if (isNaN(y)) {
              y = null;
            }
            value = {degrees:attrs.degrees, x:x, y:y};
          } else {
            if (attr === 'scale' || attr === 'scaling') {
              x = attrs.x;
              if (isNaN(x)) {
                x = null;
              }
              y = attrs.y;
              if (isNaN(y)) {
                y = null;
              }
              value = {x:x, y:y, cx:attrs.cx, cy:attrs.cy};
            } else {
              if (attr === 'width' || attr === 'height' || attr === 'x' || attr === 'y') {
                value = parseFloat(attrs);
              } else {
                value = attrs;
              }
            }
          }
        }
        idx = Ext.Array.indexOf(spriteArr, sprite);
        if (idx == -1) {
          spriteArr.push([sprite, {}]);
          idx = spriteArr.length - 1;
        }
        spriteArr[idx][1][attr] = value;
      }
    }
  }
  ln = spriteArr.length;
  for (i = 0; i < ln; i++) {
    spriteArr[i][0].setAttributes(spriteArr[i][1]);
  }
  this.target.redraw();
}});
Ext.define('Ext.fx.target.CompositeSprite', {extend:Ext.fx.target.Sprite, getAttr:function(attr, val) {
  var out = [], sprites = [].concat(this.target.items), length = sprites.length, i, sprite;
  for (i = 0; i < length; i++) {
    sprite = sprites[i];
    out.push([sprite, val != undefined ? val : this.getFromPrim(sprite, attr)]);
  }
  return out;
}});
Ext.define('Ext.fx.target.Component', {extend:Ext.fx.target.Target, type:'component', getPropMethod:{top:function() {
  return this.getPosition(true)[1];
}, left:function() {
  return this.getPosition(true)[0];
}, x:function() {
  return this.getPosition()[0];
}, y:function() {
  return this.getPosition()[1];
}, height:function() {
  return this.getHeight();
}, width:function() {
  return this.getWidth();
}, opacity:function() {
  return this.el.getStyle('opacity');
}}, setMethods:{top:'setPosition', left:'setPosition', x:'setPagePosition', y:'setPagePosition', height:'setSize', width:'setSize', opacity:'setOpacity'}, getAttr:function(attr, val) {
  return [[this.target, val !== undefined ? val : this.getPropMethod[attr].call(this.target)]];
}, setAttr:function(targetData, isFirstFrame, isLastFrame) {
  var me = this, ln = targetData.length, attrs, attr, o, i, j, targets, left, top, w, h, methodsToCall = {}, methodProps;
  for (i = 0; i < ln; i++) {
    attrs = targetData[i].attrs;
    for (attr in attrs) {
      targets = attrs[attr].length;
      for (j = 0; j < targets; j++) {
        o = attrs[attr][j];
        methodProps = methodsToCall[me.setMethods[attr]] || (methodsToCall[me.setMethods[attr]] = {});
        methodProps.target = o[0];
        methodProps[attr] = o[1];
      }
    }
    if (methodsToCall.setPosition) {
      o = methodsToCall.setPosition;
      left = o.left === undefined ? undefined : parseFloat(o.left);
      top = o.top === undefined ? undefined : parseFloat(o.top);
      o.target.setPosition(left, top);
    }
    if (methodsToCall.setPagePosition) {
      o = methodsToCall.setPagePosition;
      o.target.setPagePosition(o.x, o.y);
    }
    if (methodsToCall.setSize) {
      o = methodsToCall.setSize;
      w = o.width === undefined ? o.target.getWidth() : parseFloat(o.width);
      h = o.height === undefined ? o.target.getHeight() : parseFloat(o.height);
      o.target.el.setSize(w, h);
      if (isLastFrame || me.dynamic) {
        Ext.globalEvents.on({idle:Ext.Function.bind(o.target.setSize, o.target, [w, h]), single:true});
      }
    }
    if (methodsToCall.setOpacity) {
      o = methodsToCall.setOpacity;
      o.target.el.setStyle('opacity', o.opacity);
    }
  }
}});
Ext.define('Ext.fx.Queue', {constructor:function() {
  this.targets = new Ext.util.HashMap;
  this.fxQueue = {};
}, getFxDefaults:function(targetId) {
  var target = this.targets.get(targetId);
  if (target) {
    return target.fxDefaults;
  }
  return {};
}, setFxDefaults:function(targetId, obj) {
  var target = this.targets.get(targetId);
  if (target) {
    target.fxDefaults = Ext.apply(target.fxDefaults || {}, obj);
  }
}, stopAnimation:function(targetId) {
  var me = this, queue = me.getFxQueue(targetId), ln = queue.length;
  while (ln) {
    queue[ln - 1].end();
    ln--;
  }
}, getActiveAnimation:function(targetId) {
  var queue = this.getFxQueue(targetId);
  return queue && !!queue.length ? queue[0] : false;
}, hasFxBlock:function(targetId) {
  var queue = this.getFxQueue(targetId);
  return queue && queue[0] && queue[0].block;
}, getFxQueue:function(targetId) {
  if (!targetId) {
    return false;
  }
  var me = this, queue = me.fxQueue[targetId], target = me.targets.get(targetId);
  if (!target) {
    return false;
  }
  if (!queue) {
    me.fxQueue[targetId] = [];
    if (target.type != 'element') {
      target.target.on('destroy', function() {
        me.fxQueue[targetId] = [];
      });
    }
  }
  return me.fxQueue[targetId];
}, queueFx:function(anim) {
  var me = this, target = anim.target, queue, ln;
  if (!target) {
    return;
  }
  queue = me.getFxQueue(target.getId());
  ln = queue.length;
  if (ln) {
    if (anim.concurrent) {
      anim.paused = false;
    } else {
      queue[ln - 1].on('afteranimate', function() {
        anim.paused = false;
      });
    }
  } else {
    anim.paused = false;
  }
  anim.on('afteranimate', function() {
    Ext.Array.remove(queue, anim);
    if (queue.length === 0) {
      me.targets.remove(anim.target);
    }
    if (anim.remove) {
      if (target.type == 'element') {
        var el = Ext.get(target.id);
        if (el) {
          el.remove();
        }
      }
    }
  }, me, {single:true});
  queue.push(anim);
}});
Ext.define('Ext.fx.Manager', {singleton:true, mixins:{queue:Ext.fx.Queue}, constructor:function() {
  var me = this;
  me.items = new Ext.util.MixedCollection;
  me.mixins.queue.constructor.call(me);
  me.taskRunner = new Ext.util.TaskRunner;
}, interval:16, forceJS:true, createTarget:function(target) {
  var me = this, useCSS3 = !me.forceJS && Ext.supports.Transitions, targetObj;
  me.useCSS3 = useCSS3;
  if (target) {
    if (target.tagName || Ext.isString(target) || target.isFly) {
      target = Ext.get(target);
      targetObj = new Ext.fx.target['Element' + (useCSS3 ? 'CSS' : '')](target);
    } else {
      if (target.dom) {
        targetObj = new Ext.fx.target['Element' + (useCSS3 ? 'CSS' : '')](target);
      } else {
        if (target.isComposite) {
          targetObj = new Ext.fx.target['CompositeElement' + (useCSS3 ? 'CSS' : '')](target);
        } else {
          if (target.isSprite) {
            targetObj = new Ext.fx.target.Sprite(target);
          } else {
            if (target.isCompositeSprite) {
              targetObj = new Ext.fx.target.CompositeSprite(target);
            } else {
              if (target.isComponent) {
                targetObj = new Ext.fx.target.Component(target);
              } else {
                if (target.isAnimTarget) {
                  return target;
                } else {
                  return null;
                }
              }
            }
          }
        }
      }
    }
    me.targets.add(targetObj);
    return targetObj;
  } else {
    return null;
  }
}, addAnim:function(anim) {
  var me = this, items = me.items, task = me.task;
  items.add(anim.id, anim);
  if (!task && items.length) {
    task = me.task = {run:me.runner, interval:me.interval, scope:me};
    me.taskRunner.start(task);
  }
}, removeAnim:function(anim) {
  var me = this, items = me.items, task = me.task;
  items.removeAtKey(anim.id);
  if (task && !items.length) {
    me.taskRunner.stop(task);
    delete me.task;
  }
}, runner:function() {
  var me = this, items = me.items.getRange(), i = 0, len = items.length, anim;
  me.targetArr = {};
  me.timestamp = new Date;
  for (; i < len; i++) {
    anim = items[i];
    if (anim.isReady()) {
      me.startAnim(anim);
    }
  }
  for (i = 0; i < len; i++) {
    anim = items[i];
    if (anim.isRunning()) {
      me.runAnim(anim);
    } else {
      if (!me.useCSS3) {
      }
    }
  }
  me.applyPendingAttrs();
}, startAnim:function(anim) {
  anim.start(this.timestamp);
}, runAnim:function(anim) {
  if (!anim) {
    return;
  }
  var me = this, useCSS3 = me.useCSS3 && anim.target.type == 'element', elapsedTime = me.timestamp - anim.startTime, lastFrame = elapsedTime >= anim.duration, target, o;
  target = this.collectTargetData(anim, elapsedTime, useCSS3, lastFrame);
  if (useCSS3) {
    anim.target.setAttr(target.anims[anim.id].attributes, true);
    me.collectTargetData(anim, anim.duration, useCSS3, lastFrame);
    anim.paused = true;
    target = anim.target.target;
    if (anim.target.isComposite) {
      target = anim.target.target.last();
    }
    o = {};
    o[Ext.supports.CSS3TransitionEnd] = anim.lastFrame;
    o.scope = anim;
    o.single = true;
    target.on(o);
  }
}, collectTargetData:function(anim, elapsedTime, useCSS3, isLastFrame) {
  var targetId = anim.target.getId(), target = this.targetArr[targetId];
  if (!target) {
    target = this.targetArr[targetId] = {id:targetId, el:anim.target, anims:{}};
  }
  target.anims[anim.id] = {id:anim.id, anim:anim, elapsed:elapsedTime, isLastFrame:isLastFrame, attributes:[{duration:anim.duration, easing:useCSS3 && anim.reverse ? anim.easingFn.reverse().toCSS3() : anim.easing, attrs:anim.runAnim(elapsedTime)}]};
  return target;
}, applyPendingAttrs:function() {
  var targetArr = this.targetArr, target, targetId, animWrap, anim, animId;
  for (targetId in targetArr) {
    if (targetArr.hasOwnProperty(targetId)) {
      target = targetArr[targetId];
      for (animId in target.anims) {
        if (target.anims.hasOwnProperty(animId)) {
          animWrap = target.anims[animId];
          anim = animWrap.anim;
          if (animWrap.attributes && anim.isRunning()) {
            target.el.setAttr(animWrap.attributes, false, animWrap.isLastFrame);
            if (animWrap.isLastFrame) {
              anim.lastFrame();
            }
          }
        }
      }
    }
  }
}});
Ext.define('Ext.fx.Animator', {mixins:{observable:Ext.util.Observable}, isAnimator:true, duration:250, delay:0, delayStart:0, dynamic:false, easing:'ease', running:false, paused:false, damper:1, iterations:1, currentIteration:0, keyframeStep:0, animKeyFramesRE:/^(from|to|\d+%?)$/, constructor:function(config) {
  var me = this;
  config = Ext.apply(me, config || {});
  me.config = config;
  me.id = Ext.id(null, 'ext-animator-');
  me.addEvents('beforeanimate', 'keyframe', 'afteranimate');
  me.mixins.observable.constructor.call(me, config);
  me.timeline = [];
  me.createTimeline(me.keyframes);
  if (me.target) {
    me.applyAnimator(me.target);
    Ext.fx.Manager.addAnim(me);
  }
}, sorter:function(a, b) {
  return a.pct - b.pct;
}, createTimeline:function(keyframes) {
  var me = this, attrs = [], to = me.to || {}, duration = me.duration, prevMs, ms, i, ln, pct, attr;
  for (pct in keyframes) {
    if (keyframes.hasOwnProperty(pct) && me.animKeyFramesRE.test(pct)) {
      attr = {attrs:Ext.apply(keyframes[pct], to)};
      if (pct == 'from') {
        pct = 0;
      } else {
        if (pct == 'to') {
          pct = 100;
        }
      }
      attr.pct = parseInt(pct, 10);
      attrs.push(attr);
    }
  }
  Ext.Array.sort(attrs, me.sorter);
  ln = attrs.length;
  for (i = 0; i < ln; i++) {
    prevMs = attrs[i - 1] ? duration * (attrs[i - 1].pct / 100) : 0;
    ms = duration * (attrs[i].pct / 100);
    me.timeline.push({duration:ms - prevMs, attrs:attrs[i].attrs});
  }
}, applyAnimator:function(target) {
  var me = this, anims = [], timeline = me.timeline, ln = timeline.length, anim, easing, damper, attrs, i;
  if (me.fireEvent('beforeanimate', me) !== false) {
    for (i = 0; i < ln; i++) {
      anim = timeline[i];
      attrs = anim.attrs;
      easing = attrs.easing || me.easing;
      damper = attrs.damper || me.damper;
      delete attrs.easing;
      delete attrs.damper;
      anim = new Ext.fx.Anim({target:target, easing:easing, damper:damper, duration:anim.duration, paused:true, to:attrs});
      anims.push(anim);
    }
    me.animations = anims;
    me.target = anim.target;
    for (i = 0; i < ln - 1; i++) {
      anim = anims[i];
      anim.nextAnim = anims[i + 1];
      anim.on('afteranimate', function() {
        this.nextAnim.paused = false;
      });
      anim.on('afteranimate', function() {
        this.fireEvent('keyframe', this, ++this.keyframeStep);
      }, me);
    }
    anims[ln - 1].on('afteranimate', function() {
      this.lastFrame();
    }, me);
  }
}, start:function(startTime) {
  var me = this, delay = me.delay, delayStart = me.delayStart, delayDelta;
  if (delay) {
    if (!delayStart) {
      me.delayStart = startTime;
      return;
    } else {
      delayDelta = startTime - delayStart;
      if (delayDelta < delay) {
        return;
      } else {
        startTime = new Date(delayStart.getTime() + delay);
      }
    }
  }
  if (me.fireEvent('beforeanimate', me) !== false) {
    me.startTime = startTime;
    me.running = true;
    me.animations[me.keyframeStep].paused = false;
  }
}, lastFrame:function() {
  var me = this, iter = me.iterations, iterCount = me.currentIteration;
  iterCount++;
  if (iterCount < iter) {
    me.startTime = new Date;
    me.currentIteration = iterCount;
    me.keyframeStep = 0;
    me.applyAnimator(me.target);
    me.animations[me.keyframeStep].paused = false;
  } else {
    me.currentIteration = 0;
    me.end();
  }
}, end:function() {
  var me = this;
  me.fireEvent('afteranimate', me, me.startTime, new Date - me.startTime);
}, isReady:function() {
  return this.paused === false && this.running === false && this.iterations > 0;
}, isRunning:function() {
  return false;
}});
Ext.define('Ext.fx.CubicBezier', {singleton:true, cubicBezierAtTime:function(t, p1x, p1y, p2x, p2y, duration) {
  var cx = 3 * p1x, bx = 3 * (p2x - p1x) - cx, ax = 1 - cx - bx, cy = 3 * p1y, by = 3 * (p2y - p1y) - cy, ay = 1 - cy - by;
  function sampleCurveX(t) {
    return ((ax * t + bx) * t + cx) * t;
  }
  function solve(x, epsilon) {
    var t = solveCurveX(x, epsilon);
    return ((ay * t + by) * t + cy) * t;
  }
  function solveCurveX(x, epsilon) {
    var t0, t1, t2, x2, d2, i;
    for (t2 = x, i = 0; i < 8; i++) {
      x2 = sampleCurveX(t2) - x;
      if (Math.abs(x2) < epsilon) {
        return t2;
      }
      d2 = (3 * ax * t2 + 2 * bx) * t2 + cx;
      if (Math.abs(d2) < 1.0E-6) {
        break;
      }
      t2 = t2 - x2 / d2;
    }
    t0 = 0;
    t1 = 1;
    t2 = x;
    if (t2 < t0) {
      return t0;
    }
    if (t2 > t1) {
      return t1;
    }
    while (t0 < t1) {
      x2 = sampleCurveX(t2);
      if (Math.abs(x2 - x) < epsilon) {
        return t2;
      }
      if (x > x2) {
        t0 = t2;
      } else {
        t1 = t2;
      }
      t2 = (t1 - t0) / 2 + t0;
    }
    return t2;
  }
  return solve(t, 1 / (200 * duration));
}, cubicBezier:function(x1, y1, x2, y2) {
  var fn = function(pos) {
    return Ext.fx.CubicBezier.cubicBezierAtTime(pos, x1, y1, x2, y2, 1);
  };
  fn.toCSS3 = function() {
    return 'cubic-bezier(' + [x1, y1, x2, y2].join(',') + ')';
  };
  fn.reverse = function() {
    return Ext.fx.CubicBezier.cubicBezier(1 - x2, 1 - y2, 1 - x1, 1 - y1);
  };
  return fn;
}});
Ext.require('Ext.fx.CubicBezier', function() {
  var math = Math, pi = math.PI, pow = math.pow, sin = math.sin, sqrt = math.sqrt, abs = math.abs, backInSeed = 1.70158;
  Ext.define('Ext.fx.Easing', {singleton:true, linear:Ext.identityFn, ease:function(n) {
    var q = 0.07813 - n / 2, alpha = -0.25, Q = sqrt(0.0066 + q * q), x = Q - q, X = pow(abs(x), 1 / 3) * (x < 0 ? -1 : 1), y = -Q - q, Y = pow(abs(y), 1 / 3) * (y < 0 ? -1 : 1), t = X + Y + 0.25;
    return pow(1 - t, 2) * 3 * t * 0.1 + (1 - t) * 3 * t * t + t * t * t;
  }, easeIn:function(n) {
    return pow(n, 1.7);
  }, easeOut:function(n) {
    return pow(n, 0.48);
  }, easeInOut:function(n) {
    var q = 0.48 - n / 1.04, Q = sqrt(0.1734 + q * q), x = Q - q, X = pow(abs(x), 1 / 3) * (x < 0 ? -1 : 1), y = -Q - q, Y = pow(abs(y), 1 / 3) * (y < 0 ? -1 : 1), t = X + Y + 0.5;
    return (1 - t) * 3 * t * t + t * t * t;
  }, backIn:function(n) {
    return n * n * ((backInSeed + 1) * n - backInSeed);
  }, backOut:function(n) {
    n = n - 1;
    return n * n * ((backInSeed + 1) * n + backInSeed) + 1;
  }, elasticIn:function(n) {
    if (n === 0 || n === 1) {
      return n;
    }
    var p = 0.3, s = p / 4;
    return pow(2, -10 * n) * sin((n - s) * (2 * pi) / p) + 1;
  }, elasticOut:function(n) {
    return 1 - Ext.fx.Easing.elasticIn(1 - n);
  }, bounceIn:function(n) {
    return 1 - Ext.fx.Easing.bounceOut(1 - n);
  }, bounceOut:function(n) {
    var s = 7.5625, p = 2.75, l;
    if (n < 1 / p) {
      l = s * n * n;
    } else {
      if (n < 2 / p) {
        n -= 1.5 / p;
        l = s * n * n + 0.75;
      } else {
        if (n < 2.5 / p) {
          n -= 2.25 / p;
          l = s * n * n + 0.9375;
        } else {
          n -= 2.625 / p;
          l = s * n * n + 0.984375;
        }
      }
    }
    return l;
  }}, function() {
    var easing = Ext.fx.Easing.self, proto = easing.prototype;
    easing.implement({'back-in':proto.backIn, 'back-out':proto.backOut, 'ease-in':proto.easeIn, 'ease-out':proto.easeOut, 'elastic-in':proto.elasticIn, 'elastic-out':proto.elasticOut, 'bounce-in':proto.bounceIn, 'bounce-out':proto.bounceOut, 'ease-in-out':proto.easeInOut});
  });
});
Ext.define('Ext.draw.Color', {colorToHexRe:/(.*?)rgb\((\d+),\s*(\d+),\s*(\d+)\)/, rgbRe:/\s*rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)\s*/, hexRe:/\s*#([0-9a-fA-F][0-9a-fA-F]?)([0-9a-fA-F][0-9a-fA-F]?)([0-9a-fA-F][0-9a-fA-F]?)\s*/, lightnessFactor:0.2, constructor:function(red, green, blue) {
  var me = this, clamp = Ext.Number.constrain;
  me.r = clamp(red, 0, 255);
  me.g = clamp(green, 0, 255);
  me.b = clamp(blue, 0, 255);
}, getRed:function() {
  return this.r;
}, getGreen:function() {
  return this.g;
}, getBlue:function() {
  return this.b;
}, getRGB:function() {
  var me = this;
  return [me.r, me.g, me.b];
}, getHSL:function() {
  var me = this, r = me.r / 255, g = me.g / 255, b = me.b / 255, max = Math.max(r, g, b), min = Math.min(r, g, b), delta = max - min, h, s = 0, l = 0.5 * (max + min);
  if (min != max) {
    s = l < 0.5 ? delta / (max + min) : delta / (2 - max - min);
    if (r == max) {
      h = 60 * (g - b) / delta;
    } else {
      if (g == max) {
        h = 120 + 60 * (b - r) / delta;
      } else {
        h = 240 + 60 * (r - g) / delta;
      }
    }
    if (h < 0) {
      h += 360;
    }
    if (h >= 360) {
      h -= 360;
    }
  }
  return [h, s, l];
}, getLighter:function(factor) {
  var hsl = this.getHSL();
  factor = factor || this.lightnessFactor;
  hsl[2] = Ext.Number.constrain(hsl[2] + factor, 0, 1);
  return this.fromHSL(hsl[0], hsl[1], hsl[2]);
}, getDarker:function(factor) {
  factor = factor || this.lightnessFactor;
  return this.getLighter(-factor);
}, toString:function() {
  var me = this, round = Math.round, r = round(me.r).toString(16), g = round(me.g).toString(16), b = round(me.b).toString(16);
  r = r.length == 1 ? '0' + r : r;
  g = g.length == 1 ? '0' + g : g;
  b = b.length == 1 ? '0' + b : b;
  return ['#', r, g, b].join('');
}, toHex:function(color) {
  if (Ext.isArray(color)) {
    color = color[0];
  }
  if (!Ext.isString(color)) {
    return '';
  }
  if (color.substr(0, 1) === '#') {
    return color;
  }
  var digits = this.colorToHexRe.exec(color), red, green, blue, rgb;
  if (Ext.isArray(digits)) {
    red = parseInt(digits[2], 10);
    green = parseInt(digits[3], 10);
    blue = parseInt(digits[4], 10);
    rgb = blue | green << 8 | red << 16;
    return digits[1] + '#' + ('000000' + rgb.toString(16)).slice(-6);
  } else {
    return color;
  }
}, fromString:function(str) {
  var values, r, g, b, parse = parseInt;
  if ((str.length == 4 || str.length == 7) && str.substr(0, 1) === '#') {
    values = str.match(this.hexRe);
    if (values) {
      r = parse(values[1], 16) >> 0;
      g = parse(values[2], 16) >> 0;
      b = parse(values[3], 16) >> 0;
      if (str.length == 4) {
        r += r * 16;
        g += g * 16;
        b += b * 16;
      }
    }
  } else {
    values = str.match(this.rgbRe);
    if (values) {
      r = values[1];
      g = values[2];
      b = values[3];
    }
  }
  return typeof r == 'undefined' ? undefined : new Ext.draw.Color(r, g, b);
}, getGrayscale:function() {
  return this.r * 0.3 + this.g * 0.59 + this.b * 0.11;
}, fromHSL:function(h, s, l) {
  var C, X, m, i, rgb = [], abs = Math.abs, floor = Math.floor;
  if (s == 0 || h == null) {
    rgb = [l, l, l];
  } else {
    h /= 60;
    C = s * (1 - abs(2 * l - 1));
    X = C * (1 - abs(h - 2 * floor(h / 2) - 1));
    m = l - C / 2;
    switch(floor(h)) {
      case 0:
        rgb = [C, X, 0];
        break;
      case 1:
        rgb = [X, C, 0];
        break;
      case 2:
        rgb = [0, C, X];
        break;
      case 3:
        rgb = [0, X, C];
        break;
      case 4:
        rgb = [X, 0, C];
        break;
      case 5:
        rgb = [C, 0, X];
        break;
    }
    rgb = [rgb[0] + m, rgb[1] + m, rgb[2] + m];
  }
  return new Ext.draw.Color(rgb[0] * 255, rgb[1] * 255, rgb[2] * 255);
}}, function() {
  var prototype = this.prototype;
  this.addStatics({fromHSL:function() {
    return prototype.fromHSL.apply(prototype, arguments);
  }, fromString:function() {
    return prototype.fromString.apply(prototype, arguments);
  }, toHex:function() {
    return prototype.toHex.apply(prototype, arguments);
  }});
});
Ext.define('Ext.draw.Draw', {singleton:true, pathToStringRE:/,?([achlmqrstvxz]),?/gi, pathCommandRE:/([achlmqstvz])[\s,]*((-?\d*\.?\d*(?:e[-+]?\d+)?\s*,?\s*)+)/ig, pathValuesRE:/(-?\d*\.?\d*(?:e[-+]?\d+)?)\s*,?\s*/ig, stopsRE:/^(\d+%?)$/, radian:Math.PI / 180, availableAnimAttrs:{along:'along', blur:null, 'clip-rect':'csv', cx:null, cy:null, fill:'color', 'fill-opacity':null, 'font-size':null, height:null, opacity:null, path:'path', r:null, rotation:'csv', rx:null, ry:null, scale:'csv', stroke:'color', 
'stroke-opacity':null, 'stroke-width':null, translation:'csv', width:null, x:null, y:null}, is:function(o, type) {
  type = String(type).toLowerCase();
  return type == 'object' && o === Object(o) || type == 'undefined' && typeof o == type || type == 'null' && o === null || type == 'array' && Array.isArray && Array.isArray(o) || Object.prototype.toString.call(o).toLowerCase().slice(8, -1) == type;
}, ellipsePath:function(sprite) {
  var attr = sprite.attr;
  return Ext.String.format('M{0},{1}A{2},{3},0,1,1,{0},{4}A{2},{3},0,1,1,{0},{1}z', attr.x, attr.y - attr.ry, attr.rx, attr.ry, attr.y + attr.ry);
}, rectPath:function(sprite) {
  var attr = sprite.attr;
  if (attr.radius) {
    return Ext.String.format('M{0},{1}l{2},0a{3},{3},0,0,1,{3},{3}l0,{5}a{3},{3},0,0,1,{4},{3}l{6},0a{3},{3},0,0,1,{4},{4}l0,{7}a{3},{3},0,0,1,{3},{4}z', attr.x + attr.radius, attr.y, attr.width - attr.radius * 2, attr.radius, -attr.radius, attr.height - attr.radius * 2, attr.radius * 2 - attr.width, attr.radius * 2 - attr.height);
  } else {
    return Ext.String.format('M{0},{1}L{2},{1},{2},{3},{0},{3}z', attr.x, attr.y, attr.width + attr.x, attr.height + attr.y);
  }
}, path2string:function() {
  return this.join(',').replace(Ext.draw.Draw.pathToStringRE, '$1');
}, pathToString:function(arrayPath) {
  return arrayPath.join(',').replace(Ext.draw.Draw.pathToStringRE, '$1');
}, parsePathString:function(pathString) {
  if (!pathString) {
    return null;
  }
  var paramCounts = {a:7, c:6, h:1, l:2, m:2, q:4, s:4, t:2, v:1, z:0}, data = [], me = this;
  if (me.is(pathString, 'array') && me.is(pathString[0], 'array')) {
    data = me.pathClone(pathString);
  }
  if (!data.length) {
    String(pathString).replace(me.pathCommandRE, function(a, b, c) {
      var params = [], name = b.toLowerCase();
      c.replace(me.pathValuesRE, function(a, b) {
        b && params.push(+b);
      });
      if (name == 'm' && params.length > 2) {
        data.push([b].concat(Ext.Array.splice(params, 0, 2)));
        name = 'l';
        b = b == 'm' ? 'l' : 'L';
      }
      while (params.length >= paramCounts[name]) {
        data.push([b].concat(Ext.Array.splice(params, 0, paramCounts[name])));
        if (!paramCounts[name]) {
          break;
        }
      }
    });
  }
  data.toString = me.path2string;
  return data;
}, mapPath:function(path, matrix) {
  if (!matrix) {
    return path;
  }
  var x, y, i, ii, j, jj, pathi;
  path = this.path2curve(path);
  for (i = 0, ii = path.length; i < ii; i++) {
    pathi = path[i];
    for (j = 1, jj = pathi.length; j < jj - 1; j += 2) {
      x = matrix.x(pathi[j], pathi[j + 1]);
      y = matrix.y(pathi[j], pathi[j + 1]);
      pathi[j] = x;
      pathi[j + 1] = y;
    }
  }
  return path;
}, pathClone:function(pathArray) {
  var res = [], j, jj, i, ii;
  if (!this.is(pathArray, 'array') || !this.is(pathArray && pathArray[0], 'array')) {
    pathArray = this.parsePathString(pathArray);
  }
  for (i = 0, ii = pathArray.length; i < ii; i++) {
    res[i] = [];
    for (j = 0, jj = pathArray[i].length; j < jj; j++) {
      res[i][j] = pathArray[i][j];
    }
  }
  res.toString = this.path2string;
  return res;
}, pathToAbsolute:function(pathArray) {
  if (!this.is(pathArray, 'array') || !this.is(pathArray && pathArray[0], 'array')) {
    pathArray = this.parsePathString(pathArray);
  }
  var res = [], x = 0, y = 0, mx = 0, my = 0, i = 0, ln = pathArray.length, r, pathSegment, j, ln2;
  if (ln && pathArray[0][0] == 'M') {
    x = +pathArray[0][1];
    y = +pathArray[0][2];
    mx = x;
    my = y;
    i++;
    res[0] = ['M', x, y];
  }
  for (; i < ln; i++) {
    r = res[i] = [];
    pathSegment = pathArray[i];
    if (pathSegment[0] != pathSegment[0].toUpperCase()) {
      r[0] = pathSegment[0].toUpperCase();
      switch(r[0]) {
        case 'A':
          r[1] = pathSegment[1];
          r[2] = pathSegment[2];
          r[3] = pathSegment[3];
          r[4] = pathSegment[4];
          r[5] = pathSegment[5];
          r[6] = +(pathSegment[6] + x);
          r[7] = +(pathSegment[7] + y);
          break;
        case 'V':
          r[1] = +pathSegment[1] + y;
          break;
        case 'H':
          r[1] = +pathSegment[1] + x;
          break;
        case 'M':
          mx = +pathSegment[1] + x;
          my = +pathSegment[2] + y;
        default:
          j = 1;
          ln2 = pathSegment.length;
          for (; j < ln2; j++) {
            r[j] = +pathSegment[j] + (j % 2 ? x : y);
          }
      }
    } else {
      j = 0;
      ln2 = pathSegment.length;
      for (; j < ln2; j++) {
        res[i][j] = pathSegment[j];
      }
    }
    switch(r[0]) {
      case 'Z':
        x = mx;
        y = my;
        break;
      case 'H':
        x = r[1];
        break;
      case 'V':
        y = r[1];
        break;
      case 'M':
        pathSegment = res[i];
        ln2 = pathSegment.length;
        mx = pathSegment[ln2 - 2];
        my = pathSegment[ln2 - 1];
      default:
        pathSegment = res[i];
        ln2 = pathSegment.length;
        x = pathSegment[ln2 - 2];
        y = pathSegment[ln2 - 1];
    }
  }
  res.toString = this.path2string;
  return res;
}, pathToRelative:function(pathArray) {
  if (!this.is(pathArray, 'array') || !this.is(pathArray && pathArray[0], 'array')) {
    pathArray = this.parsePathString(pathArray);
  }
  var res = [], x = 0, y = 0, mx = 0, my = 0, start = 0, r, pa, i, j, k, len, ii, jj, kk;
  if (pathArray[0][0] == 'M') {
    x = pathArray[0][1];
    y = pathArray[0][2];
    mx = x;
    my = y;
    start++;
    res.push(['M', x, y]);
  }
  for (i = start, ii = pathArray.length; i < ii; i++) {
    r = res[i] = [];
    pa = pathArray[i];
    if (pa[0] != pa[0].toLowerCase()) {
      r[0] = pa[0].toLowerCase();
      switch(r[0]) {
        case 'a':
          r[1] = pa[1];
          r[2] = pa[2];
          r[3] = pa[3];
          r[4] = pa[4];
          r[5] = pa[5];
          r[6] = +(pa[6] - x).toFixed(3);
          r[7] = +(pa[7] - y).toFixed(3);
          break;
        case 'v':
          r[1] = +(pa[1] - y).toFixed(3);
          break;
        case 'm':
          mx = pa[1];
          my = pa[2];
        default:
          for (j = 1, jj = pa.length; j < jj; j++) {
            r[j] = +(pa[j] - (j % 2 ? x : y)).toFixed(3);
          }
      }
    } else {
      r = res[i] = [];
      if (pa[0] == 'm') {
        mx = pa[1] + x;
        my = pa[2] + y;
      }
      for (k = 0, kk = pa.length; k < kk; k++) {
        res[i][k] = pa[k];
      }
    }
    len = res[i].length;
    switch(res[i][0]) {
      case 'z':
        x = mx;
        y = my;
        break;
      case 'h':
        x += +res[i][len - 1];
        break;
      case 'v':
        y += +res[i][len - 1];
        break;
      default:
        x += +res[i][len - 2];
        y += +res[i][len - 1];
    }
  }
  res.toString = this.path2string;
  return res;
}, path2curve:function(path) {
  var me = this, points = me.pathToAbsolute(path), ln = points.length, attrs = {x:0, y:0, bx:0, by:0, X:0, Y:0, qx:null, qy:null}, i, seg, segLn, point;
  for (i = 0; i < ln; i++) {
    points[i] = me.command2curve(points[i], attrs);
    if (points[i].length > 7) {
      points[i].shift();
      point = points[i];
      while (point.length) {
        Ext.Array.splice(points, i++, 0, ['C'].concat(Ext.Array.splice(point, 0, 6)));
      }
      Ext.Array.erase(points, i, 1);
      ln = points.length;
      i--;
    }
    seg = points[i];
    segLn = seg.length;
    attrs.x = seg[segLn - 2];
    attrs.y = seg[segLn - 1];
    attrs.bx = parseFloat(seg[segLn - 4]) || attrs.x;
    attrs.by = parseFloat(seg[segLn - 3]) || attrs.y;
  }
  return points;
}, interpolatePaths:function(path, path2) {
  var me = this, p = me.pathToAbsolute(path), p2 = me.pathToAbsolute(path2), attrs = {x:0, y:0, bx:0, by:0, X:0, Y:0, qx:null, qy:null}, attrs2 = {x:0, y:0, bx:0, by:0, X:0, Y:0, qx:null, qy:null}, fixArc = function(pp, i) {
    if (pp[i].length > 7) {
      pp[i].shift();
      var pi = pp[i];
      while (pi.length) {
        Ext.Array.splice(pp, i++, 0, ['C'].concat(Ext.Array.splice(pi, 0, 6)));
      }
      Ext.Array.erase(pp, i, 1);
      ii = Math.max(p.length, p2.length || 0);
    }
  }, fixM = function(path1, path2, a1, a2, i) {
    if (path1 && path2 && path1[i][0] == 'M' && path2[i][0] != 'M') {
      Ext.Array.splice(path2, i, 0, ['M', a2.x, a2.y]);
      a1.bx = 0;
      a1.by = 0;
      a1.x = path1[i][1];
      a1.y = path1[i][2];
      ii = Math.max(p.length, p2.length || 0);
    }
  }, i, ii, seg, seg2, seglen, seg2len;
  for (i = 0, ii = Math.max(p.length, p2.length || 0); i < ii; i++) {
    p[i] = me.command2curve(p[i], attrs);
    fixArc(p, i);
    p2[i] = me.command2curve(p2[i], attrs2);
    fixArc(p2, i);
    fixM(p, p2, attrs, attrs2, i);
    fixM(p2, p, attrs2, attrs, i);
    seg = p[i];
    seg2 = p2[i];
    seglen = seg.length;
    seg2len = seg2.length;
    attrs.x = seg[seglen - 2];
    attrs.y = seg[seglen - 1];
    attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
    attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
    attrs2.bx = parseFloat(seg2[seg2len - 4]) || attrs2.x;
    attrs2.by = parseFloat(seg2[seg2len - 3]) || attrs2.y;
    attrs2.x = seg2[seg2len - 2];
    attrs2.y = seg2[seg2len - 1];
  }
  return [p, p2];
}, command2curve:function(pathCommand, d) {
  var me = this;
  if (!pathCommand) {
    return ['C', d.x, d.y, d.x, d.y, d.x, d.y];
  }
  if (pathCommand[0] != 'T' && pathCommand[0] != 'Q') {
    d.qx = d.qy = null;
  }
  switch(pathCommand[0]) {
    case 'M':
      d.X = pathCommand[1];
      d.Y = pathCommand[2];
      break;
    case 'A':
      pathCommand = ['C'].concat(me.arc2curve.apply(me, [d.x, d.y].concat(pathCommand.slice(1))));
      break;
    case 'S':
      pathCommand = ['C', d.x + (d.x - (d.bx || d.x)), d.y + (d.y - (d.by || d.y))].concat(pathCommand.slice(1));
      break;
    case 'T':
      d.qx = d.x + (d.x - (d.qx || d.x));
      d.qy = d.y + (d.y - (d.qy || d.y));
      pathCommand = ['C'].concat(me.quadratic2curve(d.x, d.y, d.qx, d.qy, pathCommand[1], pathCommand[2]));
      break;
    case 'Q':
      d.qx = pathCommand[1];
      d.qy = pathCommand[2];
      pathCommand = ['C'].concat(me.quadratic2curve(d.x, d.y, pathCommand[1], pathCommand[2], pathCommand[3], pathCommand[4]));
      break;
    case 'L':
      pathCommand = ['C'].concat(d.x, d.y, pathCommand[1], pathCommand[2], pathCommand[1], pathCommand[2]);
      break;
    case 'H':
      pathCommand = ['C'].concat(d.x, d.y, pathCommand[1], d.y, pathCommand[1], d.y);
      break;
    case 'V':
      pathCommand = ['C'].concat(d.x, d.y, d.x, pathCommand[1], d.x, pathCommand[1]);
      break;
    case 'Z':
      pathCommand = ['C'].concat(d.x, d.y, d.X, d.Y, d.X, d.Y);
      break;
  }
  return pathCommand;
}, quadratic2curve:function(x1, y1, ax, ay, x2, y2) {
  var _13 = 1 / 3, _23 = 2 / 3;
  return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];
}, rotate:function(x, y, rad) {
  var cos = Math.cos(rad), sin = Math.sin(rad), X = x * cos - y * sin, Y = x * sin + y * cos;
  return {x:X, y:Y};
}, arc2curve:function(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
  var me = this, PI = Math.PI, radian = me.radian, _120 = PI * 120 / 180, rad = radian * (+angle || 0), res = [], math = Math, mcos = math.cos, msin = math.sin, msqrt = math.sqrt, mabs = math.abs, masin = math.asin, xy, x, y, h, rx2, ry2, k, cx, cy, f1, f2, df, c1, s1, c2, s2, t, hx, hy, m1, m2, m3, m4, newres, i, ln, f2old, x2old, y2old;
  if (!recursive) {
    xy = me.rotate(x1, y1, -rad);
    x1 = xy.x;
    y1 = xy.y;
    xy = me.rotate(x2, y2, -rad);
    x2 = xy.x;
    y2 = xy.y;
    x = (x1 - x2) / 2;
    y = (y1 - y2) / 2;
    h = x * x / (rx * rx) + y * y / (ry * ry);
    if (h > 1) {
      h = msqrt(h);
      rx = h * rx;
      ry = h * ry;
    }
    rx2 = rx * rx;
    ry2 = ry * ry;
    k = (large_arc_flag == sweep_flag ? -1 : 1) * msqrt(mabs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
    cx = k * rx * y / ry + (x1 + x2) / 2;
    cy = k * -ry * x / rx + (y1 + y2) / 2;
    f1 = masin(((y1 - cy) / ry).toFixed(7));
    f2 = masin(((y2 - cy) / ry).toFixed(7));
    f1 = x1 < cx ? PI - f1 : f1;
    f2 = x2 < cx ? PI - f2 : f2;
    if (f1 < 0) {
      f1 = PI * 2 + f1;
    }
    if (f2 < 0) {
      f2 = PI * 2 + f2;
    }
    if (sweep_flag && f1 > f2) {
      f1 = f1 - PI * 2;
    }
    if (!sweep_flag && f2 > f1) {
      f2 = f2 - PI * 2;
    }
  } else {
    f1 = recursive[0];
    f2 = recursive[1];
    cx = recursive[2];
    cy = recursive[3];
  }
  df = f2 - f1;
  if (mabs(df) > _120) {
    f2old = f2;
    x2old = x2;
    y2old = y2;
    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
    x2 = cx + rx * mcos(f2);
    y2 = cy + ry * msin(f2);
    res = me.arc2curve(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
  }
  df = f2 - f1;
  c1 = mcos(f1);
  s1 = msin(f1);
  c2 = mcos(f2);
  s2 = msin(f2);
  t = math.tan(df / 4);
  hx = 4 / 3 * rx * t;
  hy = 4 / 3 * ry * t;
  m1 = [x1, y1];
  m2 = [x1 + hx * s1, y1 - hy * c1];
  m3 = [x2 + hx * s2, y2 - hy * c2];
  m4 = [x2, y2];
  m2[0] = 2 * m1[0] - m2[0];
  m2[1] = 2 * m1[1] - m2[1];
  if (recursive) {
    return [m2, m3, m4].concat(res);
  } else {
    res = [m2, m3, m4].concat(res).join().split(',');
    newres = [];
    ln = res.length;
    for (i = 0; i < ln; i++) {
      newres[i] = i % 2 ? me.rotate(res[i - 1], res[i], rad).y : me.rotate(res[i], res[i + 1], rad).x;
    }
    return newres;
  }
}, rotateAndTranslatePath:function(sprite) {
  var alpha = sprite.rotation.degrees, cx = sprite.rotation.x, cy = sprite.rotation.y, dx = sprite.translation.x, dy = sprite.translation.y, path, i, p, xy, j, res = [];
  if (!alpha && !dx && !dy) {
    return this.pathToAbsolute(sprite.attr.path);
  }
  dx = dx || 0;
  dy = dy || 0;
  path = this.pathToAbsolute(sprite.attr.path);
  for (i = path.length; i--;) {
    p = res[i] = path[i].slice();
    if (p[0] == 'A') {
      xy = this.rotatePoint(p[6], p[7], alpha, cx, cy);
      p[6] = xy.x + dx;
      p[7] = xy.y + dy;
    } else {
      j = 1;
      while (p[j + 1] != null) {
        xy = this.rotatePoint(p[j], p[j + 1], alpha, cx, cy);
        p[j] = xy.x + dx;
        p[j + 1] = xy.y + dy;
        j += 2;
      }
    }
  }
  return res;
}, rotatePoint:function(x, y, alpha, cx, cy) {
  if (!alpha) {
    return {x:x, y:y};
  }
  cx = cx || 0;
  cy = cy || 0;
  x = x - cx;
  y = y - cy;
  alpha = alpha * this.radian;
  var cos = Math.cos(alpha), sin = Math.sin(alpha);
  return {x:x * cos - y * sin + cx, y:x * sin + y * cos + cy};
}, pathDimensions:function(path) {
  if (!path || !(path + '')) {
    return {x:0, y:0, width:0, height:0};
  }
  path = this.path2curve(path);
  var x = 0, y = 0, X = [], Y = [], i = 0, ln = path.length, p, xmin, ymin, xmax, ymax, dim;
  for (; i < ln; i++) {
    p = path[i];
    if (p[0] == 'M') {
      x = p[1];
      y = p[2];
      X.push(x);
      Y.push(y);
    } else {
      dim = this.curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
      X = X.concat(dim.min.x, dim.max.x);
      Y = Y.concat(dim.min.y, dim.max.y);
      x = p[5];
      y = p[6];
    }
  }
  xmin = Math.min.apply(0, X);
  ymin = Math.min.apply(0, Y);
  xmax = Math.max.apply(0, X);
  ymax = Math.max.apply(0, Y);
  return {x:Math.round(xmin), y:Math.round(ymin), path:path, width:Math.round(xmax - xmin), height:Math.round(ymax - ymin)};
}, intersectInside:function(path, cp1, cp2) {
  return (cp2[0] - cp1[0]) * (path[1] - cp1[1]) > (cp2[1] - cp1[1]) * (path[0] - cp1[0]);
}, intersectIntersection:function(s, e, cp1, cp2) {
  var p = [], dcx = cp1[0] - cp2[0], dcy = cp1[1] - cp2[1], dpx = s[0] - e[0], dpy = s[1] - e[1], n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0], n2 = s[0] * e[1] - s[1] * e[0], n3 = 1 / (dcx * dpy - dcy * dpx);
  p[0] = (n1 * dpx - n2 * dcx) * n3;
  p[1] = (n1 * dpy - n2 * dcy) * n3;
  return p;
}, intersect:function(subjectPolygon, clipPolygon) {
  var me = this, i = 0, ln = clipPolygon.length, cp1 = clipPolygon[ln - 1], outputList = subjectPolygon, cp2, s, e, ln2, inputList, j;
  for (; i < ln; ++i) {
    cp2 = clipPolygon[i];
    inputList = outputList;
    outputList = [];
    s = inputList[inputList.length - 1];
    j = 0;
    ln2 = inputList.length;
    for (; j < ln2; j++) {
      e = inputList[j];
      if (me.intersectInside(e, cp1, cp2)) {
        if (!me.intersectInside(s, cp1, cp2)) {
          outputList.push(me.intersectIntersection(s, e, cp1, cp2));
        }
        outputList.push(e);
      } else {
        if (me.intersectInside(s, cp1, cp2)) {
          outputList.push(me.intersectIntersection(s, e, cp1, cp2));
        }
      }
      s = e;
    }
    cp1 = cp2;
  }
  return outputList;
}, bezier:function(a, b, c, d, x) {
  if (x === 0) {
    return a;
  } else {
    if (x === 1) {
      return d;
    }
  }
  var du = 1 - x, d3 = du * du * du, r = x / du;
  return d3 * (a + r * (3 * b + r * (3 * c + d * r)));
}, bezierDim:function(a, b, c, d) {
  var points = [], r, A, top, C, delta, bottom, s, min, max, i;
  if (a + 3 * c == d + 3 * b) {
    r = a - b;
    r /= 2 * (a - b - b + c);
    if (r < 1 && r > 0) {
      points.push(r);
    }
  } else {
    A = a - 3 * b + 3 * c - d;
    top = 2 * (a - b - b + c);
    C = a - b;
    delta = top * top - 4 * A * C;
    bottom = A + A;
    if (delta === 0) {
      r = top / bottom;
      if (r < 1 && r > 0) {
        points.push(r);
      }
    } else {
      if (delta > 0) {
        s = Math.sqrt(delta);
        r = (s + top) / bottom;
        if (r < 1 && r > 0) {
          points.push(r);
        }
        r = (top - s) / bottom;
        if (r < 1 && r > 0) {
          points.push(r);
        }
      }
    }
  }
  min = Math.min(a, d);
  max = Math.max(a, d);
  for (i = 0; i < points.length; i++) {
    min = Math.min(min, this.bezier(a, b, c, d, points[i]));
    max = Math.max(max, this.bezier(a, b, c, d, points[i]));
  }
  return [min, max];
}, curveDim:function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
  var x = this.bezierDim(p1x, c1x, c2x, p2x), y = this.bezierDim(p1y, c1y, c2y, p2y);
  return {min:{x:x[0], y:y[0]}, max:{x:x[1], y:y[1]}};
}, getAnchors:function(prevX, prevY, curX, curY, nextX, nextY, value) {
  value = value || 4;
  var M = Math, PI = M.PI, halfPI = PI / 2, abs = M.abs, sin = M.sin, cos = M.cos, atan = M.atan, control1Length, control2Length, control1Angle, control2Angle, control1X, control1Y, control2X, control2Y, alpha;
  control1Length = (curX - prevX) / value;
  control2Length = (nextX - curX) / value;
  if (curY >= prevY && curY >= nextY || curY <= prevY && curY <= nextY) {
    control1Angle = control2Angle = halfPI;
  } else {
    control1Angle = atan((curX - prevX) / abs(curY - prevY));
    if (prevY < curY) {
      control1Angle = PI - control1Angle;
    }
    control2Angle = atan((nextX - curX) / abs(curY - nextY));
    if (nextY < curY) {
      control2Angle = PI - control2Angle;
    }
  }
  alpha = halfPI - (control1Angle + control2Angle) % (PI * 2) / 2;
  if (alpha > halfPI) {
    alpha -= PI;
  }
  control1Angle += alpha;
  control2Angle += alpha;
  control1X = curX - control1Length * sin(control1Angle);
  control1Y = curY + control1Length * cos(control1Angle);
  control2X = curX + control2Length * sin(control2Angle);
  control2Y = curY + control2Length * cos(control2Angle);
  if (curY > prevY && control1Y < prevY || curY < prevY && control1Y > prevY) {
    control1X += abs(prevY - control1Y) * (control1X - curX) / (control1Y - curY);
    control1Y = prevY;
  }
  if (curY > nextY && control2Y < nextY || curY < nextY && control2Y > nextY) {
    control2X -= abs(nextY - control2Y) * (control2X - curX) / (control2Y - curY);
    control2Y = nextY;
  }
  return {x1:control1X, y1:control1Y, x2:control2X, y2:control2Y};
}, smooth:function(originalPath, value) {
  var path = this.path2curve(originalPath), newp = [path[0]], x = path[0][1], y = path[0][2], j, points, i = 1, ii = path.length, beg = 1, mx = x, my = y, pathi, pathil, pathim, pathiml, pathip, pathipl, begl;
  for (; i < ii; i++) {
    pathi = path[i];
    pathil = pathi.length;
    pathim = path[i - 1];
    pathiml = pathim.length;
    pathip = path[i + 1];
    pathipl = pathip && pathip.length;
    if (pathi[0] == 'M') {
      mx = pathi[1];
      my = pathi[2];
      j = i + 1;
      while (path[j][0] != 'C') {
        j++;
      }
      newp.push(['M', mx, my]);
      beg = newp.length;
      x = mx;
      y = my;
      continue;
    }
    if (pathi[pathil - 2] == mx && pathi[pathil - 1] == my && (!pathip || pathip[0] == 'M')) {
      begl = newp[beg].length;
      points = this.getAnchors(pathim[pathiml - 2], pathim[pathiml - 1], mx, my, newp[beg][begl - 2], newp[beg][begl - 1], value);
      newp[beg][1] = points.x2;
      newp[beg][2] = points.y2;
    } else {
      if (!pathip || pathip[0] == 'M') {
        points = {x1:pathi[pathil - 2], y1:pathi[pathil - 1]};
      } else {
        points = this.getAnchors(pathim[pathiml - 2], pathim[pathiml - 1], pathi[pathil - 2], pathi[pathil - 1], pathip[pathipl - 2], pathip[pathipl - 1], value);
      }
    }
    newp.push(['C', x, y, points.x1, points.y1, pathi[pathil - 2], pathi[pathil - 1]]);
    x = points.x2;
    y = points.y2;
  }
  return newp;
}, findDotAtSegment:function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
  var t1 = 1 - t;
  return {x:Math.pow(t1, 3) * p1x + Math.pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + Math.pow(t, 3) * p2x, y:Math.pow(t1, 3) * p1y + Math.pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + Math.pow(t, 3) * p2y};
}, snapEnds:function(from, to, stepsMax, prettyNumbers) {
  if (Ext.isDate(from)) {
    return this.snapEndsByDate(from, to, stepsMax);
  }
  var step = (to - from) / stepsMax, level = Math.floor(Math.log(step) / Math.LN10) + 1, m = Math.pow(10, level), cur, floor, modulo = Math.round(step % m * Math.pow(10, 2 - level)), interval = [[0, 15], [10, 1], [20, 4], [25, 2], [50, 9], [100, 15]], stepCount = 0, value, weight, i, topValue, topWeight = 1000000000, ln = interval.length;
  floor = Math.floor(from / m) * m;
  if (from == floor && floor > 0) {
    floor = Math.floor((from - m / 10) / m) * m;
  }
  if (prettyNumbers) {
    for (i = 0; i < ln; i++) {
      value = interval[i][0];
      weight = value - modulo < 0 ? 1000000 : (value - modulo) / interval[i][1];
      if (weight < topWeight) {
        topValue = value;
        topWeight = weight;
      }
    }
    step = Math.floor(step * Math.pow(10, -level)) * Math.pow(10, level) + topValue * Math.pow(10, level - 2);
    if (from < 0 && to >= 0) {
      cur = 0;
      while (cur > from) {
        cur -= step;
        stepCount++;
      }
      from = +cur.toFixed(10);
      cur = 0;
      while (cur < to) {
        cur += step;
        stepCount++;
      }
      to = +cur.toFixed(10);
    } else {
      cur = from = floor;
      while (cur < to) {
        cur += step;
        stepCount++;
      }
    }
    to = +cur.toFixed(10);
  } else {
    from = floor;
    stepCount = stepsMax;
  }
  return {from:from, to:to, power:level, step:step, steps:stepCount};
}, snapEndsByDate:function(from, to, stepsMax, lockEnds) {
  var selectedStep = false, scales = [[Ext.Date.MILLI, [1, 2, 5, 10, 20, 50, 100, 200, 250, 500]], [Ext.Date.SECOND, [1, 2, 5, 10, 15, 30]], [Ext.Date.MINUTE, [1, 2, 5, 10, 15, 30]], [Ext.Date.HOUR, [1, 2, 3, 4, 6, 12]], [Ext.Date.DAY, [1, 2, 7, 14]], [Ext.Date.MONTH, [1, 2, 3, 6]]], sLen = scales.length, stop = false, scale, j, yearDiff, s;
  for (s = 0; s < sLen; s++) {
    scale = scales[s];
    if (!stop) {
      for (j = 0; j < scale[1].length; j++) {
        if (to < Ext.Date.add(from, scale[0], scale[1][j] * stepsMax)) {
          selectedStep = [scale[0], scale[1][j]];
          stop = true;
          break;
        }
      }
    }
  }
  if (!selectedStep) {
    yearDiff = this.snapEnds(from.getFullYear(), to.getFullYear() + 1, stepsMax, lockEnds);
    selectedStep = [Date.YEAR, Math.round(yearDiff.step)];
  }
  return this.snapEndsByDateAndStep(from, to, selectedStep, lockEnds);
}, snapEndsByDateAndStep:function(from, to, step, lockEnds) {
  var fromStat = [from.getFullYear(), from.getMonth(), from.getDate(), from.getHours(), from.getMinutes(), from.getSeconds(), from.getMilliseconds()], steps, testFrom, testTo, date, year, month, day, fractionalMonth, stepUnit = step[0], stepValue = step[1];
  if (lockEnds) {
    testFrom = from;
  } else {
    switch(stepUnit) {
      case Ext.Date.MILLI:
        testFrom = new Date(fromStat[0], fromStat[1], fromStat[2], fromStat[3], fromStat[4], fromStat[5], Math.floor(fromStat[6] / stepValue) * stepValue);
        break;
      case Ext.Date.SECOND:
        testFrom = new Date(fromStat[0], fromStat[1], fromStat[2], fromStat[3], fromStat[4], Math.floor(fromStat[5] / stepValue) * stepValue, 0);
        break;
      case Ext.Date.MINUTE:
        testFrom = new Date(fromStat[0], fromStat[1], fromStat[2], fromStat[3], Math.floor(fromStat[4] / stepValue) * stepValue, 0, 0);
        break;
      case Ext.Date.HOUR:
        testFrom = new Date(fromStat[0], fromStat[1], fromStat[2], Math.floor(fromStat[3] / stepValue) * stepValue, 0, 0, 0);
        break;
      case Ext.Date.DAY:
        testFrom = new Date(fromStat[0], fromStat[1], Math.floor((fromStat[2] - 1) / stepValue) * stepValue + 1, 0, 0, 0, 0);
        break;
      case Ext.Date.MONTH:
        testFrom = new Date(fromStat[0], Math.floor(fromStat[1] / stepValue) * stepValue, 1, 0, 0, 0, 0);
        break;
      default:
        testFrom = new Date(Math.floor(fromStat[0] / stepValue) * stepValue, 0, 1, 0, 0, 0, 0);
        break;
    }
  }
  fractionalMonth = stepUnit === Ext.Date.MONTH && (stepValue == 1 / 2 || stepValue == 1 / 3 || stepValue == 1 / 4);
  steps = fractionalMonth ? [] : 0;
  testTo = new Date(testFrom);
  while (testTo < to) {
    if (fractionalMonth) {
      date = new Date(testTo);
      year = date.getFullYear();
      month = date.getMonth();
      day = date.getDate();
      switch(stepValue) {
        case 1 / 2:
          if (day >= 15) {
            day = 1;
            if (++month > 11) {
              year++;
            }
          } else {
            day = 15;
          }
          break;
        case 1 / 3:
          if (day >= 20) {
            day = 1;
            if (++month > 11) {
              year++;
            }
          } else {
            if (day >= 10) {
              day = 20;
            } else {
              day = 10;
            }
          }
          break;
        case 1 / 4:
          if (day >= 22) {
            day = 1;
            if (++month > 11) {
              year++;
            }
          } else {
            if (day >= 15) {
              day = 22;
            } else {
              if (day >= 8) {
                day = 15;
              } else {
                day = 8;
              }
            }
          }
          break;
      }
      testTo.setYear(year);
      testTo.setMonth(month);
      testTo.setDate(day);
      steps.push(new Date(testTo));
    } else {
      testTo = Ext.Date.add(testTo, stepUnit, stepValue);
      steps++;
    }
  }
  if (lockEnds) {
    testTo = to;
  }
  if (fractionalMonth) {
    return {from:+testFrom, to:+testTo, steps:steps};
  } else {
    return {from:+testFrom, to:+testTo, step:(testTo - testFrom) / steps, steps:steps};
  }
}, sorter:function(a, b) {
  return a.offset - b.offset;
}, rad:function(degrees) {
  return degrees % 360 * Math.PI / 180;
}, degrees:function(radian) {
  return radian * 180 / Math.PI % 360;
}, withinBox:function(x, y, bbox) {
  bbox = bbox || {};
  return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;
}, parseGradient:function(gradient) {
  var me = this, type = gradient.type || 'linear', angle = gradient.angle || 0, radian = me.radian, stops = gradient.stops, stopsArr = [], stop, vector, max, stopObj;
  if (type == 'linear') {
    vector = [0, 0, Math.cos(angle * radian), Math.sin(angle * radian)];
    max = 1 / (Math.max(Math.abs(vector[2]), Math.abs(vector[3])) || 1);
    vector[2] *= max;
    vector[3] *= max;
    if (vector[2] < 0) {
      vector[0] = -vector[2];
      vector[2] = 0;
    }
    if (vector[3] < 0) {
      vector[1] = -vector[3];
      vector[3] = 0;
    }
  }
  for (stop in stops) {
    if (stops.hasOwnProperty(stop) && me.stopsRE.test(stop)) {
      stopObj = {offset:parseInt(stop, 10), color:Ext.draw.Color.toHex(stops[stop].color) || '#ffffff', opacity:stops[stop].opacity || 1};
      stopsArr.push(stopObj);
    }
  }
  Ext.Array.sort(stopsArr, me.sorter);
  if (type == 'linear') {
    return {id:gradient.id, type:type, vector:vector, stops:stopsArr};
  } else {
    return {id:gradient.id, type:type, centerX:gradient.centerX, centerY:gradient.centerY, focalX:gradient.focalX, focalY:gradient.focalY, radius:gradient.radius, vector:vector, stops:stopsArr};
  }
}});
Ext.define('Ext.fx.PropertyHandler', {statics:{defaultHandler:{pixelDefaultsRE:/width|height|top$|bottom$|left$|right$/i, unitRE:/^(-?\d*\.?\d*){1}(em|ex|px|in|cm|mm|pt|pc|%)*$/, scrollRE:/^scroll/i, computeDelta:function(from, end, damper, initial, attr) {
  damper = typeof damper == 'number' ? damper : 1;
  var unitRE = this.unitRE, match = unitRE.exec(from), start, units;
  if (match) {
    from = match[1];
    units = match[2];
    if (!this.scrollRE.test(attr) && !units && this.pixelDefaultsRE.test(attr)) {
      units = 'px';
    }
  }
  from = +from || 0;
  match = unitRE.exec(end);
  if (match) {
    end = match[1];
    units = match[2] || units;
  }
  end = +end || 0;
  start = initial != null ? initial : from;
  return {from:from, delta:(end - start) * damper, units:units};
}, get:function(from, end, damper, initialFrom, attr) {
  var ln = from.length, out = [], i, initial, res, j, len;
  for (i = 0; i < ln; i++) {
    if (initialFrom) {
      initial = initialFrom[i][1].from;
    }
    if (Ext.isArray(from[i][1]) && Ext.isArray(end)) {
      res = [];
      j = 0;
      len = from[i][1].length;
      for (; j < len; j++) {
        res.push(this.computeDelta(from[i][1][j], end[j], damper, initial, attr));
      }
      out.push([from[i][0], res]);
    } else {
      out.push([from[i][0], this.computeDelta(from[i][1], end, damper, initial, attr)]);
    }
  }
  return out;
}, set:function(values, easing) {
  var ln = values.length, out = [], i, val, res, len, j;
  for (i = 0; i < ln; i++) {
    val = values[i][1];
    if (Ext.isArray(val)) {
      res = [];
      j = 0;
      len = val.length;
      for (; j < len; j++) {
        res.push(val[j].from + val[j].delta * easing + (val[j].units || 0));
      }
      out.push([values[i][0], res]);
    } else {
      out.push([values[i][0], val.from + val.delta * easing + (val.units || 0)]);
    }
  }
  return out;
}}, stringHandler:{computeDelta:function(from, end, damper, initial, attr) {
  return {from:from, delta:end};
}, get:function(from, end, damper, initialFrom, attr) {
  var ln = from.length, out = [], i, initial, res, j, len;
  for (i = 0; i < ln; i++) {
    out.push([from[i][0], this.computeDelta(from[i][1], end, damper, initial, attr)]);
  }
  return out;
}, set:function(values, easing) {
  var ln = values.length, out = [], i, val, res, len, j;
  for (i = 0; i < ln; i++) {
    val = values[i][1];
    out.push([values[i][0], val.delta]);
  }
  return out;
}}, color:{rgbRE:/^rgb\(([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\)$/i, hexRE:/^#?([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})$/i, hex3RE:/^#?([0-9A-F]{1})([0-9A-F]{1})([0-9A-F]{1})$/i, parseColor:function(color, damper) {
  damper = typeof damper == 'number' ? damper : 1;
  var out = false, reList = [this.hexRE, this.rgbRE, this.hex3RE], length = reList.length, match, base, re, i;
  for (i = 0; i < length; i++) {
    re = reList[i];
    base = i % 2 === 0 ? 16 : 10;
    match = re.exec(color);
    if (match && match.length === 4) {
      if (i === 2) {
        match[1] += match[1];
        match[2] += match[2];
        match[3] += match[3];
      }
      out = {red:parseInt(match[1], base), green:parseInt(match[2], base), blue:parseInt(match[3], base)};
      break;
    }
  }
  return out || color;
}, computeDelta:function(from, end, damper, initial) {
  from = this.parseColor(from);
  end = this.parseColor(end, damper);
  var start = initial ? initial : from, tfrom = typeof start, tend = typeof end;
  if (tfrom == 'string' || tfrom == 'undefined' || tend == 'string' || tend == 'undefined') {
    return end || start;
  }
  return {from:from, delta:{red:Math.round((end.red - start.red) * damper), green:Math.round((end.green - start.green) * damper), blue:Math.round((end.blue - start.blue) * damper)}};
}, get:function(start, end, damper, initialFrom) {
  var ln = start.length, out = [], i, initial;
  for (i = 0; i < ln; i++) {
    if (initialFrom) {
      initial = initialFrom[i][1].from;
    }
    out.push([start[i][0], this.computeDelta(start[i][1], end, damper, initial)]);
  }
  return out;
}, set:function(values, easing) {
  var ln = values.length, out = [], i, val, parsedString, from, delta;
  for (i = 0; i < ln; i++) {
    val = values[i][1];
    if (val) {
      from = val.from;
      delta = val.delta;
      val = typeof val == 'object' && 'red' in val ? 'rgb(' + val.red + ', ' + val.green + ', ' + val.blue + ')' : val;
      val = typeof val == 'object' && val.length ? val[0] : val;
      if (typeof val == 'undefined') {
        return [];
      }
      parsedString = typeof val == 'string' ? val : 'rgb(' + [(from.red + Math.round(delta.red * easing)) % 256, (from.green + Math.round(delta.green * easing)) % 256, (from.blue + Math.round(delta.blue * easing)) % 256].join(',') + ')';
      out.push([values[i][0], parsedString]);
    }
  }
  return out;
}}, object:{interpolate:function(prop, damper) {
  damper = typeof damper == 'number' ? damper : 1;
  var out = {}, p;
  for (p in prop) {
    out[p] = parseFloat(prop[p]) * damper;
  }
  return out;
}, computeDelta:function(from, end, damper, initial) {
  from = this.interpolate(from);
  end = this.interpolate(end, damper);
  var start = initial ? initial : from, delta = {}, p;
  for (p in end) {
    delta[p] = end[p] - start[p];
  }
  return {from:from, delta:delta};
}, get:function(start, end, damper, initialFrom) {
  var ln = start.length, out = [], i, initial;
  for (i = 0; i < ln; i++) {
    if (initialFrom) {
      initial = initialFrom[i][1].from;
    }
    out.push([start[i][0], this.computeDelta(start[i][1], end, damper, initial)]);
  }
  return out;
}, set:function(values, easing) {
  var ln = values.length, out = [], outObject = {}, i, from, delta, val, p;
  for (i = 0; i < ln; i++) {
    val = values[i][1];
    from = val.from;
    delta = val.delta;
    for (p in from) {
      outObject[p] = from[p] + delta[p] * easing;
    }
    out.push([values[i][0], outObject]);
  }
  return out;
}}, path:{computeDelta:function(from, end, damper, initial) {
  damper = typeof damper == 'number' ? damper : 1;
  var start;
  from = +from || 0;
  end = +end || 0;
  start = initial != null ? initial : from;
  return {from:from, delta:(end - start) * damper};
}, forcePath:function(path) {
  if (!Ext.isArray(path) && !Ext.isArray(path[0])) {
    path = Ext.draw.Draw.parsePathString(path);
  }
  return path;
}, get:function(start, end, damper, initialFrom) {
  var endPath = this.forcePath(end), out = [], startLn = start.length, startPathLn, pointsLn, i, deltaPath, initial, j, k, path, startPath;
  for (i = 0; i < startLn; i++) {
    startPath = this.forcePath(start[i][1]);
    deltaPath = Ext.draw.Draw.interpolatePaths(startPath, endPath);
    startPath = deltaPath[0];
    endPath = deltaPath[1];
    startPathLn = startPath.length;
    path = [];
    for (j = 0; j < startPathLn; j++) {
      deltaPath = [startPath[j][0]];
      pointsLn = startPath[j].length;
      for (k = 1; k < pointsLn; k++) {
        initial = initialFrom && initialFrom[0][1][j][k].from;
        deltaPath.push(this.computeDelta(startPath[j][k], endPath[j][k], damper, initial));
      }
      path.push(deltaPath);
    }
    out.push([start[i][0], path]);
  }
  return out;
}, set:function(values, easing) {
  var ln = values.length, out = [], i, j, k, newPath, calcPath, deltaPath, deltaPathLn, pointsLn;
  for (i = 0; i < ln; i++) {
    deltaPath = values[i][1];
    newPath = [];
    deltaPathLn = deltaPath.length;
    for (j = 0; j < deltaPathLn; j++) {
      calcPath = [deltaPath[j][0]];
      pointsLn = deltaPath[j].length;
      for (k = 1; k < pointsLn; k++) {
        calcPath.push(deltaPath[j][k].from + deltaPath[j][k].delta * easing);
      }
      newPath.push(calcPath.join(','));
    }
    out.push([values[i][0], newPath.join(',')]);
  }
  return out;
}}}}, function() {
  var props = ['outlineColor', 'backgroundColor', 'borderColor', 'borderTopColor', 'borderRightColor', 'borderBottomColor', 'borderLeftColor', 'fill', 'stroke'], length = props.length, i = 0, prop;
  for (; i < length; i++) {
    prop = props[i];
    this[prop] = this.color;
  }
  props = ['cursor'];
  length = props.length;
  i = 0;
  for (; i < length; i++) {
    prop = props[i];
    this[prop] = this.stringHandler;
  }
});
Ext.define('Ext.fx.Anim', {mixins:{observable:Ext.util.Observable}, isAnimation:true, duration:250, delay:0, delayStart:0, dynamic:false, easing:'ease', damper:1, bezierRE:/^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/, reverse:false, running:false, paused:false, iterations:1, alternate:false, currentIteration:0, startTime:0, frameCount:0, constructor:function(config) {
  var me = this, curve;
  config = config || {};
  if (config.keyframes) {
    return new Ext.fx.Animator(config);
  }
  Ext.apply(me, config);
  if (me.from === undefined) {
    me.from = {};
  }
  me.propHandlers = {};
  me.config = config;
  me.target = Ext.fx.Manager.createTarget(me.target);
  me.easingFn = Ext.fx.Easing[me.easing];
  me.target.dynamic = me.dynamic;
  if (!me.easingFn) {
    me.easingFn = String(me.easing).match(me.bezierRE);
    if (me.easingFn && me.easingFn.length == 5) {
      curve = me.easingFn;
      me.easingFn = Ext.fx.CubicBezier.cubicBezier(+curve[1], +curve[2], +curve[3], +curve[4]);
    }
  }
  me.id = Ext.id(null, 'ext-anim-');
  me.addEvents('beforeanimate', 'afteranimate', 'lastframe');
  me.mixins.observable.constructor.call(me);
  Ext.fx.Manager.addAnim(me);
}, setAttr:function(attr, value) {
  return Ext.fx.Manager.items.get(this.id).setAttr(this.target, attr, value);
}, initAttrs:function() {
  var me = this, from = me.from, to = me.to, initialFrom = me.initialFrom || {}, out = {}, start, end, propHandler, attr;
  for (attr in to) {
    if (to.hasOwnProperty(attr)) {
      start = me.target.getAttr(attr, from[attr]);
      end = to[attr];
      if (!Ext.fx.PropertyHandler[attr]) {
        if (Ext.isObject(end)) {
          propHandler = me.propHandlers[attr] = Ext.fx.PropertyHandler.object;
        } else {
          propHandler = me.propHandlers[attr] = Ext.fx.PropertyHandler.defaultHandler;
        }
      } else {
        propHandler = me.propHandlers[attr] = Ext.fx.PropertyHandler[attr];
      }
      out[attr] = propHandler.get(start, end, me.damper, initialFrom[attr], attr);
    }
  }
  me.currentAttrs = out;
}, start:function(startTime) {
  var me = this, delay = me.delay, delayStart = me.delayStart, delayDelta;
  if (delay) {
    if (!delayStart) {
      me.delayStart = startTime;
      return;
    } else {
      delayDelta = startTime - delayStart;
      if (delayDelta < delay) {
        return;
      } else {
        startTime = new Date(delayStart.getTime() + delay);
      }
    }
  }
  if (me.fireEvent('beforeanimate', me) !== false) {
    me.startTime = startTime;
    if (!me.paused && !me.currentAttrs) {
      me.initAttrs();
    }
    me.running = true;
    me.frameCount = 0;
  }
}, runAnim:function(elapsedTime) {
  var me = this, attrs = me.currentAttrs, duration = me.duration, easingFn = me.easingFn, propHandlers = me.propHandlers, ret = {}, easing, values, attr, lastFrame;
  if (elapsedTime >= duration) {
    elapsedTime = duration;
    lastFrame = true;
  }
  if (me.reverse) {
    elapsedTime = duration - elapsedTime;
  }
  for (attr in attrs) {
    if (attrs.hasOwnProperty(attr)) {
      values = attrs[attr];
      easing = lastFrame ? 1 : easingFn(elapsedTime / duration);
      ret[attr] = propHandlers[attr].set(values, easing);
    }
  }
  me.frameCount++;
  return ret;
}, lastFrame:function() {
  var me = this, iter = me.iterations, iterCount = me.currentIteration;
  iterCount++;
  if (iterCount < iter) {
    if (me.alternate) {
      me.reverse = !me.reverse;
    }
    me.startTime = new Date;
    me.currentIteration = iterCount;
    me.paused = false;
  } else {
    me.currentIteration = 0;
    me.end();
    me.fireEvent('lastframe', me, me.startTime);
  }
}, endWasCalled:0, end:function() {
  if (this.endWasCalled++) {
    return;
  }
  var me = this;
  me.startTime = 0;
  me.paused = false;
  me.running = false;
  Ext.fx.Manager.removeAnim(me);
  me.fireEvent('afteranimate', me, me.startTime);
  Ext.callback(me.callback, me.scope, [me, me.startTime]);
}, isReady:function() {
  return this.paused === false && this.running === false && this.iterations > 0;
}, isRunning:function() {
  return this.paused === false && this.running === true && this.isAnimator !== true;
}});
Ext.enableFx = true;
Ext.define('Ext.util.Animate', {isAnimate:true, animate:function(animObj) {
  var me = this;
  if (Ext.fx.Manager.hasFxBlock(me.id)) {
    return me;
  }
  Ext.fx.Manager.queueFx(new Ext.fx.Anim(me.anim(animObj)));
  return this;
}, anim:function(config) {
  if (!Ext.isObject(config)) {
    return config ? {} : false;
  }
  var me = this;
  if (config.stopAnimation) {
    me.stopAnimation();
  }
  Ext.applyIf(config, Ext.fx.Manager.getFxDefaults(me.id));
  return Ext.apply({target:me, paused:true}, config);
}, stopFx:Ext.Function.alias(Ext.util.Animate, 'stopAnimation'), stopAnimation:function() {
  Ext.fx.Manager.stopAnimation(this.id);
  return this;
}, syncFx:function() {
  Ext.fx.Manager.setFxDefaults(this.id, {concurrent:true});
  return this;
}, sequenceFx:function() {
  Ext.fx.Manager.setFxDefaults(this.id, {concurrent:false});
  return this;
}, hasActiveFx:Ext.Function.alias(Ext.util.Animate, 'getActiveAnimation'), getActiveAnimation:function() {
  return Ext.fx.Manager.getActiveAnimation(this.id);
}}, function() {
  Ext.applyIf(Ext.Element.prototype, this.prototype);
  Ext.CompositeElementLite.importElementMethods();
});
Ext.define('Ext.util.ElementContainer', {childEls:[], constructor:function() {
  var me = this, childEls;
  if (me.hasOwnProperty('childEls')) {
    childEls = me.childEls;
    delete me.childEls;
    me.addChildEls.apply(me, childEls);
  }
}, destroy:function() {
  var me = this, childEls = me.getChildEls(), child, childName, i, k;
  for (i = childEls.length; i--;) {
    childName = childEls[i];
    if (typeof childName != 'string') {
      childName = childName.name;
    }
    child = me[childName];
    if (child) {
      me[childName] = null;
      child.remove();
    }
  }
}, addChildEls:function() {
  var me = this, args = arguments;
  if (me.hasOwnProperty('childEls')) {
    me.childEls.push.apply(me.childEls, args);
  } else {
    me.childEls = me.getChildEls().concat(Array.prototype.slice.call(args));
  }
  me.prune(me.childEls, false);
}, applyChildEls:function(el, id) {
  var me = this, childEls = me.getChildEls(), baseId, childName, i, selector, value;
  baseId = (id || me.id) + '-';
  for (i = childEls.length; i--;) {
    childName = childEls[i];
    if (typeof childName == 'string') {
      value = el.getById(baseId + childName);
    } else {
      if (selector = childName.select) {
        value = Ext.select(selector, true, el.dom);
      } else {
        if (selector = childName.selectNode) {
          value = Ext.get(Ext.DomQuery.selectNode(selector, el.dom));
        } else {
          value = el.getById(childName.id || baseId + childName.itemId);
        }
      }
      childName = childName.name;
    }
    me[childName] = value;
  }
}, getChildEls:function() {
  var me = this, self;
  if (me.hasOwnProperty('childEls')) {
    return me.childEls;
  }
  self = me.self;
  return self.$childEls || me.getClassChildEls(self);
}, getClassChildEls:function(cls) {
  var me = this, result = cls.$childEls, childEls, i, length, forked, mixin, mixins, name, parts, proto, supr, superMixins;
  if (!result) {
    supr = cls.superclass;
    if (supr) {
      supr = supr.self;
      parts = [supr.$childEls || me.getClassChildEls(supr)];
      superMixins = supr.prototype.mixins || {};
    } else {
      parts = [];
      superMixins = {};
    }
    proto = cls.prototype;
    mixins = proto.mixins;
    for (name in mixins) {
      if (mixins.hasOwnProperty(name) && !superMixins.hasOwnProperty(name)) {
        mixin = mixins[name].self;
        parts.push(mixin.$childEls || me.getClassChildEls(mixin));
      }
    }
    parts.push(proto.hasOwnProperty('childEls') && proto.childEls);
    for (i = 0, length = parts.length; i < length; ++i) {
      childEls = parts[i];
      if (childEls && childEls.length) {
        if (!result) {
          result = childEls;
        } else {
          if (!forked) {
            forked = true;
            result = result.slice(0);
          }
          result.push.apply(result, childEls);
        }
      }
    }
    cls.$childEls = result = result ? me.prune(result, !forked) : [];
  }
  return result;
}, prune:function(childEls, shared) {
  var index = childEls.length, map = {}, name;
  while (index--) {
    name = childEls[index];
    if (typeof name != 'string') {
      name = name.name;
    }
    if (!map[name]) {
      map[name] = 1;
    } else {
      if (shared) {
        shared = false;
        childEls = childEls.slice(0);
      }
      Ext.Array.erase(childEls, index, 1);
    }
  }
  return childEls;
}, removeChildEls:function(testFn) {
  var me = this, old = me.getChildEls(), keepers = me.childEls = [], n, i, cel;
  for (i = 0, n = old.length; i < n; ++i) {
    cel = old[i];
    if (!testFn(cel)) {
      keepers.push(cel);
    }
  }
}});
Ext.define('Ext.util.Renderable', {frameCls:Ext.baseCSSPrefix + 'frame', frameIdRegex:/[\-]frame\d+[TMB][LCR]$/, frameElNames:['TL', 'TC', 'TR', 'ML', 'MC', 'MR', 'BL', 'BC', 'BR'], frameTpl:['{%this.renderDockedItems(out,values,0);%}', '\x3ctpl if\x3d"top"\x3e', '\x3ctpl if\x3d"left"\x3e\x3cdiv id\x3d"{fgid}TL" class\x3d"{frameCls}-tl {baseCls}-tl {baseCls}-{ui}-tl\x3ctpl for\x3d"uiCls"\x3e {parent.baseCls}-{parent.ui}-{.}-tl\x3c/tpl\x3e{frameElCls}" role\x3d"presentation"\x3e\x3c/tpl\x3e', '\x3ctpl if\x3d"right"\x3e\x3cdiv id\x3d"{fgid}TR" class\x3d"{frameCls}-tr {baseCls}-tr {baseCls}-{ui}-tr\x3ctpl for\x3d"uiCls"\x3e {parent.baseCls}-{parent.ui}-{.}-tr\x3c/tpl\x3e{frameElCls}" role\x3d"presentation"\x3e\x3c/tpl\x3e', 
'\x3cdiv id\x3d"{fgid}TC" class\x3d"{frameCls}-tc {baseCls}-tc {baseCls}-{ui}-tc\x3ctpl for\x3d"uiCls"\x3e {parent.baseCls}-{parent.ui}-{.}-tc\x3c/tpl\x3e{frameElCls}" role\x3d"presentation"\x3e\x3c/div\x3e', '\x3ctpl if\x3d"right"\x3e\x3c/div\x3e\x3c/tpl\x3e', '\x3ctpl if\x3d"left"\x3e\x3c/div\x3e\x3c/tpl\x3e', '\x3c/tpl\x3e', '\x3ctpl if\x3d"left"\x3e\x3cdiv id\x3d"{fgid}ML" class\x3d"{frameCls}-ml {baseCls}-ml {baseCls}-{ui}-ml\x3ctpl for\x3d"uiCls"\x3e {parent.baseCls}-{parent.ui}-{.}-ml\x3c/tpl\x3e{frameElCls}" role\x3d"presentation"\x3e\x3c/tpl\x3e', 
'\x3ctpl if\x3d"right"\x3e\x3cdiv id\x3d"{fgid}MR" class\x3d"{frameCls}-mr {baseCls}-mr {baseCls}-{ui}-mr\x3ctpl for\x3d"uiCls"\x3e {parent.baseCls}-{parent.ui}-{.}-mr\x3c/tpl\x3e{frameElCls}" role\x3d"presentation"\x3e\x3c/tpl\x3e', '\x3cdiv id\x3d"{fgid}MC" class\x3d"{frameCls}-mc {baseCls}-mc {baseCls}-{ui}-mc\x3ctpl for\x3d"uiCls"\x3e {parent.baseCls}-{parent.ui}-{.}-mc\x3c/tpl\x3e{frameElCls}" role\x3d"presentation"\x3e', '{%this.applyRenderTpl(out, values)%}', '\x3c/div\x3e', '\x3ctpl if\x3d"right"\x3e\x3c/div\x3e\x3c/tpl\x3e', 
'\x3ctpl if\x3d"left"\x3e\x3c/div\x3e\x3c/tpl\x3e', '\x3ctpl if\x3d"bottom"\x3e', '\x3ctpl if\x3d"left"\x3e\x3cdiv id\x3d"{fgid}BL" class\x3d"{frameCls}-bl {baseCls}-bl {baseCls}-{ui}-bl\x3ctpl for\x3d"uiCls"\x3e {parent.baseCls}-{parent.ui}-{.}-bl\x3c/tpl\x3e{frameElCls}" role\x3d"presentation"\x3e\x3c/tpl\x3e', '\x3ctpl if\x3d"right"\x3e\x3cdiv id\x3d"{fgid}BR" class\x3d"{frameCls}-br {baseCls}-br {baseCls}-{ui}-br\x3ctpl for\x3d"uiCls"\x3e {parent.baseCls}-{parent.ui}-{.}-br\x3c/tpl\x3e{frameElCls}" role\x3d"presentation"\x3e\x3c/tpl\x3e', 
'\x3cdiv id\x3d"{fgid}BC" class\x3d"{frameCls}-bc {baseCls}-bc {baseCls}-{ui}-bc\x3ctpl for\x3d"uiCls"\x3e {parent.baseCls}-{parent.ui}-{.}-bc\x3c/tpl\x3e{frameElCls}" role\x3d"presentation"\x3e\x3c/div\x3e', '\x3ctpl if\x3d"right"\x3e\x3c/div\x3e\x3c/tpl\x3e', '\x3ctpl if\x3d"left"\x3e\x3c/div\x3e\x3c/tpl\x3e', '\x3c/tpl\x3e', '{%this.renderDockedItems(out,values,1);%}'], frameTableTpl:['{%this.renderDockedItems(out,values,0);%}', '\x3ctable class\x3d"', Ext.plainTableCls, '" cellpadding\x3d"0"\x3e\x3ctbody\x3e', 
'\x3ctpl if\x3d"top"\x3e', '\x3ctr\x3e', '\x3ctpl if\x3d"left"\x3e\x3ctd id\x3d"{fgid}TL" class\x3d"{frameCls}-tl {baseCls}-tl {baseCls}-{ui}-tl\x3ctpl for\x3d"uiCls"\x3e {parent.baseCls}-{parent.ui}-{.}-tl\x3c/tpl\x3e{frameElCls}" role\x3d"presentation"\x3e\x3c/td\x3e\x3c/tpl\x3e', '\x3ctd id\x3d"{fgid}TC" class\x3d"{frameCls}-tc {baseCls}-tc {baseCls}-{ui}-tc\x3ctpl for\x3d"uiCls"\x3e {parent.baseCls}-{parent.ui}-{.}-tc\x3c/tpl\x3e{frameElCls}" role\x3d"presentation"\x3e\x3c/td\x3e', '\x3ctpl if\x3d"right"\x3e\x3ctd id\x3d"{fgid}TR" class\x3d"{frameCls}-tr {baseCls}-tr {baseCls}-{ui}-tr\x3ctpl for\x3d"uiCls"\x3e {parent.baseCls}-{parent.ui}-{.}-tr\x3c/tpl\x3e{frameElCls}" role\x3d"presentation"\x3e\x3c/td\x3e\x3c/tpl\x3e', 
'\x3c/tr\x3e', '\x3c/tpl\x3e', '\x3ctr\x3e', '\x3ctpl if\x3d"left"\x3e\x3ctd id\x3d"{fgid}ML" class\x3d"{frameCls}-ml {baseCls}-ml {baseCls}-{ui}-ml\x3ctpl for\x3d"uiCls"\x3e {parent.baseCls}-{parent.ui}-{.}-ml\x3c/tpl\x3e{frameElCls}" role\x3d"presentation"\x3e\x3c/td\x3e\x3c/tpl\x3e', '\x3ctd id\x3d"{fgid}MC" class\x3d"{frameCls}-mc {baseCls}-mc {baseCls}-{ui}-mc\x3ctpl for\x3d"uiCls"\x3e {parent.baseCls}-{parent.ui}-{.}-mc\x3c/tpl\x3e{frameElCls}" role\x3d"presentation"\x3e', '{%this.applyRenderTpl(out, values)%}', 
'\x3c/td\x3e', '\x3ctpl if\x3d"right"\x3e\x3ctd id\x3d"{fgid}MR" class\x3d"{frameCls}-mr {baseCls}-mr {baseCls}-{ui}-mr\x3ctpl for\x3d"uiCls"\x3e {parent.baseCls}-{parent.ui}-{.}-mr\x3c/tpl\x3e{frameElCls}" role\x3d"presentation"\x3e\x3c/td\x3e\x3c/tpl\x3e', '\x3c/tr\x3e', '\x3ctpl if\x3d"bottom"\x3e', '\x3ctr\x3e', '\x3ctpl if\x3d"left"\x3e\x3ctd id\x3d"{fgid}BL" class\x3d"{frameCls}-bl {baseCls}-bl {baseCls}-{ui}-bl\x3ctpl for\x3d"uiCls"\x3e {parent.baseCls}-{parent.ui}-{.}-bl\x3c/tpl\x3e{frameElCls}" role\x3d"presentation"\x3e\x3c/td\x3e\x3c/tpl\x3e', 
'\x3ctd id\x3d"{fgid}BC" class\x3d"{frameCls}-bc {baseCls}-bc {baseCls}-{ui}-bc\x3ctpl for\x3d"uiCls"\x3e {parent.baseCls}-{parent.ui}-{.}-bc\x3c/tpl\x3e{frameElCls}" role\x3d"presentation"\x3e\x3c/td\x3e', '\x3ctpl if\x3d"right"\x3e\x3ctd id\x3d"{fgid}BR" class\x3d"{frameCls}-br {baseCls}-br {baseCls}-{ui}-br\x3ctpl for\x3d"uiCls"\x3e {parent.baseCls}-{parent.ui}-{.}-br\x3c/tpl\x3e{frameElCls}" role\x3d"presentation"\x3e\x3c/td\x3e\x3c/tpl\x3e', '\x3c/tr\x3e', '\x3c/tpl\x3e', '\x3c/tbody\x3e\x3c/table\x3e', 
'{%this.renderDockedItems(out,values,1);%}'], afterRender:function() {
  var me = this, data = {}, protoEl = me.protoEl, target = me.el, item, pre, hide, contentEl;
  me.finishRenderChildren();
  if (me.contentEl) {
    pre = Ext.baseCSSPrefix;
    hide = pre + 'hide-';
    contentEl = Ext.get(me.contentEl);
    contentEl.removeCls([pre + 'hidden', hide + 'display', hide + 'offsets', hide + 'nosize']);
    me.getContentTarget().appendChild(contentEl.dom);
  }
  protoEl.writeTo(data);
  item = data.removed;
  if (item) {
    target.removeCls(item);
  }
  item = data.cls;
  if (item.length) {
    target.addCls(item);
  }
  item = data.style;
  if (data.style) {
    target.setStyle(item);
  }
  me.protoEl = null;
  if (!me.ownerCt) {
    me.updateLayout();
  }
}, afterFirstLayout:function(width, height) {
  var me = this, x = me.x, y = me.y, hasX, hasY, pos, xy;
  if (!me.ownerLayout) {
    hasX = Ext.isDefined(x);
    hasY = Ext.isDefined(y);
  }
  if (me.floating && (!hasX || !hasY)) {
    if (me.floatParent) {
      pos = me.floatParent.getTargetEl().getViewRegion();
      xy = me.el.getAlignToXY(me.floatParent.getTargetEl(), 'c-c');
      pos.x = xy[0] - pos.x;
      pos.y = xy[1] - pos.y;
    } else {
      xy = me.el.getAlignToXY(me.container, 'c-c');
      pos = me.container.translateXY(xy[0], xy[1]);
    }
    x = hasX ? x : pos.x;
    y = hasY ? y : pos.y;
    hasX = hasY = true;
  }
  if (hasX || hasY) {
    me.setPosition(x, y);
  }
  me.onBoxReady(width, height);
}, applyRenderSelectors:function() {
  var me = this, selectors = me.renderSelectors, el = me.el, dom = el.dom, selector;
  me.applyChildEls(el);
  if (selectors) {
    for (selector in selectors) {
      if (selectors.hasOwnProperty(selector) && selectors[selector]) {
        me[selector] = Ext.get(Ext.DomQuery.selectNode(selectors[selector], dom));
      }
    }
  }
}, beforeRender:function() {
  var me = this, target = me.getTargetEl(), overflowEl = me.getOverflowEl(), layout = me.getComponentLayout(), overflowStyle = me.getOverflowStyle();
  me.frame = me.frame || me.alwaysFramed;
  if (!layout.initialized) {
    layout.initLayout();
  }
  if (overflowEl) {
    overflowEl.setStyle(overflowStyle);
    me.overflowStyleSet = true;
  }
  me.setUI(me.ui);
  if (me.disabled) {
    me.disable(true);
  }
}, doApplyRenderTpl:function(out, values) {
  var me = values.$comp, tpl;
  if (!me.rendered) {
    tpl = me.initRenderTpl();
    tpl.applyOut(values.renderData, out);
  }
}, doAutoRender:function() {
  var me = this;
  if (!me.rendered) {
    if (me.floating) {
      me.render(document.body);
    } else {
      me.render(Ext.isBoolean(me.autoRender) ? Ext.getBody() : me.autoRender);
    }
  }
}, doRenderContent:function(out, renderData) {
  var me = renderData.$comp;
  if (me.html) {
    Ext.DomHelper.generateMarkup(me.html, out);
    delete me.html;
  }
  if (me.tpl) {
    if (!me.tpl.isTemplate) {
      me.tpl = new Ext.XTemplate(me.tpl);
    }
    if (me.data) {
      me.tpl.applyOut(me.data, out);
      delete me.data;
    }
  }
}, doRenderFramingDockedItems:function(out, renderData, after) {
  var me = renderData.$comp;
  if (!me.rendered && me.doRenderDockedItems) {
    renderData.renderData.$skipDockedItems = true;
    me.doRenderDockedItems.call(this, out, renderData, after);
  }
}, finishRender:function(containerIdx) {
  var me = this, tpl, data, el;
  if (!me.el || me.$pid) {
    if (me.container) {
      el = me.container.getById(me.id, true);
    } else {
      el = Ext.getDom(me.id);
    }
    if (!me.el) {
      me.wrapPrimaryEl(el);
    } else {
      delete me.$pid;
      if (!me.el.dom) {
        me.wrapPrimaryEl(me.el);
      }
      el.parentNode.insertBefore(me.el.dom, el);
      Ext.removeNode(el);
    }
  } else {
    if (!me.rendering) {
      tpl = me.initRenderTpl();
      if (tpl) {
        data = me.initRenderData();
        tpl.insertFirst(me.getTargetEl(), data);
      }
    }
  }
  if (!me.container) {
    me.container = Ext.get(me.el.dom.parentNode);
  }
  if (me.ctCls) {
    me.container.addCls(me.ctCls);
  }
  me.onRender(me.container, containerIdx);
  if (!me.overflowStyleSet) {
    me.getOverflowEl().setStyle(me.getOverflowStyle());
  }
  me.el.setVisibilityMode(Ext.Element[me.hideMode.toUpperCase()]);
  if (me.overCls) {
    me.el.hover(me.addOverCls, me.removeOverCls, me);
  }
  if (me.hasListeners.render) {
    me.fireEvent('render', me);
  }
  me.afterRender();
  if (me.hasListeners.afterrender) {
    me.fireEvent('afterrender', me);
  }
  me.initEvents();
  if (me.hidden) {
    me.el.hide();
  }
}, finishRenderChildren:function() {
  var layout = this.getComponentLayout();
  layout.finishRender();
}, getElConfig:function() {
  var me = this, autoEl = me.autoEl, frameInfo = me.getFrameInfo(), config = {tag:'div', tpl:frameInfo ? me.initFramingTpl(frameInfo.table) : me.initRenderTpl()}, protoEl = me.protoEl, i, frameElNames, len, suffix, frameGenId, frameData;
  me.initStyles(protoEl);
  protoEl.writeTo(config);
  protoEl.flush();
  if (Ext.isString(autoEl)) {
    config.tag = autoEl;
  } else {
    Ext.apply(config, autoEl);
  }
  config.id = me.id;
  if (config.tpl) {
    if (frameInfo) {
      frameElNames = me.frameElNames;
      len = frameElNames.length;
      config.tplData = frameData = me.getFrameRenderData();
      frameData.renderData = me.initRenderData();
      frameGenId = frameData.fgid;
      for (i = 0; i < len; i++) {
        suffix = frameElNames[i];
        me.addChildEls({name:'frame' + suffix, id:frameGenId + suffix});
      }
      me.addChildEls({name:'frameBody', id:frameGenId + 'MC'});
    } else {
      config.tplData = me.initRenderData();
    }
  }
  return config;
}, initFramingTpl:function(table) {
  var tpl = this.getFrameTpl(table);
  if (tpl && !tpl.applyRenderTpl) {
    this.setupFramingTpl(tpl);
  }
  return tpl;
}, setupFramingTpl:function(frameTpl) {
  frameTpl.applyRenderTpl = this.doApplyRenderTpl;
  frameTpl.renderDockedItems = this.doRenderFramingDockedItems;
}, getInsertPosition:function(position) {
  if (position !== undefined) {
    if (Ext.isNumber(position)) {
      position = this.container.dom.childNodes[position];
    } else {
      position = Ext.getDom(position);
    }
  }
  return position;
}, getRenderTree:function() {
  var me = this;
  if (!me.hasListeners.beforerender || me.fireEvent('beforerender', me) !== false) {
    me.beforeRender();
    me.rendering = true;
    if (me.el) {
      return {tag:'div', id:me.$pid = Ext.id()};
    }
    return me.getElConfig();
  }
  return null;
}, initContainer:function(container) {
  var me = this;
  if (!container && me.el) {
    container = me.el.dom.parentNode;
    me.allowDomMove = false;
  }
  me.container = container.dom ? container : Ext.get(container);
  return me.container;
}, initRenderData:function() {
  var me = this;
  return Ext.apply({$comp:me, id:me.id, ui:me.ui, uiCls:me.uiCls, baseCls:me.baseCls, componentCls:me.componentCls, frame:me.frame, childElCls:''}, me.renderData);
}, initRenderTpl:function() {
  var tpl = this.getTpl('renderTpl');
  if (tpl && !tpl.renderContent) {
    this.setupRenderTpl(tpl);
  }
  return tpl;
}, onRender:function(parentNode, containerIdx) {
  var me = this, x = me.x, y = me.y, lastBox = null, width, height, el = me.el;
  me.applyRenderSelectors();
  me.rendering = null;
  me.rendered = true;
  if (x != null) {
    lastBox = {x:x};
  }
  if (y != null) {
    (lastBox = lastBox || {}).y = y;
  }
  if (!me.getFrameInfo() && Ext.isBorderBox) {
    width = me.width;
    height = me.height;
    if (typeof width === 'number') {
      lastBox = lastBox || {};
      lastBox.width = width;
    }
    if (typeof height === 'number') {
      lastBox = lastBox || {};
      lastBox.height = height;
    }
  }
  me.lastBox = el.lastBox = lastBox;
}, render:function(container, position) {
  var me = this, el = me.el && (me.el = Ext.get(me.el)), vetoed, tree, nextSibling;
  Ext.suspendLayouts();
  container = me.initContainer(container);
  nextSibling = me.getInsertPosition(position);
  if (!el) {
    tree = me.getRenderTree();
    if (me.ownerLayout && me.ownerLayout.transformItemRenderTree) {
      tree = me.ownerLayout.transformItemRenderTree(tree);
    }
    if (tree) {
      if (nextSibling) {
        el = Ext.DomHelper.insertBefore(nextSibling, tree);
      } else {
        el = Ext.DomHelper.append(container, tree);
      }
      me.wrapPrimaryEl(el);
    }
  } else {
    if (!me.hasListeners.beforerender || me.fireEvent('beforerender', me) !== false) {
      me.beforeRender();
      me.initStyles(el);
      if (me.allowDomMove !== false) {
        if (nextSibling) {
          container.dom.insertBefore(el.dom, nextSibling);
        } else {
          container.dom.appendChild(el.dom);
        }
      }
    } else {
      vetoed = true;
    }
  }
  if (el && !vetoed) {
    me.finishRender(position);
  }
  Ext.resumeLayouts(!me.hidden && !container.isDetachedBody);
}, ensureAttachedToBody:function(runLayout) {
  var comp = this, body;
  while (comp.ownerCt) {
    comp = comp.ownerCt;
  }
  if (comp.container.isDetachedBody) {
    comp.container = body = Ext.getBody();
    body.appendChild(comp.el.dom);
    if (runLayout) {
      comp.updateLayout();
    }
    if (typeof comp.x == 'number' || typeof comp.y == 'number') {
      comp.setPosition(comp.x, comp.y);
    }
  }
}, setupRenderTpl:function(renderTpl) {
  renderTpl.renderBody = renderTpl.renderContent = this.doRenderContent;
}, wrapPrimaryEl:function(dom) {
  this.el = Ext.get(dom, true);
}, initFrame:function() {
  if (Ext.supports.CSS3BorderRadius || !this.frame) {
    return;
  }
  var me = this, frameInfo = me.getFrameInfo(), frameTpl, frameGenId, frameElNames = me.frameElNames, len = frameElNames.length, i, frameData, suffix;
  if (frameInfo) {
    frameTpl = me.getFrameTpl(frameInfo.table);
    frameData = me.getFrameRenderData();
    frameGenId = frameData.fgid;
    frameTpl.insertFirst(me.el, frameData);
    me.frameBody = me.el.down('.' + me.frameCls + '-mc');
    me.removeChildEls(function(c) {
      return c.id && me.frameIdRegex.test(c.id);
    });
    for (i = 0; i < len; i++) {
      suffix = frameElNames[i];
      me['frame' + suffix] = me.el.getById(frameGenId + suffix);
    }
  }
}, getFrameRenderData:function() {
  var me = this, frameInfo = me.frameSize, frameGenId = (me.frameGenId || 0) + 1;
  me.frameGenId = frameGenId;
  return {$comp:me, fgid:me.id + '-frame' + frameGenId, ui:me.ui, uiCls:me.uiCls, frameCls:me.frameCls, baseCls:me.baseCls, top:!!frameInfo.top, left:!!frameInfo.left, right:!!frameInfo.right, bottom:!!frameInfo.bottom, frameElCls:''};
}, updateFrame:function() {
  if (Ext.supports.CSS3BorderRadius || !this.frame) {
    return;
  }
  var me = this, wasTable = me.frameSize && me.frameSize.table, oldFrameTL = me.frameTL, oldFrameBL = me.frameBL, oldFrameML = me.frameML, oldFrameMC = me.frameMC, newMCClassName;
  me.initFrame();
  if (oldFrameMC) {
    if (me.frame) {
      newMCClassName = me.frameMC.dom.className;
      oldFrameMC.insertAfter(me.frameMC);
      me.frameMC.remove();
      me.frameBody = me.frameMC = oldFrameMC;
      oldFrameMC.dom.className = newMCClassName;
      if (wasTable) {
        me.el.query('\x3e table')[1].remove();
      } else {
        if (oldFrameTL) {
          oldFrameTL.remove();
        }
        if (oldFrameBL) {
          oldFrameBL.remove();
        }
        if (oldFrameML) {
          oldFrameML.remove();
        }
      }
    }
  } else {
    if (me.frame) {
      me.applyRenderSelectors();
    }
  }
}, getFrameInfo:function() {
  if (Ext.supports.CSS3BorderRadius || !this.frame) {
    return false;
  }
  var me = this, frameInfoCache = me.frameInfoCache, cls = me.getFramingInfoCls() + '-frameInfo', frameInfo = frameInfoCache[cls], max = Math.max, styleEl, match, info, frameTop, frameRight, frameBottom, frameLeft, borderWidthT, borderWidthR, borderWidthB, borderWidthL, paddingT, paddingR, paddingB, paddingL, borderRadiusTL, borderRadiusTR, borderRadiusBR, borderRadiusBL;
  if (frameInfo == null) {
    styleEl = Ext.fly(me.getStyleProxy(cls), 'frame-style-el');
    info = styleEl.getStyle('font-family');
    if (info) {
      info = info.split('-');
      borderRadiusTL = parseInt(info[1], 10);
      borderRadiusTR = parseInt(info[2], 10);
      borderRadiusBR = parseInt(info[3], 10);
      borderRadiusBL = parseInt(info[4], 10);
      borderWidthT = parseInt(info[5], 10);
      borderWidthR = parseInt(info[6], 10);
      borderWidthB = parseInt(info[7], 10);
      borderWidthL = parseInt(info[8], 10);
      paddingT = parseInt(info[9], 10);
      paddingR = parseInt(info[10], 10);
      paddingB = parseInt(info[11], 10);
      paddingL = parseInt(info[12], 10);
      frameTop = max(borderWidthT, max(borderRadiusTL, borderRadiusTR));
      frameRight = max(borderWidthR, max(borderRadiusTR, borderRadiusBR));
      frameBottom = max(borderWidthB, max(borderRadiusBL, borderRadiusBR));
      frameLeft = max(borderWidthL, max(borderRadiusTL, borderRadiusBL));
      frameInfo = {table:info[0].charAt(0) === 't', vertical:info[0].charAt(1) === 'v', top:frameTop, right:frameRight, bottom:frameBottom, left:frameLeft, width:frameLeft + frameRight, height:frameTop + frameBottom, maxWidth:max(frameTop, frameRight, frameBottom, frameLeft), border:{top:borderWidthT, right:borderWidthR, bottom:borderWidthB, left:borderWidthL, width:borderWidthL + borderWidthR, height:borderWidthT + borderWidthB}, padding:{top:paddingT, right:paddingR, bottom:paddingB, left:paddingL, 
      width:paddingL + paddingR, height:paddingT + paddingB}, radius:{tl:borderRadiusTL, tr:borderRadiusTR, br:borderRadiusBR, bl:borderRadiusBL}};
    } else {
      frameInfo = false;
    }
    if (me.frame === true && !frameInfo) {
      Ext.log.error('You have set frame: true explicity on this component (' + me.getXType() + ') and it ' + 'does not have any framing defined in the CSS template. In this case IE cannot figure out ' + 'what sizes to use and thus framing on this component will be disabled.');
    }
    frameInfoCache[cls] = frameInfo;
  }
  me.frame = !!frameInfo;
  me.frameSize = frameInfo;
  return frameInfo;
}, getFramingInfoCls:function() {
  return this.baseCls + '-' + this.ui;
}, getStyleProxy:function(cls) {
  var result = this.styleProxyEl || (Ext.AbstractComponent.prototype.styleProxyEl = Ext.getBody().createChild({style:{position:'absolute', top:'-10000px'}}, null, true));
  result.className = cls;
  return result;
}, getFrameTpl:function(table) {
  return this.getTpl(table ? 'frameTableTpl' : 'frameTpl');
}, frameInfoCache:{}});
Ext.define('Ext.state.Provider', {mixins:{observable:Ext.util.Observable}, prefix:'ext-', constructor:function(config) {
  config = config || {};
  var me = this;
  Ext.apply(me, config);
  me.addEvents('statechange');
  me.state = {};
  me.mixins.observable.constructor.call(me);
}, get:function(name, defaultValue) {
  return typeof this.state[name] == 'undefined' ? defaultValue : this.state[name];
}, clear:function(name) {
  var me = this;
  delete me.state[name];
  me.fireEvent('statechange', me, name, null);
}, set:function(name, value) {
  var me = this;
  me.state[name] = value;
  me.fireEvent('statechange', me, name, value);
}, decodeValue:function(value) {
  var me = this, re = /^(a|n|d|b|s|o|e):(.*)$/, matches = re.exec(unescape(value)), all, type, keyValue, values, vLen, v;
  if (!matches || !matches[1]) {
    return;
  }
  type = matches[1];
  value = matches[2];
  switch(type) {
    case 'e':
      return null;
    case 'n':
      return parseFloat(value);
    case 'd':
      return new Date(Date.parse(value));
    case 'b':
      return value == '1';
    case 'a':
      all = [];
      if (value != '') {
        values = value.split('^');
        vLen = values.length;
        for (v = 0; v < vLen; v++) {
          value = values[v];
          all.push(me.decodeValue(value));
        }
      }
      return all;
    case 'o':
      all = {};
      if (value != '') {
        values = value.split('^');
        vLen = values.length;
        for (v = 0; v < vLen; v++) {
          value = values[v];
          keyValue = value.split('\x3d');
          all[keyValue[0]] = me.decodeValue(keyValue[1]);
        }
      }
      return all;
    default:
      return value;
  }
}, encodeValue:function(value) {
  var flat = '', i = 0, enc, len, key;
  if (value == null) {
    return 'e:1';
  } else {
    if (typeof value == 'number') {
      enc = 'n:' + value;
    } else {
      if (typeof value == 'boolean') {
        enc = 'b:' + (value ? '1' : '0');
      } else {
        if (Ext.isDate(value)) {
          enc = 'd:' + value.toGMTString();
        } else {
          if (Ext.isArray(value)) {
            for (len = value.length; i < len; i++) {
              flat += this.encodeValue(value[i]);
              if (i != len - 1) {
                flat += '^';
              }
            }
            enc = 'a:' + flat;
          } else {
            if (typeof value == 'object') {
              for (key in value) {
                if (typeof value[key] != 'function' && value[key] !== undefined) {
                  flat += key + '\x3d' + this.encodeValue(value[key]) + '^';
                }
              }
              enc = 'o:' + flat.substring(0, flat.length - 1);
            } else {
              enc = 's:' + value;
            }
          }
        }
      }
    }
  }
  return escape(enc);
}});
Ext.define('Ext.state.Manager', {singleton:true, constructor:function() {
  this.provider = new Ext.state.Provider;
}, setProvider:function(stateProvider) {
  this.provider = stateProvider;
}, get:function(key, defaultValue) {
  return this.provider.get(key, defaultValue);
}, set:function(key, value) {
  this.provider.set(key, value);
}, clear:function(key) {
  this.provider.clear(key);
}, getProvider:function() {
  return this.provider;
}});
Ext.define('Ext.state.Stateful', {mixins:{observable:Ext.util.Observable}, stateful:false, saveDelay:100, constructor:function(config) {
  var me = this;
  config = config || {};
  if (config.stateful !== undefined) {
    me.stateful = config.stateful;
  }
  if (config.saveDelay !== undefined) {
    me.saveDelay = config.saveDelay;
  }
  me.stateId = me.stateId || config.stateId;
  if (!me.stateEvents) {
    me.stateEvents = [];
  }
  if (config.stateEvents) {
    me.stateEvents.concat(config.stateEvents);
  }
  this.addEvents('beforestaterestore', 'staterestore', 'beforestatesave', 'statesave');
  me.mixins.observable.constructor.call(me);
  if (me.stateful !== false) {
    me.addStateEvents(me.stateEvents);
    me.initState();
  }
}, addStateEvents:function(events) {
  var me = this, i, event, stateEventsByName;
  if (me.stateful && me.getStateId()) {
    if (typeof events == 'string') {
      events = Array.prototype.slice.call(arguments, 0);
    }
    stateEventsByName = me.stateEventsByName || (me.stateEventsByName = {});
    for (i = events.length; i--;) {
      event = events[i];
      if (!stateEventsByName[event]) {
        stateEventsByName[event] = 1;
        me.on(event, me.onStateChange, me);
      }
    }
  }
}, onStateChange:function() {
  var me = this, delay = me.saveDelay, statics, runner;
  if (!me.stateful) {
    return;
  }
  if (delay) {
    if (!me.stateTask) {
      statics = Ext.state.Stateful;
      runner = statics.runner || (statics.runner = new Ext.util.TaskRunner);
      me.stateTask = runner.newTask({run:me.saveState, scope:me, interval:delay, repeat:1});
    }
    me.stateTask.start();
  } else {
    me.saveState();
  }
}, saveState:function() {
  var me = this, id = me.stateful && me.getStateId(), hasListeners = me.hasListeners, state;
  if (id) {
    state = me.getState() || {};
    if (!hasListeners.beforestatesave || me.fireEvent('beforestatesave', me, state) !== false) {
      Ext.state.Manager.set(id, state);
      if (hasListeners.statesave) {
        me.fireEvent('statesave', me, state);
      }
    }
  }
}, getState:function() {
  return null;
}, applyState:function(state) {
  if (state) {
    Ext.apply(this, state);
  }
}, getStateId:function() {
  var me = this;
  return me.stateId || (me.autoGenId ? null : me.id);
}, initState:function() {
  var me = this, id = me.stateful && me.getStateId(), hasListeners = me.hasListeners, state;
  if (id) {
    state = Ext.state.Manager.get(id);
    if (state) {
      state = Ext.apply({}, state);
      if (!hasListeners.beforestaterestore || me.fireEvent('beforestaterestore', me, state) !== false) {
        me.applyState(state);
        if (hasListeners.staterestore) {
          me.fireEvent('staterestore', me, state);
        }
      }
    }
  }
}, savePropToState:function(propName, state, stateName) {
  var me = this, value = me[propName], config = me.initialConfig;
  if (me.hasOwnProperty(propName)) {
    if (!config || config[propName] !== value) {
      if (state) {
        state[stateName || propName] = value;
      }
      return true;
    }
  }
  return false;
}, savePropsToState:function(propNames, state) {
  var me = this, i, n;
  if (typeof propNames == 'string') {
    me.savePropToState(propNames, state);
  } else {
    for (i = 0, n = propNames.length; i < n; ++i) {
      me.savePropToState(propNames[i], state);
    }
  }
  return state;
}, destroy:function() {
  var me = this, task = me.stateTask;
  if (task) {
    task.destroy();
    me.stateTask = null;
  }
  me.clearListeners();
}});
Ext.define('Ext.AbstractComponent', {mixins:{positionable:Ext.util.Positionable, observable:Ext.util.Observable, animate:Ext.util.Animate, elementCt:Ext.util.ElementContainer, renderable:Ext.util.Renderable, state:Ext.state.Stateful}, statics:{AUTO_ID:1000, pendingLayouts:null, layoutSuspendCount:0, cancelLayout:function(comp, isDestroying) {
  var context = this.runningLayoutContext || this.pendingLayouts;
  if (context) {
    context.cancelComponent(comp, false, isDestroying);
  }
}, flushLayouts:function() {
  var me = this, context = me.pendingLayouts;
  if (context && context.invalidQueue.length) {
    me.pendingLayouts = null;
    me.runningLayoutContext = context;
    Ext.override(context, {runComplete:function() {
      me.runningLayoutContext = null;
      var result = this.callParent();
      if (Ext.globalEvents.hasListeners.afterlayout) {
        Ext.globalEvents.fireEvent('afterlayout');
      }
      return result;
    }});
    context.run();
  }
}, resumeLayouts:function(flush) {
  if (this.layoutSuspendCount && !--this.layoutSuspendCount) {
    if (flush) {
      this.flushLayouts();
    }
    if (Ext.globalEvents.hasListeners.resumelayouts) {
      Ext.globalEvents.fireEvent('resumelayouts');
    }
  }
}, suspendLayouts:function() {
  ++this.layoutSuspendCount;
}, updateLayout:function(comp, defer) {
  var me = this, running = me.runningLayoutContext, pending;
  if (running) {
    running.queueInvalidate(comp);
  } else {
    pending = me.pendingLayouts || (me.pendingLayouts = new Ext.layout.Context);
    pending.queueInvalidate(comp);
    if (!defer && !me.layoutSuspendCount && !comp.isLayoutSuspended()) {
      me.flushLayouts();
    }
  }
}}, isComponent:true, getAutoId:function() {
  this.autoGenId = true;
  return ++Ext.AbstractComponent.AUTO_ID;
}, deferLayouts:false, autoGenId:false, renderTpl:'{%this.renderContent(out,values)%}', frameSize:null, tplWriteMode:'overwrite', baseCls:Ext.baseCSSPrefix + 'component', disabledCls:Ext.baseCSSPrefix + 'item-disabled', ui:'default', uiCls:[], hidden:false, disabled:false, draggable:false, floating:false, hideMode:'display', autoShow:false, autoRender:false, allowDomMove:true, rendered:false, componentLayoutCounter:0, shrinkWrap:2, weight:0, maskOnDisable:true, _isLayoutRoot:false, contentPaddingProperty:'padding', 
horizontalPosProp:'left', borderBoxCls:Ext.baseCSSPrefix + 'border-box', constructor:function(config) {
  var me = this, i, len, xhooks;
  if (config) {
    Ext.apply(me, config);
    xhooks = me.xhooks;
    if (xhooks) {
      delete me.xhooks;
      Ext.override(me, xhooks);
    }
  } else {
    config = {};
  }
  me.initialConfig = config;
  me.mixins.elementCt.constructor.call(me);
  me.addEvents('beforeactivate', 'activate', 'beforedeactivate', 'deactivate', 'added', 'disable', 'enable', 'beforeshow', 'show', 'beforehide', 'hide', 'removed', 'beforerender', 'render', 'afterrender', 'boxready', 'beforedestroy', 'destroy', 'resize', 'move', 'focus', 'blur');
  me.getId();
  me.setupProtoEl();
  if (me.cls) {
    me.initialCls = me.cls;
    me.protoEl.addCls(me.cls);
  }
  if (me.style) {
    me.initialStyle = me.style;
    me.protoEl.setStyle(me.style);
  }
  me.renderData = me.renderData || {};
  me.renderSelectors = me.renderSelectors || {};
  if (me.plugins) {
    me.plugins = me.constructPlugins();
  }
  if (!me.hasListeners) {
    me.hasListeners = new me.HasListeners;
  }
  me.initComponent();
  Ext.ComponentManager.register(me);
  me.mixins.observable.constructor.call(me);
  me.mixins.state.constructor.call(me, config);
  this.addStateEvents('resize');
  if (me.plugins) {
    for (i = 0, len = me.plugins.length; i < len; i++) {
      me.plugins[i] = me.initPlugin(me.plugins[i]);
    }
  }
  me.loader = me.getLoader();
  if (me.renderTo) {
    me.render(me.renderTo);
  }
  if (me.autoShow && !me.isContained) {
    me.show();
  }
  if (Ext.isDefined(me.disabledClass)) {
    if (Ext.isDefined(Ext.global.console)) {
      Ext.global.console.warn('Ext.Component: disabledClass has been deprecated. Please use disabledCls.');
    }
    me.disabledCls = me.disabledClass;
    delete me.disabledClass;
  }
}, initComponent:function() {
  this.plugins = this.constructPlugins();
  this.setSize(this.width, this.height);
}, getState:function() {
  var me = this, state = null, sizeModel = me.getSizeModel();
  if (sizeModel.width.configured) {
    state = me.addPropertyToState(state, 'width');
  }
  if (sizeModel.height.configured) {
    state = me.addPropertyToState(state, 'height');
  }
  return state;
}, addPropertyToState:function(state, propName, value) {
  var me = this, len = arguments.length;
  if (len == 3 || me.hasOwnProperty(propName)) {
    if (len < 3) {
      value = me[propName];
    }
    if (value !== me.initialConfig[propName]) {
      (state || (state = {}))[propName] = value;
    }
  }
  return state;
}, show:Ext.emptyFn, animate:function(animObj) {
  var me = this, hasToWidth, hasToHeight, toHeight, toWidth, to, clearWidth, clearHeight, curWidth, w, curHeight, h, isExpanding, wasConstrained, wasConstrainedHeader, passedCallback, oldOverflow;
  animObj = animObj || {};
  to = animObj.to || {};
  if (Ext.fx.Manager.hasFxBlock(me.id)) {
    return me;
  }
  hasToWidth = Ext.isDefined(to.width);
  if (hasToWidth) {
    toWidth = Ext.Number.constrain(to.width, me.minWidth, me.maxWidth);
  }
  hasToHeight = Ext.isDefined(to.height);
  if (hasToHeight) {
    toHeight = Ext.Number.constrain(to.height, me.minHeight, me.maxHeight);
  }
  if (!animObj.dynamic && (hasToWidth || hasToHeight)) {
    curWidth = (animObj.from ? animObj.from.width : undefined) || me.getWidth();
    w = curWidth;
    curHeight = (animObj.from ? animObj.from.height : undefined) || me.getHeight();
    h = curHeight;
    isExpanding = false;
    if (hasToHeight && toHeight > curHeight) {
      h = toHeight;
      isExpanding = true;
    }
    if (hasToWidth && toWidth > curWidth) {
      w = toWidth;
      isExpanding = true;
    }
    if (hasToHeight || hasToWidth) {
      oldOverflow = me.el.getStyle('overtflow');
      if (oldOverflow !== 'hidden') {
        me.el.setStyle('overflow', 'hidden');
      }
    }
    if (isExpanding) {
      clearWidth = !Ext.isNumber(me.width);
      clearHeight = !Ext.isNumber(me.height);
      me.setSize(w, h);
      me.el.setSize(curWidth, curHeight);
      if (clearWidth) {
        delete me.width;
      }
      if (clearHeight) {
        delete me.height;
      }
    }
    if (hasToWidth) {
      to.width = toWidth;
    }
    if (hasToHeight) {
      to.height = toHeight;
    }
  }
  wasConstrained = me.constrain;
  wasConstrainedHeader = me.constrainHeader;
  if (wasConstrained || wasConstrainedHeader) {
    me.constrain = me.constrainHeader = false;
    passedCallback = animObj.callback;
    animObj.callback = function() {
      me.constrain = wasConstrained;
      me.constrainHeader = wasConstrainedHeader;
      if (passedCallback) {
        passedCallback.call(animObj.scope || me, arguments);
      }
      if (oldOverflow !== 'hidden') {
        me.el.setStyle('overflow', oldOverflow);
      }
    };
  }
  return me.mixins.animate.animate.apply(me, arguments);
}, setHiddenState:function(hidden) {
  var hierarchyState = this.getHierarchyState();
  this.hidden = hidden;
  if (hidden) {
    hierarchyState.hidden = true;
  } else {
    delete hierarchyState.hidden;
  }
}, onHide:function() {
  if (this.ownerLayout) {
    this.updateLayout({isRoot:false});
  }
}, onShow:function() {
  this.updateLayout({isRoot:false});
}, constructPlugin:function(plugin) {
  var me = this;
  if (typeof plugin == 'string') {
    plugin = Ext.PluginManager.create({}, plugin, me);
  } else {
    plugin = Ext.PluginManager.create(plugin, null, me);
  }
  return plugin;
}, constructPlugins:function() {
  var me = this, plugins = me.plugins, result, i, len;
  if (plugins) {
    result = [];
    if (!Ext.isArray(plugins)) {
      plugins = [plugins];
    }
    for (i = 0, len = plugins.length; i < len; i++) {
      result[i] = me.constructPlugin(plugins[i]);
    }
  }
  me.pluginsInitialized = true;
  return result;
}, initPlugin:function(plugin) {
  plugin.init(this);
  return plugin;
}, addPlugin:function(plugin) {
  var me = this;
  plugin = me.constructPlugin(plugin);
  if (me.plugins) {
    me.plugins.push(plugin);
  } else {
    me.plugins = [plugin];
  }
  if (me.pluginsInitialized) {
    me.initPlugin(plugin);
  }
  return plugin;
}, removePlugin:function(plugin) {
  Ext.Array.remove(this.plugins, plugin);
  plugin.destroy();
}, findPlugin:function(ptype) {
  var i, plugins = this.plugins, ln = plugins && plugins.length;
  for (i = 0; i < ln; i++) {
    if (plugins[i].ptype === ptype) {
      return plugins[i];
    }
  }
}, getPlugin:function(pluginId) {
  var i, plugins = this.plugins, ln = plugins && plugins.length;
  for (i = 0; i < ln; i++) {
    if (plugins[i].pluginId === pluginId) {
      return plugins[i];
    }
  }
}, beforeLayout:Ext.emptyFn, updateAria:Ext.emptyFn, registerFloatingItem:function(cmp) {
  var me = this;
  if (!me.floatingDescendants) {
    me.floatingDescendants = new Ext.ZIndexManager(me);
  }
  me.floatingDescendants.register(cmp);
}, unregisterFloatingItem:function(cmp) {
  var me = this;
  if (me.floatingDescendants) {
    me.floatingDescendants.unregister(cmp);
  }
}, layoutSuspendCount:0, suspendLayouts:function() {
  var me = this;
  if (!me.rendered) {
    return;
  }
  if (++me.layoutSuspendCount == 1) {
    me.suspendLayout = true;
  }
}, resumeLayouts:function(flushOptions) {
  var me = this;
  if (!me.rendered) {
    return;
  }
  if (!--me.layoutSuspendCount) {
    me.suspendLayout = false;
    if (flushOptions && !me.isLayoutSuspended()) {
      me.updateLayout(flushOptions);
    }
  }
}, setupProtoEl:function() {
  var cls = this.initCls();
  this.protoEl = new Ext.util.ProtoElement({cls:cls.join(' ')});
}, initCls:function() {
  var me = this, cls = [me.baseCls, me.getComponentLayout().targetCls];
  if (me.componentCls) {
    cls.push(me.componentCls);
  } else {
    me.componentCls = me.baseCls;
  }
  return cls;
}, setUI:function(ui) {
  var me = this, uiCls = me.uiCls, activeUI = me.activeUI, classes;
  if (ui === activeUI) {
    return;
  }
  if (activeUI) {
    classes = me.removeClsWithUI(uiCls, true);
    if (classes.length) {
      me.removeCls(classes);
    }
    me.removeUIFromElement();
  } else {
    me.uiCls = [];
  }
  me.ui = ui;
  me.activeUI = ui;
  me.addUIToElement();
  classes = me.addClsWithUI(uiCls, true);
  if (classes.length) {
    me.addCls(classes);
  }
  if (me.rendered) {
    me.updateLayout();
  }
}, addClsWithUI:function(classes, skip) {
  var me = this, clsArray = [], i = 0, uiCls = me.uiCls = Ext.Array.clone(me.uiCls), activeUI = me.activeUI, length, cls;
  if (typeof classes === 'string') {
    classes = classes.indexOf(' ') < 0 ? [classes] : Ext.String.splitWords(classes);
  }
  length = classes.length;
  for (; i < length; i++) {
    cls = classes[i];
    if (cls && !me.hasUICls(cls)) {
      uiCls.push(cls);
      if (activeUI) {
        clsArray = clsArray.concat(me.addUIClsToElement(cls));
      }
    }
  }
  if (skip !== true && activeUI) {
    me.addCls(clsArray);
  }
  return clsArray;
}, removeClsWithUI:function(classes, skip) {
  var me = this, clsArray = [], i = 0, extArray = Ext.Array, remove = extArray.remove, uiCls = me.uiCls = extArray.clone(me.uiCls), activeUI = me.activeUI, length, cls;
  if (typeof classes === 'string') {
    classes = classes.indexOf(' ') < 0 ? [classes] : Ext.String.splitWords(classes);
  }
  length = classes.length;
  for (i = 0; i < length; i++) {
    cls = classes[i];
    if (cls && me.hasUICls(cls)) {
      remove(uiCls, cls);
      if (activeUI) {
        clsArray = clsArray.concat(me.removeUIClsFromElement(cls));
      }
    }
  }
  if (skip !== true && activeUI) {
    me.removeCls(clsArray);
  }
  return clsArray;
}, hasUICls:function(cls) {
  var me = this, uiCls = me.uiCls || [];
  return Ext.Array.contains(uiCls, cls);
}, frameElementsArray:['tl', 'tc', 'tr', 'ml', 'mc', 'mr', 'bl', 'bc', 'br'], addUIClsToElement:function(cls) {
  var me = this, baseClsUi = me.baseCls + '-' + me.ui + '-' + cls, result = [Ext.baseCSSPrefix + cls, me.baseCls + '-' + cls, baseClsUi], frameElementsArray, frameElementsLength, i, el, frameElement;
  if (me.rendered && me.frame && !Ext.supports.CSS3BorderRadius) {
    frameElementsArray = me.frameElementsArray;
    frameElementsLength = frameElementsArray.length;
    for (i = 0; i < frameElementsLength; i++) {
      frameElement = frameElementsArray[i];
      el = me['frame' + frameElement.toUpperCase()];
      if (el) {
        el.addCls(baseClsUi + '-' + frameElement);
      }
    }
  }
  return result;
}, removeUIClsFromElement:function(cls) {
  var me = this, baseClsUi = me.baseCls + '-' + me.ui + '-' + cls, result = [Ext.baseCSSPrefix + cls, me.baseCls + '-' + cls, baseClsUi], frameElementsArray, frameElementsLength, i, el, frameElement;
  if (me.rendered && me.frame && !Ext.supports.CSS3BorderRadius) {
    frameElementsArray = me.frameElementsArray;
    frameElementsLength = frameElementsArray.length;
    for (i = 0; i < frameElementsLength; i++) {
      frameElement = frameElementsArray[i];
      el = me['frame' + frameElement.toUpperCase()];
      if (el) {
        el.removeCls(baseClsUi + '-' + frameElement);
      }
    }
  }
  return result;
}, addUIToElement:function() {
  var me = this, baseClsUI = me.baseCls + '-' + me.ui, frameElementsArray, frameElementsLength, i, el, frameElement;
  me.addCls(baseClsUI);
  if (me.rendered && me.frame && !Ext.supports.CSS3BorderRadius) {
    frameElementsArray = me.frameElementsArray;
    frameElementsLength = frameElementsArray.length;
    for (i = 0; i < frameElementsLength; i++) {
      frameElement = frameElementsArray[i];
      el = me['frame' + frameElement.toUpperCase()];
      if (el) {
        el.addCls(baseClsUI + '-' + frameElement);
      }
    }
  }
}, removeUIFromElement:function() {
  var me = this, baseClsUI = me.baseCls + '-' + me.ui, frameElementsArray, frameElementsLength, i, el, frameElement;
  me.removeCls(baseClsUI);
  if (me.rendered && me.frame && !Ext.supports.CSS3BorderRadius) {
    frameElementsArray = me.frameElementsArray;
    frameElementsLength = frameElementsArray.length;
    for (i = 0; i < frameElementsLength; i++) {
      frameElement = frameElementsArray[i];
      el = me['frame' + frameElement.toUpperCase()];
      if (el) {
        el.removeCls(baseClsUI + '-' + frameElement);
      }
    }
  }
}, getTpl:function(name) {
  return Ext.XTemplate.getTpl(this, name);
}, initStyles:function(targetEl) {
  var me = this, Element = Ext.Element, margin = me.margin, border = me.border, cls = me.cls, style = me.style, x = me.x, y = me.y, width, height;
  me.initPadding(targetEl);
  if (margin != null) {
    targetEl.setStyle('margin', this.unitizeBox(margin === true ? 5 : margin));
  }
  if (border != null) {
    me.setBorder(border, targetEl);
  }
  if (cls && cls != me.initialCls) {
    targetEl.addCls(cls);
    me.cls = me.initialCls = null;
  }
  if (style && style != me.initialStyle) {
    targetEl.setStyle(style);
    me.style = me.initialStyle = null;
  }
  if (x != null) {
    targetEl.setStyle(me.horizontalPosProp, typeof x == 'number' ? x + 'px' : x);
  }
  if (y != null) {
    targetEl.setStyle('top', typeof y == 'number' ? y + 'px' : y);
  }
  if (Ext.isBorderBox && (!me.ownerCt || me.floating)) {
    targetEl.addCls(me.borderBoxCls);
  }
  if (!me.getFrameInfo()) {
    width = me.width;
    height = me.height;
    if (width != null) {
      if (typeof width === 'number') {
        if (Ext.isBorderBox) {
          targetEl.setStyle('width', width + 'px');
        }
      } else {
        targetEl.setStyle('width', width);
      }
    }
    if (height != null) {
      if (typeof height === 'number') {
        if (Ext.isBorderBox) {
          targetEl.setStyle('height', height + 'px');
        }
      } else {
        targetEl.setStyle('height', height);
      }
    }
  }
}, initPadding:function(targetEl) {
  var me = this, padding = me.padding;
  if (padding != null) {
    if (me.layout && me.layout.managePadding && me.contentPaddingProperty === 'padding') {
      targetEl.setStyle('padding', 0);
    } else {
      targetEl.setStyle('padding', this.unitizeBox(padding === true ? 5 : padding));
    }
  }
}, parseBox:function(box) {
  return Ext.dom.Element.parseBox(box);
}, unitizeBox:function(box) {
  return Ext.dom.Element.unitizeBox(box);
}, setMargin:function(margin, preventLayout) {
  var me = this;
  if (me.rendered) {
    if (!margin && margin !== 0) {
      margin = '';
    } else {
      if (margin === true) {
        margin = 5;
      }
      margin = this.unitizeBox(margin);
    }
    me.getTargetEl().setStyle('margin', margin);
    if (!preventLayout) {
      me.updateLayout();
    }
  } else {
    me.margin = margin;
  }
}, initEvents:function() {
  var me = this, afterRenderEvents = me.afterRenderEvents, afterRenderEvent, el, property, index, len;
  if (afterRenderEvents) {
    for (property in afterRenderEvents) {
      el = me[property];
      if (el && el.on) {
        afterRenderEvent = afterRenderEvents[property];
        for (index = 0, len = afterRenderEvent.length; index < len; ++index) {
          me.mon(el, afterRenderEvent[index]);
        }
      }
    }
  }
  me.addFocusListener();
}, addFocusListener:function() {
  var me = this, focusEl = me.getFocusEl(), needsTabIndex;
  if (focusEl) {
    if (focusEl.isComponent) {
      return focusEl.addFocusListener();
    }
    needsTabIndex = focusEl.needsTabIndex();
    if (!me.focusListenerAdded && (!needsTabIndex || Ext.FocusManager.enabled)) {
      if (needsTabIndex) {
        focusEl.dom.tabIndex = -1;
      }
      focusEl.on({focus:me.onFocus, blur:me.onBlur, scope:me});
      me.focusListenerAdded = true;
    }
  }
}, getFocusEl:Ext.emptyFn, isFocusable:function() {
  var me = this, focusEl;
  if (me.focusable !== false && (focusEl = me.getFocusEl()) && me.rendered && !me.destroying && !me.isDestroyed && !me.disabled && me.isVisible(true)) {
    return focusEl.isFocusable(true);
  }
}, beforeFocus:Ext.emptyFn, onFocus:function(e) {
  var me = this, focusCls = me.focusCls, focusEl = me.getFocusEl();
  if (!me.disabled) {
    me.beforeFocus(e);
    if (focusCls && focusEl) {
      focusEl.addCls(me.addClsWithUI(focusCls, true));
    }
    if (!me.hasFocus) {
      me.hasFocus = true;
      me.fireEvent('focus', me, e);
    }
  }
}, beforeBlur:Ext.emptyFn, onBlur:function(e) {
  var me = this, focusCls = me.focusCls, focusEl = me.getFocusEl();
  if (me.destroying) {
    return;
  }
  me.beforeBlur(e);
  if (focusCls && focusEl) {
    focusEl.removeCls(me.removeClsWithUI(focusCls, true));
  }
  if (me.validateOnBlur) {
    me.validate();
  }
  me.hasFocus = false;
  me.fireEvent('blur', me, e);
  me.postBlur(e);
}, postBlur:Ext.emptyFn, is:function(selector) {
  return Ext.ComponentQuery.is(this, selector);
}, up:function(selector, limit) {
  var result = this.getRefOwner(), limitSelector = typeof limit === 'string', limitCount = typeof limit === 'number', limitComponent = limit && limit.isComponent, steps = 0;
  if (selector) {
    for (; result; result = result.getRefOwner()) {
      steps++;
      if (selector.isComponent) {
        if (result === selector) {
          return result;
        }
      } else {
        if (Ext.ComponentQuery.is(result, selector)) {
          return result;
        }
      }
      if (limitSelector && result.is(limit)) {
        return;
      }
      if (limitCount && steps === limit) {
        return;
      }
      if (limitComponent && result === limit) {
        return;
      }
    }
  }
  return result;
}, nextSibling:function(selector) {
  var o = this.ownerCt, it, last, idx, c;
  if (o) {
    it = o.items;
    idx = it.indexOf(this) + 1;
    if (idx) {
      if (selector) {
        for (last = it.getCount(); idx < last; idx++) {
          if ((c = it.getAt(idx)).is(selector)) {
            return c;
          }
        }
      } else {
        if (idx < it.getCount()) {
          return it.getAt(idx);
        }
      }
    }
  }
  return null;
}, previousSibling:function(selector) {
  var o = this.ownerCt, it, idx, c;
  if (o) {
    it = o.items;
    idx = it.indexOf(this);
    if (idx != -1) {
      if (selector) {
        for (--idx; idx >= 0; idx--) {
          if ((c = it.getAt(idx)).is(selector)) {
            return c;
          }
        }
      } else {
        if (idx) {
          return it.getAt(--idx);
        }
      }
    }
  }
  return null;
}, previousNode:function(selector, includeSelf) {
  var node = this, ownerCt = node.ownerCt, result, it, i, sib;
  if (includeSelf && node.is(selector)) {
    return node;
  }
  if (ownerCt) {
    for (it = ownerCt.items.items, i = Ext.Array.indexOf(it, node) - 1; i > -1; i--) {
      sib = it[i];
      if (sib.query) {
        result = sib.query(selector);
        result = result[result.length - 1];
        if (result) {
          return result;
        }
      }
      if (sib.is(selector)) {
        return sib;
      }
    }
    return ownerCt.previousNode(selector, true);
  }
  return null;
}, nextNode:function(selector, includeSelf) {
  var node = this, ownerCt = node.ownerCt, result, it, len, i, sib;
  if (includeSelf && node.is(selector)) {
    return node;
  }
  if (ownerCt) {
    for (it = ownerCt.items.items, i = Ext.Array.indexOf(it, node) + 1, len = it.length; i < len; i++) {
      sib = it[i];
      if (sib.is(selector)) {
        return sib;
      }
      if (sib.down) {
        result = sib.down(selector);
        if (result) {
          return result;
        }
      }
    }
    return ownerCt.nextNode(selector);
  }
  return null;
}, getId:function() {
  return this.id || (this.id = 'ext-comp-' + this.getAutoId());
}, getItemId:function() {
  return this.itemId || this.id;
}, getEl:function() {
  return this.el;
}, getTargetEl:function() {
  return this.frameBody || this.el;
}, getOverflowEl:function() {
  return this.getTargetEl();
}, getOverflowStyle:function() {
  var me = this, result = null, ox, oy, overflowStyle;
  if (typeof me.autoScroll === 'boolean') {
    result = {overflow:overflowStyle = me.autoScroll ? 'auto' : ''};
    me.scrollFlags = {overflowX:overflowStyle, overflowY:overflowStyle, x:true, y:true, both:true};
  } else {
    ox = me.overflowX;
    oy = me.overflowY;
    if (ox !== undefined || oy !== undefined) {
      result = {'overflowX':ox = ox || '', 'overflowY':oy = oy || ''};
      me.scrollFlags = {overflowX:ox, overflowY:oy, x:ox = ox === 'auto' || ox === 'scroll', y:oy = oy === 'auto' || oy === 'scroll', both:ox && oy};
    } else {
      me.scrollFlags = {overflowX:'', overflowY:'', x:false, y:false, both:false};
    }
  }
  if (result && Ext.isIE7m) {
    result.position = 'relative';
  }
  return result;
}, isXType:function(xtype, shallow) {
  if (shallow) {
    return this.xtype === xtype;
  } else {
    return this.xtypesMap[xtype];
  }
}, getXTypes:function() {
  var self = this.self, xtypes, parentPrototype, parentXtypes;
  if (!self.xtypes) {
    xtypes = [];
    parentPrototype = this;
    while (parentPrototype) {
      parentXtypes = parentPrototype.xtypes;
      if (parentXtypes !== undefined) {
        xtypes.unshift.apply(xtypes, parentXtypes);
      }
      parentPrototype = parentPrototype.superclass;
    }
    self.xtypeChain = xtypes;
    self.xtypes = xtypes.join('/');
  }
  return self.xtypes;
}, update:function(htmlOrData, loadScripts, cb) {
  var me = this, isData = me.tpl && !Ext.isString(htmlOrData), el;
  if (isData) {
    me.data = htmlOrData;
  } else {
    me.html = Ext.isObject(htmlOrData) ? Ext.DomHelper.markup(htmlOrData) : htmlOrData;
  }
  if (me.rendered) {
    el = me.isContainer ? me.layout.getRenderTarget() : me.getTargetEl();
    if (isData) {
      me.tpl[me.tplWriteMode](el, htmlOrData || {});
    } else {
      el.update(me.html, loadScripts, cb);
    }
    me.updateLayout();
  }
}, setVisible:function(visible) {
  return this[visible ? 'show' : 'hide']();
}, isVisible:function(deep) {
  var me = this, hidden;
  if (me.hidden || !me.rendered || me.isDestroyed) {
    hidden = true;
  } else {
    if (deep) {
      hidden = me.isHierarchicallyHidden();
    }
  }
  return !hidden;
}, isHierarchicallyHidden:function() {
  var child = this, hidden = false, parent, parentHierarchyState;
  for (; parent = child.ownerCt || child.floatParent; child = parent) {
    parentHierarchyState = parent.getHierarchyState();
    if (parentHierarchyState.hidden) {
      hidden = true;
      break;
    }
    if (child.getHierarchyState().collapseImmune) {
      if (parent.collapsed && !child.collapseImmune) {
        hidden = true;
        break;
      }
    } else {
      hidden = !!parentHierarchyState.collapsed;
      break;
    }
  }
  return hidden;
}, onBoxReady:function(width, height) {
  var me = this;
  if (me.disableOnBoxReady) {
    me.onDisable();
  } else {
    if (me.enableOnBoxReady) {
      me.onEnable();
    }
  }
  if (me.resizable) {
    me.initResizable(me.resizable);
  }
  if (me.draggable) {
    me.initDraggable();
  }
  if (me.hasListeners.boxready) {
    me.fireEvent('boxready', me, width, height);
  }
}, enable:function(silent) {
  var me = this;
  delete me.disableOnBoxReady;
  me.removeCls(me.disabledCls);
  if (me.rendered) {
    me.onEnable();
  } else {
    me.enableOnBoxReady = true;
  }
  me.disabled = false;
  delete me.resetDisable;
  if (silent !== true) {
    me.fireEvent('enable', me);
  }
  return me;
}, disable:function(silent) {
  var me = this;
  delete me.enableOnBoxReady;
  me.addCls(me.disabledCls);
  if (me.rendered) {
    me.onDisable();
  } else {
    me.disableOnBoxReady = true;
  }
  me.disabled = true;
  if (silent !== true) {
    delete me.resetDisable;
    me.fireEvent('disable', me);
  }
  return me;
}, onEnable:function() {
  if (this.maskOnDisable) {
    this.el.dom.disabled = false;
    this.unmask();
  }
}, onDisable:function() {
  var me = this, focusCls = me.focusCls, focusEl = me.getFocusEl();
  if (focusCls && focusEl) {
    focusEl.removeCls(me.removeClsWithUI(focusCls, true));
  }
  if (me.maskOnDisable) {
    me.el.dom.disabled = true;
    me.mask();
  }
}, mask:function() {
  var box = this.lastBox, target = this.getMaskTarget(), args = [];
  if (box) {
    args[2] = box.height;
  }
  target.mask.apply(target, args);
}, unmask:function() {
  this.getMaskTarget().unmask();
}, getMaskTarget:function() {
  return this.el;
}, isDisabled:function() {
  return this.disabled;
}, setDisabled:function(disabled) {
  return this[disabled ? 'disable' : 'enable']();
}, isHidden:function() {
  return this.hidden;
}, addCls:function(cls) {
  var me = this, el = me.rendered ? me.el : me.protoEl;
  el.addCls.apply(el, arguments);
  return me;
}, addClass:function() {
  return this.addCls.apply(this, arguments);
}, hasCls:function(cls) {
  var me = this, el = me.rendered ? me.el : me.protoEl;
  return el.hasCls.apply(el, arguments);
}, removeCls:function(cls) {
  var me = this, el = me.rendered ? me.el : me.protoEl;
  el.removeCls.apply(el, arguments);
  return me;
}, removeClass:function() {
  if (Ext.isDefined(Ext.global.console)) {
    Ext.global.console.warn('Ext.Component: removeClass has been deprecated. Please use removeCls.');
  }
  return this.removeCls.apply(this, arguments);
}, addOverCls:function() {
  var me = this;
  if (!me.disabled) {
    me.el.addCls(me.overCls);
  }
}, removeOverCls:function() {
  this.el.removeCls(this.overCls);
}, addListener:function(element, listeners, scope, options) {
  var me = this, fn, option;
  if (Ext.isString(element) && (Ext.isObject(listeners) || options && options.element)) {
    if (options.element) {
      fn = listeners;
      listeners = {};
      listeners[element] = fn;
      element = options.element;
      if (scope) {
        listeners.scope = scope;
      }
      for (option in options) {
        if (options.hasOwnProperty(option)) {
          if (me.eventOptionsRe.test(option)) {
            listeners[option] = options[option];
          }
        }
      }
    }
    if (me[element] && me[element].on) {
      me.mon(me[element], listeners);
    } else {
      me.afterRenderEvents = me.afterRenderEvents || {};
      if (!me.afterRenderEvents[element]) {
        me.afterRenderEvents[element] = [];
      }
      me.afterRenderEvents[element].push(listeners);
    }
    return;
  }
  return me.mixins.observable.addListener.apply(me, arguments);
}, removeManagedListenerItem:function(isClear, managedListener, item, ename, fn, scope) {
  var me = this, element = managedListener.options ? managedListener.options.element : null;
  if (element) {
    element = me[element];
    if (element && element.un) {
      if (isClear || managedListener.item === item && managedListener.ename === ename && (!fn || managedListener.fn === fn) && (!scope || managedListener.scope === scope)) {
        element.un(managedListener.ename, managedListener.fn, managedListener.scope);
        if (!isClear) {
          Ext.Array.remove(me.managedListeners, managedListener);
        }
      }
    }
  } else {
    return me.mixins.observable.removeManagedListenerItem.apply(me, arguments);
  }
}, getBubbleTarget:function() {
  return this.ownerCt;
}, isFloating:function() {
  return this.floating;
}, isDraggable:function() {
  return !!this.draggable;
}, isDroppable:function() {
  return !!this.droppable;
}, onAdded:function(container, pos) {
  var me = this;
  me.ownerCt = container;
  if (me.hierarchyState) {
    me.hierarchyState.invalid = true;
    delete me.hierarchyState;
  }
  if (me.hasListeners.added) {
    me.fireEvent('added', me, container, pos);
  }
}, onRemoved:function(destroying) {
  var me = this;
  if (me.hasListeners.removed) {
    me.fireEvent('removed', me, me.ownerCt);
  }
  delete me.ownerCt;
  delete me.ownerLayout;
}, beforeDestroy:Ext.emptyFn, onResize:function(width, height, oldWidth, oldHeight) {
  var me = this;
  if (me.floating && me.constrain) {
    me.doConstrain();
  }
  if (me.hasListeners.resize) {
    me.fireEvent('resize', me, width, height, oldWidth, oldHeight);
  }
}, setSize:function(width, height) {
  var me = this;
  if (width && typeof width == 'object') {
    height = width.height;
    width = width.width;
  }
  if (typeof width == 'number') {
    me.width = Ext.Number.constrain(width, me.minWidth, me.maxWidth);
  } else {
    if (width === null) {
      delete me.width;
    }
  }
  if (typeof height == 'number') {
    me.height = Ext.Number.constrain(height, me.minHeight, me.maxHeight);
  } else {
    if (height === null) {
      delete me.height;
    }
  }
  if (me.rendered && me.isVisible()) {
    me.updateLayout({isRoot:false});
  }
  return me;
}, isLayoutRoot:function() {
  var me = this, ownerLayout = me.ownerLayout;
  if (!ownerLayout || me._isLayoutRoot || me.floating) {
    return true;
  }
  return ownerLayout.isItemLayoutRoot(me);
}, isLayoutSuspended:function() {
  var comp = this, ownerLayout;
  while (comp) {
    if (comp.layoutSuspendCount || comp.suspendLayout) {
      return true;
    }
    ownerLayout = comp.ownerLayout;
    if (!ownerLayout) {
      break;
    }
    comp = ownerLayout.owner;
  }
  return false;
}, updateLayout:function(options) {
  var me = this, defer, lastBox = me.lastBox, isRoot = options && options.isRoot;
  if (lastBox) {
    lastBox.invalid = true;
  }
  if (!me.rendered || me.layoutSuspendCount || me.suspendLayout) {
    return;
  }
  if (me.hidden) {
    Ext.AbstractComponent.cancelLayout(me);
  } else {
    if (typeof isRoot != 'boolean') {
      isRoot = me.isLayoutRoot();
    }
  }
  if (isRoot || !me.ownerLayout || !me.ownerLayout.onContentChange(me)) {
    if (!me.isLayoutSuspended()) {
      defer = options && options.hasOwnProperty('defer') ? options.defer : me.deferLayouts;
      Ext.AbstractComponent.updateLayout(me, defer);
    }
  }
}, getSizeModel:function(ownerCtSizeModel) {
  var me = this, models = Ext.layout.SizeModel, ownerContext = me.componentLayout.ownerContext, width = me.width, height = me.height, typeofWidth, typeofHeight, hasPixelWidth, hasPixelHeight, heightModel, ownerLayout, policy, shrinkWrap, topLevel, widthModel;
  if (ownerContext) {
    widthModel = ownerContext.widthModel;
    heightModel = ownerContext.heightModel;
  }
  if (!widthModel || !heightModel) {
    hasPixelWidth = (typeofWidth = typeof width) == 'number';
    hasPixelHeight = (typeofHeight = typeof height) == 'number';
    topLevel = me.floating || !(ownerLayout = me.ownerLayout);
    if (topLevel) {
      policy = Ext.layout.Layout.prototype.autoSizePolicy;
      shrinkWrap = me.floating ? 3 : me.shrinkWrap;
      if (hasPixelWidth) {
        widthModel = models.configured;
      }
      if (hasPixelHeight) {
        heightModel = models.configured;
      }
    } else {
      policy = ownerLayout.getItemSizePolicy(me, ownerCtSizeModel);
      shrinkWrap = ownerLayout.isItemShrinkWrap(me);
    }
    if (ownerContext) {
      ownerContext.ownerSizePolicy = policy;
    }
    shrinkWrap = shrinkWrap === true ? 3 : shrinkWrap || 0;
    if (topLevel && shrinkWrap) {
      if (width && typeofWidth == 'string') {
        shrinkWrap &= 2;
      }
      if (height && typeofHeight == 'string') {
        shrinkWrap &= 1;
      }
    }
    if (shrinkWrap !== 3) {
      if (!ownerCtSizeModel) {
        ownerCtSizeModel = me.ownerCt && me.ownerCt.getSizeModel();
      }
      if (ownerCtSizeModel) {
        shrinkWrap |= (ownerCtSizeModel.width.shrinkWrap ? 1 : 0) | (ownerCtSizeModel.height.shrinkWrap ? 2 : 0);
      }
    }
    if (!widthModel) {
      if (!policy.setsWidth) {
        if (hasPixelWidth) {
          widthModel = models.configured;
        } else {
          widthModel = shrinkWrap & 1 ? models.shrinkWrap : models.natural;
        }
      } else {
        if (policy.readsWidth) {
          if (hasPixelWidth) {
            widthModel = models.calculatedFromConfigured;
          } else {
            widthModel = shrinkWrap & 1 ? models.calculatedFromShrinkWrap : models.calculatedFromNatural;
          }
        } else {
          widthModel = models.calculated;
        }
      }
    }
    if (!heightModel) {
      if (!policy.setsHeight) {
        if (hasPixelHeight) {
          heightModel = models.configured;
        } else {
          heightModel = shrinkWrap & 2 ? models.shrinkWrap : models.natural;
        }
      } else {
        if (policy.readsHeight) {
          if (hasPixelHeight) {
            heightModel = models.calculatedFromConfigured;
          } else {
            heightModel = shrinkWrap & 2 ? models.calculatedFromShrinkWrap : models.calculatedFromNatural;
          }
        } else {
          heightModel = models.calculated;
        }
      }
    }
  }
  return widthModel.pairsByHeightOrdinal[heightModel.ordinal];
}, isDescendant:function(ancestor) {
  if (ancestor.isContainer) {
    for (var c = this.ownerCt; c; c = c.ownerCt) {
      if (c === ancestor) {
        return true;
      }
    }
  }
  return false;
}, doComponentLayout:function() {
  this.updateLayout();
  return this;
}, forceComponentLayout:function() {
  this.updateLayout();
}, setComponentLayout:function(layout) {
  var currentLayout = this.componentLayout;
  if (currentLayout && currentLayout.isLayout && currentLayout != layout) {
    currentLayout.setOwner(null);
  }
  this.componentLayout = layout;
  layout.setOwner(this);
}, getComponentLayout:function() {
  var me = this;
  if (!me.componentLayout || !me.componentLayout.isLayout) {
    me.setComponentLayout(Ext.layout.Layout.create(me.componentLayout, 'autocomponent'));
  }
  return me.componentLayout;
}, afterComponentLayout:function(width, height, oldWidth, oldHeight) {
  var me = this;
  if (++me.componentLayoutCounter === 1) {
    me.afterFirstLayout(width, height);
  }
  if (width !== oldWidth || height !== oldHeight) {
    me.onResize(width, height, oldWidth, oldHeight);
  }
}, beforeComponentLayout:function(width, height) {
  return true;
}, setPosition:function(x, y, animate) {
  var me = this, pos = me.beforeSetPosition.apply(me, arguments);
  if (pos && me.rendered) {
    x = pos.x;
    y = pos.y;
    if (animate) {
      if (x !== me.getLocalX() || y !== me.getLocalY()) {
        me.stopAnimation();
        me.animate(Ext.apply({duration:1000, listeners:{afteranimate:Ext.Function.bind(me.afterSetPosition, me, [x, y])}, to:{x:x, y:y}}, animate));
      }
    } else {
      me.setLocalXY(x, y);
      me.afterSetPosition(x, y);
    }
  }
  return me;
}, beforeSetPosition:function(x, y, animate) {
  var pos, x0;
  if (x) {
    if (Ext.isNumber(x0 = x[0])) {
      animate = y;
      y = x[1];
      x = x0;
    } else {
      if ((x0 = x.x) !== undefined) {
        animate = y;
        y = x.y;
        x = x0;
      }
    }
  }
  if (this.constrain || this.constrainHeader) {
    pos = this.calculateConstrainedPosition(null, [x, y], true);
    if (pos) {
      x = pos[0];
      y = pos[1];
    }
  }
  pos = {x:this.x = x, y:this.y = y, anim:animate, hasX:x !== undefined, hasY:y !== undefined};
  return pos.hasX || pos.hasY ? pos : null;
}, afterSetPosition:function(x, y) {
  var me = this;
  me.onPosition(x, y);
  if (me.hasListeners.move) {
    me.fireEvent('move', me, x, y);
  }
}, onPosition:Ext.emptyFn, setWidth:function(width) {
  return this.setSize(width);
}, setHeight:function(height) {
  return this.setSize(undefined, height);
}, getSize:function() {
  return this.el.getSize();
}, getWidth:function() {
  return this.el.getWidth();
}, getHeight:function() {
  return this.el.getHeight();
}, getLoader:function() {
  var me = this, autoLoad = me.autoLoad ? Ext.isObject(me.autoLoad) ? me.autoLoad : {url:me.autoLoad} : null, loader = me.loader || autoLoad;
  if (loader) {
    if (!loader.isLoader) {
      me.loader = new Ext.ComponentLoader(Ext.apply({target:me, autoLoad:autoLoad}, loader));
    } else {
      loader.setTarget(me);
    }
    return me.loader;
  }
  return null;
}, setDocked:function(dock, layoutParent) {
  var me = this;
  me.dock = dock;
  if (layoutParent && me.ownerCt && me.rendered) {
    me.ownerCt.updateLayout();
  }
  return me;
}, setBorder:function(border, targetEl) {
  var me = this, initial = !!targetEl;
  if (me.rendered || initial) {
    if (!initial) {
      targetEl = me.el;
    }
    if (!border) {
      border = 0;
    } else {
      if (border === true) {
        border = '1px';
      } else {
        border = this.unitizeBox(border);
      }
    }
    targetEl.setStyle('border-width', border);
    if (!initial) {
      me.updateLayout();
    }
  }
  me.border = border;
}, onDestroy:function() {
  var me = this;
  if (me.monitorResize && Ext.EventManager.resizeEvent) {
    Ext.EventManager.resizeEvent.removeListener(me.setSize, me);
  }
  Ext.destroy(me.componentLayout, me.loadMask, me.floatingDescendants);
}, destroy:function() {
  var me = this, selectors = me.renderSelectors, selector, el;
  if (!me.isDestroyed) {
    if (!me.hasListeners.beforedestroy || me.fireEvent('beforedestroy', me) !== false) {
      me.destroying = true;
      me.beforeDestroy();
      if (me.floating) {
        delete me.floatParent;
        if (me.zIndexManager) {
          me.zIndexManager.unregister(me);
        }
      } else {
        if (me.ownerCt && me.ownerCt.remove) {
          me.ownerCt.remove(me, false);
        }
      }
      me.stopAnimation();
      me.onDestroy();
      Ext.destroy(me.plugins);
      if (me.hasListeners.destroy) {
        me.fireEvent('destroy', me);
      }
      Ext.ComponentManager.unregister(me);
      me.mixins.state.destroy.call(me);
      me.clearListeners();
      if (me.rendered) {
        if (!me.preserveElOnDestroy) {
          me.el.remove();
        }
        me.mixins.elementCt.destroy.call(me);
        if (selectors) {
          for (selector in selectors) {
            if (selectors.hasOwnProperty(selector)) {
              el = me[selector];
              if (el) {
                delete me[selector];
                el.remove();
              }
            }
          }
        }
        delete me.el;
        delete me.frameBody;
        delete me.rendered;
      }
      me.destroying = false;
      me.isDestroyed = true;
    }
  }
}, isDescendantOf:function(container) {
  return !!this.findParentBy(function(p) {
    return p === container;
  });
}, getHierarchyState:function(inner) {
  var me = this, hierarchyState = inner && me.hierarchyStateInner || me.hierarchyState, ownerCt = me.ownerCt, parent, layout, hierarchyStateInner, getInner;
  if (!hierarchyState || hierarchyState.invalid) {
    parent = me.getRefOwner();
    if (ownerCt) {
      getInner = me.ownerLayout === ownerCt.layout;
    }
    me.hierarchyState = hierarchyState = Ext.Object.chain(parent ? parent.getHierarchyState(getInner) : Ext.rootHierarchyState);
    me.initHierarchyState(hierarchyState);
    if ((layout = me.componentLayout).initHierarchyState) {
      layout.initHierarchyState(hierarchyState);
    }
    if (me.isContainer) {
      me.hierarchyStateInner = hierarchyStateInner = Ext.Object.chain(hierarchyState);
      layout = me.layout;
      if (layout && layout.initHierarchyState) {
        layout.initHierarchyState(hierarchyStateInner, hierarchyState);
      }
      if (inner) {
        hierarchyState = hierarchyStateInner;
      }
    }
  }
  return hierarchyState;
}, initHierarchyState:function(hierarchyState) {
  var me = this;
  if (me.collapsed) {
    hierarchyState.collapsed = true;
  }
  if (me.hidden) {
    hierarchyState.hidden = true;
  }
  if (me.collapseImmune) {
    hierarchyState.collapseImmune = true;
  }
}, getAnchorToXY:function(el, anchor, local, mySize) {
  return el.getAnchorXY(anchor, local, mySize);
}, getBorderPadding:function() {
  return this.el.getBorderPadding();
}, getLocalX:function() {
  return this.el.getLocalX();
}, getLocalXY:function() {
  return this.el.getLocalXY();
}, getLocalY:function() {
  return this.el.getLocalY();
}, getX:function() {
  return this.el.getX();
}, getXY:function() {
  return this.el.getXY();
}, getY:function() {
  return this.el.getY();
}, setLocalX:function(x) {
  this.el.setLocalX(x);
}, setLocalXY:function(x, y) {
  this.el.setLocalXY(x, y);
}, setLocalY:function(y) {
  this.el.setLocalY(y);
}, setX:function(x, animate) {
  this.el.setX(x, animate);
}, setXY:function(xy, animate) {
  this.el.setXY(xy, animate);
}, setY:function(y, animate) {
  this.el.setY(y, animate);
}}, function() {
  var AbstractComponent = this;
  AbstractComponent.createAlias({on:'addListener', prev:'previousSibling', next:'nextSibling'});
  Ext.resumeLayouts = function(flush) {
    AbstractComponent.resumeLayouts(flush);
  };
  Ext.suspendLayouts = function() {
    AbstractComponent.suspendLayouts();
  };
  Ext.batchLayouts = function(fn, scope) {
    AbstractComponent.suspendLayouts();
    fn.call(scope);
    AbstractComponent.resumeLayouts(true);
  };
});
Ext.define('Ext.AbstractPlugin', {disabled:false, isPlugin:true, constructor:function(config) {
  this.pluginConfig = config;
  Ext.apply(this, config);
}, clonePlugin:function(overrideCfg) {
  return new this.self(Ext.apply({}, overrideCfg, this.pluginConfig));
}, setCmp:function(cmp) {
  this.cmp = cmp;
}, getCmp:function() {
  return this.cmp;
}, init:Ext.emptyFn, destroy:Ext.emptyFn, enable:function() {
  this.disabled = false;
}, disable:function() {
  this.disabled = true;
}, onClassExtended:function(cls, data, hooks) {
  var alias = data.alias;
  if (alias && !data.ptype) {
    if (Ext.isArray(alias)) {
      alias = alias[0];
    }
    cls.prototype.ptype = alias.split('plugin.')[1];
  }
}});
Ext.define('Ext.Action', {constructor:function(config) {
  this.initialConfig = config;
  this.itemId = config.itemId = config.itemId || config.id || Ext.id();
  this.items = [];
}, isAction:true, setText:function(text) {
  this.initialConfig.text = text;
  this.callEach('setText', [text]);
}, getText:function() {
  return this.initialConfig.text;
}, setIconCls:function(cls) {
  this.initialConfig.iconCls = cls;
  this.callEach('setIconCls', [cls]);
}, getIconCls:function() {
  return this.initialConfig.iconCls;
}, setDisabled:function(v) {
  this.initialConfig.disabled = v;
  this.callEach('setDisabled', [v]);
}, enable:function() {
  this.setDisabled(false);
}, disable:function() {
  this.setDisabled(true);
}, isDisabled:function() {
  return this.initialConfig.disabled;
}, setHidden:function(v) {
  this.initialConfig.hidden = v;
  this.callEach('setVisible', [!v]);
}, show:function() {
  this.setHidden(false);
}, hide:function() {
  this.setHidden(true);
}, isHidden:function() {
  return this.initialConfig.hidden;
}, setHandler:function(fn, scope) {
  this.initialConfig.handler = fn;
  this.initialConfig.scope = scope;
  this.callEach('setHandler', [fn, scope]);
}, each:function(fn, scope) {
  Ext.each(this.items, fn, scope);
}, callEach:function(fnName, args) {
  var items = this.items, i = 0, len = items.length, item;
  Ext.suspendLayouts();
  for (; i < len; i++) {
    item = items[i];
    item[fnName].apply(item, args);
  }
  Ext.resumeLayouts(true);
}, addComponent:function(comp) {
  this.items.push(comp);
  comp.on('destroy', this.removeComponent, this);
}, removeComponent:function(comp) {
  Ext.Array.remove(this.items, comp);
}, execute:function() {
  this.initialConfig.handler.apply(this.initialConfig.scope || Ext.global, arguments);
}});
Ext.define('Ext.data.flash.BinaryXhr', {statics:{flashPluginActivated:function() {
  Ext.data.flash.BinaryXhr.flashPluginActive = true;
  Ext.data.flash.BinaryXhr.flashPlugin = document.getElementById('ext-flash-polyfill');
  Ext.globalEvents.fireEvent('flashready');
}, flashPluginActive:false, flashPluginInjected:false, connectionIndex:1, liveConnections:{}, flashPlugin:null, onFlashStateChange:function(javascriptId, state, data) {
  var connection;
  connection = this.liveConnections[Number(javascriptId)];
  if (connection) {
    connection.onFlashStateChange(state, data);
  } else {
    Ext.warn.log('onFlashStateChange for unknown connection ID: ' + javascriptId);
  }
}, registerConnection:function(conn) {
  var i = this.connectionIndex;
  this.conectionIndex = this.connectionIndex + 1;
  this.liveConnections[i] = conn;
  return i;
}, injectFlashPlugin:function() {
  var divTag, pTag, aTag, iTag, me = this, flashLoaderPath, flashObjectPath;
  iTag = document.createElement('img');
  iTag.setAttribute('src', window.location.protocol + '//www.adobe.com/images/shared/download_buttons/get_flash_player.gif');
  iTag.setAttribute('alt', 'Get Adobe Flash player');
  aTag = document.createElement('a');
  aTag.setAttribute('href', 'http://www.adobe.com/go/getflashplayer');
  aTag.appendChild(iTag);
  pTag = document.createElement('p');
  pTag.innerHTML = 'To view this page ensure that Adobe Flash Player version 11.1.0 or greater is installed.';
  divTag = document.createElement('div');
  divTag.setAttribute('id', 'ext-flash-polyfill');
  divTag.appendChild(pTag);
  divTag.appendChild(iTag);
  Ext.getBody().dom.appendChild(divTag);
  flashLoaderPath = [Ext.Loader.getPath('Ext.data.Connection'), '../../../plugins/flash/swfobject.js'].join('/');
  flashObjectPath = '/plugins/flash/FlashPlugin.swf';
  flashObjectPath = [Ext.Loader.getPath('Ext.data.Connection'), '../../plugins/flash/FlashPlugin.swf'].join('/');
  if (Ext.flashPluginPath) {
    flashObjectPath = Ext.flashPluginPath;
  }
  Ext.Loader.loadScript({url:flashLoaderPath, onLoad:function() {
    var swfVersionStr = '11.4.0';
    var xiSwfUrlStr = 'playerProductInstall.swf';
    var flashvars = {};
    var params = {};
    params.quality = 'high';
    params.bgcolor = '#ffffff';
    params.allowscriptaccess = 'sameDomain';
    params.allowfullscreen = 'true';
    var attributes = {};
    attributes.id = 'ext-flash-polyfill';
    attributes.name = 'polyfill';
    attributes.align = 'middle';
    swfobject.embedSWF(flashObjectPath, 'ext-flash-polyfill', '0', '0', swfVersionStr, xiSwfUrlStr, flashvars, params, attributes);
  }, onError:function() {
    Ext.Error.raise('Could not load flash-loader file swfobject.js from ' + flashLoader);
  }, scope:me});
  Ext.globalEvents.addEvents('flashready');
  Ext.data.flash.BinaryXhr.flashPluginInjected = true;
}}, readyState:0, status:0, statusText:'', responseBytes:null, javascriptId:null, constructor:function(config) {
  if (!Ext.data.flash.BinaryXhr.flashPluginInjected) {
    Ext.data.flash.BinaryXhr.injectFlashPlugin();
  }
  var me = this;
  Ext.apply(me, config);
  me.requestHeaders = {};
}, abort:function() {
  var me = this;
  if (me.readyState == 4) {
    Ext.warn.log("Aborting a connection that's completed its transfer: " + this.url);
    return;
  }
  me.aborted = true;
  if (!Ext.data.flash.BinaryXhr.flashPluginActive) {
    Ext.globalEvents.removeListener('flashready', me.onFlashReady, me);
    return;
  }
  Ext.data.flash.BinaryXhr.flashPlugin.abortRequest(me.javascriptId);
  delete Ext.data.flash.BinaryXhr.liveConnections[me.javascriptId];
}, getAllResponseHeaders:function() {
  var headers = [];
  Ext.Object.each(this.responseHeaders, function(name, value) {
    headers.push(name + ': ' + value);
  });
  return headers.join('\r\n');
}, getResponseHeader:function(header) {
  var headers = this.responseHeaders;
  return headers && headers[header] || null;
}, open:function(method, url, async, user, password) {
  var me = this;
  me.method = method;
  me.url = url;
  me.async = async !== false;
  me.user = user;
  me.password = password;
  if (!me.async) {
    Ext.Error.raise('Binary posts are only supported in async mode: ' + url);
  }
  if (me.method != 'POST') {
    Ext.log.warn('Binary data can only be sent as a POST request: ' + url);
  }
}, overrideMimeType:function(mimeType) {
  this.mimeType = mimeType;
}, send:function(body) {
  var me = this;
  me.body = body;
  if (!Ext.data.flash.BinaryXhr.flashPluginActive) {
    Ext.globalEvents.addListener('flashready', me.onFlashReady, me);
  } else {
    this.onFlashReady();
  }
}, onFlashReady:function() {
  var me = this, req, status;
  me.javascriptId = Ext.data.flash.BinaryXhr.registerConnection(me);
  req = {method:me.method, url:me.url, user:me.user, password:me.password, mimeType:me.mimeType, requestHeaders:me.requestHeaders, body:me.body, javascriptId:me.javascriptId};
  status = Ext.data.flash.BinaryXhr.flashPlugin.postBinary(req);
}, setReadyState:function(state) {
  var me = this;
  if (me.readyState != state) {
    me.readyState = state;
    me.onreadystatechange();
  }
}, setRequestHeader:function(header, value) {
  this.requestHeaders[header] = value;
}, onreadystatechange:Ext.emptyFn, parseData:function(data) {
  var me = this;
  this.status = data.status || 0;
  me.responseHeaders = {};
  if (me.mimeType) {
    me.responseHeaders['content-type'] = me.mimeType;
  }
  if (data.reason == 'complete') {
    this.responseBytes = data.data;
    me.responseHeaders['content-length'] = data.data.length;
  } else {
    if (data.reason == 'error' || data.reason == 'securityError') {
      this.statusText = data.text;
      me.responseHeaders['content-length'] = 0;
    } else {
      Ext.Error.raise('Unkown reason code in data: ' + data.reason);
    }
  }
}, onFlashStateChange:function(state, data) {
  var me = this;
  if (state == 4) {
    me.parseData(data);
    delete Ext.data.flash.BinaryXhr.liveConnections[me.javascriptId];
  }
  me.setReadyState(state);
}});
Ext.define('Ext.data.Connection', {mixins:{observable:Ext.util.Observable}, statics:{requestId:0}, url:null, async:true, method:null, username:'', password:'', disableCaching:true, withCredentials:false, binary:false, cors:false, isXdr:false, defaultXdrContentType:'text/plain', disableCachingParam:'_dc', timeout:30000, useDefaultHeader:true, defaultPostHeader:'application/x-www-form-urlencoded; charset\x3dUTF-8', useDefaultXhrHeader:true, defaultXhrHeader:'XMLHttpRequest', constructor:function(config) {
  config = config || {};
  Ext.apply(this, config);
  this.requests = {};
  this.mixins.observable.constructor.call(this);
}, request:function(options) {
  options = options || {};
  var me = this, scope = options.scope || window, username = options.username || me.username, password = options.password || me.password || '', async, requestOptions, request, headers, xhr;
  if (me.fireEvent('beforerequest', me, options) !== false) {
    requestOptions = me.setOptions(options, scope);
    if (me.isFormUpload(options)) {
      me.upload(options.form, requestOptions.url, requestOptions.data, options);
      return null;
    }
    if (options.autoAbort || me.autoAbort) {
      me.abort();
    }
    async = options.async !== false ? options.async || me.async : false;
    xhr = me.openRequest(options, requestOptions, async, username, password);
    if (!me.isXdr) {
      headers = me.setupHeaders(xhr, options, requestOptions.data, requestOptions.params);
    }
    request = {id:++Ext.data.Connection.requestId, xhr:xhr, headers:headers, options:options, async:async, binary:options.binary || me.binary, timeout:setTimeout(function() {
      request.timedout = true;
      me.abort(request);
    }, options.timeout || me.timeout)};
    me.requests[request.id] = request;
    me.latestId = request.id;
    if (async) {
      if (!me.isXdr) {
        xhr.onreadystatechange = Ext.Function.bind(me.onStateChange, me, [request]);
      }
    }
    if (me.isXdr) {
      me.processXdrRequest(request, xhr);
    }
    xhr.send(requestOptions.data);
    if (!async) {
      return me.onComplete(request);
    }
    return request;
  } else {
    Ext.callback(options.callback, options.scope, [options, undefined, undefined]);
    return null;
  }
}, processXdrRequest:function(request, xhr) {
  var me = this;
  delete request.headers;
  request.contentType = request.options.contentType || me.defaultXdrContentType;
  xhr.onload = Ext.Function.bind(me.onStateChange, me, [request, true]);
  xhr.onerror = xhr.ontimeout = Ext.Function.bind(me.onStateChange, me, [request, false]);
}, processXdrResponse:function(response, xhr) {
  response.getAllResponseHeaders = function() {
    return [];
  };
  response.getResponseHeader = function() {
    return '';
  };
  response.contentType = xhr.contentType || this.defaultXdrContentType;
}, upload:function(form, url, params, options) {
  form = Ext.getDom(form);
  options = options || {};
  var id = Ext.id(), frame = document.createElement('iframe'), hiddens = [], encoding = 'multipart/form-data', buf = {target:form.target, method:form.method, encoding:form.encoding, enctype:form.enctype, action:form.action}, addField = function(name, value) {
    hiddenItem = document.createElement('input');
    Ext.fly(hiddenItem).set({type:'hidden', value:value, name:name});
    form.appendChild(hiddenItem);
    hiddens.push(hiddenItem);
  }, hiddenItem, obj, value, name, vLen, v, hLen, h;
  Ext.fly(frame).set({id:id, name:id, cls:Ext.baseCSSPrefix + 'hide-display', src:Ext.SSL_SECURE_URL});
  document.body.appendChild(frame);
  if (document.frames) {
    document.frames[id].name = id;
  }
  Ext.fly(form).set({target:id, method:'POST', enctype:encoding, encoding:encoding, action:url || buf.action});
  if (params) {
    obj = Ext.Object.fromQueryString(params) || {};
    for (name in obj) {
      if (obj.hasOwnProperty(name)) {
        value = obj[name];
        if (Ext.isArray(value)) {
          vLen = value.length;
          for (v = 0; v < vLen; v++) {
            addField(name, value[v]);
          }
        } else {
          addField(name, value);
        }
      }
    }
  }
  Ext.fly(frame).on('load', Ext.Function.bind(this.onUploadComplete, this, [frame, options]), null, {single:!Ext.isOpera});
  form.submit();
  Ext.fly(form).set(buf);
  hLen = hiddens.length;
  for (h = 0; h < hLen; h++) {
    Ext.removeNode(hiddens[h]);
  }
}, onUploadComplete:function(frame, options) {
  var me = this, response = {responseText:'', responseXML:null}, callback, success, doc, contentNode;
  try {
    doc = frame.contentWindow.document || frame.contentDocument || window.frames[frame.id].document;
    if (doc) {
      if (Ext.isOpera && doc.location == 'about:blank') {
        return;
      }
      if (doc.body) {
        if ((contentNode = doc.body.firstChild) && /pre/i.test(contentNode.tagName)) {
          response.responseText = contentNode.textContent;
        } else {
          if (contentNode = doc.getElementsByTagName('textarea')[0]) {
            response.responseText = contentNode.value;
          } else {
            response.responseText = doc.body.textContent || doc.body.innerText;
          }
        }
      }
      response.responseXML = doc.XMLDocument || doc;
      callback = options.success;
      success = true;
    }
  } catch (e$19) {
    response.responseText = '{success:false,message:"' + Ext.String.trim(e$19.message || e$19.description) + '"}';
    callback = options.failure;
    success = false;
  }
  me.fireEvent('requestcomplete', me, response, options);
  Ext.callback(callback, options.scope, [response, options]);
  Ext.callback(options.callback, options.scope, [options, success, response]);
  setTimeout(function() {
    Ext.removeNode(frame);
  }, 100);
}, isFormUpload:function(options) {
  var form = this.getForm(options);
  if (form) {
    return options.isUpload || /multipart\/form-data/i.test(form.getAttribute('enctype'));
  }
  return false;
}, getForm:function(options) {
  return Ext.getDom(options.form) || null;
}, setOptions:function(options, scope) {
  var me = this, params = options.params || {}, extraParams = me.extraParams, urlParams = options.urlParams, url = options.url || me.url, jsonData = options.jsonData, method, disableCache, data;
  if (Ext.isFunction(params)) {
    params = params.call(scope, options);
  }
  if (Ext.isFunction(url)) {
    url = url.call(scope, options);
  }
  url = this.setupUrl(options, url);
  if (!url) {
    Ext.Error.raise({options:options, msg:'No URL specified'});
  }
  data = options.rawData || options.binaryData || options.xmlData || jsonData || null;
  if (jsonData && !Ext.isPrimitive(jsonData)) {
    data = Ext.encode(data);
  }
  if (options.binaryData) {
    if (!Ext.isArray(options.binaryData)) {
      Ext.log.warn('Binary submission data must be an array of byte values! Instead got ' + typeof options.binaryData);
    }
    if (me.nativeBinaryPostSupport()) {
      data = new Uint8Array(options.binaryData);
      if (Ext.isChrome && Ext.chromeVersion < 22 || Ext.isSafari || Ext.isGecko) {
        data = data.buffer;
      }
    }
  }
  if (Ext.isObject(params)) {
    params = Ext.Object.toQueryString(params);
  }
  if (Ext.isObject(extraParams)) {
    extraParams = Ext.Object.toQueryString(extraParams);
  }
  params = params + (extraParams ? (params ? '\x26' : '') + extraParams : '');
  urlParams = Ext.isObject(urlParams) ? Ext.Object.toQueryString(urlParams) : urlParams;
  params = this.setupParams(options, params);
  method = (options.method || me.method || (params || data ? 'POST' : 'GET')).toUpperCase();
  this.setupMethod(options, method);
  disableCache = options.disableCaching !== false ? options.disableCaching || me.disableCaching : false;
  if (method === 'GET' && disableCache) {
    url = Ext.urlAppend(url, (options.disableCachingParam || me.disableCachingParam) + '\x3d' + (new Date).getTime());
  }
  if ((method == 'GET' || data) && params) {
    url = Ext.urlAppend(url, params);
    params = null;
  }
  if (urlParams) {
    url = Ext.urlAppend(url, urlParams);
  }
  return {url:url, method:method, data:data || params || null};
}, setupUrl:function(options, url) {
  var form = this.getForm(options);
  if (form) {
    url = url || form.action;
  }
  return url;
}, setupParams:function(options, params) {
  var form = this.getForm(options), serializedForm;
  if (form && !this.isFormUpload(options)) {
    serializedForm = Ext.Element.serializeForm(form);
    params = params ? params + '\x26' + serializedForm : serializedForm;
  }
  return params;
}, setupMethod:function(options, method) {
  if (this.isFormUpload(options)) {
    return 'POST';
  }
  return method;
}, setupHeaders:function(xhr, options, data, params) {
  var me = this, headers = Ext.apply({}, options.headers || {}, me.defaultHeaders || {}), contentType = me.defaultPostHeader, jsonData = options.jsonData, xmlData = options.xmlData, key, header;
  if (!headers['Content-Type'] && (data || params)) {
    if (data) {
      if (options.rawData) {
        contentType = 'text/plain';
      } else {
        if (xmlData && Ext.isDefined(xmlData)) {
          contentType = 'text/xml';
        } else {
          if (jsonData && Ext.isDefined(jsonData)) {
            contentType = 'application/json';
          }
        }
      }
    }
    headers['Content-Type'] = contentType;
  }
  if (me.useDefaultXhrHeader && !headers['X-Requested-With']) {
    headers['X-Requested-With'] = me.defaultXhrHeader;
  }
  try {
    for (key in headers) {
      if (headers.hasOwnProperty(key)) {
        header = headers[key];
        xhr.setRequestHeader(key, header);
      }
    }
  } catch (e$20) {
    me.fireEvent('exception', key, header);
  }
  return headers;
}, newRequest:function(options) {
  var me = this, xhr;
  if (options.binaryData) {
    if (me.nativeBinaryPostSupport()) {
      xhr = this.getXhrInstance();
    } else {
      xhr = new Ext.data.flash.BinaryXhr;
    }
  } else {
    if ((options.cors || me.cors) && Ext.isIE && Ext.ieVersion <= 9) {
      xhr = me.getXdrInstance();
      me.isXdr = true;
    } else {
      xhr = me.getXhrInstance();
    }
  }
  return xhr;
}, openRequest:function(options, requestOptions, async, username, password) {
  var me = this, xhr = me.newRequest(options);
  if (username) {
    xhr.open(requestOptions.method, requestOptions.url, async, username, password);
  } else {
    if (me.isXdr) {
      xhr.open(requestOptions.method, requestOptions.url);
    } else {
      xhr.open(requestOptions.method, requestOptions.url, async);
    }
  }
  if (options.binary || me.binary) {
    if (window.Uint8Array) {
      xhr.responseType = 'arraybuffer';
    } else {
      if (xhr.overrideMimeType) {
        xhr.overrideMimeType('text/plain; charset\x3dx-user-defined');
      } else {
        if (!Ext.isIE) {
          Ext.log.warn('Your does not support loading binary data using Ajax.');
        }
      }
    }
  }
  if (options.withCredentials || me.withCredentials) {
    xhr.withCredentials = true;
  }
  return xhr;
}, getXdrInstance:function() {
  var xdr;
  if (Ext.ieVersion >= 8) {
    xdr = new XDomainRequest;
  } else {
    Ext.Error.raise({msg:'Your browser does not support CORS'});
  }
  return xdr;
}, getXhrInstance:function() {
  var options = [function() {
    return new XMLHttpRequest;
  }, function() {
    return new ActiveXObject('MSXML2.XMLHTTP.3.0');
  }, function() {
    return new ActiveXObject('MSXML2.XMLHTTP');
  }, function() {
    return new ActiveXObject('Microsoft.XMLHTTP');
  }], i = 0, len = options.length, xhr;
  for (; i < len; ++i) {
    try {
      xhr = options[i];
      xhr();
      break;
    } catch (e$21) {
    }
  }
  return xhr;
}(), isLoading:function(request) {
  if (!request) {
    request = this.getLatest();
  }
  if (!(request && request.xhr)) {
    return false;
  }
  var state = request.xhr.readyState;
  return request.xhr instanceof Ext.data.flash.BinaryXhr && state != 4 || !(state === 0 || state == 4);
}, abort:function(request) {
  var me = this, xhr;
  if (!request) {
    request = me.getLatest();
  }
  if (request && me.isLoading(request)) {
    xhr = request.xhr;
    try {
      xhr.onreadystatechange = null;
    } catch (e$22) {
      xhr.onreadystatechange = Ext.emptyFn;
    }
    xhr.abort();
    me.clearTimeout(request);
    if (!request.timedout) {
      request.aborted = true;
    }
    me.onComplete(request);
    me.cleanup(request);
  }
}, abortAll:function() {
  var requests = this.requests, id;
  for (id in requests) {
    if (requests.hasOwnProperty(id)) {
      this.abort(requests[id]);
    }
  }
}, getLatest:function() {
  var id = this.latestId, request;
  if (id) {
    request = this.requests[id];
  }
  return request || null;
}, onStateChange:function(request, xdrResult) {
  var me = this;
  if (request.xhr && request.xhr.readyState == 4 || me.isXdr) {
    me.clearTimeout(request);
    me.onComplete(request, xdrResult);
    me.cleanup(request);
    Ext.EventManager.idleEvent.fire();
  }
}, clearTimeout:function(request) {
  clearTimeout(request.timeout);
  delete request.timeout;
}, cleanup:function(request) {
  request.xhr = null;
  delete request.xhr;
}, onComplete:function(request, xdrResult) {
  var me = this, options = request.options, result, success, response;
  try {
    result = me.parseStatus(request.xhr.status);
  } catch (e$23) {
    result = {success:false, isException:false};
  }
  success = me.isXdr ? xdrResult : result.success;
  if (success) {
    response = me.createResponse(request);
    me.fireEvent('requestcomplete', me, response, options);
    Ext.callback(options.success, options.scope, [response, options]);
  } else {
    if (result.isException || request.aborted || request.timedout) {
      response = me.createException(request);
    } else {
      response = me.createResponse(request);
    }
    me.fireEvent('requestexception', me, response, options);
    Ext.callback(options.failure, options.scope, [response, options]);
  }
  Ext.callback(options.callback, options.scope, [options, success, response]);
  delete me.requests[request.id];
  return response;
}, parseStatus:function(status) {
  status = status == 1223 ? 204 : status;
  var success = status >= 200 && status < 300 || status == 304, isException = false;
  if (!success) {
    switch(status) {
      case 12002:
      case 12029:
      case 12030:
      case 12031:
      case 12152:
      case 13030:
        isException = true;
        break;
    }
  }
  return {success:success, isException:isException};
}, createResponse:function(request) {
  var me = this, xhr = request.xhr, isXdr = me.isXdr, headers = {}, lines = isXdr ? [] : xhr.getAllResponseHeaders().replace(/\r\n/g, '\n').split('\n'), count = lines.length, line, index, key, response, byteArray;
  while (count--) {
    line = lines[count];
    index = line.indexOf(':');
    if (index >= 0) {
      key = line.substr(0, index).toLowerCase();
      if (line.charAt(index + 1) == ' ') {
        ++index;
      }
      headers[key] = line.substr(index + 1);
    }
  }
  request.xhr = null;
  delete request.xhr;
  response = {request:request, requestId:request.id, status:xhr.status, statusText:xhr.statusText, getResponseHeader:function(header) {
    return headers[header.toLowerCase()];
  }, getAllResponseHeaders:function() {
    return headers;
  }};
  if (isXdr) {
    me.processXdrResponse(response, xhr);
  }
  if (request.binary) {
    response.responseBytes = me.getByteArray(xhr);
  } else {
    response.responseText = xhr.responseText;
    response.responseXML = xhr.responseXML;
  }
  xhr = null;
  return response;
}, createException:function(request) {
  return {request:request, requestId:request.id, status:request.aborted ? -1 : 0, statusText:request.aborted ? 'transaction aborted' : 'communication failure', aborted:request.aborted, timedout:request.timedout};
}, getByteArray:function(xhr) {
  var response = xhr.response, responseBody = xhr.responseBody, byteArray, responseText, len, i;
  if (xhr instanceof Ext.data.flash.BinaryXhr) {
    byteArray = xhr.responseBytes;
  } else {
    if (window.Uint8Array) {
      byteArray = response ? new Uint8Array(response) : [];
    } else {
      if (Ext.isIE9p) {
        try {
          byteArray = (new VBArray(responseBody)).toArray();
        } catch (e$24) {
          byteArray = [];
        }
      } else {
        if (Ext.isIE) {
          if (!this.self.vbScriptInjected) {
            this.injectVBScript();
          }
          getIEByteArray(xhr.responseBody, byteArray = []);
        } else {
          byteArray = [];
          responseText = xhr.responseText;
          len = responseText.length;
          for (i = 0; i < len; i++) {
            byteArray.push(responseText.charCodeAt(i) & 255);
          }
        }
      }
    }
  }
  return byteArray;
}, injectVBScript:function() {
  var scriptTag = document.createElement('script');
  scriptTag.type = 'text/vbscript';
  scriptTag.text = ['Function getIEByteArray(byteArray, out)', 'Dim len, i', 'len \x3d LenB(byteArray)', 'For i \x3d 1 to len', 'out.push(AscB(MidB(byteArray, i, 1)))', 'Next', 'End Function'].join('\n');
  Ext.getHead().dom.appendChild(scriptTag);
  this.self.vbScriptInjected = true;
}, nativeBinaryPostSupport:function() {
  return Ext.isChrome || Ext.isSafari && Ext.isDefined(window.Uint8Array) || Ext.isGecko && Ext.isDefined(window.Uint8Array);
}});
Ext.define('Ext.Ajax', {extend:Ext.data.Connection, singleton:true, autoAbort:false});
Ext.define('Ext.util.Floating', {focusOnToFront:true, shadow:'sides', constrain:false, constructor:function(dom) {
  var me = this;
  me.fixed = me.fixed && !(Ext.isIE6 || Ext.isIEQuirks);
  me.el = new Ext.dom.Layer(Ext.apply({preventSync:true, hideMode:me.hideMode, hidden:me.hidden, shadow:typeof me.shadow != 'undefined' ? me.shadow : 'sides', shadowOffset:me.shadowOffset, constrain:false, fixed:me.fixed, shim:me.shim === false ? false : undefined}, me.floating), dom);
  if (me.modal && !(Ext.FocusManager && Ext.FocusManager.enabled)) {
    me.mon(me.el, {keydown:me.onKeyDown, scope:me});
  }
  me.mon(me.el, {mousedown:me.onMouseDown, scope:me});
  me.floating = true;
  me.registerWithOwnerCt();
  me.initHierarchyEvents();
}, initHierarchyEvents:function() {
  var me = this, syncHidden = this.syncHidden;
  if (!me.hasHierarchyEventListeners) {
    me.mon(me.hierarchyEventSource, {hide:syncHidden, collapse:syncHidden, show:syncHidden, expand:syncHidden, added:syncHidden, scope:me});
    me.hasHierarchyEventListeners = true;
  }
}, registerWithOwnerCt:function() {
  var me = this, ownerCt = me.ownerCt, zip = me.zIndexParent;
  if (zip) {
    zip.unregisterFloatingItem(me);
  }
  zip = me.zIndexParent = me.up('[floating]');
  me.setFloatParent(ownerCt || zip);
  delete me.ownerCt;
  if (zip) {
    zip.registerFloatingItem(me);
  } else {
    Ext.WindowManager.register(me);
  }
}, onKeyDown:function(e) {
  var me = this, shift, focusables, first, last;
  if (e.getKey() == Ext.EventObject.TAB) {
    shift = e.shiftKey;
    focusables = me.el.query(':focusable');
    first = focusables[0];
    last = focusables[focusables.length - 1];
    if (first && last && e.target === (shift ? first : last)) {
      e.stopEvent();
      (shift ? last : first).focus(false, true);
    }
  }
}, onMouseDown:function(e) {
  var focusTask = this.focusTask;
  if (this.floating && (!focusTask || !focusTask.id)) {
    this.toFront(!!e.getTarget(':focusable'));
  }
}, setFloatParent:function(floatParent) {
  var me = this;
  me.floatParent = floatParent;
  if ((me.constrain || me.constrainHeader) && !me.constrainTo) {
    me.constrainTo = floatParent ? floatParent.getTargetEl() : me.container;
  }
}, syncShadow:function() {
  if (this.floating) {
    this.el.sync(true);
  }
}, onBeforeFloatLayout:function() {
  this.el.preventSync = true;
}, onAfterFloatLayout:function() {
  delete this.el.preventSync;
  this.syncShadow();
}, syncHidden:function() {
  var me = this, hidden = me.hidden || !me.rendered, hierarchicallyHidden = me.hierarchicallyHidden = me.isHierarchicallyHidden(), pendingShow = me.pendingShow;
  if (hidden !== hierarchicallyHidden) {
    if (hierarchicallyHidden) {
      me.hide();
      me.pendingShow = true;
    } else {
      if (pendingShow) {
        delete me.pendingShow;
        if (pendingShow.length) {
          me.show.apply(me, pendingShow);
        } else {
          me.show();
        }
      }
    }
  }
}, setZIndex:function(index) {
  var me = this;
  me.el.setZIndex(index);
  index += 10;
  if (me.floatingDescendants) {
    index = Math.floor(me.floatingDescendants.setBase(index) / 100) * 100 + 10000;
  }
  return index;
}, doConstrain:function(constrainTo) {
  var me = this, xy = me.calculateConstrainedPosition(constrainTo, null, true);
  if (xy) {
    me.setPosition(xy);
  }
}, toFront:function(preventFocus) {
  var me = this, zip = me.zIndexParent, preventFocusSetting = me.preventFocusOnActivate;
  if (zip && me.bringParentToFront !== false) {
    zip.toFront(true);
  }
  if (!Ext.isDefined(preventFocus)) {
    preventFocus = !me.focusOnToFront;
  }
  if (preventFocus) {
    me.preventFocusOnActivate = true;
  }
  if (me.zIndexManager.bringToFront(me, preventFocus)) {
    if (!preventFocus) {
      me.focus(false, true);
    }
  }
  me.preventFocusOnActivate = preventFocusSetting;
  return me;
}, setActive:function(active, newActive) {
  var me = this;
  if (active) {
    if (me.el.shadow && !me.maximized) {
      me.el.enableShadow(true);
    }
    if (!me.preventFocusOnActivate) {
      me.focus(false, true);
    }
    me.fireEvent('activate', me);
  } else {
    if (me.isWindow && (newActive && newActive.isWindow) && me.hideShadowOnDeactivate) {
      me.el.disableShadow();
    }
    me.fireEvent('deactivate', me);
  }
}, toBack:function() {
  this.zIndexManager.sendToBack(this);
  return this;
}, center:function() {
  var me = this, xy;
  if (me.isVisible()) {
    xy = me.getAlignToXY(me.container, 'c-c');
    me.setPagePosition(xy);
  } else {
    me.needsCenter = true;
  }
  return me;
}, onFloatShow:function() {
  if (this.needsCenter) {
    this.center();
  }
  delete this.needsCenter;
}, fitContainer:function(animate) {
  var me = this, parent = me.floatParent, container = parent ? parent.getTargetEl() : me.container, newBox = container.getViewSize(false), newPosition = parent || container.dom !== document.body ? [0, 0] : container.getXY();
  newBox.x = newPosition[0];
  newBox.y = newPosition[1];
  me.setBox(newBox, animate);
}});
Ext.define('Ext.Component', {alias:['widget.component', 'widget.box'], extend:Ext.AbstractComponent, mixins:{floating:Ext.util.Floating}, statics:{DIRECTION_TOP:'top', DIRECTION_RIGHT:'right', DIRECTION_BOTTOM:'bottom', DIRECTION_LEFT:'left', VERTICAL_DIRECTION_Re:/^(?:top|bottom)$/, INVALID_ID_CHARS_Re:/[\.,\s]/g}, resizeHandles:'all', floating:false, defaultAlign:'tl-bl?', toFrontOnShow:true, hideMode:'display', offsetsCls:Ext.baseCSSPrefix + 'hide-offsets', bubbleEvents:[], defaultComponentLayoutType:'autocomponent', 
constructor:function(config) {
  var me = this;
  config = config || {};
  if (config.initialConfig) {
    if (config.isAction) {
      me.baseAction = config;
    }
    config = config.initialConfig;
  } else {
    if (config.tagName || config.dom || Ext.isString(config)) {
      config = {applyTo:config, id:config.id || config};
    }
  }
  me.callParent([config]);
  if (me.baseAction) {
    me.baseAction.addComponent(me);
  }
}, initComponent:function() {
  var me = this;
  me.callParent();
  if (me.listeners) {
    me.on(me.listeners);
    me.listeners = null;
  }
  me.enableBubble(me.bubbleEvents);
}, afterRender:function() {
  var me = this;
  me.callParent();
  if (!(me.x && me.y) && (me.pageX || me.pageY)) {
    me.setPagePosition(me.pageX, me.pageY);
  }
}, setAutoScroll:function(scroll) {
  var me = this;
  me.autoScroll = !!scroll;
  if (me.rendered) {
    me.getOverflowEl().setStyle(me.getOverflowStyle());
  }
  me.updateLayout();
  return me;
}, setOverflowXY:function(overflowX, overflowY) {
  var me = this, argCount = arguments.length;
  if (argCount) {
    me.overflowX = overflowX || '';
    if (argCount > 1) {
      me.overflowY = overflowY || '';
    }
  }
  if (me.rendered) {
    me.getOverflowEl().setStyle(me.getOverflowStyle());
  }
  me.updateLayout();
  return me;
}, beforeRender:function() {
  var me = this, floating = me.floating, cls;
  if (floating) {
    me.addCls(Ext.baseCSSPrefix + 'layer');
    cls = floating.cls;
    if (cls) {
      me.addCls(cls);
    }
  }
  return me.callParent();
}, beforeLayout:function() {
  this.callParent(arguments);
  if (this.floating) {
    this.onBeforeFloatLayout();
  }
}, afterComponentLayout:function() {
  this.callParent(arguments);
  if (this.floating) {
    this.onAfterFloatLayout();
  }
}, makeFloating:function(dom) {
  this.mixins.floating.constructor.call(this, dom);
}, wrapPrimaryEl:function(dom) {
  if (this.floating) {
    this.makeFloating(dom);
  } else {
    this.callParent(arguments);
  }
}, initResizable:function(resizable) {
  var me = this;
  resizable = Ext.apply({target:me, dynamic:false, constrainTo:me.constrainTo || (me.floatParent ? me.floatParent.getTargetEl() : null), handles:me.resizeHandles}, resizable);
  resizable.target = me;
  me.resizer = new Ext.resizer.Resizer(resizable);
}, getDragEl:function() {
  return this.el;
}, initDraggable:function() {
  var me = this, dragTarget = me.resizer && me.resizer.el !== me.el ? me.resizerComponent = new Ext.Component({el:me.resizer.el, rendered:true, container:me.container}) : me, ddConfig = Ext.applyIf({el:dragTarget.getDragEl(), constrainTo:me.constrain || me.draggable.constrain ? me.constrainTo || (me.floatParent ? me.floatParent.getTargetEl() : me.container) : undefined}, me.draggable);
  if (me.constrain || me.constrainDelegate) {
    ddConfig.constrain = me.constrain;
    ddConfig.constrainDelegate = me.constrainDelegate;
  }
  me.dd = new Ext.util.ComponentDragger(dragTarget, ddConfig);
}, scrollBy:function(deltaX, deltaY, animate) {
  var el;
  if ((el = this.getTargetEl()) && el.dom) {
    el.scrollBy.apply(el, arguments);
  }
}, setLoading:function(load, targetEl) {
  var me = this, config = {target:me};
  if (me.rendered) {
    Ext.destroy(me.loadMask);
    me.loadMask = null;
    if (load !== false && !me.collapsed) {
      if (Ext.isObject(load)) {
        Ext.apply(config, load);
      } else {
        if (Ext.isString(load)) {
          config.msg = load;
        }
      }
      if (targetEl) {
        Ext.applyIf(config, {useTargetEl:true});
      }
      me.loadMask = new Ext.LoadMask(config);
      me.loadMask.show();
    }
  }
  return me.loadMask;
}, beforeSetPosition:function() {
  var me = this, pos = me.callParent(arguments), adj;
  if (pos) {
    adj = me.adjustPosition(pos.x, pos.y);
    pos.x = adj.x;
    pos.y = adj.y;
  }
  return pos || null;
}, afterSetPosition:function(ax, ay) {
  this.onPosition(ax, ay);
  this.fireEvent('move', this, ax, ay);
}, showAt:function(x, y, animate) {
  var me = this;
  if (!me.rendered && (me.autoRender || me.floating)) {
    me.x = x;
    me.y = y;
    return me.show();
  }
  if (me.floating) {
    me.setPosition(x, y, animate);
  } else {
    me.setPagePosition(x, y, animate);
  }
  me.show();
}, showBy:function(cmp, pos, off) {
  var me = this;
  if (!me.floating) {
    Ext.log.warn('Using showBy on a non-floating component');
    return me;
  }
  if (me.floating && cmp) {
    me.show();
    if (me.rendered && !me.hidden) {
      me.alignTo(cmp, pos || me.defaultAlign, off);
    }
  }
  return me;
}, setPagePosition:function(x, y, animate) {
  var me = this, p, floatParentBox;
  if (Ext.isArray(x)) {
    y = x[1];
    x = x[0];
  }
  me.pageX = x;
  me.pageY = y;
  if (me.floating) {
    if (me.isContainedFloater()) {
      floatParentBox = me.floatParent.getTargetEl().getViewRegion();
      if (Ext.isNumber(x) && Ext.isNumber(floatParentBox.left)) {
        x -= floatParentBox.left;
      }
      if (Ext.isNumber(y) && Ext.isNumber(floatParentBox.top)) {
        y -= floatParentBox.top;
      }
    } else {
      p = me.el.translateXY(x, y);
      x = p.x;
      y = p.y;
    }
    me.setPosition(x, y, animate);
  } else {
    p = me.el.translateXY(x, y);
    me.setPosition(p.x, p.y, animate);
  }
  return me;
}, isContainedFloater:function() {
  return this.floating && this.floatParent;
}, updateBox:function(box) {
  this.setSize(box.width, box.height);
  this.setPagePosition(box.x, box.y);
  return this;
}, getOuterSize:function() {
  var el = this.el;
  return {width:el.getWidth() + el.getMargin('lr'), height:el.getHeight() + el.getMargin('tb')};
}, adjustPosition:function(x, y) {
  var me = this, floatParentBox;
  if (me.isContainedFloater()) {
    floatParentBox = me.floatParent.getTargetEl().getViewRegion();
    x += floatParentBox.left;
    y += floatParentBox.top;
  }
  return {x:x, y:y};
}, getPosition:function(local) {
  var me = this, xy, isContainedFloater = me.isContainedFloater(), floatParentBox;
  if (local === true && !isContainedFloater) {
    return [me.getLocalX(), me.getLocalY()];
  }
  xy = me.getXY();
  if (local === true && isContainedFloater) {
    floatParentBox = me.floatParent.getTargetEl().getViewRegion();
    xy[0] -= floatParentBox.left;
    xy[1] -= floatParentBox.top;
  }
  return xy;
}, getId:function() {
  var me = this, xtype;
  if (!me.id) {
    xtype = me.getXType();
    if (xtype) {
      xtype = xtype.replace(Ext.Component.INVALID_ID_CHARS_Re, '-');
    } else {
      xtype = Ext.name.toLowerCase() + '-comp';
    }
    me.id = xtype + '-' + me.getAutoId();
  }
  return me.id;
}, show:function(animateTarget, cb, scope) {
  var me = this, rendered = me.rendered;
  if (me.hierarchicallyHidden || me.floating && !rendered && me.isHierarchicallyHidden()) {
    if (!rendered) {
      me.initHierarchyEvents();
    }
    if (arguments.length > 1) {
      arguments[0] = null;
      me.pendingShow = arguments;
    } else {
      me.pendingShow = true;
    }
  } else {
    if (rendered && me.isVisible()) {
      if (me.toFrontOnShow && me.floating) {
        me.toFront();
      }
    } else {
      if (me.fireEvent('beforeshow', me) !== false) {
        me.hidden = false;
        delete this.getHierarchyState().hidden;
        Ext.suspendLayouts();
        if (!rendered && (me.autoRender || me.floating)) {
          me.doAutoRender();
          rendered = me.rendered;
        }
        if (rendered) {
          me.beforeShow();
          Ext.resumeLayouts();
          me.onShow.apply(me, arguments);
          me.afterShow.apply(me, arguments);
        } else {
          Ext.resumeLayouts(true);
        }
      } else {
        me.onShowVeto();
      }
    }
  }
  return me;
}, onShowVeto:Ext.emptyFn, beforeShow:Ext.emptyFn, onShow:function() {
  var me = this;
  me.el.show();
  me.callParent(arguments);
  if (me.floating) {
    if (me.maximized) {
      me.fitContainer();
    } else {
      if (me.constrain) {
        me.doConstrain();
      }
    }
  }
}, getAnimateTarget:function(target) {
  target = target || this.animateTarget;
  if (target) {
    target = target.isComponent ? target.getEl() : Ext.get(target);
  }
  return target || null;
}, afterShow:function(animateTarget, cb, scope) {
  var me = this, myEl = me.el, fromBox, toBox, ghostPanel;
  animateTarget = me.getAnimateTarget(animateTarget);
  if (!me.ghost) {
    animateTarget = null;
  }
  if (animateTarget) {
    toBox = {x:myEl.getX(), y:myEl.getY(), width:myEl.dom.offsetWidth, height:myEl.dom.offsetHeight};
    fromBox = {x:animateTarget.getX(), y:animateTarget.getY(), width:animateTarget.dom.offsetWidth, height:animateTarget.dom.offsetHeight};
    myEl.addCls(me.offsetsCls);
    ghostPanel = me.ghost();
    ghostPanel.el.stopAnimation();
    ghostPanel.setX(-10000);
    me.ghostBox = toBox;
    ghostPanel.el.animate({from:fromBox, to:toBox, listeners:{afteranimate:function() {
      delete ghostPanel.componentLayout.lastComponentSize;
      me.unghost();
      delete me.ghostBox;
      myEl.removeCls(me.offsetsCls);
      me.onShowComplete(cb, scope);
    }}});
  } else {
    me.onShowComplete(cb, scope);
  }
  me.fireHierarchyEvent('show');
}, onShowComplete:function(cb, scope) {
  var me = this;
  if (me.floating) {
    me.toFront();
    me.onFloatShow();
  }
  Ext.callback(cb, scope || me);
  me.fireEvent('show', me);
  delete me.hiddenByLayout;
}, hide:function(animateTarget, cb, scope) {
  var me = this, continueHide;
  if (me.pendingShow) {
    delete me.pendingShow;
  }
  if (!(me.rendered && !me.isVisible())) {
    continueHide = me.fireEvent('beforehide', me) !== false;
    if (me.hierarchicallyHidden || continueHide) {
      me.hidden = true;
      me.getHierarchyState().hidden = true;
      if (me.rendered) {
        me.onHide.apply(me, arguments);
      }
    }
  }
  return me;
}, onHide:function(animateTarget, cb, scope) {
  var me = this, ghostPanel, fromSize, toBox;
  animateTarget = me.getAnimateTarget(animateTarget);
  if (!me.ghost) {
    animateTarget = null;
  }
  if (animateTarget) {
    toBox = {x:animateTarget.getX(), y:animateTarget.getY(), width:animateTarget.dom.offsetWidth, height:animateTarget.dom.offsetHeight};
    ghostPanel = me.ghost();
    ghostPanel.el.stopAnimation();
    fromSize = me.getSize();
    ghostPanel.el.animate({to:toBox, listeners:{afteranimate:function() {
      delete ghostPanel.componentLayout.lastComponentSize;
      ghostPanel.el.hide();
      ghostPanel.el.setSize(fromSize);
      me.afterHide(cb, scope);
    }}});
  }
  me.el.hide();
  if (!animateTarget) {
    me.afterHide(cb, scope);
  }
}, afterHide:function(cb, scope) {
  var me = this, activeEl = Ext.Element.getActiveElement();
  me.hiddenByLayout = null;
  Ext.AbstractComponent.prototype.onHide.call(me);
  if (activeEl === me.el || me.el.contains(activeEl)) {
    Ext.fly(activeEl).blur();
  }
  Ext.callback(cb, scope || me);
  me.fireEvent('hide', me);
  me.fireHierarchyEvent('hide');
}, onDestroy:function() {
  var me = this;
  if (me.rendered) {
    Ext.destroy(me.dd, me.resizer, me.proxy, me.proxyWrap, me.resizerComponent);
  }
  delete me.focusTask;
  me.callParent();
}, deleteMembers:function() {
  var args = arguments, len = args.length, i = 0;
  for (; i < len; ++i) {
    delete this[args[i]];
  }
}, focus:function(selectText, delay, callback, scope) {
  var me = this, focusEl, focusElDom, containerScrollTop;
  if (delay) {
    if (!me.focusTask) {
      Ext.Component.prototype.focusTask = new Ext.util.DelayedTask(me.focus);
    }
    me.focusTask.delay(Ext.isNumber(delay) ? delay : 10, null, me, [selectText, false, callback, scope]);
    return me;
  }
  if (me.focusTask) {
    me.focusTask.cancel();
  }
  if (me.rendered && !me.isDestroyed && me.isVisible(true) && (focusEl = me.getFocusEl())) {
    if (focusEl.isComponent) {
      return focusEl.focus(selectText, delay);
    }
    if (focusElDom = focusEl.dom) {
      if (focusEl.needsTabIndex()) {
        focusElDom.tabIndex = -1;
      }
      if (me.floating) {
        containerScrollTop = me.container.dom.scrollTop;
      }
      focusEl.focus();
      if (selectText === true) {
        focusElDom.select();
      }
      Ext.callback(callback, scope);
    }
    if (me.floating) {
      me.toFront(true);
      if (containerScrollTop !== undefined) {
        me.container.dom.scrollTop = containerScrollTop;
      }
    }
  }
  return me;
}, cancelFocus:function() {
  var task = this.focusTask;
  if (task) {
    task.cancel();
  }
}, blur:function() {
  var focusEl;
  if (this.rendered && (focusEl = this.getFocusEl())) {
    focusEl.blur();
  }
  return this;
}, getEl:function() {
  return this.el;
}, getResizeEl:function() {
  return this.el;
}, getPositionEl:function() {
  return this.el;
}, getActionEl:function() {
  return this.el;
}, getVisibilityEl:function() {
  return this.el;
}, getRefOwner:function() {
  return this.ownerCt || this.floatParent;
}, getBubbleTarget:function() {
  return this.getRefOwner();
}, getContentTarget:function() {
  return this.el;
}, cloneConfig:function(overrides) {
  overrides = overrides || {};
  var id = overrides.id || Ext.id(), cfg = Ext.applyIf(overrides, this.initialConfig), self;
  cfg.id = id;
  self = Ext.getClass(this);
  return new self(cfg);
}, getXType:function() {
  return this.self.xtype;
}, findParentBy:function(fn) {
  var p;
  for (p = this.getBubbleTarget(); p && !fn(p, this); p = p.getBubbleTarget()) {
  }
  return p || null;
}, findParentByType:function(xtype) {
  return Ext.isFunction(xtype) ? this.findParentBy(function(p) {
    return p.constructor === xtype;
  }) : this.up(xtype);
}, bubble:function(fn, scope, args) {
  var p = this;
  while (p) {
    if (fn.apply(scope || p, args || [p]) === false) {
      break;
    }
    p = p.getBubbleTarget();
  }
  return this;
}, getProxy:function() {
  var me = this, target;
  if (!me.proxy) {
    target = Ext.getBody();
    me.proxy = me.el.createProxy(Ext.baseCSSPrefix + 'proxy-el', target, true);
  }
  return me.proxy;
}, fireHierarchyEvent:function(ename) {
  this.hierarchyEventSource.fireEvent(ename, this);
}, onAdded:function() {
  this.callParent(arguments);
  if (this.hierarchyEventSource.hasListeners.added) {
    this.fireHierarchyEvent('added');
  }
}}, function() {
  this.hierarchyEventSource = this.prototype.hierarchyEventSource = new Ext.util.Observable({events:{hide:true, show:true, collapse:true, expand:true, added:true}});
});
Ext.define('Ext.layout.container.border.Region', {override:'Ext.Component', initBorderRegion:function() {
  var me = this;
  if (!me._borderRegionInited) {
    me._borderRegionInited = true;
    me.addStateEvents(['changeregion', 'changeweight']);
    Ext.override(me, {getState:function() {
      var state = me.callParent();
      state = me.addPropertyToState(state, 'region');
      state = me.addPropertyToState(state, 'weight');
      return state;
    }});
  }
}, getOwningBorderContainer:function() {
  var layout = this.getOwningBorderLayout();
  return layout && layout.owner;
}, getOwningBorderLayout:function() {
  var layout = this.ownerLayout;
  return layout && layout.isBorderLayout ? layout : null;
}, setBorderRegion:function(region) {
  var me = this, borderLayout, old = me.region;
  if (region !== old) {
    borderLayout = me.getOwningBorderLayout();
    if (borderLayout) {
      var regionFlags = borderLayout.regionFlags[region], placeholder = me.placeholder, splitter = me.splitter, owner = borderLayout.owner, regionMeta = borderLayout.regionMeta, collapsed = me.collapsed || me.floated, delta, items, index;
      if (me.fireEventArgs('beforechangeregion', [me, region]) === false) {
        return old;
      }
      Ext.suspendLayouts();
      me.region = region;
      Ext.apply(me, regionFlags);
      if (me.updateCollapseTool) {
        me.updateCollapseTool();
      }
      if (splitter) {
        Ext.apply(splitter, regionFlags);
        splitter.updateOrientation();
        items = owner.items;
        index = items.indexOf(me);
        if (index >= 0) {
          delta = regionMeta[region].splitterDelta;
          if (items.getAt(index + delta) !== splitter) {
            items.remove(splitter);
            index = items.indexOf(me);
            if (delta > 0) {
              ++index;
            }
            items.insert(index, splitter);
          }
        }
      }
      if (placeholder) {
        if (collapsed) {
          me.expand(false);
        }
        owner.remove(placeholder);
        me.placeholder = null;
        if (collapsed) {
          me.collapse(null, false);
        }
      }
      owner.updateLayout();
      Ext.resumeLayouts(true);
      me.fireEventArgs('changeregion', [me, old]);
    } else {
      me.region = region;
    }
  }
  return old;
}, setRegionWeight:function(weight) {
  var me = this, ownerCt = me.getOwningBorderContainer(), placeholder = me.placeholder, old = me.weight;
  if (weight !== old) {
    if (me.fireEventArgs('beforechangeweight', [me, weight]) !== false) {
      me.weight = weight;
      if (placeholder) {
        placeholder.weight = weight;
      }
      if (ownerCt) {
        ownerCt.updateLayout();
      }
      me.fireEventArgs('changeweight', [me, old]);
    }
  }
  return old;
}});
Ext.define('Ext.ElementLoader', {mixins:{observable:Ext.util.Observable}, statics:{Renderer:{Html:function(loader, response, active) {
  loader.getTarget().update(response.responseText, active.scripts === true);
  return true;
}}}, url:null, params:null, baseParams:null, autoLoad:false, target:null, loadMask:false, ajaxOptions:null, scripts:false, isLoader:true, constructor:function(config) {
  var me = this, autoLoad;
  config = config || {};
  Ext.apply(me, config);
  me.setTarget(me.target);
  me.addEvents('beforeload', 'exception', 'load');
  me.mixins.observable.constructor.call(me);
  if (me.autoLoad) {
    autoLoad = me.autoLoad;
    if (autoLoad === true) {
      autoLoad = {};
    }
    me.load(autoLoad);
  }
}, setTarget:function(target) {
  var me = this;
  target = Ext.get(target);
  if (me.target && me.target != target) {
    me.abort();
  }
  me.target = target;
}, getTarget:function() {
  return this.target || null;
}, abort:function() {
  var active = this.active;
  if (active !== undefined) {
    Ext.Ajax.abort(active.request);
    if (active.mask) {
      this.removeMask();
    }
    delete this.active;
  }
}, removeMask:function() {
  this.target.unmask();
}, addMask:function(mask) {
  this.target.mask(mask === true ? null : mask);
}, load:function(options) {
  if (!this.target) {
    Ext.Error.raise('A valid target is required when loading content');
  }
  options = Ext.apply({}, options);
  var me = this, mask = Ext.isDefined(options.loadMask) ? options.loadMask : me.loadMask, params = Ext.apply({}, options.params), ajaxOptions = Ext.apply({}, options.ajaxOptions), callback = options.callback || me.callback, scope = options.scope || me.scope || me;
  Ext.applyIf(ajaxOptions, me.ajaxOptions);
  Ext.applyIf(options, ajaxOptions);
  Ext.applyIf(params, me.params);
  Ext.apply(params, me.baseParams);
  Ext.applyIf(options, {url:me.url});
  if (!options.url) {
    Ext.Error.raise('You must specify the URL from which content should be loaded');
  }
  Ext.apply(options, {scope:me, params:params, callback:me.onComplete});
  if (me.fireEvent('beforeload', me, options) === false) {
    return;
  }
  if (mask) {
    me.addMask(mask);
  }
  me.active = {options:options, mask:mask, scope:scope, callback:callback, success:options.success || me.success, failure:options.failure || me.failure, renderer:options.renderer || me.renderer, scripts:Ext.isDefined(options.scripts) ? options.scripts : me.scripts};
  me.active.request = Ext.Ajax.request(options);
  me.setOptions(me.active, options);
}, setOptions:Ext.emptyFn, onComplete:function(options, success, response) {
  var me = this, active = me.active, scope;
  if (active) {
    scope = active.scope;
    if (success) {
      success = me.getRenderer(active.renderer).call(me, me, response, active) !== false;
    }
    if (success) {
      Ext.callback(active.success, scope, [me, response, options]);
      me.fireEvent('load', me, response, options);
    } else {
      Ext.callback(active.failure, scope, [me, response, options]);
      me.fireEvent('exception', me, response, options);
    }
    Ext.callback(active.callback, scope, [me, success, response, options]);
    if (active.mask) {
      me.removeMask();
    }
  }
  delete me.active;
}, getRenderer:function(renderer) {
  if (Ext.isFunction(renderer)) {
    return renderer;
  }
  return this.statics().Renderer.Html;
}, startAutoRefresh:function(interval, options) {
  var me = this;
  me.stopAutoRefresh();
  me.autoRefresh = setInterval(function() {
    me.load(options);
  }, interval);
}, stopAutoRefresh:function() {
  clearInterval(this.autoRefresh);
  delete this.autoRefresh;
}, isAutoRefreshing:function() {
  return Ext.isDefined(this.autoRefresh);
}, destroy:function() {
  var me = this;
  me.stopAutoRefresh();
  delete me.target;
  me.abort();
  me.clearListeners();
}});
Ext.define('Ext.ComponentLoader', {extend:Ext.ElementLoader, statics:{Renderer:{Data:function(loader, response, active) {
  var success = true;
  try {
    loader.getTarget().update(Ext.decode(response.responseText));
  } catch (e$25) {
    success = false;
  }
  return success;
}, Component:function(loader, response, active) {
  var success = true, target = loader.getTarget(), items = [];
  if (!target.isContainer) {
    Ext.Error.raise({target:target, msg:'Components can only be loaded into a container'});
  }
  try {
    items = Ext.decode(response.responseText);
  } catch (e$26) {
    success = false;
  }
  if (success) {
    target.suspendLayouts();
    if (active.removeAll) {
      target.removeAll();
    }
    target.add(items);
    target.resumeLayouts(true);
  }
  return success;
}}}, target:null, loadMask:false, renderer:'html', setTarget:function(target) {
  var me = this;
  if (Ext.isString(target)) {
    target = Ext.getCmp(target);
  }
  if (me.target && me.target != target) {
    me.abort();
  }
  me.target = target;
}, removeMask:function() {
  this.target.setLoading(false);
}, addMask:function(mask) {
  this.target.setLoading(mask);
}, setOptions:function(active, options) {
  active.removeAll = Ext.isDefined(options.removeAll) ? options.removeAll : this.removeAll;
}, getRenderer:function(renderer) {
  if (Ext.isFunction(renderer)) {
    return renderer;
  }
  var renderers = this.statics().Renderer;
  switch(renderer) {
    case 'component':
      return renderers.Component;
    case 'data':
      return renderers.Data;
    default:
      return Ext.ElementLoader.Renderer.Html;
  }
}});
Ext.define('Ext.layout.SizeModel', {constructor:function(config) {
  var me = this, SizeModel = me.self, sizeModelsArray = SizeModel.sizeModelsArray, name;
  Ext.apply(me, config);
  me[name = me.name] = true;
  me.fixed = !(me.auto = me.natural || me.shrinkWrap);
  sizeModelsArray[me.ordinal = sizeModelsArray.length] = SizeModel[name] = SizeModel.sizeModels[name] = me;
}, statics:{sizeModelsArray:[], sizeModels:{}}, calculated:false, configured:false, constrainedMax:false, constrainedMin:false, natural:false, shrinkWrap:false, calculatedFromConfigured:false, calculatedFromNatural:false, calculatedFromShrinkWrap:false, names:null}, function() {
  var SizeModel = this, sizeModelsArray = SizeModel.sizeModelsArray, i, j, n, pairs, sizeModel;
  new SizeModel({name:'calculated'});
  new SizeModel({name:'configured', names:{width:'width', height:'height'}});
  new SizeModel({name:'natural'});
  new SizeModel({name:'shrinkWrap'});
  new SizeModel({name:'calculatedFromConfigured', configured:true, names:{width:'width', height:'height'}});
  new SizeModel({name:'calculatedFromNatural', natural:true});
  new SizeModel({name:'calculatedFromShrinkWrap', shrinkWrap:true});
  new SizeModel({name:'constrainedMax', configured:true, constrained:true, names:{width:'maxWidth', height:'maxHeight'}});
  new SizeModel({name:'constrainedMin', configured:true, constrained:true, names:{width:'minWidth', height:'minHeight'}});
  new SizeModel({name:'constrainedDock', configured:true, constrained:true, constrainedByMin:true, names:{width:'dockConstrainedWidth', height:'dockConstrainedHeight'}});
  for (i = 0, n = sizeModelsArray.length; i < n; ++i) {
    sizeModel = sizeModelsArray[i];
    sizeModel.pairsByHeightOrdinal = pairs = [];
    for (j = 0; j < n; ++j) {
      pairs.push({width:sizeModel, height:sizeModelsArray[j]});
    }
  }
});
Ext.define('Ext.layout.Layout', {isLayout:true, initialized:false, running:false, autoSizePolicy:{readsWidth:1, readsHeight:1, setsWidth:0, setsHeight:0}, statics:{layoutsByType:{}, create:function(layout, defaultType) {
  var ClassManager = Ext.ClassManager, layoutsByType = this.layoutsByType, alias, className, config, layoutClass, type, load;
  if (!layout || typeof layout === 'string') {
    type = layout || defaultType;
    config = {};
  } else {
    if (layout.isLayout) {
      return layout;
    } else {
      config = layout;
      type = layout.type || defaultType;
    }
  }
  if (!(layoutClass = layoutsByType[type])) {
    alias = 'layout.' + type;
    className = ClassManager.getNameByAlias(alias);
    if (!className) {
      load = true;
    }
    layoutClass = ClassManager.get(className);
    if (load || !layoutClass) {
      return ClassManager.instantiateByAlias(alias, config || {});
    }
    layoutsByType[type] = layoutClass;
  }
  return new layoutClass(config);
}}, constructor:function(config) {
  var me = this;
  me.id = Ext.id(null, me.type + '-');
  Ext.apply(me, config);
  me.layoutCount = 0;
}, beginLayout:Ext.emptyFn, beginLayoutCycle:function(ownerContext) {
  var me = this, context = me.context, changed;
  if (me.lastWidthModel != ownerContext.widthModel) {
    if (me.lastWidthModel) {
      changed = true;
    }
    me.lastWidthModel = ownerContext.widthModel;
  }
  if (me.lastHeightModel != ownerContext.heightModel) {
    if (me.lastWidthModel) {
      changed = true;
    }
    me.lastHeightModel = ownerContext.heightModel;
  }
  if (changed) {
    (context = ownerContext.context).clearTriggers(me, false);
    context.clearTriggers(me, true);
    me.triggerCount = 0;
  }
}, finishedLayout:function(ownerContext) {
  this.lastWidthModel = ownerContext.widthModel;
  this.lastHeightModel = ownerContext.heightModel;
  this.ownerContext = null;
}, redoLayout:Ext.emptyFn, undoLayout:Ext.emptyFn, getAnimatePolicy:function() {
  return this.animatePolicy;
}, getItemSizePolicy:function(item) {
  return this.autoSizePolicy;
}, isItemBoxParent:function(itemContext) {
  return false;
}, isItemLayoutRoot:function(item) {
  var sizeModel = item.getSizeModel(), width = sizeModel.width, height = sizeModel.height;
  if (!item.componentLayout.lastComponentSize && (width.calculated || height.calculated)) {
    return false;
  }
  return !width.shrinkWrap && !height.shrinkWrap;
}, isItemShrinkWrap:function(item) {
  return item.shrinkWrap;
}, isRunning:function() {
  return !!this.ownerContext;
}, getItemsRenderTree:function(items, renderCfgs) {
  var length = items.length, i, item, itemConfig, result;
  if (length) {
    result = [];
    for (i = 0; i < length; ++i) {
      item = items[i];
      if (!item.rendered) {
        if (renderCfgs && renderCfgs[item.id] !== undefined) {
          itemConfig = renderCfgs[item.id];
        } else {
          this.configureItem(item);
          itemConfig = item.getRenderTree();
          if (renderCfgs) {
            renderCfgs[item.id] = itemConfig;
          }
        }
        if (itemConfig) {
          result.push(itemConfig);
        }
      }
    }
  }
  return result;
}, finishRender:Ext.emptyFn, finishRenderItems:function(target, items) {
  var length = items.length, i, item;
  for (i = 0; i < length; i++) {
    item = items[i];
    if (item.rendering) {
      item.finishRender(i);
      this.afterRenderItem(item);
    }
  }
}, renderChildren:function() {
  var me = this, items = me.getLayoutItems(), target = me.getRenderTarget();
  me.renderItems(items, target);
}, renderItems:function(items, target) {
  var me = this, ln = items.length, i = 0, item;
  if (ln) {
    Ext.suspendLayouts();
    for (; i < ln; i++) {
      item = items[i];
      if (item && !item.rendered) {
        me.renderItem(item, target, i);
      } else {
        if (!me.isValidParent(item, target, i)) {
          me.moveItem(item, target, i);
        } else {
          me.configureItem(item);
        }
      }
    }
    Ext.resumeLayouts(true);
  }
}, isValidParent:function(item, target, position) {
  var itemDom = item.el ? item.el.dom : Ext.getDom(item), targetDom = target && target.dom || target, parentNode = itemDom.parentNode, className;
  if (parentNode) {
    className = parentNode.className;
    if (className && className.indexOf(Ext.baseCSSPrefix + 'resizable-wrap') !== -1) {
      itemDom = itemDom.parentNode;
    }
  }
  if (itemDom && targetDom) {
    if (typeof position == 'number') {
      position = this.getPositionOffset(position);
      return itemDom === targetDom.childNodes[position];
    }
    return itemDom.parentNode === targetDom;
  }
  return false;
}, getPositionOffset:function(position) {
  return position;
}, configureItem:function(item) {
  item.ownerLayout = this;
}, renderItem:function(item, target, position) {
  var me = this;
  if (!item.rendered) {
    me.configureItem(item);
    item.render(target, position);
    me.afterRenderItem(item);
  }
}, moveItem:function(item, target, position) {
  target = target.dom || target;
  if (typeof position == 'number') {
    position = target.childNodes[position];
  }
  target.insertBefore(item.el.dom, position || null);
  item.container = Ext.get(target);
  this.configureItem(item);
}, onContentChange:function() {
  this.owner.updateLayout();
  return true;
}, initLayout:function() {
  this.initialized = true;
}, setOwner:function(owner) {
  this.owner = owner;
}, getLayoutItems:function() {
  return [];
}, onAdd:function(item) {
  item.ownerLayout = this;
}, afterRenderItem:Ext.emptyFn, onRemove:Ext.emptyFn, onDestroy:Ext.emptyFn, afterRemove:function(item) {
  var me = this, el = item.el, owner = me.owner, removeClasses;
  if (item.rendered) {
    removeClasses = [].concat(me.itemCls || []);
    if (owner.itemCls) {
      removeClasses = Ext.Array.push(removeClasses, owner.itemCls);
    }
    if (removeClasses.length) {
      el.removeCls(removeClasses);
    }
  }
  delete item.ownerLayout;
}, destroy:function() {
  var me = this, target;
  if (me.targetCls) {
    target = me.getTarget();
    if (target) {
      target.removeCls(me.targetCls);
    }
  }
  me.onDestroy();
}, sortWeightedItems:function(items, reverseProp) {
  for (var i = 0, length = items.length; i < length; ++i) {
    items[i].$i = i;
  }
  Ext.Array.sort(items, function(item1, item2) {
    var ret = item2.weight - item1.weight;
    if (!ret) {
      ret = item1.$i - item2.$i;
      if (item1[reverseProp]) {
        ret = -ret;
      }
    }
    return ret;
  });
  for (i = 0; i < length; ++i) {
    delete items[i].$i;
  }
}}, function() {
  var Layout = this;
  Layout.prototype.sizeModels = Layout.sizeModels = Ext.layout.SizeModel.sizeModels;
});
Ext.define('Ext.layout.container.Container', {alias:['layout.container'], extend:Ext.layout.Layout, alternateClassName:'Ext.layout.ContainerLayout', mixins:{elementCt:Ext.util.ElementContainer}, type:'container', beginCollapse:Ext.emptyFn, beginExpand:Ext.emptyFn, animatePolicy:null, childEls:['overflowPadderEl'], renderTpl:['{%this.renderBody(out,values)%}'], usesContainerHeight:true, usesContainerWidth:true, usesHeight:true, usesWidth:true, constructor:function() {
  this.callParent(arguments);
  this.mixins.elementCt.constructor.call(this);
}, destroy:function() {
  this.callParent();
  this.mixins.elementCt.destroy.call(this);
}, beginLayout:function(ownerContext) {
  this.callParent(arguments);
  ownerContext.targetContext = ownerContext.paddingContext = ownerContext.getEl('getTarget', this);
  this.cacheChildItems(ownerContext);
}, beginLayoutCycle:function(ownerContext, firstCycle) {
  var me = this;
  me.callParent(arguments);
  if (firstCycle) {
    if (me.usesContainerHeight) {
      ++ownerContext.consumersContainerHeight;
    }
    if (me.usesContainerWidth) {
      ++ownerContext.consumersContainerWidth;
    }
  }
}, cacheChildItems:function(ownerContext) {
  var context = ownerContext.context, childItems = [], items = this.getVisibleItems(), length = items.length, i;
  ownerContext.childItems = childItems;
  ownerContext.visibleItems = items;
  for (i = 0; i < length; ++i) {
    childItems.push(context.getCmp(items[i]));
  }
}, cacheElements:function() {
  var owner = this.owner;
  this.applyChildEls(owner.el, owner.id);
}, configureItem:function(item) {
  var me = this, itemCls = me.itemCls, ownerItemCls = me.owner.itemCls, addClasses;
  item.ownerLayout = me;
  if (itemCls) {
    addClasses = typeof itemCls === 'string' ? [itemCls] : itemCls;
  }
  if (ownerItemCls) {
    addClasses = Ext.Array.push(addClasses || [], ownerItemCls);
  }
  if (addClasses) {
    item.addCls(addClasses);
  }
}, doRenderBody:function(out, renderData) {
  this.renderItems(out, renderData);
  this.renderContent(out, renderData);
}, doRenderContainer:function(out, renderData) {
  var me = renderData.$comp.layout, tpl = me.getRenderTpl(), data = me.getRenderData();
  tpl.applyOut(data, out);
}, doRenderItems:function(out, renderData) {
  var me = renderData.$layout, tree = me.getRenderTree();
  if (tree) {
    Ext.DomHelper.generateMarkup(tree, out);
  }
}, finishRender:function() {
  var me = this, target, items;
  me.callParent();
  me.cacheElements();
  target = me.getRenderTarget();
  items = me.getLayoutItems();
  if (me.targetCls && !me.getTarget().hasCls(me.targetCls)) {
    Ext.log.warn('targetCls is missing. This may mean that getTargetEl() is being overridden but not applyTargetCls(). ' + me.owner.id);
  }
  me.finishRenderItems(target, items);
}, notifyOwner:function() {
  this.owner.afterLayout(this);
}, getContainerSize:function(ownerContext, inDom) {
  var targetContext = ownerContext.targetContext, frameInfo = targetContext.getFrameInfo(), padding = ownerContext.paddingContext.getPaddingInfo(), got = 0, needed = 0, gotWidth, gotHeight, width, height;
  if (!ownerContext.widthModel.shrinkWrap) {
    ++needed;
    width = inDom ? targetContext.getDomProp('width') : targetContext.getProp('width');
    gotWidth = typeof width == 'number';
    if (gotWidth) {
      ++got;
      width -= frameInfo.width + padding.width;
      if (width < 0) {
        width = 0;
      }
    }
  }
  if (!ownerContext.heightModel.shrinkWrap) {
    ++needed;
    height = inDom ? targetContext.getDomProp('height') : targetContext.getProp('height');
    gotHeight = typeof height == 'number';
    if (gotHeight) {
      ++got;
      height -= frameInfo.height + padding.height;
      if (height < 0) {
        height = 0;
      }
    }
  }
  return {width:width, height:height, needed:needed, got:got, gotAll:got == needed, gotWidth:gotWidth, gotHeight:gotHeight};
}, getPositionOffset:function(position) {
  if (!this.createsInnerCt) {
    var offset = this.owner.itemNodeOffset;
    if (offset) {
      position += offset;
    }
  }
  return position;
}, getLayoutItems:function() {
  var owner = this.owner, items = owner && owner.items;
  return items && items.items || [];
}, getRenderData:function() {
  var comp = this.owner;
  return {$comp:comp, $layout:this, ownerId:comp.id};
}, getRenderedItems:function() {
  var me = this, target = me.getRenderTarget(), items = me.getLayoutItems(), ln = items.length, renderedItems = [], i, item;
  for (i = 0; i < ln; i++) {
    item = items[i];
    if (item.rendered && me.isValidParent(item, target, i)) {
      renderedItems.push(item);
    }
  }
  return renderedItems;
}, getRenderTarget:function() {
  return this.owner.getTargetEl();
}, getElementTarget:function() {
  return this.getRenderTarget();
}, getRenderTpl:function() {
  var me = this, renderTpl = Ext.XTemplate.getTpl(this, 'renderTpl');
  if (!renderTpl.renderContent) {
    me.owner.setupRenderTpl(renderTpl);
  }
  return renderTpl;
}, getRenderTree:function() {
  var result, items = this.owner.items, itemsGen, renderCfgs = {};
  do {
    itemsGen = items.generation;
    result = this.getItemsRenderTree(this.getLayoutItems(), renderCfgs);
  } while (items.generation !== itemsGen);
  return result;
}, renderChildren:function() {
  var me = this, ownerItems = me.owner.items, target = me.getRenderTarget(), itemsGen, items;
  do {
    itemsGen = ownerItems.generation;
    items = me.getLayoutItems();
    me.renderItems(items, target);
  } while (ownerItems.generation !== itemsGen);
}, getScrollbarsNeeded:function(width, height, contentWidth, contentHeight) {
  var scrollbarSize = Ext.getScrollbarSize(), hasWidth = typeof width == 'number', hasHeight = typeof height == 'number', needHorz = 0, needVert = 0;
  if (!scrollbarSize.width) {
    return 0;
  }
  if (hasHeight && height < contentHeight) {
    needVert = 2;
    width -= scrollbarSize.width;
  }
  if (hasWidth && width < contentWidth) {
    needHorz = 1;
    if (!needVert && hasHeight) {
      height -= scrollbarSize.height;
      if (height < contentHeight) {
        needVert = 2;
      }
    }
  }
  return needVert + needHorz;
}, getTarget:function() {
  return this.owner.getTargetEl();
}, getVisibleItems:function() {
  var target = this.getRenderTarget(), items = this.getLayoutItems(), ln = items.length, visibleItems = [], i, item;
  for (i = 0; i < ln; i++) {
    item = items[i];
    if (item.rendered && this.isValidParent(item, target, i) && item.hidden !== true) {
      visibleItems.push(item);
    }
  }
  return visibleItems;
}, setupRenderTpl:function(renderTpl) {
  var me = this;
  renderTpl.renderBody = me.doRenderBody;
  renderTpl.renderContainer = me.doRenderContainer;
  renderTpl.renderItems = me.doRenderItems;
}, getContentTarget:function() {
  return this.owner.getDefaultContentTarget();
}});
Ext.define('Ext.layout.container.Auto', {alias:['layout.auto', 'layout.autocontainer'], extend:Ext.layout.container.Container, type:'autocontainer', childEls:['outerCt', 'innerCt', 'clearEl'], reserveScrollbar:false, managePadding:true, manageOverflow:false, lastOverflowAdjust:{width:0, height:0}, renderTpl:['{% if (!(Ext.isIEQuirks || Ext.isIE7m)) { %}', '\x3cspan id\x3d"{ownerId}-outerCt" style\x3d"display:table;"\x3e', '\x3cdiv id\x3d"{ownerId}-innerCt" style\x3d"display:table-cell;height:100%;', 
'vertical-align:top;{%this.renderPadding(out, values)%}" class\x3d"{innerCtCls}"\x3e', '{%this.renderBody(out,values)%}', '\x3c/div\x3e', '\x3c/span\x3e', '{% } else if (values.shrinkWrapWidth) { %}', '\x3ctable id\x3d"{ownerId}-outerCt" class\x3d"' + Ext.plainTableCls + '"\x3e', '\x3ctr\x3e', '\x3ctd id\x3d"{ownerId}-innerCt" style\x3d"vertical-align:top;padding:0;', '{%this.renderPadding(out, values)%}" class\x3d"{innerCtCls}"\x3e', '{%this.renderBody(out,values)%}', '\x3cdiv id\x3d"{ownerId}-clearEl" class\x3d"', 
Ext.baseCSSPrefix, 'clear"', 'role\x3d"presentation"\x3e\x3c/div\x3e', '\x3c/td\x3e', '\x3c/tr\x3e', '\x3c/table\x3e', '{% } else { %}', '\x3cdiv id\x3d"{ownerId}-outerCt" style\x3d"zoom:1;{%this.renderPadding(out, values)%}"\x3e', '\x3cdiv id\x3d"{ownerId}-innerCt" style\x3d"zoom:1;height:100%;" class\x3d"{innerCtCls}"\x3e', '{%this.renderBody(out,values)%}', '\x3cdiv id\x3d"{ownerId}-clearEl" class\x3d"', Ext.baseCSSPrefix, 'clear"', 'role\x3d"presentation"\x3e\x3c/div\x3e', '\x3c/div\x3e', '\x3c/div\x3e', 
'{% values.$layout.isShrinkWrapTpl \x3d false %}', '{% } %}'], tableTpl:['\x3ctable id\x3d"{ownerId}-outerCt" class\x3d"' + Ext.plainTableCls + '"\x3e', '\x3ctr\x3e', '\x3ctd id\x3d"{ownerId}-innerCt" style\x3d"vertical-align:top;padding:0;', '{%this.renderPadding(out, values)%}" class\x3d"{innerCtCls}"\x3e', '\x3c/td\x3e', '\x3c/tr\x3e', '\x3c/table\x3e'], isShrinkWrapTpl:true, beginLayout:function(ownerContext) {
  var me = this, bottomPadding, overflowYStyle, overflowXStyle, needsTable;
  me.callParent(arguments);
  me.initContextItems(ownerContext);
  if (!me.isShrinkWrapTpl) {
    if (ownerContext.widthModel.shrinkWrap) {
      needsTable = true;
    }
    if (Ext.isStrict && Ext.isIE7) {
      overflowXStyle = me.getOverflowXStyle(ownerContext);
      if ((overflowXStyle === 'auto' || overflowXStyle === 'scroll') && ownerContext.paddingContext.getPaddingInfo().right) {
        needsTable = true;
      }
    }
    if (needsTable) {
      me.insertTableCt(ownerContext);
    }
  }
  if (!me.isShrinkWrapTpl && Ext.isIE7 && Ext.isStrict && !me.clearElHasPadding) {
    bottomPadding = ownerContext.paddingContext.getPaddingInfo().bottom;
    overflowYStyle = me.getOverflowYStyle(ownerContext);
    if (bottomPadding && (overflowYStyle === 'auto' || overflowYStyle === 'scroll')) {
      me.clearEl.setStyle('height', bottomPadding);
      me.clearElHasPadding = true;
    }
  }
}, beforeLayoutCycle:function(ownerContext) {
  var comp = this.owner, hierarchyState = comp.hierarchyState, hierarchyStateInner = comp.hierarchyStateInner;
  if (!hierarchyState || hierarchyState.invalid) {
    hierarchyState = comp.getHierarchyState();
    hierarchyStateInner = comp.hierarchyStateInner;
  }
  if (ownerContext.widthModel.shrinkWrap && this.isShrinkWrapTpl) {
    hierarchyStateInner.inShrinkWrapTable = true;
  } else {
    delete hierarchyStateInner.inShrinkWrapTable;
  }
}, beginLayoutCycle:function(ownerContext) {
  var me = this, outerCt = me.outerCt, lastOuterCtWidth = me.lastOuterCtWidth || '', lastOuterCtHeight = me.lastOuterCtHeight || '', lastOuterCtTableLayout = me.lastOuterCtTableLayout || '', state = ownerContext.state, overflowXStyle, overflowYStyle, outerCtWidth, outerCtHeight, outerCtTableLayout, deferWidth, hierarchyStateInner;
  me.callParent(arguments);
  outerCtWidth = outerCtHeight = outerCtTableLayout = '';
  if (!ownerContext.widthModel.shrinkWrap && me.isShrinkWrapTpl) {
    if (Ext.isIE7m && Ext.isStrict) {
      overflowYStyle = me.getOverflowYStyle(ownerContext);
      if (overflowYStyle === 'auto' || overflowYStyle === 'scroll') {
        deferWidth = true;
      }
    }
    if (!deferWidth) {
      outerCtWidth = '100%';
    }
    hierarchyStateInner = me.owner.hierarchyStateInner;
    overflowXStyle = me.getOverflowXStyle(ownerContext);
    outerCtTableLayout = hierarchyStateInner.inShrinkWrapTable || overflowXStyle === 'auto' || overflowXStyle === 'scroll' ? '' : 'fixed';
  }
  if (!ownerContext.heightModel.shrinkWrap && !Ext.supports.PercentageHeightOverflowBug) {
    outerCtHeight = '100%';
  }
  if (outerCtWidth !== lastOuterCtWidth || me.hasOuterCtPxWidth) {
    outerCt.setStyle('width', outerCtWidth);
    me.lastOuterCtWidth = outerCtWidth;
    me.hasOuterCtPxWidth = false;
  }
  if (outerCtTableLayout !== lastOuterCtTableLayout) {
    outerCt.setStyle('table-layout', outerCtTableLayout);
    me.lastOuterCtTableLayout = outerCtTableLayout;
  }
  if (outerCtHeight !== lastOuterCtHeight || me.hasOuterCtPxHeight) {
    outerCt.setStyle('height', outerCtHeight);
    me.lastOuterCtHeight = outerCtHeight;
    me.hasOuterCtPxHeight = false;
  }
  if (me.hasInnerCtPxHeight) {
    me.innerCt.setStyle('height', '');
    me.hasInnerCtPxHeight = false;
  }
  state.overflowAdjust = state.overflowAdjust || me.lastOverflowAdjust;
}, calculate:function(ownerContext) {
  var me = this, state = ownerContext.state, containerSize = me.getContainerSize(ownerContext, true), calculatedItems = state.calculatedItems || (state.calculatedItems = me.calculateItems ? me.calculateItems(ownerContext, containerSize) : true);
  me.setCtSizeIfNeeded(ownerContext, containerSize);
  if (calculatedItems && ownerContext.hasDomProp('containerChildrenSizeDone')) {
    me.calculateContentSize(ownerContext);
    if (containerSize.gotAll) {
      if (me.manageOverflow && !ownerContext.state.secondPass && !me.reserveScrollbar) {
        me.calculateOverflow(ownerContext, containerSize);
      }
      return;
    }
  }
  me.done = false;
}, calculateContentSize:function(ownerContext) {
  var me = this, containerDimensions = (ownerContext.widthModel.shrinkWrap ? 1 : 0) | (ownerContext.heightModel.shrinkWrap ? 2 : 0), calcWidth = containerDimensions & 1 || undefined, calcHeight = containerDimensions & 2 || undefined, needed = 0, props = ownerContext.props;
  if (calcWidth) {
    if (isNaN(props.contentWidth)) {
      ++needed;
    } else {
      calcWidth = undefined;
    }
  }
  if (calcHeight) {
    if (isNaN(props.contentHeight)) {
      ++needed;
    } else {
      calcHeight = undefined;
    }
  }
  if (needed) {
    if (calcWidth && !ownerContext.setContentWidth(me.measureContentWidth(ownerContext))) {
      me.done = false;
    }
    if (calcHeight && !ownerContext.setContentHeight(me.measureContentHeight(ownerContext))) {
      me.done = false;
    }
  }
}, calculateOverflow:function(ownerContext) {
  var me = this, width, height, scrollbarSize, scrollbars, xauto, yauto, targetEl;
  xauto = me.getOverflowXStyle(ownerContext) === 'auto';
  yauto = me.getOverflowYStyle(ownerContext) === 'auto';
  if (xauto || yauto) {
    scrollbarSize = Ext.getScrollbarSize();
    targetEl = ownerContext.overflowContext.el.dom;
    scrollbars = 0;
    if (targetEl.scrollWidth > targetEl.clientWidth) {
      scrollbars |= 1;
    }
    if (targetEl.scrollHeight > targetEl.clientHeight) {
      scrollbars |= 2;
    }
    width = yauto && scrollbars & 2 ? scrollbarSize.width : 0;
    height = xauto && scrollbars & 1 ? scrollbarSize.height : 0;
    if (width !== me.lastOverflowAdjust.width || height !== me.lastOverflowAdjust.height) {
      me.done = false;
      ownerContext.invalidate({state:{overflowAdjust:{width:width, height:height}, overflowState:scrollbars, secondPass:true}});
    }
  }
}, completeLayout:function(ownerContext) {
  this.lastOverflowAdjust = ownerContext.state.overflowAdjust;
}, doRenderPadding:function(out, renderData) {
  var me = renderData.$layout, owner = renderData.$layout.owner, padding = owner[owner.contentPaddingProperty];
  if (me.managePadding && padding) {
    out.push('padding:', owner.unitizeBox(padding));
  }
}, finishedLayout:function(ownerContext) {
  var innerCt = this.innerCt;
  this.callParent(arguments);
  if (Ext.isIEQuirks || Ext.isIE8m) {
    innerCt.repaint();
  }
  if (Ext.isOpera) {
    innerCt.setStyle('position', 'relative');
    innerCt.dom.scrollWidth;
    innerCt.setStyle('position', '');
  }
}, getContainerSize:function(ownerContext, inDom) {
  var size = this.callParent(arguments), overflowAdjust = ownerContext.state.overflowAdjust;
  if (overflowAdjust) {
    size.width -= overflowAdjust.width;
    size.height -= overflowAdjust.height;
  }
  return size;
}, getRenderData:function() {
  var owner = this.owner, data = this.callParent();
  if ((Ext.isIEQuirks || Ext.isIE7m) && (owner.shrinkWrap & 1 || owner.floating && !owner.width)) {
    data.shrinkWrapWidth = true;
  }
  return data;
}, getRenderTarget:function() {
  return this.innerCt;
}, getElementTarget:function() {
  return this.innerCt;
}, getOverflowXStyle:function(ownerContext) {
  return ownerContext.overflowXStyle || (ownerContext.overflowXStyle = this.owner.scrollFlags.overflowX || ownerContext.overflowContext.getStyle('overflow-x'));
}, getOverflowYStyle:function(ownerContext) {
  return ownerContext.overflowYStyle || (ownerContext.overflowYStyle = this.owner.scrollFlags.overflowY || ownerContext.overflowContext.getStyle('overflow-y'));
}, initContextItems:function(ownerContext) {
  var me = this, target = ownerContext.target, customOverflowEl = me.owner.customOverflowEl;
  ownerContext.outerCtContext = ownerContext.getEl('outerCt', me);
  ownerContext.innerCtContext = ownerContext.getEl('innerCt', me);
  if (customOverflowEl) {
    ownerContext.overflowContext = ownerContext.getEl(customOverflowEl);
  } else {
    ownerContext.overflowContext = ownerContext.targetContext;
  }
  if (target[target.contentPaddingProperty] !== undefined) {
    ownerContext.paddingContext = me.isShrinkWrapTpl ? ownerContext.innerCtContext : ownerContext.outerCtContext;
  }
}, initLayout:function() {
  var me = this, scrollbarWidth = Ext.getScrollbarSize().width, owner = me.owner;
  me.callParent();
  if (scrollbarWidth && me.manageOverflow && !me.hasOwnProperty('lastOverflowAdjust')) {
    if (owner.autoScroll || me.reserveScrollbar) {
      me.lastOverflowAdjust = {width:scrollbarWidth, height:0};
    }
  }
}, insertTableCt:function(ownerContext) {
  var me = this, owner = me.owner, i = 0, renderTpl, fragment, childNodes, childLength, targetEl;
  renderTpl = Ext.XTemplate.getTpl(this, 'tableTpl');
  renderTpl.renderPadding = me.doRenderPadding;
  me.outerCt.dom.removeChild(me.innerCt.dom);
  fragment = document.createDocumentFragment();
  childNodes = me.innerCt.dom.childNodes;
  childLength = childNodes.length;
  for (; i < childLength; i++) {
    fragment.appendChild(childNodes[0]);
  }
  targetEl = me.getTarget();
  targetEl.dom.innerHTML = renderTpl.apply({$layout:me, ownerId:me.owner.id});
  targetEl.down('td').dom.appendChild(fragment);
  me.applyChildEls(owner.el, owner.id);
  me.isShrinkWrapTpl = true;
  ownerContext.removeEl(me.outerCt);
  ownerContext.removeEl(me.innerCt);
  me.initContextItems(ownerContext);
}, measureContentHeight:function(ownerContext) {
  var contentHeight = this.outerCt.getHeight(), target = ownerContext.target;
  if (this.managePadding && target[target.contentPaddingProperty] === undefined) {
    contentHeight += ownerContext.targetContext.getPaddingInfo().height;
  }
  return contentHeight;
}, measureContentWidth:function(ownerContext) {
  var dom, style, old, contentWidth, target;
  if (this.chromeCellMeasureBug) {
    dom = this.innerCt.dom;
    style = dom.style;
    old = style.display;
    if (old == 'table-cell') {
      style.display = '';
      dom.offsetWidth;
      style.display = old;
    }
  }
  contentWidth = this.outerCt.getWidth();
  target = ownerContext.target;
  if (this.managePadding && target[target.contentPaddingProperty] === undefined) {
    contentWidth += ownerContext.targetContext.getPaddingInfo().width;
  }
  return contentWidth;
}, setCtSizeIfNeeded:function(ownerContext, containerSize) {
  var me = this, width = containerSize.width, height = containerSize.height, padding = ownerContext.paddingContext.getPaddingInfo(), targetEl = me.getTarget(), overflowXStyle = me.getOverflowXStyle(ownerContext), overflowYStyle = me.getOverflowYStyle(ownerContext), canOverflowX = overflowXStyle === 'auto' || overflowXStyle === 'scroll', canOverflowY = overflowYStyle === 'auto' || overflowYStyle === 'scroll', scrollbarSize = Ext.getScrollbarSize(), isShrinkWrapTpl = me.isShrinkWrapTpl, manageOverflow = 
  me.manageOverflow, overflowStyleName, needsOuterHeight, needsInnerHeight, needsInnerCtPaddingHeight;
  if (width && !ownerContext.widthModel.shrinkWrap && (Ext.isIE7m && Ext.isStrict && isShrinkWrapTpl && canOverflowY || Ext.isIEQuirks && !isShrinkWrapTpl && !canOverflowX)) {
    if (!manageOverflow) {
      if (canOverflowY && targetEl.dom.scrollHeight > targetEl.dom.clientHeight) {
        width -= scrollbarSize.width;
      }
    }
    ownerContext.outerCtContext.setProp('width', width + padding.width);
    me.hasOuterCtPxWidth = true;
  }
  if (height && !ownerContext.heightModel.shrinkWrap) {
    if (Ext.supports.PercentageHeightOverflowBug) {
      needsOuterHeight = true;
    }
    if (Ext.isIE8 && Ext.isStrict || Ext.isIE7m && Ext.isStrict && isShrinkWrapTpl) {
      needsInnerHeight = true;
      needsInnerCtPaddingHeight = !Ext.isIE8;
    }
    if ((needsOuterHeight || needsInnerHeight) && canOverflowX && targetEl.dom.scrollWidth > targetEl.dom.clientWidth) {
      height = Math.max(height - scrollbarSize.height, 0);
    }
    if (needsOuterHeight) {
      ownerContext.outerCtContext.setProp('height', height + padding.height);
      me.hasOuterCtPxHeight = true;
    }
    if (needsInnerHeight) {
      if (needsInnerCtPaddingHeight) {
        height += padding.height;
      }
      ownerContext.innerCtContext.setProp('height', height);
      me.hasInnerCtPxHeight = true;
    }
  }
  if (Ext.isIE7 && Ext.isStrict && !isShrinkWrapTpl && overflowYStyle === 'auto') {
    overflowStyleName = overflowXStyle === 'auto' ? 'overflow-x' : 'overflow-y';
    targetEl.setStyle(overflowStyleName, 'hidden');
    targetEl.setStyle(overflowStyleName, 'auto');
  }
}, setupRenderTpl:function(renderTpl) {
  this.callParent(arguments);
  renderTpl.renderPadding = this.doRenderPadding;
}, getContentTarget:function() {
  return this.innerCt;
}}, function() {
  this.prototype.chromeCellMeasureBug = Ext.isChrome && Ext.chromeVersion >= 26;
});
Ext.define('Ext.ZIndexManager', {alternateClassName:'Ext.WindowGroup', statics:{zBase:9000}, constructor:function(container) {
  var me = this;
  me.list = {};
  me.zIndexStack = [];
  me.front = null;
  if (container) {
    if (container.isContainer) {
      container.on('resize', me._onContainerResize, me);
      me.zseed = Ext.Number.from(me.rendered ? container.getEl().getStyle('zIndex') : undefined, me.getNextZSeed());
      me.targetEl = container.getTargetEl();
      me.container = container;
    } else {
      Ext.EventManager.onWindowResize(me._onContainerResize, me);
      me.zseed = me.getNextZSeed();
      me.targetEl = Ext.get(container);
    }
  } else {
    Ext.EventManager.onWindowResize(me._onContainerResize, me);
    me.zseed = me.getNextZSeed();
    Ext.onDocumentReady(function() {
      me.targetEl = Ext.getBody();
    });
  }
}, getNextZSeed:function() {
  return Ext.ZIndexManager.zBase += 10000;
}, setBase:function(baseZIndex) {
  this.zseed = baseZIndex;
  var result = this.assignZIndices();
  this._activateLast();
  return result;
}, assignZIndices:function() {
  var a = this.zIndexStack, len = a.length, i = 0, zIndex = this.zseed, comp, topModal;
  for (; i < len; i++) {
    comp = a[i];
    if (comp && !comp.hidden) {
      zIndex = comp.setZIndex(zIndex);
      if (comp.modal) {
        topModal = comp;
      }
    }
  }
  if (topModal) {
    this._showModalMask(topModal);
  }
  return zIndex;
}, _setActiveChild:function(comp, oldFront) {
  var front = this.front, oldPreventFocus = comp.preventFocusOnActivate;
  if (comp !== front) {
    if (front && !front.destroying) {
      front.setActive(false, comp);
    }
    this.front = comp;
    if (comp && comp != oldFront) {
      comp.preventFocusOnActivate = comp.preventFocusOnActivate || oldFront && (oldFront.preventFocusOnActivate || !oldFront.focusOnToFront);
      comp.setActive(true);
      if (comp.modal) {
        this._showModalMask(comp);
      }
      comp.preventFocusOnActivate = oldPreventFocus;
    }
  }
}, onComponentHide:function(comp) {
  this._activateLast();
}, _activateLast:function() {
  var me = this, stack = me.zIndexStack, i = stack.length - 1, comp;
  for (; i >= 0 && stack[i].hidden; --i) {
  }
  if (comp = stack[i]) {
    me._setActiveChild(comp, me.front);
    if (comp.modal) {
      return;
    }
  } else {
    if (me.front && !me.front.destroying) {
      me.front.setActive(false);
    }
    me.front = null;
  }
  for (; i >= 0; --i) {
    comp = stack[i];
    if (comp.isVisible() && comp.modal) {
      me._showModalMask(comp);
      return;
    }
  }
  me._hideModalMask();
}, _showModalMask:function(comp) {
  var me = this, zIndex = comp.el.getStyle('zIndex') - 4, maskTarget = comp.floatParent ? comp.floatParent.getTargetEl() : comp.container, mask = me.mask, shim = me.maskShim, viewSize;
  if (!mask) {
    if (Ext.isIE6) {
      shim = me.maskShim = Ext.getBody().createChild({tag:'iframe', cls:Ext.baseCSSPrefix + 'shim ' + Ext.baseCSSPrefix + 'mask-shim'});
      shim.setVisibilityMode(Ext.Element.DISPLAY);
    }
    mask = me.mask = Ext.getBody().createChild({cls:Ext.baseCSSPrefix + 'mask', style:'height:0;width:0'});
    mask.setVisibilityMode(Ext.Element.DISPLAY);
    mask.on('click', me._onMaskClick, me);
  }
  mask.maskTarget = maskTarget;
  viewSize = me.getMaskBox();
  if (shim) {
    shim.setStyle('zIndex', zIndex);
    shim.show();
    shim.setBox(viewSize);
  }
  mask.setStyle('zIndex', zIndex);
  mask.show();
  mask.setBox(viewSize);
}, _hideModalMask:function() {
  var mask = this.mask, maskShim = this.maskShim;
  if (mask && mask.isVisible()) {
    mask.maskTarget = undefined;
    mask.hide();
    if (maskShim) {
      maskShim.hide();
    }
  }
}, _onMaskClick:function() {
  if (this.front) {
    this.front.focus();
  }
}, getMaskBox:function() {
  var maskTarget = this.mask.maskTarget;
  if (maskTarget.dom === document.body) {
    return {height:Math.max(document.body.scrollHeight, Ext.dom.Element.getDocumentHeight()), width:Math.max(document.body.scrollWidth, document.documentElement.clientWidth), x:0, y:0};
  } else {
    return maskTarget.getBox();
  }
}, _onContainerResize:function() {
  var me = this, mask = me.mask, maskShim = me.maskShim, viewSize;
  if (mask && mask.isVisible()) {
    mask.hide();
    if (maskShim) {
      maskShim.hide();
    }
    viewSize = me.getMaskBox();
    if (maskShim) {
      maskShim.setSize(viewSize);
      maskShim.show();
    }
    mask.setSize(viewSize);
    mask.show();
  }
}, register:function(comp) {
  var me = this, compAfterHide = comp.afterHide;
  if (comp.zIndexManager) {
    comp.zIndexManager.unregister(comp);
  }
  comp.zIndexManager = me;
  me.list[comp.id] = comp;
  me.zIndexStack.push(comp);
  comp.afterHide = function() {
    compAfterHide.apply(comp, arguments);
    me.onComponentHide(comp);
  };
}, unregister:function(comp) {
  var me = this, list = me.list;
  delete comp.zIndexManager;
  if (list && list[comp.id]) {
    delete list[comp.id];
    delete comp.afterHide;
    Ext.Array.remove(me.zIndexStack, comp);
    me._activateLast();
  }
}, get:function(id) {
  return id.isComponent ? id : this.list[id];
}, bringToFront:function(comp, preventFocus) {
  var me = this, result = false, zIndexStack = me.zIndexStack;
  comp = me.get(comp);
  if (comp !== me.front) {
    Ext.Array.remove(zIndexStack, comp);
    if (comp.preventBringToFront) {
      zIndexStack.unshift(comp);
    } else {
      zIndexStack.push(comp);
    }
    me.assignZIndices();
    if (!preventFocus) {
      me._activateLast();
    }
    result = true;
    me.front = comp;
    if (comp.modal) {
      me._showModalMask(comp);
    }
  }
  return result;
}, sendToBack:function(comp) {
  var me = this;
  comp = me.get(comp);
  Ext.Array.remove(me.zIndexStack, comp);
  me.zIndexStack.unshift(comp);
  me.assignZIndices();
  this._activateLast();
  return comp;
}, hideAll:function() {
  var list = this.list, item, id;
  for (id in list) {
    if (list.hasOwnProperty(id)) {
      item = list[id];
      if (item.isComponent && item.isVisible()) {
        item.hide();
      }
    }
  }
}, hide:function() {
  var i = 0, stack = this.zIndexStack, len = stack.length, comp;
  this.tempHidden = [];
  for (; i < len; i++) {
    comp = stack[i];
    if (comp.isVisible()) {
      this.tempHidden.push(comp);
      comp.el.hide();
      comp.hidden = true;
    }
  }
}, show:function() {
  var i = 0, tempHidden = this.tempHidden, len = tempHidden ? tempHidden.length : 0, comp;
  for (; i < len; i++) {
    comp = tempHidden[i];
    comp.el.show();
    comp.hidden = false;
    comp.setPosition(comp.x, comp.y);
  }
  delete this.tempHidden;
}, getActive:function() {
  return this.front;
}, getBy:function(fn, scope) {
  var r = [], i = 0, stack = this.zIndexStack, len = stack.length, comp;
  for (; i < len; i++) {
    comp = stack[i];
    if (fn.call(scope || comp, comp) !== false) {
      r.push(comp);
    }
  }
  return r;
}, each:function(fn, scope) {
  var list = this.list, id, comp;
  for (id in list) {
    if (list.hasOwnProperty(id)) {
      comp = list[id];
      if (comp.isComponent && fn.call(scope || comp, comp) === false) {
        return;
      }
    }
  }
}, eachBottomUp:function(fn, scope) {
  var stack = this.zIndexStack, i = 0, len = stack.length, comp;
  for (; i < len; i++) {
    comp = stack[i];
    if (comp.isComponent && fn.call(scope || comp, comp) === false) {
      return;
    }
  }
}, eachTopDown:function(fn, scope) {
  var stack = this.zIndexStack, i = stack.length, comp;
  for (; i-- > 0;) {
    comp = stack[i];
    if (comp.isComponent && fn.call(scope || comp, comp) === false) {
      return;
    }
  }
}, destroy:function() {
  var me = this, list = me.list, comp, id;
  for (id in list) {
    if (list.hasOwnProperty(id)) {
      comp = list[id];
      if (comp.isComponent) {
        comp.destroy();
      }
    }
  }
  delete me.zIndexStack;
  delete me.list;
  delete me.container;
  delete me.targetEl;
}}, function() {
  Ext.WindowManager = Ext.WindowMgr = new this;
});
Ext.define('Ext.Queryable', {isQueryable:true, query:function(selector) {
  selector = selector || '*';
  return Ext.ComponentQuery.query(selector, this);
}, queryBy:function(fn, scope) {
  var out = [], items = this.getRefItems(true), i = 0, len = items.length, item;
  for (; i < len; ++i) {
    item = items[i];
    if (fn.call(scope || item, item) !== false) {
      out.push(item);
    }
  }
  return out;
}, queryById:function(id) {
  return this.down('#' + id);
}, child:function(selector) {
  if (selector && selector.isComponent) {
    selector = '#' + Ext.escapeId(selector.getItemId());
  }
  selector = selector || '';
  return this.query('\x3e ' + selector)[0] || null;
}, down:function(selector) {
  if (selector && selector.isComponent) {
    selector = '#' + Ext.escapeId(selector.getItemId());
  }
  selector = selector || '';
  return this.query(selector)[0] || null;
}, getRefItems:function() {
  return [];
}});
Ext.define('Ext.container.AbstractContainer', {extend:Ext.Component, mixins:{queryable:Ext.Queryable}, renderTpl:'{%this.renderContainer(out,values)%}', suspendLayout:false, autoDestroy:true, defaultType:'panel', detachOnRemove:true, isContainer:true, layoutCounter:0, baseCls:Ext.baseCSSPrefix + 'container', defaultLayoutType:'auto', initComponent:function() {
  var me = this;
  me.addEvents('afterlayout', 'beforeadd', 'beforeremove', 'add', 'remove');
  me.callParent();
  me.getLayout();
  me.initItems();
}, initItems:function() {
  var me = this, items = me.items;
  me.items = new Ext.util.AbstractMixedCollection(false, me.getComponentId);
  me.floatingItems = new Ext.util.MixedCollection(false, me.getComponentId);
  if (items) {
    if (!Ext.isArray(items)) {
      items = [items];
    }
    me.add(items);
  }
}, getFocusEl:function() {
  return this.getTargetEl();
}, finishRenderChildren:function() {
  this.callParent();
  var layout = this.getLayout();
  if (layout) {
    layout.finishRender();
  }
}, beforeRender:function() {
  var me = this, layout = me.getLayout(), targetCls;
  me.callParent();
  if (!layout.initialized) {
    layout.initLayout();
  }
  targetCls = layout.targetCls;
  if (targetCls) {
    me.applyTargetCls(targetCls);
  }
}, applyTargetCls:function(targetCls) {
  this.addCls(targetCls);
}, afterComponentLayout:function() {
  var floaters = this.floatingItems.items, floaterCount = floaters.length, i, floater;
  this.callParent(arguments);
  for (i = 0; i < floaterCount; i++) {
    floater = floaters[i];
    if (!floater.rendered && floater.autoShow) {
      floater.show();
    }
  }
}, onPosition:function() {
  this.callParent(arguments);
  this.repositionFloatingItems();
}, onResize:function() {
  this.callParent(arguments);
  this.repositionFloatingItems();
}, repositionFloatingItems:function() {
  var floaters = this.floatingItems.items, floaterCount = floaters.length, i, floater;
  for (i = 0; i < floaterCount; i++) {
    floater = floaters[i];
    if (floater.el && !floater.hidden) {
      floater.setPosition(floater.x, floater.y);
    }
  }
}, setupRenderTpl:function(renderTpl) {
  this.callParent(arguments);
  this.getLayout().setupRenderTpl(renderTpl);
}, getDefaultContentTarget:function() {
  return this.el;
}, getContentTarget:function() {
  return this.getLayout().getContentTarget();
}, setLayout:function(layout) {
  var currentLayout = this.layout;
  if (currentLayout && currentLayout.isLayout && currentLayout != layout) {
    currentLayout.setOwner(null);
  }
  this.layout = layout;
  layout.setOwner(this);
}, getLayout:function() {
  var me = this;
  if (!me.layout || !me.layout.isLayout) {
    me.setLayout(Ext.layout.Layout.create(me.layout, me.self.prototype.layout || me.defaultLayoutType));
  }
  return me.layout;
}, doLayout:function() {
  this.updateLayout();
  return this;
}, afterLayout:function(layout) {
  var me = this;
  ++me.layoutCounter;
  if (me.hasListeners.afterlayout) {
    me.fireEvent('afterlayout', me, layout);
  }
}, prepareItems:function(items, applyDefaults) {
  if (Ext.isArray(items)) {
    items = items.slice();
  } else {
    items = [items];
  }
  var me = this, i = 0, len = items.length, item;
  for (; i < len; i++) {
    item = items[i];
    if (item == null) {
      Ext.Array.erase(items, i, 1);
      --i;
      --len;
    } else {
      if (applyDefaults) {
        item = this.applyDefaults(item);
      }
      item.isContained = me;
      items[i] = me.lookupComponent(item);
      delete item.isContained;
      delete items[i].isContained;
    }
  }
  return items;
}, applyDefaults:function(config) {
  var defaults = this.defaults;
  if (defaults) {
    if (Ext.isFunction(defaults)) {
      defaults = defaults.call(this, config);
    }
    if (Ext.isString(config)) {
      config = Ext.ComponentManager.get(config);
    }
    Ext.applyIf(config, defaults);
  }
  return config;
}, lookupComponent:function(comp) {
  return typeof comp == 'string' ? Ext.ComponentManager.get(comp) : Ext.ComponentManager.create(comp, this.defaultType);
}, getComponentId:function(comp) {
  return comp.getItemId && comp.getItemId();
}, add:function() {
  var me = this, args = Ext.Array.slice(arguments), index = typeof args[0] == 'number' ? args.shift() : -1, layout = me.getLayout(), addingArray, items, i, length, item, pos, ret;
  if (args.length == 1 && Ext.isArray(args[0])) {
    items = args[0];
    addingArray = true;
  } else {
    items = args;
  }
  if (me.rendered) {
    Ext.suspendLayouts();
  }
  ret = items = me.prepareItems(items, true);
  length = items.length;
  if (!addingArray && length == 1) {
    ret = items[0];
  }
  for (i = 0; i < length; i++) {
    item = items[i];
    if (!item) {
      Ext.Error.raise('Cannot add null item to Container with itemId/id: ' + me.getItemId());
    }
    pos = index < 0 ? me.items.length : index + i;
    if (item.floating) {
      me.floatingItems.add(item);
      item.onAdded(me, pos);
      if (me.hasListeners.add) {
        me.fireEvent('add', me, item, pos);
      }
    } else {
      if ((!me.hasListeners.beforeadd || me.fireEvent('beforeadd', me, item, pos) !== false) && me.onBeforeAdd(item) !== false) {
        me.items.insert(pos, item);
        item.onAdded(me, pos);
        me.onAdd(item, pos);
        layout.onAdd(item, pos);
        if (me.hasListeners.add) {
          me.fireEvent('add', me, item, pos);
        }
      }
    }
  }
  me.updateLayout();
  if (me.rendered) {
    Ext.resumeLayouts(true);
  }
  return ret;
}, onAdd:Ext.emptyFn, onRemove:Ext.emptyFn, insert:function(index, comp) {
  var compIdx;
  if (comp && comp.isComponent) {
    compIdx = this.items.indexOf(comp);
    if (compIdx !== -1) {
      return this.move(compIdx, index);
    }
  }
  return this.add(index, comp);
}, move:function(fromIdx, toIdx) {
  var items = this.items, item;
  if (fromIdx.isComponent) {
    fromIdx = items.indexOf(fromIdx);
  }
  item = items.removeAt(fromIdx);
  if (item === false) {
    return false;
  }
  items.insert(toIdx, item);
  this.onMove(item, fromIdx, toIdx);
  this.updateLayout();
  return item;
}, onMove:Ext.emptyFn, onBeforeAdd:function(item) {
  if (item.ownerCt && item.ownerCt !== this) {
    item.ownerCt.remove(item, false);
  }
}, remove:function(comp, autoDestroy) {
  var me = this, c = me.getComponent(comp);
  if (Ext.isDefined(Ext.global.console) && !c) {
    Ext.global.console.warn('Attempted to remove a component that does not exist. Ext.container.Container: remove takes an argument of the component to remove. cmp.remove() is incorrect usage.');
  }
  if (c && (!me.hasListeners.beforeremove || me.fireEvent('beforeremove', me, c) !== false)) {
    me.doRemove(c, autoDestroy);
    if (me.hasListeners.remove) {
      me.fireEvent('remove', me, c);
    }
    if (!me.destroying && !c.floating) {
      me.updateLayout();
    }
  }
  return c;
}, doRemove:function(component, doDestroy) {
  doDestroy = doDestroy === true || doDestroy !== false && this.autoDestroy;
  var me = this, layout = me.layout, hasLayout = layout && me.rendered, isDestroying = component.destroying || doDestroy, floating = component.floating;
  if (floating) {
    me.floatingItems.remove(component);
  } else {
    me.items.remove(component);
  }
  if (hasLayout && !floating) {
    if (layout.running) {
      Ext.AbstractComponent.cancelLayout(component, isDestroying);
    }
    layout.onRemove(component, isDestroying);
  }
  component.onRemoved(isDestroying);
  me.onRemove(component, isDestroying);
  if (doDestroy) {
    component.destroy();
  } else {
    if (hasLayout && !floating) {
      layout.afterRemove(component);
    }
    if (me.detachOnRemove && component.rendered) {
      me.detachComponent(component);
    }
  }
}, detachComponent:function(component) {
  Ext.getDetachedBody().appendChild(component.getEl());
}, removeAll:function(autoDestroy) {
  var me = this, removeItems = me.items.items.slice().concat(me.floatingItems.items), items = [], i = 0, len = removeItems.length, item;
  me.suspendLayouts();
  for (; i < len; i++) {
    item = removeItems[i];
    me.remove(item, autoDestroy);
    if (item.ownerCt !== me) {
      items.push(item);
    }
  }
  me.resumeLayouts(!!len);
  return items;
}, getRefItems:function(deep) {
  var me = this, items = me.items.items, len = items.length, i = 0, item, result = [];
  for (; i < len; i++) {
    item = items[i];
    result[result.length] = item;
    if (deep && item.getRefItems) {
      result.push.apply(result, item.getRefItems(true));
    }
  }
  items = me.floatingItems.items;
  len = items.length;
  for (i = 0; i < len; i++) {
    item = items[i];
    result[result.length] = item;
    if (deep && item.getRefItems) {
      result.push.apply(result, item.getRefItems(true));
    }
  }
  return result;
}, cascade:function(fn, scope, origArgs) {
  var me = this, cs = me.items ? me.items.items : [], len = cs.length, i = 0, c, args = origArgs ? origArgs.concat(me) : [me], componentIndex = args.length - 1;
  if (fn.apply(scope || me, args) !== false) {
    for (; i < len; i++) {
      c = cs[i];
      if (c.cascade) {
        c.cascade(fn, scope, origArgs);
      } else {
        args[componentIndex] = c;
        fn.apply(scope || cs, args);
      }
    }
  }
  return this;
}, isAncestor:function(possibleDescendant) {
  while (possibleDescendant) {
    if (possibleDescendant.ownerCt === this) {
      return true;
    }
    possibleDescendant = possibleDescendant.ownerCt;
  }
}, getComponent:function(comp) {
  if (Ext.isObject(comp)) {
    comp = comp.getItemId();
  }
  var c = this.items.get(comp);
  if (!c && typeof comp != 'number') {
    c = this.floatingItems.get(comp);
  }
  return c;
}, contains:function(comp, deep) {
  var result = false;
  if (deep) {
    this.cascade(function(c) {
      if (c.contains && c.contains(comp)) {
        result = true;
        return false;
      }
    });
    return result;
  } else {
    return this.items.contains(comp) || this.floatingItems.contains(comp);
  }
}, nextChild:function(child, selector) {
  var me = this, result, childIndex = me.items.indexOf(child);
  if (childIndex !== -1) {
    result = selector ? Ext.ComponentQuery(selector, me.items.items.slice(childIndex + 1)) : me.items.getAt(childIndex + 1);
    if (!result && me.ownerCt) {
      result = me.ownerCt.nextChild(me, selector);
    }
  }
  return result;
}, prevChild:function(child, selector) {
  var me = this, result, childIndex = me.items.indexOf(child);
  if (childIndex !== -1) {
    result = selector ? Ext.ComponentQuery(selector, me.items.items.slice(childIndex + 1)) : me.items.getAt(childIndex + 1);
    if (!result && me.ownerCt) {
      result = me.ownerCt.nextChild(me, selector);
    }
  }
  return result;
}, enable:function() {
  this.callParent(arguments);
  var itemsToDisable = this.getChildItemsToDisable(), length = itemsToDisable.length, item, i;
  for (i = 0; i < length; i++) {
    item = itemsToDisable[i];
    if (item.resetDisable) {
      item.enable();
    }
  }
  return this;
}, disable:function() {
  this.callParent(arguments);
  var itemsToDisable = this.getChildItemsToDisable(), length = itemsToDisable.length, item, i;
  for (i = 0; i < length; i++) {
    item = itemsToDisable[i];
    if (item.resetDisable !== false && !item.disabled) {
      item.disable();
      item.resetDisable = true;
    }
  }
  return this;
}, getChildItemsToDisable:function() {
  return this.query('[isFormField],button');
}, beforeDestroy:function() {
  var me = this, items = me.items, floatingItems = me.floatingItems, c;
  if (items) {
    while (c = items.first()) {
      me.doRemove(c, true);
    }
  }
  if (floatingItems) {
    while (c = floatingItems.first()) {
      me.doRemove(c, true);
    }
  }
  Ext.destroy(me.layout);
  me.callParent();
}});
Ext.define('Ext.container.Container', {extend:Ext.container.AbstractContainer, alias:'widget.container', alternateClassName:'Ext.Container', getChildByElement:function(el, deep) {
  var item, itemEl, i = 0, it = this.getRefItems(), ln = it.length;
  el = Ext.getDom(el);
  for (; i < ln; i++) {
    item = it[i];
    itemEl = item.getEl();
    if (itemEl && (itemEl.dom === el || itemEl.contains(el))) {
      return deep && item.getChildByElement ? item.getChildByElement(el, deep) : item;
    }
  }
  return null;
}});
Ext.define('Ext.util.KeyMap', {alternateClassName:'Ext.KeyMap', eventName:'keydown', constructor:function(config) {
  var me = this;
  if (arguments.length !== 1 || typeof config === 'string' || config.dom || config.tagName || config === document || config.isComponent) {
    me.legacyConstructor.apply(me, arguments);
    return;
  }
  Ext.apply(me, config);
  me.bindings = [];
  if (!me.target.isComponent) {
    me.target = Ext.get(me.target);
  }
  if (me.binding) {
    me.addBinding(me.binding);
  } else {
    if (config.key) {
      me.addBinding(config);
    }
  }
  me.enable();
}, legacyConstructor:function(el, binding, eventName) {
  var me = this;
  Ext.apply(me, {target:Ext.get(el), eventName:eventName || me.eventName, bindings:[]});
  if (binding) {
    me.addBinding(binding);
  }
  me.enable();
}, addBinding:function(binding) {
  var me = this, keyCode = binding.key, i, len;
  if (me.processing) {
    me.bindings = bindings.slice(0);
  }
  if (Ext.isArray(binding)) {
    for (i = 0, len = binding.length; i < len; i++) {
      me.addBinding(binding[i]);
    }
    return;
  }
  me.bindings.push(Ext.apply({keyCode:me.processKeys(keyCode)}, binding));
}, removeBinding:function(binding) {
  var me = this, bindings = me.bindings, len = bindings.length, i, item, keys;
  if (me.processing) {
    me.bindings = bindings.slice(0);
  }
  keys = me.processKeys(binding.key);
  for (i = 0; i < len; ++i) {
    item = bindings[i];
    if (item.fn === binding.fn && item.scope === binding.scope) {
      if (binding.alt == item.alt && binding.crtl == item.crtl && binding.shift == item.shift) {
        if (Ext.Array.equals(item.keyCode, keys)) {
          Ext.Array.erase(me.bindings, i, 1);
          return;
        }
      }
    }
  }
}, processKeys:function(keyCode) {
  var processed = false, key, keys, keyString, len, i;
  if (Ext.isString(keyCode)) {
    keys = [];
    keyString = keyCode.toUpperCase();
    for (i = 0, len = keyString.length; i < len; ++i) {
      keys.push(keyString.charCodeAt(i));
    }
    keyCode = keys;
    processed = true;
  }
  if (!Ext.isArray(keyCode)) {
    keyCode = [keyCode];
  }
  if (!processed) {
    for (i = 0, len = keyCode.length; i < len; ++i) {
      key = keyCode[i];
      if (Ext.isString(key)) {
        keyCode[i] = key.toUpperCase().charCodeAt(0);
      }
    }
  }
  return keyCode;
}, handleTargetEvent:function() {
  var tagRe = /input|textarea/i;
  return function(event) {
    var me = this, bindings, i, len, target, contentEditable;
    if (me.enabled) {
      bindings = me.bindings;
      i = 0;
      len = bindings.length;
      event = me.processEvent.apply(me || me.processEventScope, arguments);
      if (me.ignoreInputFields) {
        target = event.target;
        contentEditable = target.contentEditable;
        if (tagRe.test(target.tagName) || (contentEditable === '' || contentEditable === 'true')) {
          return;
        }
      }
      if (!event.getKey) {
        return event;
      }
      me.processing = true;
      for (; i < len; ++i) {
        me.processBinding(bindings[i], event);
      }
      me.processing = false;
    }
  };
}(), processEvent:Ext.identityFn, processBinding:function(binding, event) {
  if (this.checkModifiers(binding, event)) {
    var key = event.getKey(), handler = binding.fn || binding.handler, scope = binding.scope || this, keyCode = binding.keyCode, defaultEventAction = binding.defaultEventAction, i, len, keydownEvent = new Ext.EventObjectImpl(event);
    for (i = 0, len = keyCode.length; i < len; ++i) {
      if (key === keyCode[i]) {
        if (handler.call(scope, key, event) !== true && defaultEventAction) {
          keydownEvent[defaultEventAction]();
        }
        break;
      }
    }
  }
}, checkModifiers:function(binding, e) {
  var keys = ['shift', 'ctrl', 'alt'], i = 0, len = keys.length, val, key;
  for (; i < len; ++i) {
    key = keys[i];
    val = binding[key];
    if (!(val === undefined || val === e[key + 'Key'])) {
      return false;
    }
  }
  return true;
}, on:function(key, fn, scope) {
  var keyCode, shift, ctrl, alt;
  if (Ext.isObject(key) && !Ext.isArray(key)) {
    keyCode = key.key;
    shift = key.shift;
    ctrl = key.ctrl;
    alt = key.alt;
  } else {
    keyCode = key;
  }
  this.addBinding({key:keyCode, shift:shift, ctrl:ctrl, alt:alt, fn:fn, scope:scope});
}, un:function(key, fn, scope) {
  var keyCode, shift, ctrl, alt;
  if (Ext.isObject(key) && !Ext.isArray(key)) {
    keyCode = key.key;
    shift = key.shift;
    ctrl = key.ctrl;
    alt = key.alt;
  } else {
    keyCode = key;
  }
  this.removeBinding({key:keyCode, shift:shift, ctrl:ctrl, alt:alt, fn:fn, scope:scope});
}, isEnabled:function() {
  return this.enabled;
}, enable:function() {
  var me = this;
  if (!me.enabled) {
    me.target.on(me.eventName, me.handleTargetEvent, me);
    me.enabled = true;
  }
}, disable:function() {
  var me = this;
  if (me.enabled) {
    me.target.removeListener(me.eventName, me.handleTargetEvent, me);
    me.enabled = false;
  }
}, setDisabled:function(disabled) {
  if (disabled) {
    this.disable();
  } else {
    this.enable();
  }
}, destroy:function(removeTarget) {
  var me = this, target = me.target;
  me.bindings = [];
  me.disable();
  if (removeTarget === true) {
    if (target.isComponent) {
      target.destroy();
    } else {
      target.remove();
    }
  }
  delete me.target;
}});
Ext.define('Ext.util.KeyNav', {alternateClassName:'Ext.KeyNav', statics:{keyOptions:{left:37, right:39, up:38, down:40, space:32, pageUp:33, pageDown:34, del:46, backspace:8, home:36, end:35, enter:13, esc:27, tab:9}}, constructor:function(config) {
  var me = this;
  if (arguments.length === 2) {
    me.legacyConstructor.apply(me, arguments);
    return;
  }
  me.setConfig(config);
}, legacyConstructor:function(el, config) {
  this.setConfig(Ext.apply({target:el}, config));
}, setConfig:function(config) {
  var me = this, keymapCfg = {target:config.target, ignoreInputFields:config.ignoreInputFields, eventName:me.getKeyEvent('forceKeyDown' in config ? config.forceKeyDown : me.forceKeyDown, config.eventName)}, map, keyCodes, defaultScope, keyName, binding;
  if (me.map) {
    me.map.destroy();
  }
  if (config.processEvent) {
    keymapCfg.processEvent = config.processEvent;
    keymapCfg.processEventScope = config.processEventScope || me;
  }
  if (config.keyMap) {
    map = me.map = config.keyMap;
  } else {
    map = me.map = new Ext.util.KeyMap(keymapCfg);
    me.destroyKeyMap = true;
  }
  keyCodes = Ext.util.KeyNav.keyOptions;
  defaultScope = config.scope || me;
  for (keyName in keyCodes) {
    if (keyCodes.hasOwnProperty(keyName)) {
      if (binding = config[keyName]) {
        if (typeof binding === 'function') {
          binding = {handler:binding, defaultEventAction:config.defaultEventAction !== undefined ? config.defaultEventAction : me.defaultEventAction};
        }
        map.addBinding({key:keyCodes[keyName], handler:Ext.Function.bind(me.handleEvent, binding.scope || defaultScope, binding.handler || binding.fn, true), defaultEventAction:binding.defaultEventAction !== undefined ? binding.defaultEventAction : me.defaultEventAction});
      }
    }
  }
  map.disable();
  if (!config.disabled) {
    map.enable();
  }
}, handleEvent:function(keyCode, event, handler) {
  return handler.call(this, event);
}, disabled:false, defaultEventAction:'stopEvent', forceKeyDown:false, eventName:'keypress', destroy:function(removeEl) {
  if (this.destroyKeyMap) {
    this.map.destroy(removeEl);
  }
  delete this.map;
}, enable:function() {
  if (this.map) {
    this.map.enable();
    this.disabled = false;
  }
}, disable:function() {
  if (this.map) {
    this.map.disable();
  }
  this.disabled = true;
}, setDisabled:function(disabled) {
  this.map.setDisabled(disabled);
  this.disabled = disabled;
}, getKeyEvent:function(forceKeyDown, configuredEventName) {
  if (forceKeyDown || Ext.EventManager.useKeyDown && !configuredEventName) {
    return 'keydown';
  } else {
    return configuredEventName || this.eventName;
  }
}});
Ext.define('Ext.FocusManager', {singleton:true, alternateClassName:['Ext.FocusMgr'], mixins:{observable:Ext.util.Observable}, enabled:false, focusElementCls:Ext.baseCSSPrefix + 'focus-element', focusFrameCls:Ext.baseCSSPrefix + 'focus-frame', whitelist:['textfield'], constructor:function(config) {
  var me = this, CQ = Ext.ComponentQuery;
  me.mixins.observable.constructor.call(me, config);
  me.addEvents('beforecomponentfocus', 'componentfocus', 'disable', 'enable');
  me.focusTask = new Ext.util.DelayedTask(me.handleComponentFocus, me);
  Ext.override(Ext.AbstractComponent, {onFocus:function() {
    this.callParent(arguments);
    if (me.enabled && this.hasFocus) {
      Array.prototype.unshift.call(arguments, this);
      me.onComponentFocus.apply(me, arguments);
    }
  }, onBlur:function() {
    this.callParent(arguments);
    if (me.enabled && !this.hasFocus) {
      Array.prototype.unshift.call(arguments, this);
      me.onComponentBlur.apply(me, arguments);
    }
  }, onDestroy:function() {
    this.callParent(arguments);
    if (me.enabled) {
      Array.prototype.unshift.call(arguments, this);
      me.onComponentDestroy.apply(me, arguments);
    }
  }});
  Ext.override(Ext.Component, {afterHide:function() {
    this.callParent(arguments);
    if (me.enabled) {
      Array.prototype.unshift.call(arguments, this);
      me.onComponentHide.apply(me, arguments);
    }
  }});
  me.keyNav = new Ext.util.KeyNav(Ext.getDoc(), {disabled:true, scope:me, backspace:me.focusLast, enter:me.navigateIn, esc:me.navigateOut, tab:me.navigateSiblings, space:me.navigateIn, del:me.focusLast, left:me.navigateSiblings, right:me.navigateSiblings, down:me.navigateSiblings, up:me.navigateSiblings});
  me.focusData = {};
  me.subscribers = new Ext.util.HashMap;
  me.focusChain = {};
  Ext.apply(CQ.pseudos, {nextFocus:function(cmps, idx, step) {
    step = step || 1;
    idx = parseInt(idx, 10);
    var len = cmps.length, i = idx, c;
    for (;;) {
      if ((i += step) >= len) {
        i = 0;
      } else {
        if (i < 0) {
          i = len - 1;
        }
      }
      if (i === idx) {
        return [];
      }
      if ((c = cmps[i]).isFocusable()) {
        return [c];
      }
    }
    return [];
  }, prevFocus:function(cmps, idx) {
    return this.nextFocus(cmps, idx, -1);
  }, root:function(cmps) {
    var len = cmps.length, results = [], i = 0, c;
    for (; i < len; i++) {
      c = cmps[i];
      if (!c.ownerCt) {
        results.push(c);
      }
    }
    return results;
  }});
}, addXTypeToWhitelist:function(xtype) {
  var me = this;
  if (Ext.isArray(xtype)) {
    Ext.Array.forEach(xtype, me.addXTypeToWhitelist, me);
    return;
  }
  if (!Ext.Array.contains(me.whitelist, xtype)) {
    me.whitelist.push(xtype);
  }
}, clearComponent:function(cmp) {
  clearTimeout(this.cmpFocusDelay);
  if (!cmp.isDestroyed) {
    cmp.blur();
  }
}, disable:function() {
  var me = this;
  if (!me.enabled) {
    return;
  }
  delete me.options;
  me.enabled = false;
  me.removeDOM();
  me.keyNav.disable();
  me.fireEvent('disable', me);
}, enable:function(options) {
  var me = this;
  if (options === true) {
    options = {focusFrame:true};
  }
  me.options = options = options || {};
  if (me.enabled) {
    return;
  }
  me.enabled = true;
  me.initDOM(options);
  me.keyNav.enable();
  me.focusEl.focus();
  delete me.focusedCmp;
  me.fireEvent('enable', me);
}, focusLast:function(e) {
  var me = this;
  if (me.isWhitelisted(me.focusedCmp)) {
    return true;
  }
  if (me.previousFocusedCmp) {
    me.previousFocusedCmp.focus();
  }
}, getRootComponents:function() {
  var CQ = Ext.ComponentQuery, inline = CQ.query(':focusable:root:not([floating])'), floating = CQ.query(':focusable:root[floating]');
  floating.sort(function(a, b) {
    return a.el.getZIndex() > b.el.getZIndex();
  });
  return floating.concat(inline);
}, initDOM:function(options) {
  var me = this, cls = me.focusFrameCls, needListeners = Ext.ComponentQuery.query('{getFocusEl()}:not([focusListenerAdded])'), i = 0, len = needListeners.length;
  if (!Ext.isReady) {
    return Ext.onReady(me.initDOM, me);
  }
  for (; i < len; i++) {
    needListeners[i].addFocusListener();
  }
  if (!me.focusEl) {
    me.focusEl = Ext.getBody();
    me.focusEl.dom.tabIndex = -1;
  }
  if (!me.focusFrame && options.focusFrame) {
    me.focusFrame = Ext.getBody().createChild({cls:cls, children:[{cls:cls + '-top'}, {cls:cls + '-bottom'}, {cls:cls + '-left'}, {cls:cls + '-right'}], style:'top: -100px; left: -100px;'});
    me.focusFrame.setVisibilityMode(Ext.Element.DISPLAY);
    me.focusFrame.hide().setLocalXY(0, 0);
  }
}, isWhitelisted:function(cmp) {
  return cmp && Ext.Array.some(this.whitelist, function(x) {
    return cmp.isXType(x);
  });
}, navigateIn:function(e) {
  var me = this, focusedCmp = me.focusedCmp, defaultRoot, firstChild;
  if (me.isWhitelisted(focusedCmp)) {
    return true;
  }
  if (!focusedCmp) {
    defaultRoot = me.getRootComponents()[0];
    if (defaultRoot) {
      if (defaultRoot.getFocusEl() === me.focusEl) {
        me.focusEl.blur();
      }
      defaultRoot.focus();
    }
  } else {
    firstChild = focusedCmp.hasFocus ? Ext.ComponentQuery.query('\x3e:focusable', focusedCmp)[0] : focusedCmp;
    if (firstChild) {
      firstChild.focus();
    } else {
      if (Ext.isFunction(focusedCmp.onClick)) {
        e.button = 0;
        focusedCmp.onClick(e);
        if (focusedCmp.isVisible(true)) {
          focusedCmp.focus();
        } else {
          me.navigateOut();
        }
      }
    }
  }
}, navigateOut:function(e) {
  var me = this, parent;
  if (!me.focusedCmp || !(parent = me.focusedCmp.up(':focusable'))) {
    me.focusEl.focus();
  } else {
    parent.focus();
  }
  return true;
}, navigateSiblings:function(e, source, parent) {
  var me = this, src = source || me, key = e.getKey(), EO = Ext.EventObject, goBack = e.shiftKey || key == EO.LEFT || key == EO.UP, checkWhitelist = key == EO.LEFT || key == EO.RIGHT || key == EO.UP || key == EO.DOWN, nextSelector = goBack ? 'prev' : 'next', idx, next, focusedCmp, siblings;
  focusedCmp = src.focusedCmp && src.focusedCmp.comp || src.focusedCmp;
  if (!focusedCmp && !parent) {
    return true;
  }
  if (checkWhitelist && me.isWhitelisted(focusedCmp)) {
    return true;
  }
  if (!focusedCmp || focusedCmp.is(':root')) {
    siblings = me.getRootComponents();
  } else {
    parent = parent || focusedCmp.up();
    if (parent) {
      siblings = parent.getRefItems();
    }
  }
  if (siblings) {
    idx = focusedCmp ? Ext.Array.indexOf(siblings, focusedCmp) : -1;
    next = Ext.ComponentQuery.query(':' + nextSelector + 'Focus(' + idx + ')', siblings)[0];
    if (next && focusedCmp !== next) {
      next.focus();
      return next;
    }
  }
}, onComponentBlur:function(cmp, e) {
  var me = this;
  if (me.focusedCmp === cmp) {
    me.previousFocusedCmp = cmp;
    delete me.focusedCmp;
  }
  if (me.focusFrame) {
    me.focusFrame.hide();
  }
}, onComponentFocus:function(cmp, e) {
  var me = this, chain = me.focusChain, parent;
  if (!cmp.isFocusable()) {
    me.clearComponent(cmp);
    if (chain[cmp.id]) {
      return;
    }
    parent = cmp.up();
    if (parent) {
      chain[cmp.id] = true;
      parent.focus();
    }
    return;
  }
  me.focusChain = {};
  me.focusTask.delay(10, null, null, [cmp, cmp.getFocusEl()]);
}, handleComponentFocus:function(cmp, focusEl) {
  var me = this, cls, ff, box, bt, bl, bw, bh, ft, fb, fl, fr;
  if (me.fireEvent('beforecomponentfocus', me, cmp, me.previousFocusedCmp) === false) {
    me.clearComponent(cmp);
    return;
  }
  me.focusedCmp = cmp;
  if (me.shouldShowFocusFrame(cmp)) {
    cls = '.' + me.focusFrameCls + '-';
    ff = me.focusFrame;
    box = (focusEl.dom ? focusEl : focusEl.el).getBox();
    bt = box.top;
    bl = box.left;
    bw = box.width;
    bh = box.height;
    ft = ff.child(cls + 'top');
    fb = ff.child(cls + 'bottom');
    fl = ff.child(cls + 'left');
    fr = ff.child(cls + 'right');
    ft.setWidth(bw).setLocalXY(bl, bt);
    fb.setWidth(bw).setLocalXY(bl, bt + bh - 2);
    fl.setHeight(bh - 2).setLocalXY(bl, bt + 2);
    fr.setHeight(bh - 2).setLocalXY(bl + bw - 2, bt + 2);
    ff.show();
  }
  me.fireEvent('componentfocus', me, cmp, me.previousFocusedCmp);
}, onComponentHide:function(cmp) {
  var me = this, cmpHadFocus = false, focusedCmp = me.focusedCmp, parent;
  if (focusedCmp) {
    cmpHadFocus = cmp.hasFocus || cmp.isContainer && cmp.isAncestor(me.focusedCmp);
  }
  me.clearComponent(cmp);
  if (cmpHadFocus && (parent = cmp.up(':focusable'))) {
    parent.focus();
  } else {
    me.focusEl.focus();
  }
}, onComponentDestroy:function() {
}, removeDOM:function() {
  var me = this;
  if (me.enabled || me.subscribers.length) {
    return;
  }
  Ext.destroy(me.focusFrame);
  delete me.focusEl;
  delete me.focusFrame;
}, removeXTypeFromWhitelist:function(xtype) {
  var me = this;
  if (Ext.isArray(xtype)) {
    Ext.Array.forEach(xtype, me.removeXTypeFromWhitelist, me);
    return;
  }
  Ext.Array.remove(me.whitelist, xtype);
}, setupSubscriberKeys:function(container, keys) {
  var me = this, el = container.getFocusEl(), scope = keys.scope, handlers = {backspace:me.focusLast, enter:me.navigateIn, esc:me.navigateOut, scope:me}, navSiblings = function(e) {
    if (me.focusedCmp === container) {
      return me.navigateSiblings(e, me, container);
    } else {
      return me.navigateSiblings(e);
    }
  };
  Ext.iterate(keys, function(key, cb) {
    handlers[key] = function(e) {
      var ret = navSiblings(e);
      if (Ext.isFunction(cb) && cb.call(scope || container, e, ret) === true) {
        return true;
      }
      return ret;
    };
  }, me);
  return new Ext.util.KeyNav(el, handlers);
}, shouldShowFocusFrame:function(cmp) {
  var me = this, opts = me.options || {};
  if (!me.focusFrame || !cmp) {
    return false;
  }
  if (opts.focusFrame) {
    return true;
  }
  if (me.focusData[cmp.id].focusFrame) {
    return true;
  }
  return false;
}});
Ext.define('Ext.Img', {extend:Ext.Component, alias:['widget.image', 'widget.imagecomponent'], autoEl:'img', baseCls:Ext.baseCSSPrefix + 'img', src:'', alt:'', title:'', imgCls:'', initComponent:function() {
  if (this.glyph) {
    this.autoEl = 'div';
  }
  this.callParent();
}, getElConfig:function() {
  var me = this, config = me.callParent(), glyphFontFamily = Ext._glyphFontFamily, glyph = me.glyph, img, glyphParts;
  if (me.autoEl == 'img') {
    img = config;
  } else {
    if (me.glyph) {
      if (typeof glyph === 'string') {
        glyphParts = glyph.split('@');
        glyph = glyphParts[0];
        glyphFontFamily = glyphParts[1];
      }
      config.html = '\x26#' + glyph + ';';
      if (glyphFontFamily) {
        config.style = 'font-family:' + glyphFontFamily;
      }
    } else {
      config.cn = [img = {tag:'img', id:me.id + '-img'}];
    }
  }
  if (img) {
    if (me.imgCls) {
      img.cls = (img.cls ? img.cls + ' ' : '') + me.imgCls;
    }
    img.src = me.src || Ext.BLANK_IMAGE_URL;
  }
  if (me.alt) {
    (img || config).alt = me.alt;
  }
  if (me.title) {
    (img || config).title = me.title;
  }
  return config;
}, onRender:function() {
  var me = this, el;
  me.callParent(arguments);
  el = me.el;
  me.imgEl = me.autoEl == 'img' ? el : el.getById(me.id + '-img');
}, onDestroy:function() {
  Ext.destroy(this.imgEl);
  this.imgEl = null;
  this.callParent();
}, setSrc:function(src) {
  var me = this, imgEl = me.imgEl;
  me.src = src;
  if (imgEl) {
    imgEl.dom.src = src || Ext.BLANK_IMAGE_URL;
  }
}, setGlyph:function(glyph) {
  var me = this, glyphFontFamily = Ext._glyphFontFamily, glyphParts, dom;
  if (glyph != me.glyph) {
    if (typeof glyph === 'string') {
      glyphParts = glyph.split('@');
      glyph = glyphParts[0];
      glyphFontFamily = glyphParts[1];
    }
    dom = me.el.dom;
    dom.innerHTML = '\x26#' + glyph + ';';
    if (glyphFontFamily) {
      dom.style = 'font-family:' + glyphFontFamily;
    }
  }
}});
Ext.define('Ext.util.Bindable', {bindStore:function(store, initial, propertyName) {
  propertyName = propertyName || 'store';
  var me = this, oldStore = me[propertyName];
  if (!initial && oldStore) {
    me.onUnbindStore(oldStore, initial, propertyName);
    if (store !== oldStore && oldStore.autoDestroy) {
      oldStore.destroyStore();
    } else {
      me.unbindStoreListeners(oldStore);
    }
  }
  if (store) {
    store = Ext.data.StoreManager.lookup(store);
    me.bindStoreListeners(store);
    me.onBindStore(store, initial, propertyName);
  }
  me[propertyName] = store || null;
  return me;
}, getStore:function() {
  return this.store;
}, unbindStoreListeners:function(store) {
  var listeners = this.storeListeners;
  if (listeners) {
    store.un(listeners);
  }
}, bindStoreListeners:function(store) {
  var me = this, listeners = Ext.apply({}, me.getStoreListeners(store));
  if (!listeners.scope) {
    listeners.scope = me;
  }
  me.storeListeners = listeners;
  store.on(listeners);
}, getStoreListeners:Ext.emptyFn, onUnbindStore:Ext.emptyFn, onBindStore:Ext.emptyFn});
Ext.define('Ext.LoadMask', {extend:Ext.Component, alias:'widget.loadmask', mixins:{floating:Ext.util.Floating, bindable:Ext.util.Bindable}, msg:'Loading...', msgCls:Ext.baseCSSPrefix + 'mask-loading', maskCls:Ext.baseCSSPrefix + 'mask', useMsg:true, useTargetEl:false, baseCls:Ext.baseCSSPrefix + 'mask-msg', childEls:['msgEl', 'msgTextEl'], renderTpl:['\x3cdiv id\x3d"{id}-msgEl" class\x3d"{[values.$comp.msgCls]} ', Ext.baseCSSPrefix, 'mask-msg-inner{childElCls}"\x3e', '\x3cdiv id\x3d"{id}-msgTextEl" class\x3d"', 
Ext.baseCSSPrefix, 'mask-msg-text', '{childElCls}"\x3e\x3c/div\x3e', '\x3c/div\x3e'], floating:{shadow:'frame'}, focusOnToFront:false, bringParentToFront:false, constructor:function(config) {
  var me = this, comp;
  if (arguments.length === 2) {
    if (Ext.isDefined(Ext.global.console)) {
      Ext.global.console.warn('Ext.LoadMask: LoadMask now uses a standard 1 arg constructor: use the target config');
    }
    comp = config;
    config = arguments[1];
  } else {
    comp = config.target;
  }
  if (!comp.isComponent) {
    if (Ext.isDefined(Ext.global.console)) {
      Ext.global.console.warn('Ext.LoadMask: LoadMask for elements has been deprecated, use Ext.dom.Element.mask \x26 Ext.dom.Element.unmask');
    }
    comp = Ext.get(comp);
    this.isElement = true;
  }
  me.ownerCt = comp;
  if (!this.isElement) {
    me.bindComponent(comp);
  }
  me.callParent([config]);
  if (me.store) {
    me.bindStore(me.store, true);
  }
}, bindComponent:function(comp) {
  var me = this, listeners = {scope:this, resize:me.sizeMask, added:me.onComponentAdded, removed:me.onComponentRemoved};
  if (comp.floating) {
    listeners.move = me.sizeMask;
    me.activeOwner = comp;
  } else {
    if (comp.ownerCt) {
      me.onComponentAdded(comp.ownerCt);
    } else {
      me.preventBringToFront = true;
    }
  }
  me.mon(comp, listeners);
  me.mon(me.hierarchyEventSource, {show:me.onContainerShow, hide:me.onContainerHide, expand:me.onContainerExpand, collapse:me.onContainerCollapse, scope:me});
}, onComponentAdded:function(owner) {
  var me = this;
  delete me.activeOwner;
  me.floatParent = owner;
  if (!owner.floating) {
    owner = owner.up('[floating]');
  }
  if (owner) {
    me.activeOwner = owner;
    me.mon(owner, 'move', me.sizeMask, me);
  } else {
    me.preventBringToFront = true;
  }
  owner = me.floatParent.ownerCt;
  if (me.rendered && me.isVisible() && owner) {
    me.floatOwner = owner;
    me.mon(owner, 'afterlayout', me.sizeMask, me, {single:true});
  }
}, onComponentRemoved:function(owner) {
  var me = this, activeOwner = me.activeOwner, floatOwner = me.floatOwner;
  if (activeOwner) {
    me.mun(activeOwner, 'move', me.sizeMask, me);
  }
  if (floatOwner) {
    me.mun(floatOwner, 'afterlayout', me.sizeMask, me);
  }
  delete me.activeOwner;
  delete me.floatOwner;
}, afterRender:function() {
  this.callParent(arguments);
  this.container = this.floatParent.getContentTarget();
}, onContainerShow:function(container) {
  if (this.isActiveContainer(container)) {
    this.onComponentShow();
  }
}, onContainerHide:function(container) {
  if (this.isActiveContainer(container)) {
    this.onComponentHide();
  }
}, onContainerExpand:function(container) {
  if (this.isActiveContainer(container)) {
    this.onComponentShow();
  }
}, onContainerCollapse:function(container) {
  if (this.isActiveContainer(container)) {
    this.onComponentHide();
  }
}, isActiveContainer:function(container) {
  return this.isDescendantOf(container);
}, onComponentHide:function() {
  var me = this;
  if (me.rendered && me.isVisible()) {
    me.hide();
    me.showNext = true;
  }
}, onComponentShow:function() {
  if (this.showNext) {
    this.show();
  }
  delete this.showNext;
}, sizeMask:function() {
  var me = this, target;
  if (me.rendered && me.isVisible()) {
    me.center();
    target = me.getMaskTarget();
    me.getMaskEl().show().setSize(target.getSize()).alignTo(target, 'tl-tl');
  }
}, bindStore:function(store, initial) {
  var me = this;
  me.mixins.bindable.bindStore.apply(me, arguments);
  store = me.store;
  if (store && store.isLoading()) {
    me.onBeforeLoad();
  }
}, getStoreListeners:function(store) {
  var load = this.onLoad, beforeLoad = this.onBeforeLoad, result = {cachemiss:beforeLoad, cachefilled:load};
  if (!store.proxy.isSynchronous) {
    result.beforeLoad = beforeLoad;
    result.load = load;
  }
  return result;
}, onDisable:function() {
  this.callParent(arguments);
  if (this.loading) {
    this.onLoad();
  }
}, getOwner:function() {
  return this.ownerCt || this.floatParent;
}, getMaskTarget:function() {
  var owner = this.getOwner();
  return this.useTargetEl ? owner.getTargetEl() : owner.getEl();
}, onBeforeLoad:function() {
  var me = this, owner = me.getOwner(), origin;
  if (!me.disabled) {
    me.loading = true;
    if (owner.componentLayoutCounter) {
      me.maybeShow();
    } else {
      origin = owner.afterComponentLayout;
      owner.afterComponentLayout = function() {
        owner.afterComponentLayout = origin;
        origin.apply(owner, arguments);
        me.maybeShow();
      };
    }
  }
}, maybeShow:function() {
  var me = this, owner = me.getOwner();
  if (!owner.isVisible(true)) {
    me.showNext = true;
  } else {
    if (me.loading && owner.rendered) {
      me.show();
    }
  }
}, getMaskEl:function() {
  var me = this;
  return me.maskEl || (me.maskEl = me.el.insertSibling({cls:me.maskCls, style:{zIndex:me.el.getStyle('zIndex') - 2}}, 'before'));
}, onShow:function() {
  var me = this, msgEl = me.msgEl;
  me.callParent(arguments);
  me.loading = true;
  if (me.useMsg) {
    msgEl.show();
    me.msgTextEl.update(me.msg);
  } else {
    msgEl.parent().hide();
  }
}, hide:function() {
  if (this.isElement) {
    this.ownerCt.unmask();
    this.fireEvent('hide', this);
    return;
  }
  delete this.showNext;
  return this.callParent(arguments);
}, onHide:function() {
  this.callParent();
  this.getMaskEl().hide();
}, show:function() {
  if (this.isElement) {
    this.ownerCt.mask(this.useMsg ? this.msg : '', this.msgCls);
    this.fireEvent('show', this);
    return;
  }
  return this.callParent(arguments);
}, afterShow:function() {
  this.callParent(arguments);
  this.sizeMask();
}, setZIndex:function(index) {
  var me = this, owner = me.activeOwner;
  if (owner) {
    index = parseInt(owner.el.getStyle('zIndex'), 10) + 1;
  }
  me.getMaskEl().setStyle('zIndex', index - 1);
  return me.mixins.floating.setZIndex.apply(me, arguments);
}, onLoad:function() {
  this.loading = false;
  this.hide();
}, onDestroy:function() {
  var me = this;
  if (me.isElement) {
    me.ownerCt.unmask();
  }
  Ext.destroy(me.maskEl);
  me.callParent();
}});
Ext.define('Ext.data.association.Association', {alternateClassName:'Ext.data.Association', primaryKey:'id', associationKeyFunction:null, defaultReaderType:'json', isAssociation:true, initialConfig:null, statics:{AUTO_ID:1000, create:function(association) {
  if (Ext.isString(association)) {
    association = {type:association};
  }
  switch(association.type) {
    case 'belongsTo':
      return new Ext.data.association.BelongsTo(association);
    case 'hasMany':
      return new Ext.data.association.HasMany(association);
    case 'hasOne':
      return new Ext.data.association.HasOne(association);
    default:
      Ext.Error.raise('Unknown Association type: "' + association.type + '"');
  }
  return association;
}}, constructor:function(config) {
  Ext.apply(this, config);
  var me = this, types = Ext.ModelManager.types, ownerName = config.ownerModel, associatedName = config.associatedModel, ownerModel = types[ownerName], associatedModel = types[associatedName], associationKey = config.associationKey, keyReIdx;
  if (associationKey) {
    keyReIdx = String(associationKey).search(/[\[\.]/);
    if (keyReIdx >= 0) {
      me.associationKeyFunction = Ext.functionFactory('obj', 'return obj' + (keyReIdx > 0 ? '.' : '') + associationKey);
    }
  }
  me.initialConfig = config;
  if (ownerModel === undefined) {
    Ext.Error.raise('The configured ownerModel was not valid (you tried ' + ownerName + ')');
  }
  if (associatedModel === undefined) {
    Ext.Error.raise('The configured associatedModel was not valid (you tried ' + associatedName + ')');
  }
  me.ownerModel = ownerModel;
  me.associatedModel = associatedModel;
  Ext.applyIf(me, {ownerName:ownerName, associatedName:associatedName});
  me.associationId = 'association' + ++me.statics().AUTO_ID;
}, getReader:function() {
  var me = this, reader = me.reader, model = me.associatedModel;
  if (reader) {
    if (Ext.isString(reader)) {
      reader = {type:reader};
    }
    if (reader.isReader) {
      reader.setModel(model);
    } else {
      Ext.applyIf(reader, {model:model, type:me.defaultReaderType});
    }
    me.reader = Ext.createByAlias('reader.' + reader.type, reader);
  }
  return me.reader || null;
}});
Ext.define('Ext.ModelManager', {extend:Ext.AbstractManager, alternateClassName:'Ext.ModelMgr', singleton:true, typeName:'mtype', associationStack:[], registerType:function(name, config) {
  var proto = config.prototype, model;
  if (proto && proto.isModel) {
    model = config;
  } else {
    if (!config.extend) {
      config.extend = 'Ext.data.Model';
    }
    model = Ext.define(name, config);
  }
  this.types[name] = model;
  return model;
}, unregisterType:function(name) {
  delete this.types[name];
}, onModelDefined:function(model) {
  var stack = this.associationStack, length = stack.length, create = [], association, i, created;
  for (i = 0; i < length; i++) {
    association = stack[i];
    if (association.associatedModel == model.modelName) {
      create.push(association);
    }
  }
  for (i = 0, length = create.length; i < length; i++) {
    created = create[i];
    this.types[created.ownerModel].prototype.associations.add(Ext.data.association.Association.create(created));
    Ext.Array.remove(stack, created);
  }
}, registerDeferredAssociation:function(association) {
  this.associationStack.push(association);
}, getModel:function(id) {
  var model = id;
  if (typeof model == 'string') {
    model = this.types[model];
  }
  return model;
}, create:function(config, name, id) {
  var Con = typeof name == 'function' ? name : this.types[name || config.name];
  return new Con(config, id);
}}, function() {
  Ext.regModel = function() {
    if (Ext.isDefined(Ext.global.console)) {
      Ext.global.console.warn('Ext.regModel has been deprecated. Models can now be created by extending Ext.data.Model: Ext.define("MyModel", {extend: "Ext.data.Model", fields: []});.');
    }
    return this.ModelManager.registerType.apply(this.ModelManager, arguments);
  };
});
Ext.define('Ext.layout.component.Component', {extend:Ext.layout.Layout, type:'component', isComponentLayout:true, nullBox:{}, usesContentHeight:true, usesContentWidth:true, usesHeight:true, usesWidth:true, beginLayoutCycle:function(ownerContext, firstCycle) {
  var me = this, owner = me.owner, ownerCtContext = ownerContext.ownerCtContext, heightModel = ownerContext.heightModel, widthModel = ownerContext.widthModel, body = owner.el.dom === document.body, lastBox = owner.lastBox || me.nullBox, lastSize = owner.el.lastBox || me.nullBox, dirty = !body, ownerLayout, v, widthName, heightName;
  me.callParent(arguments);
  if (firstCycle) {
    if (me.usesContentWidth) {
      ++ownerContext.consumersContentWidth;
    }
    if (me.usesContentHeight) {
      ++ownerContext.consumersContentHeight;
    }
    if (me.usesWidth) {
      ++ownerContext.consumersWidth;
    }
    if (me.usesHeight) {
      ++ownerContext.consumersHeight;
    }
    if (ownerCtContext && !ownerCtContext.hasRawContent) {
      ownerLayout = owner.ownerLayout;
      if (ownerLayout.usesWidth) {
        ++ownerContext.consumersWidth;
      }
      if (ownerLayout.usesHeight) {
        ++ownerContext.consumersHeight;
      }
    }
  }
  if (widthModel.configured) {
    widthName = widthModel.names.width;
    if (!body) {
      dirty = firstCycle ? owner[widthName] !== lastSize.width : widthModel.constrained;
    }
    ownerContext.setWidth(owner[widthName], dirty);
  } else {
    if (ownerContext.isTopLevel) {
      if (widthModel.calculated) {
        v = lastBox.width;
        ownerContext.setWidth(v, v != lastSize.width);
      }
      v = lastBox.x;
      ownerContext.setProp('x', v, v != lastSize.x);
    }
  }
  if (heightModel.configured) {
    heightName = heightModel.names.height;
    if (!body) {
      dirty = firstCycle ? owner[heightName] !== lastSize.height : heightModel.constrained;
    }
    ownerContext.setHeight(owner[heightName], dirty);
  } else {
    if (ownerContext.isTopLevel) {
      if (heightModel.calculated) {
        v = lastBox.height;
        ownerContext.setHeight(v, v != lastSize.height);
      }
      v = lastBox.y;
      ownerContext.setProp('y', v, v != lastSize.y);
    }
  }
}, finishedLayout:function(ownerContext) {
  var me = this, elementChildren = ownerContext.children, owner = me.owner, len, i, elContext, lastBox, props;
  if (elementChildren) {
    len = elementChildren.length;
    for (i = 0; i < len; i++) {
      elContext = elementChildren[i];
      elContext.el.lastBox = elContext.props;
    }
  }
  ownerContext.previousSize = me.lastComponentSize;
  me.lastComponentSize = owner.el.lastBox = props = ownerContext.props;
  lastBox = owner.lastBox || (owner.lastBox = {});
  lastBox.x = props.x;
  lastBox.y = props.y;
  lastBox.width = props.width;
  lastBox.height = props.height;
  lastBox.invalid = false;
  me.callParent(arguments);
}, notifyOwner:function(ownerContext) {
  var me = this, currentSize = me.lastComponentSize, prevSize = ownerContext.previousSize, args = [currentSize.width, currentSize.height];
  if (prevSize) {
    args.push(prevSize.width, prevSize.height);
  }
  me.owner.afterComponentLayout.apply(me.owner, args);
}, getTarget:function() {
  return this.owner.el;
}, getRenderTarget:function() {
  return this.owner.el;
}, cacheTargetInfo:function(ownerContext) {
  var me = this, targetInfo = me.targetInfo, target;
  if (!targetInfo) {
    target = ownerContext.getEl('getTarget', me);
    me.targetInfo = targetInfo = {padding:target.getPaddingInfo(), border:target.getBorderInfo()};
  }
  return targetInfo;
}, measureAutoDimensions:function(ownerContext, dimensions) {
  var me = this, owner = me.owner, containerLayout = owner.layout, heightModel = ownerContext.heightModel, widthModel = ownerContext.widthModel, boxParent = ownerContext.boxParent, isBoxParent = ownerContext.isBoxParent, props = ownerContext.props, isContainer, ret = {gotWidth:false, gotHeight:false, isContainer:isContainer = !ownerContext.hasRawContent}, hv = dimensions || 3, zeroWidth, zeroHeight, needed = 0, got = 0, ready, size, temp;
  if (widthModel.shrinkWrap && ownerContext.consumersContentWidth) {
    ++needed;
    zeroWidth = !(hv & 1);
    if (isContainer) {
      if (zeroWidth) {
        ret.contentWidth = 0;
        ret.gotWidth = true;
        ++got;
      } else {
        if ((ret.contentWidth = ownerContext.getProp('contentWidth')) !== undefined) {
          ret.gotWidth = true;
          ++got;
        }
      }
    } else {
      size = props.contentWidth;
      if (typeof size == 'number') {
        ret.contentWidth = size;
        ret.gotWidth = true;
        ++got;
      } else {
        if (zeroWidth) {
          ready = true;
        } else {
          if (!ownerContext.hasDomProp('containerChildrenSizeDone')) {
            ready = false;
          } else {
            if (isBoxParent || !boxParent || boxParent.widthModel.shrinkWrap) {
              ready = true;
            } else {
              ready = boxParent.hasDomProp('width');
            }
          }
        }
        if (ready) {
          if (zeroWidth) {
            temp = 0;
          } else {
            if (containerLayout && containerLayout.measureContentWidth) {
              temp = containerLayout.measureContentWidth(ownerContext);
            } else {
              temp = me.measureContentWidth(ownerContext);
            }
          }
          if (!isNaN(ret.contentWidth = temp)) {
            ownerContext.setContentWidth(temp, true);
            ret.gotWidth = true;
            ++got;
          }
        }
      }
    }
  } else {
    if (widthModel.natural && ownerContext.consumersWidth) {
      ++needed;
      size = props.width;
      if (typeof size == 'number') {
        ret.width = size;
        ret.gotWidth = true;
        ++got;
      } else {
        if (isBoxParent || !boxParent) {
          ready = true;
        } else {
          ready = boxParent.hasDomProp('width');
        }
        if (ready) {
          if (!isNaN(ret.width = me.measureOwnerWidth(ownerContext))) {
            ownerContext.setWidth(ret.width, false);
            ret.gotWidth = true;
            ++got;
          }
        }
      }
    }
  }
  if (heightModel.shrinkWrap && ownerContext.consumersContentHeight) {
    ++needed;
    zeroHeight = !(hv & 2);
    if (isContainer) {
      if (zeroHeight) {
        ret.contentHeight = 0;
        ret.gotHeight = true;
        ++got;
      } else {
        if ((ret.contentHeight = ownerContext.getProp('contentHeight')) !== undefined) {
          ret.gotHeight = true;
          ++got;
        }
      }
    } else {
      size = props.contentHeight;
      if (typeof size == 'number') {
        ret.contentHeight = size;
        ret.gotHeight = true;
        ++got;
      } else {
        if (zeroHeight) {
          ready = true;
        } else {
          if (!ownerContext.hasDomProp('containerChildrenSizeDone')) {
            ready = false;
          } else {
            if (owner.noWrap) {
              ready = true;
            } else {
              if (!widthModel.shrinkWrap) {
                ready = (ownerContext.bodyContext || ownerContext).hasDomProp('width');
              } else {
                if (isBoxParent || !boxParent || boxParent.widthModel.shrinkWrap) {
                  ready = true;
                } else {
                  ready = boxParent.hasDomProp('width');
                }
              }
            }
          }
        }
        if (ready) {
          if (zeroHeight) {
            temp = 0;
          } else {
            if (containerLayout && containerLayout.measureContentHeight) {
              temp = containerLayout.measureContentHeight(ownerContext);
            } else {
              temp = me.measureContentHeight(ownerContext);
            }
          }
          if (!isNaN(ret.contentHeight = temp)) {
            ownerContext.setContentHeight(temp, true);
            ret.gotHeight = true;
            ++got;
          }
        }
      }
    }
  } else {
    if (heightModel.natural && ownerContext.consumersHeight) {
      ++needed;
      size = props.height;
      if (typeof size == 'number') {
        ret.height = size;
        ret.gotHeight = true;
        ++got;
      } else {
        if (isBoxParent || !boxParent) {
          ready = true;
        } else {
          ready = boxParent.hasDomProp('width');
        }
        if (ready) {
          if (!isNaN(ret.height = me.measureOwnerHeight(ownerContext))) {
            ownerContext.setHeight(ret.height, false);
            ret.gotHeight = true;
            ++got;
          }
        }
      }
    }
  }
  if (boxParent) {
    ownerContext.onBoxMeasured();
  }
  ret.gotAll = got == needed;
  return ret;
}, measureContentWidth:function(ownerContext) {
  return ownerContext.el.getWidth() - ownerContext.getFrameInfo().width;
}, measureContentHeight:function(ownerContext) {
  return ownerContext.el.getHeight() - ownerContext.getFrameInfo().height;
}, measureOwnerHeight:function(ownerContext) {
  return ownerContext.el.getHeight();
}, measureOwnerWidth:function(ownerContext) {
  return ownerContext.el.getWidth();
}});
Ext.define('Ext.layout.component.Auto', {alias:'layout.autocomponent', extend:Ext.layout.component.Component, type:'autocomponent', setHeightInDom:false, setWidthInDom:false, waitForOuterHeightInDom:false, waitForOuterWidthInDom:false, beginLayoutCycle:function(ownerContext, firstCycle) {
  var me = this, lastWidthModel = me.lastWidthModel, lastHeightModel = me.lastHeightModel, el = me.owner.el;
  me.callParent(arguments);
  if (lastWidthModel && lastWidthModel.fixed && ownerContext.widthModel.shrinkWrap) {
    el.setWidth(null);
  }
  if (lastHeightModel && lastHeightModel.fixed && ownerContext.heightModel.shrinkWrap) {
    el.setHeight(null);
  }
}, calculate:function(ownerContext) {
  var me = this, measurement = me.measureAutoDimensions(ownerContext), heightModel = ownerContext.heightModel, widthModel = ownerContext.widthModel, width, height;
  if (measurement.gotWidth) {
    if (widthModel.shrinkWrap) {
      me.publishOwnerWidth(ownerContext, measurement.contentWidth);
    } else {
      if (me.publishInnerWidth) {
        me.publishInnerWidth(ownerContext, measurement.width);
      }
    }
  } else {
    if (!widthModel.auto && me.publishInnerWidth) {
      width = me.waitForOuterWidthInDom ? ownerContext.getDomProp('width') : ownerContext.getProp('width');
      if (width === undefined) {
        me.done = false;
      } else {
        me.publishInnerWidth(ownerContext, width);
      }
    }
  }
  if (measurement.gotHeight) {
    if (heightModel.shrinkWrap) {
      me.publishOwnerHeight(ownerContext, measurement.contentHeight);
    } else {
      if (me.publishInnerHeight) {
        me.publishInnerHeight(ownerContext, measurement.height);
      }
    }
  } else {
    if (!heightModel.auto && me.publishInnerHeight) {
      height = me.waitForOuterHeightInDom ? ownerContext.getDomProp('height') : ownerContext.getProp('height');
      if (height === undefined) {
        me.done = false;
      } else {
        me.publishInnerHeight(ownerContext, height);
      }
    }
  }
  if (!measurement.gotAll) {
    me.done = false;
  }
}, calculateOwnerHeightFromContentHeight:function(ownerContext, contentHeight) {
  return contentHeight + ownerContext.getFrameInfo().height;
}, calculateOwnerWidthFromContentWidth:function(ownerContext, contentWidth) {
  return contentWidth + ownerContext.getFrameInfo().width;
}, publishOwnerHeight:function(ownerContext, contentHeight) {
  var me = this, owner = me.owner, height = me.calculateOwnerHeightFromContentHeight(ownerContext, contentHeight), constrainedHeight, dirty, heightModel;
  if (isNaN(height)) {
    me.done = false;
  } else {
    constrainedHeight = Ext.Number.constrain(height, owner.minHeight, owner.maxHeight);
    if (constrainedHeight == height) {
      dirty = me.setHeightInDom;
    } else {
      heightModel = me.sizeModels[constrainedHeight < height ? 'constrainedMax' : 'constrainedMin'];
      height = constrainedHeight;
      if (ownerContext.heightModel.calculatedFromShrinkWrap) {
        ownerContext.heightModel = heightModel;
      } else {
        ownerContext.invalidate({heightModel:heightModel});
      }
    }
    ownerContext.setHeight(height, dirty);
  }
}, publishOwnerWidth:function(ownerContext, contentWidth) {
  var me = this, owner = me.owner, width = me.calculateOwnerWidthFromContentWidth(ownerContext, contentWidth), constrainedWidth, dirty, widthModel;
  if (isNaN(width)) {
    me.done = false;
  } else {
    constrainedWidth = Ext.Number.constrain(width, owner.minWidth, owner.maxWidth);
    if (constrainedWidth == width) {
      dirty = me.setWidthInDom;
    } else {
      widthModel = me.sizeModels[constrainedWidth < width ? 'constrainedMax' : 'constrainedMin'];
      width = constrainedWidth;
      if (ownerContext.widthModel.calculatedFromShrinkWrap) {
        ownerContext.widthModel = widthModel;
      } else {
        ownerContext.invalidate({widthModel:widthModel});
      }
    }
    ownerContext.setWidth(width, dirty);
  }
}});
Ext.define('Ext.layout.component.ProgressBar', {alias:['layout.progressbar'], extend:Ext.layout.component.Auto, type:'progressbar', beginLayout:function(ownerContext) {
  var me = this, i, textEls;
  me.callParent(arguments);
  if (!ownerContext.textEls) {
    textEls = me.owner.textEl;
    if (textEls.isComposite) {
      ownerContext.textEls = [];
      textEls = textEls.elements;
      for (i = textEls.length; i--;) {
        ownerContext.textEls[i] = ownerContext.getEl(Ext.get(textEls[i]));
      }
    } else {
      ownerContext.textEls = [ownerContext.getEl('textEl')];
    }
  }
}, calculate:function(ownerContext) {
  var me = this, i, textEls, width;
  me.callParent(arguments);
  if (Ext.isNumber(width = ownerContext.getProp('width'))) {
    width -= ownerContext.getBorderInfo().width;
    textEls = ownerContext.textEls;
    for (i = textEls.length; i--;) {
      textEls[i].setWidth(width);
    }
  } else {
    me.done = false;
  }
}});
Ext.define('Ext.ProgressBar', {extend:Ext.Component, alias:'widget.progressbar', baseCls:Ext.baseCSSPrefix + 'progress', animate:false, text:'', waitTimer:null, childEls:['bar'], renderTpl:['\x3ctpl if\x3d"internalText"\x3e', '\x3cdiv class\x3d"{baseCls}-text {baseCls}-text-back"\x3e{text}\x3c/div\x3e', '\x3c/tpl\x3e', '\x3cdiv id\x3d"{id}-bar" class\x3d"{baseCls}-bar {baseCls}-bar-{ui}" style\x3d"width:{percentage}%"\x3e', '\x3ctpl if\x3d"internalText"\x3e', '\x3cdiv class\x3d"{baseCls}-text"\x3e', 
'\x3cdiv\x3e{text}\x3c/div\x3e', '\x3c/div\x3e', '\x3c/tpl\x3e', '\x3c/div\x3e'], componentLayout:'progressbar', initComponent:function() {
  this.callParent();
  this.addEvents('update');
}, initRenderData:function() {
  var me = this;
  return Ext.apply(me.callParent(), {internalText:!me.hasOwnProperty('textEl'), text:me.text || '\x26#160;', percentage:me.value ? me.value * 100 : 0});
}, onRender:function() {
  var me = this;
  me.callParent(arguments);
  if (me.textEl) {
    me.textEl = Ext.get(me.textEl);
    me.updateText(me.text);
  } else {
    me.textEl = me.el.select('.' + me.baseCls + '-text');
  }
}, updateProgress:function(value, text, animate) {
  var me = this, oldValue = me.value;
  me.value = value || 0;
  if (text) {
    me.updateText(text);
  }
  if (me.rendered && !me.isDestroyed) {
    if (animate === true || animate !== false && me.animate) {
      me.bar.stopAnimation();
      me.bar.animate(Ext.apply({from:{width:oldValue * 100 + '%'}, to:{width:me.value * 100 + '%'}}, me.animate));
    } else {
      me.bar.setStyle('width', me.value * 100 + '%');
    }
  }
  me.fireEvent('update', me, me.value, text);
  return me;
}, updateText:function(text) {
  var me = this;
  me.text = text;
  if (me.rendered) {
    me.textEl.update(me.text);
  }
  return me;
}, applyText:function(text) {
  this.updateText(text);
}, getText:function() {
  return this.text;
}, wait:function(o) {
  var me = this, scope;
  if (!me.waitTimer) {
    scope = me;
    o = o || {};
    me.updateText(o.text);
    me.waitTimer = Ext.TaskManager.start({run:function(i) {
      var inc = o.increment || 10;
      i -= 1;
      me.updateProgress(((i + inc) % inc + 1) * (100 / inc) * 0.01, null, o.animate);
    }, interval:o.interval || 1000, duration:o.duration, onStop:function() {
      if (o.fn) {
        o.fn.apply(o.scope || me);
      }
      me.reset();
    }, scope:scope});
  }
  return me;
}, isWaiting:function() {
  return this.waitTimer !== null;
}, reset:function(hide) {
  var me = this;
  me.updateProgress(0);
  me.clearTimer();
  if (hide === true) {
    me.hide();
  }
  return me;
}, clearTimer:function() {
  var me = this;
  if (me.waitTimer) {
    me.waitTimer.onStop = null;
    Ext.TaskManager.stop(me.waitTimer);
    me.waitTimer = null;
  }
}, onDestroy:function() {
  var me = this, bar = me.bar;
  me.clearTimer();
  if (me.rendered) {
    if (me.textEl.isComposite) {
      me.textEl.clear();
    }
    Ext.destroyMembers(me, 'textEl', 'progressBar');
    if (bar && me.animate) {
      bar.stopAnimation();
    }
  }
  me.callParent();
}});
Ext.define('Ext.ShadowPool', {singleton:true, markup:function() {
  return Ext.String.format('\x3cdiv class\x3d"{0}{1}-shadow" role\x3d"presentation"\x3e\x3c/div\x3e', Ext.baseCSSPrefix, Ext.isIE && !Ext.supports.CSS3BoxShadow ? 'ie' : 'css');
}(), shadows:[], pull:function() {
  var sh = this.shadows.shift();
  if (!sh) {
    sh = Ext.get(Ext.DomHelper.insertHtml('beforeBegin', document.body.firstChild, this.markup));
    sh.autoBoxAdjust = false;
  }
  return sh;
}, push:function(sh) {
  this.shadows.push(sh);
}, reset:function() {
  var shadows = [].concat(this.shadows), s, sLen = shadows.length;
  for (s = 0; s < sLen; s++) {
    shadows[s].remove();
  }
  this.shadows = [];
}});
Ext.define('Ext.Shadow', {localXYNames:{get:'getLocalXY', set:'setLocalXY'}, constructor:function(config) {
  var me = this, adjusts, offset, rad;
  Ext.apply(me, config);
  if (!Ext.isString(me.mode)) {
    me.mode = me.defaultMode;
  }
  offset = me.offset;
  rad = Math.floor(offset / 2);
  me.opacity = 50;
  switch(me.mode.toLowerCase()) {
    case 'drop':
      if (Ext.supports.CSS3BoxShadow) {
        adjusts = {t:offset, l:offset, h:-offset, w:-offset};
      } else {
        adjusts = {t:-rad, l:-rad, h:-rad, w:-rad};
      }
      break;
    case 'sides':
      if (Ext.supports.CSS3BoxShadow) {
        adjusts = {t:offset, l:0, h:-offset, w:0};
      } else {
        adjusts = {t:-(1 + rad), l:1 + rad - 2 * offset, h:-1, w:rad - 1};
      }
      break;
    case 'frame':
      if (Ext.supports.CSS3BoxShadow) {
        adjusts = {t:0, l:0, h:0, w:0};
      } else {
        adjusts = {t:1 + rad - 2 * offset, l:1 + rad - 2 * offset, h:offset - rad - 1, w:offset - rad - 1};
      }
      break;
    case 'bottom':
      if (Ext.supports.CSS3BoxShadow) {
        adjusts = {t:offset, l:0, h:-offset, w:0};
      } else {
        adjusts = {t:offset, l:0, h:0, w:0};
      }
      break;
  }
  me.adjusts = adjusts;
}, getShadowSize:function() {
  var me = this, offset = me.el ? me.offset : 0, result = [offset, offset, offset, offset], mode = me.mode.toLowerCase();
  if (me.el && mode !== 'frame') {
    result[0] = 0;
    if (mode == 'drop') {
      result[3] = 0;
    }
  }
  return result;
}, offset:4, defaultMode:'drop', boxShadowProperty:function() {
  var property = 'boxShadow', style = document.documentElement.style;
  if (!('boxShadow' in style)) {
    if ('WebkitBoxShadow' in style) {
      property = 'WebkitBoxShadow';
    } else {
      if ('MozBoxShadow' in style) {
        property = 'MozBoxShadow';
      }
    }
  }
  return property;
}(), show:function(target) {
  var me = this, index, xy;
  target = Ext.get(target);
  index = parseInt(target.getStyle('z-index'), 10) - 1 || 0;
  xy = target[me.localXYNames.get]();
  if (!me.el) {
    me.el = Ext.ShadowPool.pull();
    if (me.fixed) {
      me.el.dom.style.position = 'fixed';
    } else {
      me.el.dom.style.position = '';
    }
    if (me.el.dom.nextSibling != target.dom) {
      me.el.insertBefore(target);
    }
  }
  me.el.setStyle('z-index', me.zIndex || index);
  if (Ext.isIE && !Ext.supports.CSS3BoxShadow) {
    me.el.dom.style.filter = 'progid:DXImageTransform.Microsoft.alpha(opacity\x3d' + me.opacity + ') progid:DXImageTransform.Microsoft.Blur(pixelradius\x3d' + me.offset + ')';
  }
  me.realign(xy[0], xy[1], target.dom.offsetWidth, target.dom.offsetHeight);
  me.el.dom.style.display = 'block';
}, isVisible:function() {
  return this.el ? true : false;
}, realign:function(l, t, targetWidth, targetHeight) {
  if (!this.el) {
    return;
  }
  var adjusts = this.adjusts, el = this.el, targetStyle = el.dom.style, shadowWidth, shadowHeight, sws, shs;
  el[this.localXYNames.set](l + adjusts.l, t + adjusts.t);
  shadowWidth = Math.max(targetWidth + adjusts.w, 0);
  shadowHeight = Math.max(targetHeight + adjusts.h, 0);
  sws = shadowWidth + 'px';
  shs = shadowHeight + 'px';
  if (targetStyle.width != sws || targetStyle.height != shs) {
    targetStyle.width = sws;
    targetStyle.height = shs;
    if (Ext.supports.CSS3BoxShadow) {
      targetStyle[this.boxShadowProperty] = '0 0 ' + (this.offset + 2) + 'px #888';
    }
  }
}, hide:function() {
  var me = this;
  if (me.el) {
    me.el.dom.style.display = 'none';
    Ext.ShadowPool.push(me.el);
    delete me.el;
  }
}, setZIndex:function(z) {
  this.zIndex = z;
  if (this.el) {
    this.el.setStyle('z-index', z);
  }
}, setOpacity:function(opacity) {
  if (this.el) {
    if (Ext.isIE && !Ext.supports.CSS3BoxShadow) {
      opacity = Math.floor(opacity * 100 / 2) / 100;
    }
    this.opacity = opacity;
    this.el.setOpacity(opacity);
  }
}});
Ext.define('Ext.app.EventDomain', {statics:{instances:{}}, isEventDomain:true, constructor:function() {
  var me = this;
  Ext.app.EventDomain.instances[me.type] = me;
  me.bus = {};
  me.monitoredClasses = [];
}, dispatch:function(target, ev, args) {
  var me = this, bus = me.bus, selectors = bus[ev], selector, controllers, id, events, event, i, ln;
  if (!selectors) {
    return true;
  }
  for (selector in selectors) {
    if (selectors.hasOwnProperty(selector) && me.match(target, selector)) {
      controllers = selectors[selector];
      for (id in controllers) {
        if (controllers.hasOwnProperty(id)) {
          events = controllers[id];
          for (i = 0, ln = events.length; i < ln; i++) {
            event = events[i];
            if (event.fire.apply(event, args) === false) {
              return false;
            }
          }
        }
      }
    }
  }
  return true;
}, listen:function(selectors, controller) {
  var me = this, bus = me.bus, idProperty = me.idProperty, monitoredClasses = me.monitoredClasses, monitoredClassesCount = monitoredClasses.length, i, tree, list, selector, options, listener, scope, event, listeners, ev;
  for (selector in selectors) {
    if (selectors.hasOwnProperty(selector) && (listeners = selectors[selector])) {
      if (idProperty) {
        if (!/^[*#]/.test(selector)) {
          Ext.Error.raise('Selectors containing id should begin with #');
        }
        selector = selector === '*' ? selector : selector.substring(1);
      }
      for (ev in listeners) {
        if (listeners.hasOwnProperty(ev)) {
          options = null;
          listener = listeners[ev];
          scope = controller;
          event = new Ext.util.Event(controller, ev);
          if (Ext.isObject(listener)) {
            options = listener;
            listener = options.fn;
            scope = options.scope || controller;
            delete options.fn;
            delete options.scope;
          }
          if (typeof listener === 'string') {
            listener = scope[listener];
          }
          event.addListener(listener, scope, options);
          for (i = monitoredClassesCount; i-- > 0;) {
            monitoredClasses[i].hasListeners._incr_(ev);
          }
          tree = bus[ev] || (bus[ev] = {});
          tree = tree[selector] || (tree[selector] = {});
          list = tree[controller.id] || (tree[controller.id] = []);
          list.push(event);
        }
      }
    }
  }
}, match:function(target, selector) {
  var idProperty = this.idProperty;
  if (idProperty) {
    return selector === '*' || target[idProperty] === selector;
  }
  return false;
}, monitor:function(observable) {
  var domain = this, prototype = observable.isInstance ? observable : observable.prototype, fireEventArgs = prototype.fireEventArgs;
  domain.monitoredClasses.push(observable);
  prototype.fireEventArgs = function(ev, args) {
    var ret = fireEventArgs.apply(this, arguments);
    if (ret !== false) {
      ret = domain.dispatch(this, ev, args);
    }
    return ret;
  };
}, unlisten:function(controllerId) {
  var bus = this.bus, controllers, ev, selector, selectors;
  for (ev in bus) {
    if (bus.hasOwnProperty(ev) && (selectors = bus[ev])) {
      for (selector in selectors) {
        controllers = selectors[selector];
        delete controllers[controllerId];
      }
    }
  }
}});
Ext.define('Ext.app.domain.Component', {extend:Ext.app.EventDomain, singleton:true, type:'component', constructor:function() {
  var me = this;
  me.callParent();
  me.monitor(Ext.Component);
}, match:function(target, selector) {
  return target.is(selector);
}});
Ext.define('Ext.app.EventBus', {singleton:true, constructor:function() {
  var me = this, domains = Ext.app.EventDomain.instances;
  me.callParent();
  me.domains = domains;
  me.bus = domains.component.bus;
}, control:function(selectors, controller) {
  return this.domains.component.listen(selectors, controller);
}, listen:function(to, controller) {
  var domains = this.domains, domain;
  for (domain in to) {
    if (to.hasOwnProperty(domain)) {
      domains[domain].listen(to[domain], controller);
    }
  }
}, unlisten:function(controllerId) {
  var domains = Ext.app.EventDomain.instances, domain;
  for (domain in domains) {
    domains[domain].unlisten(controllerId);
  }
}});
Ext.define('Ext.data.StoreManager', {extend:Ext.util.MixedCollection, alternateClassName:['Ext.StoreMgr', 'Ext.data.StoreMgr', 'Ext.StoreManager'], singleton:true, register:function() {
  for (var i = 0, s; s = arguments[i]; i++) {
    this.add(s);
  }
}, unregister:function() {
  for (var i = 0, s; s = arguments[i]; i++) {
    this.remove(this.lookup(s));
  }
}, lookup:function(store) {
  if (Ext.isArray(store)) {
    var fields = ['field1'], expand = !Ext.isArray(store[0]), data = store, i, len;
    if (expand) {
      data = [];
      for (i = 0, len = store.length; i < len; ++i) {
        data.push([store[i]]);
      }
    } else {
      for (i = 2, len = store[0].length; i <= len; ++i) {
        fields.push('field' + i);
      }
    }
    return new Ext.data.ArrayStore({data:data, fields:fields, autoDestroy:true, autoCreated:true, expanded:expand});
  }
  if (Ext.isString(store)) {
    return this.get(store);
  } else {
    return Ext.data.AbstractStore.create(store);
  }
}, getKey:function(o) {
  return o.storeId;
}}, function() {
  Ext.regStore = function(name, config) {
    var store;
    if (Ext.isObject(name)) {
      config = name;
    } else {
      config.storeId = name;
    }
    if (config instanceof Ext.data.Store) {
      store = config;
    } else {
      store = new Ext.data.Store(config);
    }
    return Ext.data.StoreManager.register(store);
  };
  Ext.getStore = function(name) {
    return Ext.data.StoreManager.lookup(name);
  };
});
Ext.define('Ext.app.domain.Global', {extend:Ext.app.EventDomain, singleton:true, type:'global', constructor:function() {
  var me = this;
  me.callParent();
  me.monitor(Ext.globalEvents);
}, listen:function(listeners, controller) {
  this.callParent([{global:listeners}, controller]);
}, match:function() {
  return true;
}});
Ext.define('Ext.data.ResultSet', {loaded:true, count:0, total:0, success:false, constructor:function(config) {
  Ext.apply(this, config);
  this.totalRecords = this.total;
  if (config.count === undefined) {
    this.count = this.records.length;
  }
}});
Ext.define('Ext.data.reader.Reader', {alternateClassName:['Ext.data.Reader', 'Ext.data.DataReader'], mixins:{observable:Ext.util.Observable}, totalProperty:'total', successProperty:'success', root:'', implicitIncludes:true, readRecordsOnFailure:true, isReader:true, applyDefaults:true, lastFieldGeneration:null, constructor:function(config) {
  var me = this;
  me.mixins.observable.constructor.call(me, config);
  me.fieldCount = 0;
  me.model = Ext.ModelManager.getModel(me.model);
  if (me.model && me.model.prototype.fields) {
    me.buildExtractors();
  }
  this.addEvents('exception');
}, setModel:function(model, setOnProxy) {
  var me = this;
  me.model = Ext.ModelManager.getModel(model);
  if (model) {
    me.buildExtractors(true);
  }
  if (setOnProxy && me.proxy) {
    me.proxy.setModel(me.model, true);
  }
}, read:function(response) {
  var data;
  if (response) {
    data = response.responseText ? this.getResponseData(response) : this.readRecords(response);
  }
  return data || this.nullResultSet;
}, readRecords:function(data) {
  var me = this, success, recordCount, records, root, total, value, message;
  if (me.lastFieldGeneration !== me.model.prototype.fields.generation) {
    me.buildExtractors(true);
  }
  me.rawData = data;
  data = me.getData(data);
  success = true;
  recordCount = 0;
  records = [];
  if (me.successProperty) {
    value = me.getSuccess(data);
    if (value === false || value === 'false') {
      success = false;
    }
  }
  if (me.messageProperty) {
    message = me.getMessage(data);
  }
  if (me.readRecordsOnFailure || success) {
    root = Ext.isArray(data) ? data : me.getRoot(data);
    if (root) {
      total = root.length;
    }
    if (me.totalProperty) {
      value = parseInt(me.getTotal(data), 10);
      if (!isNaN(value)) {
        total = value;
      }
    }
    if (root) {
      records = me.extractData(root);
      recordCount = records.length;
    }
  }
  return new Ext.data.ResultSet({total:total || recordCount, count:recordCount, records:records, success:success, message:message});
}, extractData:function(root) {
  var me = this, Model = me.model, length = root.length, records = new Array(length), convertedValues, node, record, i;
  if (!root.length && Ext.isObject(root)) {
    root = [root];
    length = 1;
  }
  for (i = 0; i < length; i++) {
    node = root[i];
    if (node.isModel) {
      records[i] = node;
    } else {
      records[i] = record = new Model(undefined, me.getId(node), node, convertedValues = {});
      record.phantom = false;
      me.convertRecordData(convertedValues, node, record);
      if (me.implicitIncludes && record.associations.length) {
        me.readAssociated(record, node);
      }
    }
  }
  return records;
}, readAssociated:function(record, data) {
  var associations = record.associations.items, i = 0, length = associations.length, association, associationData, proxy, reader;
  for (; i < length; i++) {
    association = associations[i];
    associationData = this.getAssociatedDataRoot(data, association.associationKeyFunction || association.associationKey || association.name);
    if (associationData) {
      reader = association.getReader();
      if (!reader) {
        proxy = association.associatedModel.getProxy();
        if (proxy) {
          reader = proxy.getReader();
        } else {
          reader = new this.constructor({model:association.associatedName});
        }
      }
      association.read(record, reader, associationData);
    }
  }
}, getAssociatedDataRoot:function(data, associationName) {
  if (Ext.isFunction(associationName)) {
    return associationName(data);
  }
  return data[associationName];
}, getFields:function() {
  return this.model.prototype.fields.items;
}, getData:Ext.identityFn, getRoot:Ext.identityFn, getResponseData:function(response) {
  Ext.Error.raise('getResponseData must be implemented in the Ext.data.reader.Reader subclass');
}, onMetaChange:function(meta) {
  var me = this, fields = meta.fields || me.getFields(), newModel, clientIdProperty;
  me.metaData = meta;
  me.root = meta.root || me.root;
  me.idProperty = meta.idProperty || me.idProperty;
  me.totalProperty = meta.totalProperty || me.totalProperty;
  me.successProperty = meta.successProperty || me.successProperty;
  me.messageProperty = meta.messageProperty || me.messageProperty;
  clientIdProperty = meta.clientIdProperty;
  if (me.model) {
    me.model.setFields(fields, me.idProperty, clientIdProperty);
    me.setModel(me.model, true);
  } else {
    newModel = Ext.define('Ext.data.reader.Json-Model' + Ext.id(), {extend:'Ext.data.Model', fields:fields, clientIdProperty:clientIdProperty});
    if (me.idProperty) {
      newModel.idProperty = me.idProperty;
    }
    me.setModel(newModel, true);
  }
}, getIdProperty:function() {
  var idField = this.model.prototype.idField, idProperty = this.idProperty;
  if (!idProperty && idField && (idProperty = idField.mapping) == null) {
    idProperty = idField.name;
  }
  return idProperty;
}, buildExtractors:function(force) {
  var me = this, idProp = me.getIdProperty(), totalProp = me.totalProperty, successProp = me.successProperty, messageProp = me.messageProperty, accessor;
  if (force === true) {
    delete me.convertRecordData;
  }
  if (me.convertRecordData) {
    return;
  }
  if (totalProp) {
    me.getTotal = me.createAccessor(totalProp);
  }
  if (successProp) {
    me.getSuccess = me.createAccessor(successProp);
  }
  if (messageProp) {
    me.getMessage = me.createAccessor(messageProp);
  }
  if (idProp) {
    accessor = me.createAccessor(idProp);
    me.getId = function(record) {
      var id = accessor.call(me, record);
      return id === undefined || id === '' ? null : id;
    };
  } else {
    me.getId = function() {
      return null;
    };
  }
  me.convertRecordData = me.buildRecordDataExtractor();
  me.lastFieldGeneration = me.model.prototype.fields.generation;
}, recordDataExtractorTemplate:['var me \x3d this\n', '    ,fields \x3d me.model.prototype.fields\n', '    ,value\n', '    ,internalId\n', '\x3ctpl for\x3d"fields"\x3e', '    ,__field{#} \x3d fields.map["{name}"]\n', '\x3c/tpl\x3e', ';\n', 'return function(dest, source, record) {\n', '\x3ctpl for\x3d"fields"\x3e', '{% var fieldAccessExpression \x3d  this.createFieldAccessExpression(values, "__field" + xindex, "source");', '   if (fieldAccessExpression) { %}', '    value \x3d {[ this.createFieldAccessExpression(values, "__field" + xindex, "source") ]};\n', 
'\x3ctpl if\x3d"hasCustomConvert"\x3e', '    dest["{name}"] \x3d value \x3d\x3d\x3d undefined ? __field{#}.convert(__field{#}.defaultValue, record) : __field{#}.convert(value, record);\n', '\x3ctpl elseif\x3d"defaultValue !\x3d\x3d undefined"\x3e', '    if (value \x3d\x3d\x3d undefined) {\n', '        if (me.applyDefaults) {\n', '\x3ctpl if\x3d"convert"\x3e', '            dest["{name}"] \x3d __field{#}.convert(__field{#}.defaultValue, record);\n', '\x3ctpl else\x3e', '            dest["{name}"] \x3d __field{#}.defaultValue\n', 
'\x3c/tpl\x3e', '        };\n', '    } else {\n', '\x3ctpl if\x3d"convert"\x3e', '        dest["{name}"] \x3d __field{#}.convert(value, record);\n', '\x3ctpl else\x3e', '        dest["{name}"] \x3d value;\n', '\x3c/tpl\x3e', '    };\n', '\x3ctpl else\x3e', '    if (value !\x3d\x3d undefined) {\n', '\x3ctpl if\x3d"convert"\x3e', '        dest["{name}"] \x3d __field{#}.convert(value, record);\n', '\x3ctpl else\x3e', '        dest["{name}"] \x3d value;\n', '\x3c/tpl\x3e', '    }\n', '\x3c/tpl\x3e', 
'{% } else { %}', '\x3ctpl if\x3d"defaultValue !\x3d\x3d undefined"\x3e', '\x3ctpl if\x3d"convert"\x3e', '    dest["{name}"] \x3d __field{#}.convert(__field{#}.defaultValue, record);\n', '\x3ctpl else\x3e', '    dest["{name}"] \x3d __field{#}.defaultValue\n', '\x3c/tpl\x3e', '\x3c/tpl\x3e', '{% } %}', '\x3c/tpl\x3e', '\x3ctpl if\x3d"clientIdProp"\x3e', '    if (record \x26\x26 (internalId \x3d {[ this.createFieldAccessExpression({mapping: values.clientIdProp}, null, "source") ]})) {\n', '        record.{["internalId"]} \x3d internalId;\n', 
'    }\n', '\x3c/tpl\x3e', '};'], buildRecordDataExtractor:function() {
  var me = this, modelProto = me.model.prototype, templateData = {clientIdProp:modelProto.clientIdProperty, fields:modelProto.fields.items};
  me.recordDataExtractorTemplate.createFieldAccessExpression = function() {
    return me.createFieldAccessExpression.apply(me, arguments);
  };
  return Ext.functionFactory(me.recordDataExtractorTemplate.apply(templateData)).call(me);
}, destroyReader:function() {
  var me = this;
  delete me.proxy;
  delete me.model;
  delete me.convertRecordData;
  delete me.getId;
  delete me.getTotal;
  delete me.getSuccess;
  delete me.getMessage;
}}, function() {
  var proto = this.prototype;
  Ext.apply(proto, {nullResultSet:new Ext.data.ResultSet({total:0, count:0, records:[], success:true, message:''}), recordDataExtractorTemplate:new Ext.XTemplate(proto.recordDataExtractorTemplate)});
});
Ext.define('Ext.data.reader.Json', {extend:Ext.data.reader.Reader, alternateClassName:'Ext.data.JsonReader', alias:'reader.json', root:'', metaProperty:'metaData', useSimpleAccessors:false, readRecords:function(data) {
  var me = this, meta;
  if (me.getMeta) {
    meta = me.getMeta(data);
    if (meta) {
      me.onMetaChange(meta);
    }
  } else {
    if (data.metaData) {
      me.onMetaChange(data.metaData);
    }
  }
  me.jsonData = data;
  return me.callParent([data]);
}, getResponseData:function(response) {
  var data, error;
  try {
    data = Ext.decode(response.responseText);
    return this.readRecords(data);
  } catch (ex) {
    error = new Ext.data.ResultSet({total:0, count:0, records:[], success:false, message:ex.message});
    this.fireEvent('exception', this, response, error);
    Ext.Logger.warn('Unable to parse the JSON returned by the server');
    return error;
  }
}, buildExtractors:function() {
  var me = this, metaProp = me.metaProperty;
  me.callParent(arguments);
  if (me.root) {
    me.getRoot = me.createAccessor(me.root);
  } else {
    me.getRoot = Ext.identityFn;
  }
  if (metaProp) {
    me.getMeta = me.createAccessor(metaProp);
  }
}, extractData:function(root) {
  var recordName = this.record, data = [], length, i;
  if (recordName) {
    length = root.length;
    if (!length && Ext.isObject(root)) {
      length = 1;
      root = [root];
    }
    for (i = 0; i < length; i++) {
      data[i] = root[i][recordName];
    }
  } else {
    data = root;
  }
  return this.callParent([data]);
}, createAccessor:function() {
  var re = /[\[\.]/;
  return function(expr) {
    if (Ext.isEmpty(expr)) {
      return Ext.emptyFn;
    }
    if (Ext.isFunction(expr)) {
      return expr;
    }
    if (this.useSimpleAccessors !== true) {
      var i = String(expr).search(re);
      if (i >= 0) {
        return Ext.functionFactory('obj', 'return obj' + (i > 0 ? '.' : '') + expr);
      }
    }
    return function(obj) {
      return obj[expr];
    };
  };
}(), createFieldAccessExpression:function() {
  var re = /[\[\.]/;
  return function(field, fieldVarName, dataName) {
    var mapping = field.mapping, hasMap = mapping || mapping === 0, map = hasMap ? mapping : field.name, result, operatorIndex;
    if (mapping === false) {
      return;
    }
    if (typeof map === 'function') {
      result = fieldVarName + '.mapping(' + dataName + ', this)';
    } else {
      if (this.useSimpleAccessors === true || (operatorIndex = String(map).search(re)) < 0) {
        if (!hasMap || isNaN(map)) {
          map = '"' + map + '"';
        }
        result = dataName + '[' + map + ']';
      } else {
        if (operatorIndex === 0) {
          result = dataName + map;
        } else {
          var parts = map.split('.'), len = parts.length, i = 1, tempResult = dataName + '.' + parts[0], buffer = [tempResult];
          for (; i < len; i++) {
            tempResult += '.' + parts[i];
            buffer.push(tempResult);
          }
          result = buffer.join(' \x26\x26 ');
        }
      }
    }
    return result;
  };
}()});
Ext.define('Ext.data.writer.Writer', {alias:'writer.base', alternateClassName:['Ext.data.DataWriter', 'Ext.data.Writer'], writeAllFields:true, nameProperty:'name', writeRecordId:true, isWriter:true, constructor:function(config) {
  Ext.apply(this, config);
}, write:function(request) {
  var operation = request.operation, records = operation.records || [], len = records.length, i = 0, data = [];
  for (; i < len; i++) {
    data.push(this.getRecordData(records[i], operation));
  }
  return this.writeRecords(request, data);
}, getRecordData:function(record, operation) {
  var isPhantom = record.phantom === true, writeAll = this.writeAllFields || isPhantom, fields = record.fields, fieldItems = fields.items, data = {}, clientIdProperty = record.clientIdProperty, changes, field, key, mappedIdProperty, f, fLen;
  if (writeAll) {
    fLen = fieldItems.length;
    for (f = 0; f < fLen; f++) {
      field = fieldItems[f];
      if (field.persist) {
        this.writeValue(data, field, record);
      }
    }
  } else {
    changes = record.getChanges();
    for (key in changes) {
      if (changes.hasOwnProperty(key)) {
        field = fields.get(key);
        if (field.persist) {
          this.writeValue(data, field, record);
        }
      }
    }
  }
  if (isPhantom) {
    if (clientIdProperty && operation && operation.records.length > 1) {
      data[clientIdProperty] = record.internalId;
    }
  } else {
    if (this.writeRecordId) {
      mappedIdProperty = fields.get(record.idProperty)[this.nameProperty] || record.idProperty;
      data[mappedIdProperty] = record.getId();
    }
  }
  return data;
}, writeValue:function(data, field, record) {
  var name = field[this.nameProperty], dateFormat = this.dateFormat || field.dateWriteFormat || field.dateFormat, value = record.get(field.name);
  if (name == null) {
    name = field.name;
  }
  if (field.serialize) {
    data[name] = field.serialize(value, record);
  } else {
    if (field.type === Ext.data.Types.DATE && dateFormat && Ext.isDate(value)) {
      data[name] = Ext.Date.format(value, dateFormat);
    } else {
      data[name] = value;
    }
  }
}});
Ext.define('Ext.data.writer.Json', {extend:Ext.data.writer.Writer, alternateClassName:'Ext.data.JsonWriter', alias:'writer.json', root:undefined, encode:false, allowSingle:true, expandData:false, getExpandedData:function(data) {
  var dataLength = data.length, i = 0, item, prop, nameParts, j, tempObj, toObject = function(name, value) {
    var o = {};
    o[name] = value;
    return o;
  };
  for (; i < dataLength; i++) {
    item = data[i];
    for (prop in item) {
      if (item.hasOwnProperty(prop)) {
        nameParts = prop.split('.');
        j = nameParts.length - 1;
        if (j > 0) {
          tempObj = item[prop];
          for (; j > 0; j--) {
            tempObj = toObject(nameParts[j], tempObj);
          }
          item[nameParts[0]] = item[nameParts[0]] || {};
          Ext.Object.merge(item[nameParts[0]], tempObj);
          delete item[prop];
        }
      }
    }
  }
  return data;
}, writeRecords:function(request, data) {
  var root = this.root;
  if (this.expandData) {
    data = this.getExpandedData(data);
  }
  if (this.allowSingle && data.length === 1) {
    data = data[0];
  }
  if (this.encode) {
    if (root) {
      request.params[root] = Ext.encode(data);
    } else {
      Ext.Error.raise('Must specify a root when using encode');
    }
  } else {
    request.jsonData = request.jsonData || {};
    if (root) {
      request.jsonData[root] = data;
    } else {
      request.jsonData = data;
    }
  }
  return request;
}});
Ext.define('Ext.data.proxy.Proxy', {alias:'proxy.proxy', alternateClassName:['Ext.data.DataProxy', 'Ext.data.Proxy'], mixins:{observable:Ext.util.Observable}, batchOrder:'create,update,destroy', batchActions:true, defaultReaderType:'json', defaultWriterType:'json', isProxy:true, isSynchronous:false, constructor:function(config) {
  var me = this;
  config = config || {};
  me.proxyConfig = config;
  me.mixins.observable.constructor.call(me, config);
  if (me.model !== undefined && !(me.model instanceof Ext.data.Model)) {
    me.setModel(me.model);
  } else {
    if (me.reader) {
      me.setReader(me.reader);
    }
    if (me.writer) {
      me.setWriter(me.writer);
    }
  }
}, setModel:function(model, setOnStore) {
  var me = this;
  me.model = Ext.ModelManager.getModel(model);
  me.setReader(this.reader);
  me.setWriter(this.writer);
  if (setOnStore && me.store) {
    me.store.setModel(me.model);
  }
}, getModel:function() {
  return this.model;
}, setReader:function(reader) {
  var me = this, needsCopy = true, current = me.reader;
  if (reader === undefined || typeof reader == 'string') {
    reader = {type:reader};
    needsCopy = false;
  }
  if (reader.isReader) {
    reader.setModel(me.model);
  } else {
    if (needsCopy) {
      reader = Ext.apply({}, reader);
    }
    Ext.applyIf(reader, {proxy:me, model:me.model, type:me.defaultReaderType});
    reader = Ext.createByAlias('reader.' + reader.type, reader);
  }
  if (reader !== current && reader.onMetaChange) {
    reader.onMetaChange = Ext.Function.createSequence(reader.onMetaChange, this.onMetaChange, this);
  }
  me.reader = reader;
  return me.reader;
}, getReader:function() {
  return this.reader;
}, onMetaChange:function(meta) {
  this.fireEvent('metachange', this, meta);
}, setWriter:function(writer) {
  var me = this, needsCopy = true;
  if (writer === undefined || typeof writer == 'string') {
    writer = {type:writer};
    needsCopy = false;
  }
  if (!writer.isWriter) {
    if (needsCopy) {
      writer = Ext.apply({}, writer);
    }
    Ext.applyIf(writer, {model:me.model, type:me.defaultWriterType});
    writer = Ext.createByAlias('writer.' + writer.type, writer);
  }
  me.writer = writer;
  return me.writer;
}, getWriter:function() {
  return this.writer;
}, create:Ext.emptyFn, read:Ext.emptyFn, update:Ext.emptyFn, destroy:Ext.emptyFn, batch:function(options, listeners) {
  var me = this, useBatch = me.batchActions, batch, records, actions, aLen, action, a, r, rLen, record;
  if (options.operations === undefined) {
    options = {operations:options, listeners:listeners};
  }
  if (options.batch) {
    if (Ext.isDefined(options.batch.runOperation)) {
      batch = Ext.applyIf(options.batch, {proxy:me, listeners:{}});
    }
  } else {
    options.batch = {proxy:me, listeners:options.listeners || {}};
  }
  if (!batch) {
    batch = new Ext.data.Batch(options.batch);
  }
  batch.on('complete', Ext.bind(me.onBatchComplete, me, [options], 0));
  actions = me.batchOrder.split(',');
  aLen = actions.length;
  for (a = 0; a < aLen; a++) {
    action = actions[a];
    records = options.operations[action];
    if (records) {
      if (useBatch) {
        batch.add(new Ext.data.Operation({action:action, records:records}));
      } else {
        rLen = records.length;
        for (r = 0; r < rLen; r++) {
          record = records[r];
          batch.add(new Ext.data.Operation({action:action, records:[record]}));
        }
      }
    }
  }
  batch.start();
  return batch;
}, onBatchComplete:function(batchOptions, batch) {
  var scope = batchOptions.scope || this;
  if (batch.hasException) {
    if (Ext.isFunction(batchOptions.failure)) {
      Ext.callback(batchOptions.failure, scope, [batch, batchOptions]);
    }
  } else {
    if (Ext.isFunction(batchOptions.success)) {
      Ext.callback(batchOptions.success, scope, [batch, batchOptions]);
    }
  }
  if (Ext.isFunction(batchOptions.callback)) {
    Ext.callback(batchOptions.callback, scope, [batch, batchOptions]);
  }
}, clone:function() {
  return new this.self(this.proxyConfig);
}});
Ext.define('Ext.data.Operation', {synchronous:true, action:undefined, filters:undefined, sorters:undefined, groupers:undefined, start:undefined, limit:undefined, batch:undefined, callback:undefined, scope:undefined, started:false, running:false, complete:false, success:undefined, exception:false, error:undefined, actionCommitRecordsRe:/^(?:create|update)$/i, actionSkipSyncRe:/^destroy$/i, constructor:function(config) {
  Ext.apply(this, config || {});
}, commitRecords:function(serverRecords) {
  var me = this, commitRecords = me.actionCommitRecordsRe.test(me.action), mc, index, clientRecords, serverRec, clientRec, i, len, modifiedFields, recordModifiedFields;
  if (!me.actionSkipSyncRe.test(me.action)) {
    clientRecords = me.records;
    if (clientRecords && clientRecords.length) {
      if (commitRecords) {
        recordModifiedFields = [];
      }
      if (clientRecords.length > 1) {
        if (me.action == 'update' || clientRecords[0].clientIdProperty) {
          mc = new Ext.util.MixedCollection;
          mc.addAll(serverRecords);
          for (index = clientRecords.length; index--;) {
            clientRec = clientRecords[index];
            serverRec = mc.findBy(me.matchClientRec, clientRec);
            modifiedFields = clientRec.copyFrom(serverRec);
            if (commitRecords) {
              recordModifiedFields.push(modifiedFields);
            }
          }
        } else {
          for (i = 0, len = clientRecords.length; i < len; ++i) {
            clientRec = clientRecords[i];
            serverRec = serverRecords[i];
            if (clientRec && serverRec) {
              modifiedFields = me.updateRecord(clientRec, serverRec);
              if (commitRecords) {
                recordModifiedFields.push(modifiedFields);
              }
            }
          }
        }
      } else {
        modifiedFields = me.updateRecord(clientRecords[0], serverRecords[0]);
        if (commitRecords) {
          recordModifiedFields[0] = modifiedFields;
        }
      }
      if (commitRecords) {
        for (index = clientRecords.length; index--;) {
          clientRecords[index].commit(false, recordModifiedFields[index]);
        }
      }
    }
  }
}, updateRecord:function(clientRec, serverRec) {
  if (serverRec && (clientRec.phantom || clientRec.getId() === serverRec.getId())) {
    return clientRec.copyFrom(serverRec);
  }
  return [];
}, matchClientRec:function(record) {
  var clientRec = this, clientRecordId = clientRec.getId();
  if (clientRecordId && record.getId() === clientRecordId) {
    return true;
  }
  return record.internalId === clientRec.internalId;
}, setStarted:function() {
  this.started = true;
  this.running = true;
}, setCompleted:function() {
  this.complete = true;
  this.running = false;
}, setSuccessful:function() {
  this.success = true;
}, setException:function(error) {
  this.exception = true;
  this.success = false;
  this.running = false;
  this.error = error;
}, hasException:function() {
  return this.exception === true;
}, getError:function() {
  return this.error;
}, getRecords:function() {
  var resultSet = this.getResultSet();
  return this.records || (resultSet ? resultSet.records : null);
}, getResultSet:function() {
  return this.resultSet;
}, isStarted:function() {
  return this.started === true;
}, isRunning:function() {
  return this.running === true;
}, isComplete:function() {
  return this.complete === true;
}, wasSuccessful:function() {
  return this.isComplete() && this.success === true;
}, setBatch:function(batch) {
  this.batch = batch;
}, allowWrite:function() {
  return this.action != 'read';
}});
Ext.define('Ext.data.AbstractStore', {mixins:{observable:Ext.util.Observable, sortable:Ext.util.Sortable}, statics:{create:function(store) {
  if (!store.isStore) {
    if (!store.type) {
      store.type = 'store';
    }
    store = Ext.createByAlias('store.' + store.type, store);
  }
  return store;
}}, onClassExtended:function(cls, data, hooks) {
  var model = data.model, onBeforeClassCreated;
  if (typeof model == 'string') {
    onBeforeClassCreated = hooks.onBeforeCreated;
    hooks.onBeforeCreated = function() {
      var me = this, args = arguments;
      Ext.require(model, function() {
        onBeforeClassCreated.apply(me, args);
      });
    };
  }
}, remoteSort:false, remoteFilter:false, autoLoad:undefined, autoSync:false, batchUpdateMode:'operation', filterOnLoad:true, sortOnLoad:true, implicitModel:false, defaultProxyType:'memory', isDestroyed:false, isStore:true, sortRoot:'data', constructor:function(config) {
  var me = this, filters;
  Ext.apply(me, config);
  me.removed = [];
  me.mixins.observable.constructor.apply(me, arguments);
  var configModel = me.model;
  me.model = Ext.ModelManager.getModel(me.model);
  Ext.applyIf(me, {modelDefaults:null});
  if (!me.model && me.fields) {
    me.model = Ext.define('Ext.data.Store.ImplicitModel-' + (me.storeId || Ext.id()), {extend:'Ext.data.Model', fields:me.fields, proxy:me.proxy || me.defaultProxyType});
    delete me.fields;
    me.implicitModel = true;
  }
  if (!me.model && me.useModelWarning !== false) {
    var logMsg = [Ext.getClassName(me) || 'Store', ' created with no model.'];
    if (typeof configModel === 'string') {
      logMsg.push(" The name '", configModel, "'", ' does not correspond to a valid model.');
    }
    Ext.log.warn(logMsg.join(''));
  }
  me.setProxy(me.proxy || me.model.getProxy());
  if (!me.disableMetaChangeEvent) {
    me.proxy.on('metachange', me.onMetaChange, me);
  }
  if (me.id && !me.storeId) {
    me.storeId = me.id;
    delete me.id;
  }
  if (me.storeId) {
    Ext.data.StoreManager.register(me);
  }
  me.mixins.sortable.initSortable.call(me);
  filters = me.decodeFilters(me.filters);
  me.filters = new Ext.util.MixedCollection;
  me.filters.addAll(filters);
}, setProxy:function(proxy) {
  var me = this;
  if (proxy instanceof Ext.data.proxy.Proxy) {
    proxy.setModel(me.model);
  } else {
    if (Ext.isString(proxy)) {
      proxy = {type:proxy};
    }
    Ext.applyIf(proxy, {model:me.model});
    proxy = Ext.createByAlias('proxy.' + proxy.type, proxy);
  }
  me.proxy = proxy;
  return me.proxy;
}, getProxy:function() {
  return this.proxy;
}, onMetaChange:function(proxy, meta) {
  this.fireEvent('metachange', this, meta);
}, create:function(data, options) {
  var me = this, instance = Ext.ModelManager.create(Ext.applyIf(data, me.modelDefaults), me.model.modelName), operation;
  options = options || {};
  Ext.applyIf(options, {action:'create', records:[instance]});
  operation = new Ext.data.Operation(options);
  me.proxy.create(operation, me.onProxyWrite, me);
  return instance;
}, read:function() {
  return this.load.apply(this, arguments);
}, update:function(options) {
  var me = this, operation;
  options = options || {};
  Ext.applyIf(options, {action:'update', records:me.getUpdatedRecords()});
  operation = new Ext.data.Operation(options);
  return me.proxy.update(operation, me.onProxyWrite, me);
}, onProxyWrite:function(operation) {
  var me = this, success = operation.wasSuccessful(), records = operation.getRecords();
  switch(operation.action) {
    case 'create':
      me.onCreateRecords(records, operation, success);
      break;
    case 'update':
      me.onUpdateRecords(records, operation, success);
      break;
    case 'destroy':
      me.onDestroyRecords(records, operation, success);
      break;
  }
  if (success) {
    me.fireEvent('write', me, operation);
    me.fireEvent('datachanged', me);
    me.fireEvent('refresh', me);
  }
  Ext.callback(operation.callback, operation.scope || me, [records, operation, success]);
}, onCreateRecords:Ext.emptyFn, onUpdateRecords:Ext.emptyFn, onDestroyRecords:function(records, operation, success) {
  if (success) {
    this.removed = [];
  }
}, destroy:function(options) {
  var me = this, operation;
  options = options || {};
  Ext.applyIf(options, {action:'destroy', records:me.getRemovedRecords()});
  operation = new Ext.data.Operation(options);
  return me.proxy.destroy(operation, me.onProxyWrite, me);
}, onBatchOperationComplete:function(batch, operation) {
  return this.onProxyWrite(operation);
}, onBatchComplete:function(batch, operation) {
  var me = this, operations = batch.operations, length = operations.length, i;
  me.suspendEvents();
  for (i = 0; i < length; i++) {
    me.onProxyWrite(operations[i]);
  }
  me.resumeEvents();
  me.fireEvent('datachanged', me);
  me.fireEvent('refresh', me);
}, onBatchException:function(batch, operation) {
}, filterNew:function(item) {
  return item.phantom === true && item.isValid();
}, getNewRecords:function() {
  return [];
}, getUpdatedRecords:function() {
  return [];
}, getModifiedRecords:function() {
  return [].concat(this.getNewRecords(), this.getUpdatedRecords());
}, filterUpdated:function(item) {
  return item.dirty === true && item.phantom !== true && item.isValid();
}, getRemovedRecords:function() {
  return this.removed;
}, filter:function(filters, value) {
}, decodeFilters:function(filters) {
  if (!Ext.isArray(filters)) {
    if (filters === undefined) {
      filters = [];
    } else {
      filters = [filters];
    }
  }
  var length = filters.length, Filter = Ext.util.Filter, config, i;
  for (i = 0; i < length; i++) {
    config = filters[i];
    if (!(config instanceof Filter)) {
      Ext.apply(config, {root:'data'});
      if (config.fn) {
        config.filterFn = config.fn;
      }
      if (typeof config == 'function') {
        config = {filterFn:config};
      }
      filters[i] = new Filter(config);
    }
  }
  return filters;
}, clearFilter:function(supressEvent) {
}, isFiltered:function() {
}, filterBy:function(fn, scope) {
}, sync:function(options) {
  var me = this, operations = {}, toCreate = me.getNewRecords(), toUpdate = me.getUpdatedRecords(), toDestroy = me.getRemovedRecords(), needsSync = false;
  if (toCreate.length > 0) {
    operations.create = toCreate;
    needsSync = true;
  }
  if (toUpdate.length > 0) {
    operations.update = toUpdate;
    needsSync = true;
  }
  if (toDestroy.length > 0) {
    operations.destroy = toDestroy;
    needsSync = true;
  }
  if (needsSync && me.fireEvent('beforesync', operations) !== false) {
    options = options || {};
    me.proxy.batch(Ext.apply(options, {operations:operations, listeners:me.getBatchListeners()}));
  }
  return me;
}, getBatchListeners:function() {
  var me = this, listeners = {scope:me, exception:me.onBatchException};
  if (me.batchUpdateMode == 'operation') {
    listeners.operationcomplete = me.onBatchOperationComplete;
  } else {
    listeners.complete = me.onBatchComplete;
  }
  return listeners;
}, save:function() {
  return this.sync.apply(this, arguments);
}, load:function(options) {
  var me = this, operation;
  options = Ext.apply({action:'read', filters:me.filters.items, sorters:me.getSorters()}, options);
  me.lastOptions = options;
  operation = new Ext.data.Operation(options);
  if (me.fireEvent('beforeload', me, operation) !== false) {
    me.loading = true;
    me.proxy.read(operation, me.onProxyLoad, me);
  }
  return me;
}, reload:function(options) {
  return this.load(Ext.apply(this.lastOptions, options));
}, afterEdit:function(record, modifiedFieldNames) {
  var me = this, i, shouldSync;
  if (me.autoSync && !me.autoSyncSuspended) {
    for (i = modifiedFieldNames.length; i--;) {
      if (record.fields.get(modifiedFieldNames[i]).persist) {
        shouldSync = true;
        break;
      }
    }
    if (shouldSync) {
      me.sync();
    }
  }
  me.onUpdate(record, Ext.data.Model.EDIT, modifiedFieldNames);
  me.fireEvent('update', me, record, Ext.data.Model.EDIT, modifiedFieldNames);
}, afterReject:function(record) {
  this.onUpdate(record, Ext.data.Model.REJECT, null);
  this.fireEvent('update', this, record, Ext.data.Model.REJECT, null);
}, afterCommit:function(record, modifiedFieldNames) {
  if (!modifiedFieldNames) {
    modifiedFieldNames = null;
  }
  this.onUpdate(record, Ext.data.Model.COMMIT, modifiedFieldNames);
  this.fireEvent('update', this, record, Ext.data.Model.COMMIT, modifiedFieldNames);
}, onUpdate:Ext.emptyFn, onIdChanged:function(model, oldId, newId, oldInternalId) {
  this.fireEvent('idchanged', this, model, oldId, newId, oldInternalId);
}, destroyStore:function() {
  var implicitModelName, me = this;
  if (!me.isDestroyed) {
    me.clearListeners();
    if (me.storeId) {
      Ext.data.StoreManager.unregister(me);
    }
    me.clearData();
    me.data = me.tree = me.sorters = me.filters = me.groupers = null;
    if (me.reader) {
      me.reader.destroyReader();
    }
    me.proxy = me.reader = me.writer = null;
    me.isDestroyed = true;
    if (me.implicitModel) {
      implicitModelName = Ext.getClassName(me.model);
      Ext.undefine(implicitModelName);
      Ext.ModelManager.unregisterType(implicitModelName);
    } else {
      me.model = null;
    }
  }
}, getState:function() {
  var me = this, hasState, result, hasGroupers = !!me.groupers, groupers = [], sorters = [], filters = [];
  if (hasGroupers) {
    me.groupers.each(function(g) {
      groupers[groupers.length] = g.serialize();
      hasState = true;
    });
  }
  if (me.sorters) {
    me.sorters.each(function(s) {
      if (hasGroupers && !me.groupers.contains(s)) {
        sorters[sorters.length] = s.serialize();
        hasState = true;
      }
    });
  }
  if (me.filters && me.statefulFilters) {
    me.filters.each(function(f) {
      filters[filters.length] = f.serialize();
      hasState = true;
    });
  }
  if (hasState) {
    result = {};
    if (groupers.length) {
      result.groupers = groupers;
    }
    if (sorters.length) {
      result.sorters = sorters;
    }
    if (filters.length) {
      result.filters = filters;
    }
    return result;
  }
}, applyState:function(state) {
  var me = this, hasSorters = !!me.sorters, hasGroupers = !!me.groupers, hasFilters = !!me.filters, locallySorted;
  if (hasGroupers && state.groupers) {
    me.groupers.clear();
    me.groupers.addAll(me.decodeGroupers(state.groupers));
  }
  if (hasSorters && state.sorters) {
    me.sorters.clear();
    me.sorters.addAll(me.decodeSorters(state.sorters));
  }
  if (hasFilters && state.filters) {
    me.filters.clear();
    me.filters.addAll(me.decodeFilters(state.filters));
  }
  if (hasSorters && hasGroupers) {
    me.sorters.insert(0, me.groupers.getRange());
  }
  if (me.autoLoad && (me.remoteSort || me.remoteGroup || me.remoteFilter)) {
    if (me.autoLoad === true) {
      me.reload();
    } else {
      me.reload(me.autoLoad);
    }
  }
  if (hasFilters && me.filters.length && !me.remoteFilter) {
    me.filter();
    locallySorted = me.sortOnFilter;
  }
  if (hasSorters && me.sorters.length && !me.remoteSort && !locallySorted) {
    me.sort();
  }
}, doSort:function(sorterFn) {
  var me = this;
  if (me.remoteSort) {
    me.load();
  } else {
    me.data.sortBy(sorterFn);
    me.fireEvent('datachanged', me);
    me.fireEvent('refresh', me);
  }
  me.fireEvent('sort', me, me.sorters.getRange());
}, clearData:Ext.emptyFn, getCount:Ext.emptyFn, getById:Ext.emptyFn, removeAll:Ext.emptyFn, isLoading:function() {
  return !!this.loading;
}, suspendAutoSync:function() {
  this.autoSyncSuspended = true;
}, resumeAutoSync:function() {
  this.autoSyncSuspended = false;
}});
Ext.define('Ext.app.domain.Store', {extend:Ext.app.EventDomain, singleton:true, type:'store', idProperty:'storeId', constructor:function() {
  var me = this;
  me.callParent();
  me.monitor(Ext.data.AbstractStore);
}});
Ext.define('Ext.app.Controller', {mixins:{observable:Ext.util.Observable}, statics:{strings:{model:{getter:'getModel', upper:'Model'}, view:{getter:'getView', upper:'View'}, controller:{getter:'getController', upper:'Controller'}, store:{getter:'getStore', upper:'Store'}}, controllerRegex:/^(.*)\.controller\./, createGetter:function(baseGetter, name) {
  return function() {
    return this[baseGetter](name);
  };
}, getGetterName:function(name, kindUpper) {
  var fn = 'get', parts = name.split('.'), numParts = parts.length, index;
  for (index = 0; index < numParts; index++) {
    fn += Ext.String.capitalize(parts[index]);
  }
  fn += kindUpper;
  return fn;
}, processDependencies:function(cls, requires, namespace, kind, names) {
  if (!names || !names.length) {
    return;
  }
  var me = this, strings = me.strings[kind], o, absoluteName, shortName, name, j, subLn, getterName, getter;
  if (!Ext.isArray(names)) {
    names = [names];
  }
  for (j = 0, subLn = names.length; j < subLn; j++) {
    name = names[j];
    o = me.getFullName(name, kind, namespace);
    absoluteName = o.absoluteName;
    shortName = o.shortName;
    requires.push(absoluteName);
    getterName = me.getGetterName(shortName, strings.upper);
    cls[getterName] = getter = me.createGetter(strings.getter, name);
    if (kind !== 'controller') {
      getter['Ext.app.getter'] = true;
    }
  }
}, getFullName:function(name, kind, namespace) {
  var shortName = name, sep, absoluteName;
  if ((sep = name.indexOf('@')) > 0) {
    shortName = name.substring(0, sep);
    absoluteName = name.substring(sep + 1) + '.' + shortName;
  } else {
    if (name.indexOf('.') > 0 && (Ext.ClassManager.isCreated(name) || Ext.Loader.isAClassNameWithAKnownPrefix(name))) {
      absoluteName = name;
    } else {
      if (!namespace) {
        Ext.log.warn('Cannot find namespace for ' + kind + ' ' + name + ', ' + 'assuming it is fully qualified class name');
      }
      if (namespace) {
        absoluteName = namespace + '.' + kind + '.' + name;
        shortName = name;
      } else {
        absoluteName = name;
      }
    }
  }
  return {absoluteName:absoluteName, shortName:shortName};
}}, application:null, onClassExtended:function(cls, data, hooks) {
  var onBeforeClassCreated = hooks.onBeforeCreated;
  hooks.onBeforeCreated = function(cls, data) {
    var Controller = Ext.app.Controller, ctrlRegex = Controller.controllerRegex, requires = [], className, namespace, requires, proto, match;
    proto = cls.prototype;
    className = Ext.getClassName(cls);
    namespace = data.$namespace || Ext.app.getNamespace(className) || (match = ctrlRegex.exec(className)) && match[1];
    if (namespace) {
      proto.$namespace = namespace;
    } else {
      Ext.log.warn('Missing namespace for ' + className + ', please define it ' + 'in namespaces property of your Application class.');
    }
    Controller.processDependencies(proto, requires, namespace, 'model', data.models);
    Controller.processDependencies(proto, requires, namespace, 'view', data.views);
    Controller.processDependencies(proto, requires, namespace, 'store', data.stores);
    Controller.processDependencies(proto, requires, namespace, 'controller', data.controllers);
    Ext.require(requires, Ext.Function.pass(onBeforeClassCreated, arguments, this));
  };
}, constructor:function(config) {
  var me = this;
  me.mixins.observable.constructor.call(me, config);
  if (me.refs) {
    me.ref(me.refs);
  }
  me.eventbus = Ext.app.EventBus;
  me.initAutoGetters();
}, initAutoGetters:function() {
  var proto = this.self.prototype, prop, fn;
  for (prop in proto) {
    fn = proto[prop];
    if (fn && fn['Ext.app.getter']) {
      fn.call(this);
    }
  }
}, doInit:function(app) {
  var me = this;
  if (!me._initialized) {
    me.init(app);
    me._initialized = true;
  }
}, finishInit:function(app) {
  var me = this, controllers = me.controllers, controller, i, l;
  if (me._initialized && controllers && controllers.length) {
    for (i = 0, l = controllers.length; i < l; i++) {
      controller = me.getController(controllers[i]);
      controller.finishInit(app);
    }
  }
}, init:Ext.emptyFn, onLaunch:Ext.emptyFn, ref:function(refs) {
  var me = this, i = 0, length = refs.length, info, ref, fn;
  refs = Ext.Array.from(refs);
  me.references = me.references || [];
  for (; i < length; i++) {
    info = refs[i];
    ref = info.ref;
    fn = 'get' + Ext.String.capitalize(ref);
    if (!me[fn]) {
      me[fn] = Ext.Function.pass(me.getRef, [ref, info], me);
    }
    me.references.push(ref.toLowerCase());
  }
}, addRef:function(refs) {
  this.ref(refs);
}, getRef:function(ref, info, config) {
  var me = this, refCache = me.refCache || (me.refCache = {}), cached = refCache[ref];
  info = info || {};
  config = config || {};
  Ext.apply(info, config);
  if (info.forceCreate) {
    return Ext.ComponentManager.create(info, 'component');
  }
  if (!cached) {
    if (info.selector) {
      refCache[ref] = cached = Ext.ComponentQuery.query(info.selector)[0];
    }
    if (!cached && info.autoCreate) {
      refCache[ref] = cached = Ext.ComponentManager.create(info, 'component');
    }
    if (cached) {
      cached.on('beforedestroy', function() {
        refCache[ref] = null;
      });
    }
  }
  return cached;
}, hasRef:function(ref) {
  var references = this.references;
  return references && Ext.Array.indexOf(references, ref.toLowerCase()) !== -1;
}, control:function(selectors, listeners, controller) {
  var me = this, ctrl = controller, obj;
  if (Ext.isString(selectors)) {
    obj = {};
    obj[selectors] = listeners;
  } else {
    obj = selectors;
    ctrl = listeners;
  }
  me.eventbus.control(obj, ctrl || me);
}, listen:function(to, controller) {
  this.eventbus.listen(to, controller || this);
}, getController:function(id) {
  var me = this, app = me.application;
  if (id === me.id) {
    return me;
  }
  return app && app.getController(id);
}, getStore:function(name) {
  var storeId, store;
  storeId = name.indexOf('@') == -1 ? name : name.split('@')[0];
  store = Ext.StoreManager.get(storeId);
  if (!store) {
    name = Ext.app.Controller.getFullName(name, 'store', this.$namespace);
    if (name) {
      store = Ext.create(name.absoluteName, {storeId:storeId});
    }
  }
  return store;
}, getModel:function(model) {
  var name = Ext.app.Controller.getFullName(model, 'model', this.$namespace);
  return name && Ext.ModelManager.getModel(name.absoluteName);
}, getView:function(view) {
  var name = Ext.app.Controller.getFullName(view, 'view', this.$namespace);
  return name && Ext.ClassManager.get(name.absoluteName);
}, getApplication:function() {
  return this.application;
}});
Ext.define('Ext.container.DockingContainer', {isDockingContainer:true, defaultDockWeights:{top:{render:1, visual:1}, left:{render:3, visual:5}, right:{render:5, visual:7}, bottom:{render:7, visual:3}}, dockOrder:{top:-1, left:-1, right:1, bottom:1}, horizontalDocks:0, addDocked:function(items, pos) {
  var me = this, i = 0, item, length;
  items = me.prepareItems(items);
  length = items.length;
  for (; i < length; i++) {
    item = items[i];
    item.dock = item.dock || 'top';
    if (item.dock === 'left' || item.dock === 'right') {
      me.horizontalDocks++;
    }
    if (pos !== undefined) {
      i += pos;
      me.dockedItems.insert(i, item);
    } else {
      me.dockedItems.add(item);
    }
    item.onAdded(me, i);
    if (me.hasListeners.dockedadd) {
      me.fireEvent('dockedadd', me, item, i);
    }
    if (me.onDockedAdd !== Ext.emptyFn) {
      me.onDockedAdd(item);
    }
  }
  if (me.rendered && !me.suspendLayout) {
    me.updateLayout();
  }
  return items;
}, destroyDockedItems:function() {
  var dockedItems = this.dockedItems, c;
  if (dockedItems) {
    while (c = dockedItems.first()) {
      this.removeDocked(c, true);
    }
  }
}, doRenderDockedItems:function(out, renderData, after) {
  var me = renderData.$comp, layout = me.componentLayout, items, tree;
  if (layout.getDockedItems && !renderData.$skipDockedItems) {
    items = layout.getDockedItems('render', !after);
    tree = items && layout.getItemsRenderTree(items);
    if (tree) {
      Ext.DomHelper.generateMarkup(tree, out);
    }
  }
}, getDockedComponent:function(comp) {
  if (Ext.isObject(comp)) {
    comp = comp.getItemId();
  }
  return this.dockedItems.get(comp);
}, getDockedItems:function(selector, beforeBody) {
  var dockedItems = this.getComponentLayout().getDockedItems('render', beforeBody);
  if (selector && dockedItems.length) {
    dockedItems = Ext.ComponentQuery.query(selector, dockedItems);
  }
  return dockedItems;
}, getDockingRefItems:function(deep, containerItems) {
  var selector = deep && '*,* *', dockedItems = this.getDockedItems(selector, true), items;
  dockedItems.push.apply(dockedItems, containerItems);
  items = this.getDockedItems(selector, false);
  dockedItems.push.apply(dockedItems, items);
  return dockedItems;
}, initDockingItems:function() {
  var me = this, items = me.dockedItems;
  me.dockedItems = new Ext.util.AbstractMixedCollection(false, me.getComponentId);
  if (items) {
    me.addDocked(items);
  }
}, insertDocked:function(pos, items) {
  this.addDocked(items, pos);
}, onDockedAdd:Ext.emptyFn, onDockedRemove:Ext.emptyFn, removeDocked:function(item, autoDestroy) {
  var me = this, layout, hasLayout;
  autoDestroy = autoDestroy === true || autoDestroy !== false && me.autoDestroy;
  if (!me.dockedItems.contains(item)) {
    return item;
  }
  if (item.dock === 'left' || item.dock === 'right') {
    me.horizontalDocks--;
  }
  layout = me.componentLayout;
  hasLayout = layout && me.rendered;
  if (hasLayout) {
    layout.onRemove(item);
  }
  me.dockedItems.remove(item);
  item.onRemoved(item.destroying || autoDestroy);
  me.onDockedRemove(item);
  if (autoDestroy) {
    item.destroy();
  } else {
    if (hasLayout) {
      layout.afterRemove(item);
    }
  }
  if (me.hasListeners.dockedremove) {
    me.fireEvent('dockedremove', me, item);
  }
  if (!me.destroying && !me.suspendLayout) {
    me.updateLayout();
  }
  return item;
}, setupDockingRenderTpl:function(renderTpl) {
  renderTpl.renderDockedItems = this.doRenderDockedItems;
}});
Ext.define('Ext.toolbar.Fill', {extend:Ext.Component, alias:'widget.tbfill', alternateClassName:'Ext.Toolbar.Fill', isFill:true, flex:1});
Ext.define('Ext.layout.container.boxOverflow.None', {alternateClassName:'Ext.layout.boxOverflow.None', constructor:function(layout, config) {
  this.layout = layout;
  Ext.apply(this, config);
}, handleOverflow:Ext.emptyFn, clearOverflow:Ext.emptyFn, beginLayout:Ext.emptyFn, beginLayoutCycle:Ext.emptyFn, calculate:function(ownerContext) {
  var me = this, plan = ownerContext.state.boxPlan, overflow;
  if (plan && plan.tooNarrow) {
    overflow = me.handleOverflow(ownerContext);
    if (overflow) {
      if (overflow.reservedSpace) {
        me.layout.publishInnerCtSize(ownerContext, overflow.reservedSpace);
      }
    }
  } else {
    me.clearOverflow();
  }
}, completeLayout:Ext.emptyFn, finishedLayout:function(ownerContext) {
  var me = this, owner = me.layout.owner, hiddens, hiddenCount;
  if (owner.hasListeners.overflowchange) {
    hiddens = owner.query('\x3e[hidden]');
    hiddenCount = hiddens.length;
    if (hiddenCount !== me.lastHiddenCount) {
      owner.fireEvent('overflowchange', me.lastHiddenCount, hiddenCount, hiddens);
      me.lastHiddenCount = hiddenCount;
    }
  }
}, onRemove:Ext.emptyFn, getItem:function(item) {
  return this.layout.owner.getComponent(item);
}, getOwnerType:function(owner) {
  var type;
  if (owner.isToolbar) {
    type = 'toolbar';
  } else {
    if (owner.isTabBar) {
      type = 'tabbar';
    } else {
      if (owner.isMenu) {
        type = 'menu';
      } else {
        type = owner.getXType();
      }
    }
  }
  return type;
}, getPrefixConfig:Ext.emptyFn, getSuffixConfig:Ext.emptyFn, getOverflowCls:function() {
  return '';
}});
Ext.define('Ext.toolbar.Item', {extend:Ext.Component, alias:'widget.tbitem', alternateClassName:'Ext.Toolbar.Item', enable:Ext.emptyFn, disable:Ext.emptyFn, focus:Ext.emptyFn});
Ext.define('Ext.toolbar.Separator', {extend:Ext.toolbar.Item, alias:'widget.tbseparator', alternateClassName:'Ext.Toolbar.Separator', baseCls:Ext.baseCSSPrefix + 'toolbar-separator', focusable:false});
Ext.define('Ext.button.Manager', {singleton:true, alternateClassName:'Ext.ButtonToggleManager', groups:{}, pressedButton:null, buttonSelector:'.' + Ext.baseCSSPrefix + 'btn', init:function() {
  var me = this;
  if (!me.initialized) {
    Ext.getDoc().on({keydown:me.onDocumentKeyDown, mouseup:me.onDocumentMouseUp, scope:me});
    me.initialized = true;
  }
}, onDocumentKeyDown:function(e) {
  var k = e.getKey(), btn;
  if (k === e.SPACE || k === e.ENTER) {
    btn = e.getTarget(this.buttonSelector);
    if (btn) {
      Ext.getCmp(btn.id).onClick(e);
    }
  }
}, onButtonMousedown:function(button, e) {
  var pressed = this.pressedButton;
  if (pressed) {
    pressed.onMouseUp(e);
  }
  this.pressedButton = button;
}, onDocumentMouseUp:function(e) {
  var pressed = this.pressedButton;
  if (pressed) {
    pressed.onMouseUp(e);
    this.pressedButton = null;
  }
}, toggleGroup:function(btn, state) {
  if (state) {
    var g = this.groups[btn.toggleGroup], length = g.length, i;
    for (i = 0; i < length; i++) {
      if (g[i] !== btn) {
        g[i].toggle(false);
      }
    }
  }
}, register:function(btn) {
  var me = this, groups = this.groups, group = groups[btn.toggleGroup];
  me.init();
  if (!btn.toggleGroup) {
    return;
  }
  if (!group) {
    group = groups[btn.toggleGroup] = [];
  }
  group.push(btn);
  btn.on('toggle', me.toggleGroup, me);
}, unregister:function(btn) {
  if (!btn.toggleGroup) {
    return;
  }
  var me = this, group = me.groups[btn.toggleGroup];
  if (group) {
    Ext.Array.remove(group, btn);
    btn.un('toggle', me.toggleGroup, me);
  }
}, getPressed:function(group) {
  var g = this.groups[group], i = 0, len;
  if (g) {
    for (len = g.length; i < len; i++) {
      if (g[i].pressed === true) {
        return g[i];
      }
    }
  }
  return null;
}});
Ext.define('Ext.menu.Manager', {singleton:true, alternateClassName:'Ext.menu.MenuMgr', menuSelector:'.' + Ext.baseCSSPrefix + 'menu', menus:{}, groups:{}, attached:false, lastShow:new Date, init:function() {
  var me = this;
  me.active = new Ext.util.MixedCollection;
  Ext.getDoc().addKeyListener(27, function() {
    if (me.active.length > 0) {
      me.hideAll();
    }
  }, me);
}, hideAll:function() {
  var active = this.active, menus, m, mLen;
  if (active && active.length > 0) {
    menus = Ext.Array.slice(active.items);
    mLen = menus.length;
    for (m = 0; m < mLen; m++) {
      menus[m].hide();
    }
    return true;
  }
  return false;
}, onHide:function(m) {
  var me = this, active = me.active;
  active.remove(m);
  if (active.length < 1) {
    Ext.getDoc().un('mousedown', me.onMouseDown, me);
    me.attached = false;
  }
}, onShow:function(m) {
  var me = this, active = me.active, attached = me.attached;
  me.lastShow = new Date;
  active.add(m);
  if (!attached) {
    Ext.getDoc().on('mousedown', me.onMouseDown, me, {buffer:Ext.isIE9m ? 10 : undefined});
    me.attached = true;
  }
  m.toFront();
}, onBeforeHide:function(m) {
  if (m.activeChild) {
    m.activeChild.hide();
  }
  if (m.autoHideTimer) {
    clearTimeout(m.autoHideTimer);
    delete m.autoHideTimer;
  }
}, onBeforeShow:function(m) {
  var active = this.active, parentMenu = m.parentMenu;
  active.remove(m);
  if (!parentMenu && !m.allowOtherMenus) {
    this.hideAll();
  } else {
    if (parentMenu && parentMenu.activeChild && m != parentMenu.activeChild) {
      parentMenu.activeChild.hide();
    }
  }
}, onMouseDown:function(e) {
  var me = this, active = me.active, lastShow = me.lastShow, doHide = true;
  if (Ext.Date.getElapsed(lastShow) > 50 && active.length > 0 && !e.getTarget(me.menuSelector)) {
    if (Ext.isIE9m && !Ext.getDoc().contains(e.target)) {
      doHide = false;
    }
    if (doHide) {
      me.hideAll();
    }
  }
}, register:function(menu) {
  var me = this;
  if (!me.active) {
    me.init();
  }
  if (menu.floating) {
    me.menus[menu.id] = menu;
    menu.on({beforehide:me.onBeforeHide, hide:me.onHide, beforeshow:me.onBeforeShow, show:me.onShow, scope:me});
  }
}, get:function(menu) {
  var menus = this.menus;
  if (typeof menu == 'string') {
    if (!menus) {
      return null;
    }
    return menus[menu];
  } else {
    if (menu.isMenu) {
      return menu;
    } else {
      if (Ext.isArray(menu)) {
        return new Ext.menu.Menu({items:menu});
      } else {
        return Ext.ComponentManager.create(menu, 'menu');
      }
    }
  }
}, unregister:function(menu) {
  var me = this, menus = me.menus, active = me.active;
  delete menus[menu.id];
  active.remove(menu);
  menu.un({beforehide:me.onBeforeHide, hide:me.onHide, beforeshow:me.onBeforeShow, show:me.onShow, scope:me});
}, registerCheckable:function(menuItem) {
  var groups = this.groups, groupId = menuItem.group;
  if (groupId) {
    if (!groups[groupId]) {
      groups[groupId] = [];
    }
    groups[groupId].push(menuItem);
  }
}, unregisterCheckable:function(menuItem) {
  var groups = this.groups, groupId = menuItem.group;
  if (groupId) {
    Ext.Array.remove(groups[groupId], menuItem);
  }
}, onCheckChange:function(menuItem, state) {
  var groups = this.groups, groupId = menuItem.group, i = 0, group, ln, curr;
  if (groupId && state) {
    group = groups[groupId];
    ln = group.length;
    for (; i < ln; i++) {
      curr = group[i];
      if (curr != menuItem) {
        curr.setChecked(false);
      }
    }
  }
}});
Ext.define('Ext.util.ClickRepeater', {extend:Ext.util.Observable, constructor:function(el, config) {
  var me = this;
  me.el = Ext.get(el);
  me.el.unselectable();
  Ext.apply(me, config);
  me.callParent();
  me.addEvents('mousedown', 'click', 'mouseup');
  if (!me.disabled) {
    me.disabled = true;
    me.enable();
  }
  if (me.handler) {
    me.on('click', me.handler, me.scope || me);
  }
}, interval:20, delay:250, preventDefault:true, stopDefault:false, timer:0, enable:function() {
  if (this.disabled) {
    this.el.on('mousedown', this.handleMouseDown, this);
    if (Ext.isIE && !(Ext.isIE10p || Ext.isStrict && Ext.isIE9)) {
      this.el.on('dblclick', this.handleDblClick, this);
    }
    if (this.preventDefault || this.stopDefault) {
      this.el.on('click', this.eventOptions, this);
    }
  }
  this.disabled = false;
}, disable:function(force) {
  if (force || !this.disabled) {
    clearTimeout(this.timer);
    if (this.pressedCls) {
      this.el.removeCls(this.pressedCls);
    }
    Ext.getDoc().un('mouseup', this.handleMouseUp, this);
    this.el.removeAllListeners();
  }
  this.disabled = true;
}, setDisabled:function(disabled) {
  this[disabled ? 'disable' : 'enable']();
}, eventOptions:function(e) {
  if (this.preventDefault) {
    e.preventDefault();
  }
  if (this.stopDefault) {
    e.stopEvent();
  }
}, destroy:function() {
  this.disable(true);
  Ext.destroy(this.el);
  this.clearListeners();
}, handleDblClick:function(e) {
  clearTimeout(this.timer);
  this.el.blur();
  this.fireEvent('mousedown', this, e);
  this.fireEvent('click', this, e);
}, handleMouseDown:function(e) {
  clearTimeout(this.timer);
  this.el.blur();
  if (this.pressedCls) {
    this.el.addCls(this.pressedCls);
  }
  this.mousedownTime = new Date;
  Ext.getDoc().on('mouseup', this.handleMouseUp, this);
  this.el.on('mouseout', this.handleMouseOut, this);
  this.fireEvent('mousedown', this, e);
  this.fireEvent('click', this, e);
  if (this.accelerate) {
    this.delay = 400;
  }
  e = new Ext.EventObjectImpl(e);
  this.timer = Ext.defer(this.click, this.delay || this.interval, this, [e]);
}, click:function(e) {
  this.fireEvent('click', this, e);
  this.timer = Ext.defer(this.click, this.accelerate ? this.easeOutExpo(Ext.Date.getElapsed(this.mousedownTime), 400, -390, 12000) : this.interval, this, [e]);
}, easeOutExpo:function(t, b, c, d) {
  return t == d ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
}, handleMouseOut:function() {
  clearTimeout(this.timer);
  if (this.pressedCls) {
    this.el.removeCls(this.pressedCls);
  }
  this.el.on('mouseover', this.handleMouseReturn, this);
}, handleMouseReturn:function() {
  this.el.un('mouseover', this.handleMouseReturn, this);
  if (this.pressedCls) {
    this.el.addCls(this.pressedCls);
  }
  this.click();
}, handleMouseUp:function(e) {
  clearTimeout(this.timer);
  this.el.un('mouseover', this.handleMouseReturn, this);
  this.el.un('mouseout', this.handleMouseOut, this);
  Ext.getDoc().un('mouseup', this.handleMouseUp, this);
  if (this.pressedCls) {
    this.el.removeCls(this.pressedCls);
  }
  this.fireEvent('mouseup', this, e);
}});
Ext.define('Ext.layout.component.Button', {alias:['layout.button'], extend:Ext.layout.component.Auto, type:'button', htmlRE:/<.*>/, beginLayout:function(ownerContext) {
  var me = this, owner = me.owner, text = owner.text;
  me.callParent(arguments);
  ownerContext.btnWrapContext = ownerContext.getEl('btnWrap');
  ownerContext.btnElContext = ownerContext.getEl('btnEl');
  ownerContext.btnInnerElContext = ownerContext.getEl('btnInnerEl');
  ownerContext.btnIconElContext = ownerContext.getEl('btnIconEl');
  if (text && me.htmlRE.test(text)) {
    ownerContext.isHtmlText = true;
    owner.btnInnerEl.setStyle('line-height', 'normal');
    owner.btnInnerEl.setStyle('padding-top', '');
  }
}, beginLayoutCycle:function(ownerContext) {
  var owner = this.owner, lastWidthModel = this.lastWidthModel;
  this.callParent(arguments);
  if (lastWidthModel && !this.lastWidthModel.shrinkWrap && ownerContext.widthModel.shrinkWrap) {
    owner.btnWrap.setStyle('height', '');
    owner.btnEl.setStyle('height', '');
    owner.btnInnerEl.setStyle('line-height', '');
  }
}, calculate:function(ownerContext) {
  var me = this, owner = me.owner, btnElContext = ownerContext.btnElContext, btnInnerElContext = ownerContext.btnInnerElContext, btnWrapContext = ownerContext.btnWrapContext, mmax = Math.max, ownerHeight, contentHeight, btnElHeight, innerElHeight;
  me.callParent(arguments);
  if (ownerContext.heightModel.shrinkWrap) {
    btnElHeight = owner.btnEl.getHeight();
    if (ownerContext.isHtmlText) {
      me.centerInnerEl(ownerContext, btnElHeight);
      me.ieCenterIcon(ownerContext, btnElHeight);
    }
  } else {
    ownerHeight = ownerContext.getProp('height');
    if (ownerHeight) {
      contentHeight = ownerHeight - ownerContext.getFrameInfo().height - ownerContext.getPaddingInfo().height;
      btnElHeight = contentHeight;
      if ((owner.menu || owner.split) && owner.arrowAlign === 'bottom') {
        btnElHeight -= btnWrapContext.getPaddingInfo().bottom;
      }
      innerElHeight = btnElHeight;
      if ((owner.icon || owner.iconCls || owner.glyph) && (owner.iconAlign === 'top' || owner.iconAlign === 'bottom')) {
        innerElHeight -= btnInnerElContext.getPaddingInfo().height;
      }
      btnWrapContext.setProp('height', mmax(0, contentHeight));
      btnElContext.setProp('height', mmax(0, btnElHeight));
      if (ownerContext.isHtmlText) {
        me.centerInnerEl(ownerContext, btnElHeight);
      } else {
        btnInnerElContext.setProp('line-height', mmax(0, innerElHeight) + 'px');
      }
      me.ieCenterIcon(ownerContext, btnElHeight);
    } else {
      if (ownerHeight !== 0) {
        me.done = false;
      }
    }
  }
}, centerInnerEl:function(ownerContext, btnElHeight) {
  var me = this, btnInnerElContext = ownerContext.btnInnerElContext, innerElHeight = me.owner.btnInnerEl.getHeight();
  if (ownerContext.heightModel.shrinkWrap && btnElHeight < innerElHeight) {
    ownerContext.btnElContext.setHeight(innerElHeight);
  } else {
    if (btnElHeight > innerElHeight) {
      btnInnerElContext.setProp('padding-top', Math.round((btnElHeight - innerElHeight) / 2) + btnInnerElContext.getPaddingInfo().top);
    }
  }
}, ieCenterIcon:function(ownerContext, btnElHeight) {
  var iconAlign = this.owner.iconAlign;
  if ((Ext.isIEQuirks || Ext.isIE6) && (iconAlign === 'left' || iconAlign === 'right')) {
    ownerContext.btnIconElContext.setHeight(btnElHeight);
  }
}, publishInnerWidth:function(ownerContext, width) {
  if (this.owner.getFrameInfo().table) {
    ownerContext.btnInnerElContext.setWidth(width - ownerContext.getFrameInfo().width - ownerContext.getPaddingInfo().width - ownerContext.btnWrapContext.getPaddingInfo().width);
  }
}});
Ext.define('Ext.util.TextMetrics', {statics:{shared:null, measure:function(el, text, fixedWidth) {
  var me = this, shared = me.shared;
  if (!shared) {
    shared = me.shared = new me(el, fixedWidth);
  }
  shared.bind(el);
  shared.setFixedWidth(fixedWidth || 'auto');
  return shared.getSize(text);
}, destroy:function() {
  var me = this;
  Ext.destroy(me.shared);
  me.shared = null;
}}, constructor:function(bindTo, fixedWidth) {
  var me = this, measure = Ext.getBody().createChild({cls:Ext.baseCSSPrefix + 'textmetrics'});
  me.measure = measure;
  if (bindTo) {
    me.bind(bindTo);
  }
  measure.position('absolute');
  measure.setLocalXY(-1000, -1000);
  measure.hide();
  if (fixedWidth) {
    measure.setWidth(fixedWidth);
  }
}, getSize:function(text) {
  var measure = this.measure, size;
  measure.update(text);
  size = measure.getSize();
  measure.update('');
  return size;
}, bind:function(el) {
  var me = this;
  me.el = Ext.get(el);
  me.measure.setStyle(me.el.getStyles('font-size', 'font-style', 'font-weight', 'font-family', 'line-height', 'text-transform', 'letter-spacing'));
}, setFixedWidth:function(width) {
  this.measure.setWidth(width);
}, getWidth:function(text) {
  this.measure.dom.style.width = 'auto';
  return this.getSize(text).width;
}, getHeight:function(text) {
  return this.getSize(text).height;
}, destroy:function() {
  var me = this;
  me.measure.remove();
  delete me.el;
  delete me.measure;
}}, function() {
  Ext.Element.addMethods({getTextWidth:function(text, min, max) {
    return Ext.Number.constrain(Ext.util.TextMetrics.measure(this.dom, Ext.value(text, this.dom.innerHTML, true)).width, min || 0, max || 1000000);
  }});
});
Ext.define('Ext.button.Button', {alias:'widget.button', extend:Ext.Component, mixins:{queryable:Ext.Queryable}, alternateClassName:'Ext.Button', isButton:true, componentLayout:'button', hidden:false, disabled:false, pressed:false, tabIndex:0, enableToggle:false, menuAlign:'tl-bl?', showEmptyMenu:false, textAlign:'center', clickEvent:'click', preventDefault:true, handleMouseEvents:true, tooltipType:'qtip', baseCls:Ext.baseCSSPrefix + 'btn', pressedCls:'pressed', overCls:'over', focusCls:'focus', menuActiveCls:'menu-active', 
hrefTarget:'_blank', childEls:['btnEl', 'btnWrap', 'btnInnerEl', 'btnIconEl'], renderTpl:['\x3cspan id\x3d"{id}-btnWrap" class\x3d"{baseCls}-wrap', '\x3ctpl if\x3d"splitCls"\x3e {splitCls}\x3c/tpl\x3e', '{childElCls}" unselectable\x3d"on"\x3e', '\x3cspan id\x3d"{id}-btnEl" class\x3d"{baseCls}-button"\x3e', '\x3cspan id\x3d"{id}-btnInnerEl" class\x3d"{baseCls}-inner {innerCls}', '{childElCls}" unselectable\x3d"on"\x3e', '{text}', '\x3c/span\x3e', '\x3cspan role\x3d"img" id\x3d"{id}-btnIconEl" class\x3d"{baseCls}-icon-el {iconCls}', 
'{childElCls} {glyphCls}" unselectable\x3d"on" style\x3d"', '\x3ctpl if\x3d"iconUrl"\x3ebackground-image:url({iconUrl});\x3c/tpl\x3e', '\x3ctpl if\x3d"glyph \x26\x26 glyphFontFamily"\x3efont-family:{glyphFontFamily};\x3c/tpl\x3e"\x3e', '\x3ctpl if\x3d"glyph"\x3e\x26#{glyph};\x3c/tpl\x3e\x3ctpl if\x3d"iconCls || iconUrl"\x3e\x26#160;\x3c/tpl\x3e', '\x3c/span\x3e', '\x3c/span\x3e', '\x3c/span\x3e', '\x3ctpl if\x3d"closable"\x3e', '\x3cspan id\x3d"{id}-closeEl" class\x3d"{baseCls}-close-btn" title\x3d"{closeText}" tabIndex\x3d"0"\x3e\x3c/span\x3e', 
'\x3c/tpl\x3e'], scale:'small', allowedScales:['small', 'medium', 'large'], iconAlign:'left', arrowAlign:'right', arrowCls:'arrow', maskOnDisable:false, shrinkWrap:3, frame:true, _triggerRegion:{}, initComponent:function() {
  var me = this;
  me.autoEl = {tag:'a', role:'button', hidefocus:'on', unselectable:'on'};
  me.addCls('x-unselectable');
  me.callParent(arguments);
  me.addEvents('click', 'toggle', 'mouseover', 'mouseout', 'menushow', 'menuhide', 'menutriggerover', 'menutriggerout', 'textchange', 'iconchange', 'glyphchange');
  if (me.menu) {
    me.split = true;
    me.menu = Ext.menu.Manager.get(me.menu);
    me.menu.ownerButton = me;
  }
  if (me.url) {
    me.href = me.url;
  }
  if (me.href && !me.hasOwnProperty('preventDefault')) {
    me.preventDefault = false;
  }
  if (Ext.isString(me.toggleGroup) && me.toggleGroup !== '') {
    me.enableToggle = true;
  }
  if (me.html && !me.text) {
    me.text = me.html;
    delete me.html;
  }
  me.glyphCls = me.baseCls + '-glyph';
}, getActionEl:function() {
  return this.el;
}, getFocusEl:function() {
  return this.el;
}, onDisable:function() {
  this.callParent(arguments);
}, setComponentCls:function() {
  var me = this, cls = me.getComponentCls();
  if (!Ext.isEmpty(me.oldCls)) {
    me.removeClsWithUI(me.oldCls);
    me.removeClsWithUI(me.pressedCls);
  }
  me.oldCls = cls;
  me.addClsWithUI(cls);
}, getComponentCls:function() {
  var me = this, cls;
  if (me.iconCls || me.icon || me.glyph) {
    cls = [me.text ? 'icon-text-' + me.iconAlign : 'icon'];
  } else {
    if (me.text) {
      cls = ['noicon'];
    } else {
      cls = [];
    }
  }
  if (me.pressed) {
    cls[cls.length] = me.pressedCls;
  }
  return cls;
}, beforeRender:function() {
  var me = this, autoEl = me.autoEl, href = me.getHref(), hrefTarget = me.hrefTarget;
  if (!me.disabled) {
    autoEl.tabIndex = me.tabIndex;
  }
  if (href) {
    autoEl.href = href;
    if (hrefTarget) {
      autoEl.target = hrefTarget;
    }
  }
  me.callParent();
  me.oldCls = me.getComponentCls();
  me.addClsWithUI(me.oldCls);
  Ext.applyIf(me.renderData, me.getTemplateArgs());
}, onRender:function() {
  var me = this, addOnclick, btn, btnListeners;
  me.doc = Ext.getDoc();
  me.callParent(arguments);
  btn = me.el;
  if (me.tooltip) {
    me.setTooltip(me.tooltip, true);
  }
  if (me.handleMouseEvents) {
    btnListeners = {scope:me, mouseover:me.onMouseOver, mouseout:me.onMouseOut, mousedown:me.onMouseDown};
    if (me.split) {
      btnListeners.mousemove = me.onMouseMove;
    }
  } else {
    btnListeners = {scope:me};
  }
  if (me.menu) {
    me.mon(me.menu, {scope:me, show:me.onMenuShow, hide:me.onMenuHide});
    me.keyMap = new Ext.util.KeyMap({target:me.el, key:Ext.EventObject.DOWN, handler:me.onDownKey, scope:me});
  }
  if (me.repeat) {
    me.mon(new Ext.util.ClickRepeater(btn, Ext.isObject(me.repeat) ? me.repeat : {}), 'click', me.onRepeatClick, me);
  } else {
    if (btnListeners[me.clickEvent]) {
      addOnclick = true;
    } else {
      btnListeners[me.clickEvent] = me.onClick;
    }
  }
  me.mon(btn, btnListeners);
  if (addOnclick) {
    me.mon(btn, me.clickEvent, me.onClick, me);
  }
  Ext.button.Manager.register(me);
}, getTemplateArgs:function() {
  var me = this, glyph = me.glyph, glyphFontFamily = Ext._glyphFontFamily, glyphParts;
  if (typeof glyph === 'string') {
    glyphParts = glyph.split('@');
    glyph = glyphParts[0];
    glyphFontFamily = glyphParts[1];
  }
  return {innerCls:me.getInnerCls(), splitCls:me.getSplitCls(), iconUrl:me.icon, iconCls:me.iconCls, glyph:glyph, glyphCls:glyph ? me.glyphCls : '', glyphFontFamily:glyphFontFamily, text:me.text || '\x26#160;'};
}, setHref:function(href) {
  this.href = href;
  this.el.dom.href = this.getHref();
}, getHref:function() {
  var me = this, href = me.href;
  return href ? Ext.urlAppend(href, Ext.Object.toQueryString(Ext.apply({}, me.params, me.baseParams))) : false;
}, setParams:function(params) {
  this.params = params;
  this.el.dom.href = this.getHref();
}, getSplitCls:function() {
  var me = this;
  return me.split ? me.baseCls + '-' + me.arrowCls + ' ' + (me.baseCls + '-' + me.arrowCls + '-' + me.arrowAlign) : '';
}, getInnerCls:function() {
  return this.textAlign ? this.baseCls + '-inner-' + this.textAlign : '';
}, setIcon:function(icon) {
  icon = icon || '';
  var me = this, btnIconEl = me.btnIconEl, oldIcon = me.icon || '';
  me.icon = icon;
  if (icon != oldIcon) {
    if (btnIconEl) {
      btnIconEl.setStyle('background-image', icon ? 'url(' + icon + ')' : '');
      me.setComponentCls();
      if (me.didIconStateChange(oldIcon, icon)) {
        me.updateLayout();
      }
    }
    me.fireEvent('iconchange', me, oldIcon, icon);
  }
  return me;
}, setIconCls:function(cls) {
  cls = cls || '';
  var me = this, btnIconEl = me.btnIconEl, oldCls = me.iconCls || '';
  me.iconCls = cls;
  if (oldCls != cls) {
    if (btnIconEl) {
      btnIconEl.removeCls(oldCls);
      btnIconEl.addCls(cls);
      me.setComponentCls();
      if (me.didIconStateChange(oldCls, cls)) {
        me.updateLayout();
      }
    }
    me.fireEvent('iconchange', me, oldCls, cls);
  }
  return me;
}, setGlyph:function(glyph) {
  glyph = glyph || 0;
  var me = this, btnIconEl = me.btnIconEl, oldGlyph = me.glyph, fontFamily, glyphParts;
  me.glyph = glyph;
  if (btnIconEl) {
    if (typeof glyph === 'string') {
      glyphParts = glyph.split('@');
      glyph = glyphParts[0];
      fontFamily = glyphParts[1] || Ext._glyphFontFamily;
    }
    if (!glyph) {
      btnIconEl.dom.innerHTML = '';
    } else {
      if (oldGlyph != glyph) {
        btnIconEl.dom.innerHTML = '\x26#' + glyph + ';';
      }
    }
    if (fontFamily) {
      btnIconEl.setStyle('font-family', fontFamily);
    }
  }
  me.fireEvent('glyphchange', me, me.glyph, oldGlyph);
  return me;
}, setTooltip:function(tooltip, initial) {
  var me = this;
  if (me.rendered) {
    if (!initial || !tooltip) {
      me.clearTip();
    }
    if (tooltip) {
      if (Ext.quickTipsActive && Ext.isObject(tooltip)) {
        Ext.tip.QuickTipManager.register(Ext.apply({target:me.el.id}, tooltip));
        me.tooltip = tooltip;
      } else {
        me.el.dom.setAttribute(me.getTipAttr(), tooltip);
      }
    }
  } else {
    me.tooltip = tooltip;
  }
  return me;
}, setTextAlign:function(align) {
  var me = this, btnEl = me.btnEl;
  if (btnEl) {
    btnEl.removeCls(me.baseCls + '-inner-' + me.textAlign);
    btnEl.addCls(me.baseCls + '-inner-' + align);
  }
  me.textAlign = align;
  return me;
}, getTipAttr:function() {
  return this.tooltipType == 'qtip' ? 'data-qtip' : 'title';
}, getRefItems:function(deep) {
  var menu = this.menu, items;
  if (menu) {
    items = menu.getRefItems(deep);
    items.unshift(menu);
  }
  return items || [];
}, clearTip:function() {
  var me = this, el = me.el;
  if (Ext.quickTipsActive && Ext.isObject(me.tooltip)) {
    Ext.tip.QuickTipManager.unregister(el);
  } else {
    el.dom.removeAttribute(me.getTipAttr());
  }
}, beforeDestroy:function() {
  var me = this;
  if (me.rendered) {
    me.clearTip();
  }
  if (me.menu && me.destroyMenu !== false) {
    Ext.destroy(me.menu);
  }
  Ext.destroy(me.btnInnerEl, me.repeater);
  me.callParent();
}, onDestroy:function() {
  var me = this;
  if (me.rendered) {
    me.doc.un('mouseover', me.monitorMouseOver, me);
    delete me.doc;
    Ext.destroy(me.keyMap);
    delete me.keyMap;
  }
  Ext.button.Manager.unregister(me);
  me.callParent();
}, setHandler:function(handler, scope) {
  this.handler = handler;
  this.scope = scope;
  return this;
}, setText:function(text) {
  text = text || '';
  var me = this, oldText = me.text || '';
  if (text != oldText) {
    me.text = text;
    if (me.rendered) {
      me.btnInnerEl.update(text || '\x26#160;');
      me.setComponentCls();
      if (Ext.isStrict && Ext.isIE8) {
        me.el.repaint();
      }
      me.updateLayout();
    }
    me.fireEvent('textchange', me, oldText, text);
  }
  return me;
}, didIconStateChange:function(old, current) {
  var currentEmpty = Ext.isEmpty(current);
  return Ext.isEmpty(old) ? !currentEmpty : currentEmpty;
}, getText:function() {
  return this.text;
}, toggle:function(state, suppressEvent) {
  var me = this;
  state = state === undefined ? !me.pressed : !!state;
  if (state !== me.pressed) {
    if (me.rendered) {
      me[state ? 'addClsWithUI' : 'removeClsWithUI'](me.pressedCls);
    }
    me.pressed = state;
    if (!suppressEvent) {
      me.fireEvent('toggle', me, state);
      Ext.callback(me.toggleHandler, me.scope || me, [me, state]);
    }
  }
  return me;
}, maybeShowMenu:function() {
  var me = this;
  if (me.menu && !me.hasVisibleMenu() && !me.ignoreNextClick) {
    me.showMenu(true);
  }
}, showMenu:function(fromEvent) {
  var me = this, menu = me.menu;
  if (me.rendered) {
    if (me.tooltip && Ext.quickTipsActive && me.getTipAttr() != 'title') {
      Ext.tip.QuickTipManager.getQuickTip().cancelShow(me.el);
    }
    if (menu.isVisible()) {
      menu.hide();
    }
    if (!fromEvent || me.showEmptyMenu || menu.items.getCount() > 0) {
      menu.showBy(me.el, me.menuAlign);
    }
  }
  return me;
}, hideMenu:function() {
  if (this.hasVisibleMenu()) {
    this.menu.hide();
  }
  return this;
}, hasVisibleMenu:function() {
  var menu = this.menu;
  return menu && menu.rendered && menu.isVisible();
}, onRepeatClick:function(repeat, e) {
  this.onClick(e);
}, onClick:function(e) {
  var me = this;
  if (me.preventDefault || me.disabled && me.getHref() && e) {
    e.preventDefault();
  }
  if (e.type !== 'keydown' && e.button !== 0) {
    return;
  }
  if (!me.disabled) {
    me.doToggle();
    me.maybeShowMenu();
    me.fireHandler(e);
  }
}, fireHandler:function(e) {
  var me = this, handler = me.handler;
  if (me.fireEvent('click', me, e) !== false) {
    if (handler) {
      handler.call(me.scope || me, me, e);
    }
  }
}, doToggle:function() {
  var me = this;
  if (me.enableToggle && (me.allowDepress !== false || !me.pressed)) {
    me.toggle();
  }
}, onMouseOver:function(e) {
  var me = this;
  if (!me.disabled && !e.within(me.el, true, true)) {
    me.onMouseEnter(e);
  }
}, onMouseOut:function(e) {
  var me = this;
  if (!e.within(me.el, true, true)) {
    if (me.overMenuTrigger) {
      me.onMenuTriggerOut(e);
    }
    me.onMouseLeave(e);
  }
}, onMouseMove:function(e) {
  var me = this, el = me.el, over = me.overMenuTrigger, overPosition, triggerRegion;
  if (me.split) {
    overPosition = me.arrowAlign === 'right' ? e.getX() - me.getX() : e.getY() - el.getY();
    triggerRegion = me.getTriggerRegion();
    if (overPosition > triggerRegion.begin && overPosition < triggerRegion.end) {
      if (!over) {
        me.onMenuTriggerOver(e);
      }
    } else {
      if (over) {
        me.onMenuTriggerOut(e);
      }
    }
  }
}, getTriggerRegion:function() {
  var me = this, region = me._triggerRegion, triggerSize = me.getTriggerSize(), btnSize = me.arrowAlign === 'right' ? me.getWidth() : me.getHeight();
  region.begin = btnSize - triggerSize;
  region.end = btnSize;
  return region;
}, getTriggerSize:function() {
  var me = this, size = me.triggerSize, side, sideFirstLetter;
  if (size == null) {
    side = me.arrowAlign;
    sideFirstLetter = side.charAt(0);
    size = me.triggerSize = me.el.getFrameWidth(sideFirstLetter) + me.getBtnWrapFrameWidth(sideFirstLetter);
    if (me.frameSize) {
      size = me.triggerSize += me.frameSize[side];
    }
  }
  return size;
}, getBtnWrapFrameWidth:function(side) {
  return this.btnWrap.getFrameWidth(side);
}, addOverCls:function() {
  if (!this.disabled) {
    this.addClsWithUI(this.overCls);
  }
}, removeOverCls:function() {
  this.removeClsWithUI(this.overCls);
}, onMouseEnter:function(e) {
  this.fireEvent('mouseover', this, e);
}, onMouseLeave:function(e) {
  this.fireEvent('mouseout', this, e);
}, onMenuTriggerOver:function(e) {
  var me = this, arrowTip = me.arrowTooltip;
  me.overMenuTrigger = true;
  if (me.split && arrowTip) {
    me.btnWrap.dom.setAttribute(me.getTipAttr(), arrowTip);
  }
  me.fireEvent('menutriggerover', me, me.menu, e);
}, onMenuTriggerOut:function(e) {
  var me = this;
  delete me.overMenuTrigger;
  if (me.split && me.arrowTooltip) {
    me.btnWrap.dom.setAttribute(me.getTipAttr(), '');
  }
  me.fireEvent('menutriggerout', me, me.menu, e);
}, enable:function(silent) {
  var me = this;
  me.callParent(arguments);
  me.removeClsWithUI('disabled');
  if (me.rendered) {
    me.el.dom.setAttribute('tabIndex', me.tabIndex);
  }
  return me;
}, disable:function(silent) {
  var me = this;
  me.callParent(arguments);
  me.addClsWithUI('disabled');
  me.removeClsWithUI(me.overCls);
  if (me.rendered) {
    me.el.dom.removeAttribute('tabIndex');
  }
  if (me.btnInnerEl && Ext.isIE7m) {
    me.btnInnerEl.repaint();
  }
  return me;
}, setScale:function(scale) {
  var me = this, ui = me.ui.replace('-' + me.scale, '');
  if (!Ext.Array.contains(me.allowedScales, scale)) {
    throw '#setScale: scale must be an allowed scale (' + me.allowedScales.join(', ') + ')';
  }
  me.scale = scale;
  me.setUI(ui);
}, setUI:function(ui) {
  var me = this;
  if (me.scale && !ui.match(me.scale)) {
    ui = ui + '-' + me.scale;
  }
  me.callParent([ui]);
}, onMouseDown:function(e) {
  var me = this;
  if (Ext.isIE) {
    me.getFocusEl().focus();
  }
  if (!me.disabled && e.button === 0) {
    Ext.button.Manager.onButtonMousedown(me, e);
    me.addClsWithUI(me.pressedCls);
  }
}, onMouseUp:function(e) {
  var me = this;
  if (e.button === 0) {
    if (!me.pressed) {
      me.removeClsWithUI(me.pressedCls);
    }
  }
}, onMenuShow:function(e) {
  var me = this;
  me.ignoreNextClick = 0;
  me.addClsWithUI(me.menuActiveCls);
  me.fireEvent('menushow', me, me.menu);
}, onMenuHide:function(e) {
  var me = this;
  me.removeClsWithUI(me.menuActiveCls);
  me.ignoreNextClick = Ext.defer(me.restoreClick, 250, me);
  me.fireEvent('menuhide', me, me.menu);
  me.focus();
}, restoreClick:function() {
  this.ignoreNextClick = 0;
}, onDownKey:function(k, e) {
  var me = this;
  if (me.menu && !me.disabled) {
    me.showMenu();
    e.stopEvent();
    return false;
  }
}});
Ext.define('Ext.layout.container.boxOverflow.Menu', {extend:Ext.layout.container.boxOverflow.None, alternateClassName:'Ext.layout.boxOverflow.Menu', noItemsMenuText:'\x3cdiv class\x3d"' + Ext.baseCSSPrefix + 'toolbar-no-items"\x3e(None)\x3c/div\x3e', constructor:function(layout) {
  var me = this;
  me.callParent(arguments);
  me.triggerButtonCls = me.triggerButtonCls || Ext.baseCSSPrefix + 'box-menu-after';
  me.menuItems = [];
}, beginLayout:function(ownerContext) {
  this.callParent(arguments);
  this.clearOverflow(ownerContext);
}, beginLayoutCycle:function(ownerContext, firstCycle) {
  this.callParent(arguments);
  if (!firstCycle) {
    this.clearOverflow(ownerContext);
    this.layout.cacheChildItems(ownerContext);
  }
}, onRemove:function(comp) {
  Ext.Array.remove(this.menuItems, comp);
}, getSuffixConfig:function() {
  var me = this, layout = me.layout, owner = layout.owner, oid = owner.id;
  me.menu = new Ext.menu.Menu({listeners:{scope:me, beforeshow:me.beforeMenuShow}});
  me.menuTrigger = new Ext.button.Button({id:oid + '-menu-trigger', cls:Ext.layout.container.Box.prototype.innerCls + ' ' + me.triggerButtonCls + ' ' + Ext.baseCSSPrefix + 'toolbar-item', plain:owner.usePlainButtons, ownerCt:owner, ownerLayout:layout, iconCls:Ext.baseCSSPrefix + me.getOwnerType(owner) + '-more-icon', ui:owner instanceof Ext.toolbar.Toolbar ? 'default-toolbar' : 'default', menu:me.menu, showEmptyMenu:true, getSplitCls:function() {
    return '';
  }});
  return me.menuTrigger.getRenderTree();
}, getOverflowCls:function() {
  return Ext.baseCSSPrefix + this.layout.direction + '-box-overflow-body';
}, handleOverflow:function(ownerContext) {
  var me = this, layout = me.layout, names = layout.names, plan = ownerContext.state.boxPlan, posArgs = [null, null];
  me.showTrigger(ownerContext);
  if (me.layout.direction !== 'vertical') {
    posArgs[names.heightIndex] = (plan.maxSize - me.menuTrigger[names.getHeight]()) / 2;
    me.menuTrigger.setPosition.apply(me.menuTrigger, posArgs);
  }
  return {reservedSpace:me.triggerTotalWidth};
}, captureChildElements:function() {
  var me = this, menuTrigger = me.menuTrigger, names = me.layout.names;
  if (menuTrigger.rendering) {
    menuTrigger.finishRender();
    me.triggerTotalWidth = menuTrigger[names.getWidth]() + menuTrigger.el.getMargin(names.parallelMargins);
  }
}, _asLayoutRoot:{isRoot:true}, clearOverflow:function(ownerContext) {
  var me = this, items = me.menuItems, item, i = 0, length = items.length, owner = me.layout.owner, asLayoutRoot = me._asLayoutRoot;
  owner.suspendLayouts();
  me.captureChildElements();
  me.hideTrigger();
  owner.resumeLayouts();
  for (; i < length; i++) {
    item = items[i];
    item.suspendLayouts();
    item.show();
    item.resumeLayouts(asLayoutRoot);
  }
  items.length = 0;
}, showTrigger:function(ownerContext) {
  var me = this, layout = me.layout, owner = layout.owner, names = layout.names, startProp = names.x, sizeProp = names.width, plan = ownerContext.state.boxPlan, available = plan.targetSize[sizeProp], childItems = ownerContext.childItems, len = childItems.length, menuTrigger = me.menuTrigger, childContext, comp, i, props;
  menuTrigger.suspendLayouts();
  menuTrigger.show();
  menuTrigger.resumeLayouts(me._asLayoutRoot);
  available -= me.triggerTotalWidth;
  owner.suspendLayouts();
  me.menuItems.length = 0;
  for (i = 0; i < len; i++) {
    childContext = childItems[i];
    props = childContext.props;
    if (props[startProp] + props[sizeProp] > available) {
      comp = childContext.target;
      me.menuItems.push(comp);
      comp.hide();
    }
  }
  owner.resumeLayouts();
}, hideTrigger:function() {
  var menuTrigger = this.menuTrigger;
  if (menuTrigger) {
    menuTrigger.hide();
  }
}, beforeMenuShow:function(menu) {
  var me = this, items = me.menuItems, i = 0, len = items.length, item, prev, needsSep = function(group, prev) {
    return group.isXType('buttongroup') && !(prev instanceof Ext.toolbar.Separator);
  };
  menu.suspendLayouts();
  me.clearMenu();
  menu.removeAll();
  for (; i < len; i++) {
    item = items[i];
    if (!i && item instanceof Ext.toolbar.Separator) {
      continue;
    }
    if (prev && (needsSep(item, prev) || needsSep(prev, item))) {
      menu.add('-');
    }
    me.addComponentToMenu(menu, item);
    prev = item;
  }
  if (menu.items.length < 1) {
    menu.add(me.noItemsMenuText);
  }
  menu.resumeLayouts();
}, createMenuConfig:function(component, hideOnClick) {
  var me = this, config = Ext.apply({}, component.initialConfig), group = component.toggleGroup;
  Ext.copyTo(config, component, ['iconCls', 'icon', 'itemId', 'disabled', 'handler', 'scope', 'menu', 'tabIndex']);
  Ext.apply(config, {text:component.overflowText || component.text, hideOnClick:hideOnClick, destroyMenu:false, listeners:{}});
  if (component.isFormField) {
    config.value = component.getValue();
    config.listeners.change = function(c, newVal, oldVal) {
      component.setValue(newVal);
    };
  } else {
    if (group || component.enableToggle) {
      Ext.apply(config, {hideOnClick:false, group:group, checked:component.pressed, handler:function(item, e) {
        component.onClick(e);
      }});
    }
  }
  if (component.isButton && !component.changeListenersAdded) {
    component.on({textchange:me.onButtonAttrChange, iconchange:me.onButtonAttrChange, toggle:me.onButtonToggle});
    component.changeListenersAdded = true;
  }
  delete config.margin;
  delete config.ownerCt;
  delete config.xtype;
  delete config.id;
  delete config.itemId;
  return config;
}, onButtonAttrChange:function(btn) {
  var clone = btn.overflowClone;
  clone.suspendLayouts();
  clone.setText(btn.text);
  clone.setIcon(btn.icon);
  clone.setIconCls(btn.iconCls);
  clone.resumeLayouts(true);
}, onButtonToggle:function(btn, state) {
  if (btn.overflowClone.checked !== state) {
    btn.overflowClone.setChecked(state);
  }
}, addComponentToMenu:function(menu, component) {
  var me = this, i, items, iLen;
  if (component instanceof Ext.toolbar.Separator) {
    menu.add('-');
  } else {
    if (component.isComponent) {
      if (component.isXType('splitbutton')) {
        component.overflowClone = menu.add(me.createMenuConfig(component, true));
      } else {
        if (component.isXType('button')) {
          component.overflowClone = menu.add(me.createMenuConfig(component, !component.menu));
        } else {
          if (component.isXType('buttongroup')) {
            items = component.items.items;
            iLen = items.length;
            for (i = 0; i < iLen; i++) {
              me.addComponentToMenu(menu, items[i]);
            }
          } else {
            component.overflowClone = menu.add(Ext.create(Ext.getClassName(component), me.createMenuConfig(component)));
          }
        }
      }
    }
  }
}, clearMenu:function() {
  var menu = this.menu, items, i, iLen, item;
  if (menu && menu.items) {
    items = menu.items.items;
    iLen = items.length;
    for (i = 0; i < iLen; i++) {
      item = items[i];
      if (item.setMenu) {
        item.setMenu(null);
      }
    }
  }
}, destroy:function() {
  var trigger = this.menuTrigger;
  if (trigger && !this.layout.owner.items.contains(trigger)) {
    delete trigger.ownerCt;
  }
  Ext.destroy(this.menu, trigger);
}});
Ext.define('Ext.layout.container.boxOverflow.Scroller', {extend:Ext.layout.container.boxOverflow.None, alternateClassName:'Ext.layout.boxOverflow.Scroller', mixins:{observable:Ext.util.Observable}, animateScroll:false, scrollIncrement:20, wheelIncrement:10, scrollRepeatInterval:60, scrollDuration:400, scrollerCls:Ext.baseCSSPrefix + 'box-scroller', constructor:function(layout, config) {
  var me = this;
  me.layout = layout;
  Ext.apply(me, config || {});
  me.mixins.observable.constructor.call(me);
  me.addEvents('scroll');
  me.scrollPosition = 0;
  me.scrollSize = 0;
}, getPrefixConfig:function() {
  var me = this, layout = me.layout, owner = layout.owner, cls;
  me.initCSSClasses();
  cls = Ext.layout.container.Box.prototype.innerCls + ' ' + me.beforeCtCls;
  if (owner.plain) {
    cls += ' ' + me.scrollerCls + '-plain';
  }
  return {cls:cls, cn:{id:owner.id + layout.names.beforeScrollerSuffix, cls:me.scrollerCls + ' ' + me.beforeScrollerCls, style:'display:none'}};
}, getSuffixConfig:function() {
  var me = this, layout = me.layout, owner = layout.owner, cls = Ext.layout.container.Box.prototype.innerCls + ' ' + me.afterCtCls;
  if (owner.plain) {
    cls += ' ' + me.scrollerCls + '-plain';
  }
  return {cls:cls, cn:{id:owner.id + layout.names.afterScrollerSuffix, cls:me.scrollerCls + ' ' + me.afterScrollerCls, style:'display:none'}};
}, getOverflowCls:function() {
  return Ext.baseCSSPrefix + this.layout.direction + '-box-overflow-body';
}, initCSSClasses:function() {
  var me = this, prefix = Ext.baseCSSPrefix, layout = me.layout, names = layout.names, beforeXName = names.beforeX, afterXName = names.afterX, type = me.getOwnerType(layout.owner);
  me.beforeCtCls = me.beforeCtCls || prefix + 'box-scroller-' + beforeXName;
  me.afterCtCls = me.afterCtCls || prefix + 'box-scroller-' + afterXName;
  me.beforeScrollerCls = me.beforeScrollerCls || prefix + type + '-scroll-' + beforeXName;
  me.afterScrollerCls = me.afterScrollerCls || prefix + type + '-scroll-' + afterXName;
}, beginLayout:function(ownerContext) {
  var layout = this.layout;
  ownerContext.innerCtScrollPos = this.getScrollPosition();
  this.callParent(arguments);
}, completeLayout:function(ownerContext) {
  var me = this, plan = ownerContext.state.boxPlan, names = me.layout.names, last;
  if (plan && plan.tooNarrow) {
    last = ownerContext.childItems[ownerContext.childItems.length - 1];
    me.scrollSize = last.props[names.x] + last.props[names.width];
    me.updateScrollButtons();
  }
  this.callParent(arguments);
}, finishedLayout:function(ownerContext) {
  var me = this, layout = me.layout, scrollPos = Math.min(me.getMaxScrollPosition(), ownerContext.innerCtScrollPos);
  layout.innerCt[layout.names.setScrollLeft](scrollPos);
}, handleOverflow:function(ownerContext) {
  var me = this, methodName = me.layout.names.getWidth;
  me.showScrollers();
  return {reservedSpace:me.beforeCt[methodName]() + me.afterCt[methodName]()};
}, captureChildElements:function() {
  var me = this, el = me.layout.owner.el, before, after, hoverCls, pressedSuffix, pressedCls, hoverSuffix;
  if (!me.beforeCt) {
    hoverSuffix = '-hover';
    pressedSuffix = '-pressed';
    hoverCls = me.scrollerCls + hoverSuffix;
    pressedCls = me.scrollerCls + pressedSuffix;
    before = me.beforeScroller = el.getById(me.layout.owner.id + '-before-scroller');
    after = me.afterScroller = el.getById(me.layout.owner.id + '-after-scroller');
    me.beforeCt = before.up('');
    me.afterCt = after.up('');
    me.createWheelListener();
    before.addClsOnOver(hoverCls);
    before.addClsOnOver(me.beforeScrollerCls + hoverSuffix);
    before.addClsOnClick(pressedCls);
    before.addClsOnClick(me.beforeScrollerCls + pressedSuffix);
    after.addClsOnOver(hoverCls);
    after.addClsOnOver(me.afterScrollerCls + hoverSuffix);
    after.addClsOnClick(pressedCls);
    after.addClsOnClick(me.afterScrollerCls + pressedSuffix);
    before.setVisibilityMode(Ext.Element.DISPLAY);
    after.setVisibilityMode(Ext.Element.DISPLAY);
    me.beforeRepeater = new Ext.util.ClickRepeater(before, {interval:me.scrollRepeatInterval, handler:me.scrollLeft, scope:me});
    me.afterRepeater = new Ext.util.ClickRepeater(after, {interval:me.scrollRepeatInterval, handler:me.scrollRight, scope:me});
  }
}, createWheelListener:function() {
  var me = this;
  me.layout.innerCt.on({mousewheel:function(e) {
    me.scrollBy(me.getWheelDelta(e) * me.wheelIncrement * -1, false);
  }, stopEvent:true});
}, getWheelDelta:function(e) {
  return e.getWheelDelta();
}, clearOverflow:function() {
  this.hideScrollers();
}, showScrollers:function() {
  var me = this;
  me.captureChildElements();
  me.beforeScroller.show();
  me.afterScroller.show();
  me.layout.owner.addClsWithUI(me.layout.direction === 'vertical' ? 'vertical-scroller' : 'scroller');
}, hideScrollers:function() {
  var me = this;
  if (me.beforeScroller !== undefined) {
    me.beforeScroller.hide();
    me.afterScroller.hide();
    me.layout.owner.removeClsWithUI(me.layout.direction === 'vertical' ? 'vertical-scroller' : 'scroller');
  }
}, destroy:function() {
  var me = this;
  Ext.destroy(me.beforeRepeater, me.afterRepeater, me.beforeScroller, me.afterScroller, me.beforeCt, me.afterCt);
}, scrollBy:function(delta, animate) {
  this.scrollTo(this.getScrollPosition() + delta, animate);
}, getScrollAnim:function() {
  return {duration:this.scrollDuration, callback:this.updateScrollButtons, scope:this};
}, updateScrollButtons:function() {
  var me = this, beforeMeth, afterMeth, beforeCls, afterCls, disabledCls, suffix = '-disabled';
  if (me.beforeScroller == null || me.afterScroller == null) {
    return;
  }
  beforeMeth = me.atExtremeBefore() ? 'addCls' : 'removeCls';
  afterMeth = me.atExtremeAfter() ? 'addCls' : 'removeCls';
  disabledCls = me.scrollerCls + suffix;
  beforeCls = [disabledCls, me.beforeScrollerCls + suffix];
  afterCls = [disabledCls, me.afterScrollerCls + suffix];
  me.beforeScroller[beforeMeth](beforeCls);
  me.afterScroller[afterMeth](afterCls);
  me.scrolling = false;
}, scrollLeft:function() {
  this.scrollBy(-this.scrollIncrement, false);
}, scrollRight:function() {
  this.scrollBy(this.scrollIncrement, false);
}, getScrollPosition:function() {
  var me = this, layout = me.layout, result;
  if (isNaN(me.scrollPosition)) {
    result = layout.innerCt[layout.names.getScrollLeft]();
  } else {
    result = me.scrollPosition;
  }
  return result;
}, getMaxScrollPosition:function() {
  var me = this, layout = me.layout, maxScrollPos = me.scrollSize - layout.innerCt[layout.names.getWidth]();
  return maxScrollPos < 0 ? 0 : maxScrollPos;
}, atExtremeBefore:function() {
  return !this.getScrollPosition();
}, atExtremeAfter:function() {
  return this.getScrollPosition() >= this.getMaxScrollPosition();
}, scrollTo:function(position, animate) {
  var me = this, layout = me.layout, names = layout.names, oldPosition = me.getScrollPosition(), newPosition = Ext.Number.constrain(position, 0, me.getMaxScrollPosition());
  if (newPosition != oldPosition && !me.scrolling) {
    me.scrollPosition = NaN;
    if (animate === undefined) {
      animate = me.animateScroll;
    }
    layout.innerCt[names.scrollTo](names.beforeScrollX, newPosition, animate ? me.getScrollAnim() : false);
    if (animate) {
      me.scrolling = true;
    } else {
      me.updateScrollButtons();
    }
    me.fireEvent('scroll', me, newPosition, animate ? me.getScrollAnim() : false);
  }
}, scrollToItem:function(item, animate) {
  var me = this, layout = me.layout, owner = layout.owner, names = layout.names, visibility, box, newPos;
  item = me.getItem(item);
  if (item !== undefined) {
    if (item == owner.items.first()) {
      newPos = 0;
    } else {
      if (item === owner.items.last()) {
        newPos = me.getMaxScrollPosition();
      } else {
        visibility = me.getItemVisibility(item);
        if (!visibility.fullyVisible) {
          box = item.getBox(false, true);
          newPos = box[names.x];
          if (visibility.hiddenEnd) {
            newPos -= me.layout.innerCt[names.getWidth]() - box[names.width];
          }
        }
      }
    }
    if (newPos !== undefined) {
      me.scrollTo(newPos, animate);
    }
  }
}, getItemVisibility:function(item) {
  var me = this, box = me.getItem(item).getBox(true, true), layout = me.layout, names = layout.names, itemStart = box[names.x], itemEnd = itemStart + box[names.width], scrollStart = me.getScrollPosition(), scrollEnd = scrollStart + layout.innerCt[names.getWidth]();
  return {hiddenStart:itemStart < scrollStart, hiddenEnd:itemEnd > scrollEnd, fullyVisible:itemStart > scrollStart && itemEnd < scrollEnd};
}});
Ext.define('Ext.util.Offset', {statics:{fromObject:function(obj) {
  return new this(obj.x, obj.y);
}}, constructor:function(x, y) {
  this.x = x != null && !isNaN(x) ? x : 0;
  this.y = y != null && !isNaN(y) ? y : 0;
  return this;
}, copy:function() {
  return new Ext.util.Offset(this.x, this.y);
}, copyFrom:function(p) {
  this.x = p.x;
  this.y = p.y;
}, toString:function() {
  return 'Offset[' + this.x + ',' + this.y + ']';
}, equals:function(offset) {
  if (!(offset instanceof this.statics())) {
    Ext.Error.raise('Offset must be an instance of Ext.util.Offset');
  }
  return this.x == offset.x && this.y == offset.y;
}, round:function(to) {
  if (!isNaN(to)) {
    var factor = Math.pow(10, to);
    this.x = Math.round(this.x * factor) / factor;
    this.y = Math.round(this.y * factor) / factor;
  } else {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
  }
}, isZero:function() {
  return this.x == 0 && this.y == 0;
}});
Ext.define('Ext.util.Region', {statics:{getRegion:function(el) {
  return Ext.fly(el).getRegion();
}, from:function(o) {
  return new this(o.top, o.right, o.bottom, o.left);
}}, constructor:function(t, r, b, l) {
  var me = this;
  me.y = me.top = me[1] = t;
  me.right = r;
  me.bottom = b;
  me.x = me.left = me[0] = l;
}, contains:function(region) {
  var me = this;
  return region.x >= me.x && region.right <= me.right && region.y >= me.y && region.bottom <= me.bottom;
}, intersect:function(region) {
  var me = this, t = Math.max(me.y, region.y), r = Math.min(me.right, region.right), b = Math.min(me.bottom, region.bottom), l = Math.max(me.x, region.x);
  if (b > t && r > l) {
    return new this.self(t, r, b, l);
  } else {
    return false;
  }
}, union:function(region) {
  var me = this, t = Math.min(me.y, region.y), r = Math.max(me.right, region.right), b = Math.max(me.bottom, region.bottom), l = Math.min(me.x, region.x);
  return new this.self(t, r, b, l);
}, constrainTo:function(r) {
  var me = this, constrain = Ext.Number.constrain;
  me.top = me.y = constrain(me.top, r.y, r.bottom);
  me.bottom = constrain(me.bottom, r.y, r.bottom);
  me.left = me.x = constrain(me.left, r.x, r.right);
  me.right = constrain(me.right, r.x, r.right);
  return me;
}, adjust:function(t, r, b, l) {
  var me = this;
  me.top = me.y += t;
  me.left = me.x += l;
  me.right += r;
  me.bottom += b;
  return me;
}, getOutOfBoundOffset:function(axis, p) {
  if (!Ext.isObject(axis)) {
    if (axis == 'x') {
      return this.getOutOfBoundOffsetX(p);
    } else {
      return this.getOutOfBoundOffsetY(p);
    }
  } else {
    p = axis;
    var d = new Ext.util.Offset;
    d.x = this.getOutOfBoundOffsetX(p.x);
    d.y = this.getOutOfBoundOffsetY(p.y);
    return d;
  }
}, getOutOfBoundOffsetX:function(p) {
  if (p <= this.x) {
    return this.x - p;
  } else {
    if (p >= this.right) {
      return this.right - p;
    }
  }
  return 0;
}, getOutOfBoundOffsetY:function(p) {
  if (p <= this.y) {
    return this.y - p;
  } else {
    if (p >= this.bottom) {
      return this.bottom - p;
    }
  }
  return 0;
}, isOutOfBound:function(axis, p) {
  if (!Ext.isObject(axis)) {
    if (axis == 'x') {
      return this.isOutOfBoundX(p);
    } else {
      return this.isOutOfBoundY(p);
    }
  } else {
    p = axis;
    return this.isOutOfBoundX(p.x) || this.isOutOfBoundY(p.y);
  }
}, isOutOfBoundX:function(p) {
  return p < this.x || p > this.right;
}, isOutOfBoundY:function(p) {
  return p < this.y || p > this.bottom;
}, restrict:function(axis, p, factor) {
  if (Ext.isObject(axis)) {
    var newP;
    factor = p;
    p = axis;
    if (p.copy) {
      newP = p.copy();
    } else {
      newP = {x:p.x, y:p.y};
    }
    newP.x = this.restrictX(p.x, factor);
    newP.y = this.restrictY(p.y, factor);
    return newP;
  } else {
    if (axis == 'x') {
      return this.restrictX(p, factor);
    } else {
      return this.restrictY(p, factor);
    }
  }
}, restrictX:function(p, factor) {
  if (!factor) {
    factor = 1;
  }
  if (p <= this.x) {
    p -= (p - this.x) * factor;
  } else {
    if (p >= this.right) {
      p -= (p - this.right) * factor;
    }
  }
  return p;
}, restrictY:function(p, factor) {
  if (!factor) {
    factor = 1;
  }
  if (p <= this.y) {
    p -= (p - this.y) * factor;
  } else {
    if (p >= this.bottom) {
      p -= (p - this.bottom) * factor;
    }
  }
  return p;
}, getSize:function() {
  return {width:this.right - this.x, height:this.bottom - this.y};
}, copy:function() {
  return new this.self(this.y, this.right, this.bottom, this.x);
}, copyFrom:function(p) {
  var me = this;
  me.top = me.y = me[1] = p.y;
  me.right = p.right;
  me.bottom = p.bottom;
  me.left = me.x = me[0] = p.x;
  return this;
}, toString:function() {
  return 'Region[' + this.top + ',' + this.right + ',' + this.bottom + ',' + this.left + ']';
}, translateBy:function(x, y) {
  if (arguments.length == 1) {
    y = x.y;
    x = x.x;
  }
  var me = this;
  me.top = me.y += y;
  me.right += x;
  me.bottom += y;
  me.left = me.x += x;
  return me;
}, round:function() {
  var me = this;
  me.top = me.y = Math.round(me.y);
  me.right = Math.round(me.right);
  me.bottom = Math.round(me.bottom);
  me.left = me.x = Math.round(me.x);
  return me;
}, equals:function(region) {
  return this.top == region.top && this.right == region.right && this.bottom == region.bottom && this.left == region.left;
}});
Ext.define('Ext.dd.DragDropManager', {singleton:true, alternateClassName:['Ext.dd.DragDropMgr', 'Ext.dd.DDM'], ids:{}, handleIds:{}, dragCurrent:null, dragOvers:{}, deltaX:0, deltaY:0, preventDefault:true, stopPropagation:true, initialized:false, locked:false, init:function() {
  this.initialized = true;
}, POINT:0, INTERSECT:1, mode:0, notifyOccluded:false, dragCls:Ext.baseCSSPrefix + 'dd-drag-current', _execOnAll:function(sMethod, args) {
  var i, j, oDD;
  for (i in this.ids) {
    for (j in this.ids[i]) {
      oDD = this.ids[i][j];
      if (!this.isTypeOfDD(oDD)) {
        continue;
      }
      oDD[sMethod].apply(oDD, args);
    }
  }
}, _onLoad:function() {
  this.init();
  var Event = Ext.EventManager;
  Event.on(document, 'mouseup', this.handleMouseUp, this, true);
  Event.on(document, 'mousemove', this.handleMouseMove, this, true);
  Event.on(window, 'unload', this._onUnload, this, true);
  Event.on(window, 'resize', this._onResize, this, true);
}, _onResize:function(e) {
  this._execOnAll('resetConstraints', []);
}, lock:function() {
  this.locked = true;
}, unlock:function() {
  this.locked = false;
}, isLocked:function() {
  return this.locked;
}, locationCache:{}, useCache:true, clickPixelThresh:3, clickTimeThresh:350, dragThreshMet:false, clickTimeout:null, startX:0, startY:0, regDragDrop:function(oDD, sGroup) {
  if (!this.initialized) {
    this.init();
  }
  if (!this.ids[sGroup]) {
    this.ids[sGroup] = {};
  }
  this.ids[sGroup][oDD.id] = oDD;
}, removeDDFromGroup:function(oDD, sGroup) {
  if (!this.ids[sGroup]) {
    this.ids[sGroup] = {};
  }
  var obj = this.ids[sGroup];
  if (obj && obj[oDD.id]) {
    delete obj[oDD.id];
  }
}, _remove:function(oDD) {
  for (var g in oDD.groups) {
    if (g && this.ids[g] && this.ids[g][oDD.id]) {
      delete this.ids[g][oDD.id];
    }
  }
  delete this.handleIds[oDD.id];
}, regHandle:function(sDDId, sHandleId) {
  if (!this.handleIds[sDDId]) {
    this.handleIds[sDDId] = {};
  }
  this.handleIds[sDDId][sHandleId] = sHandleId;
}, isDragDrop:function(id) {
  return this.getDDById(id) ? true : false;
}, getRelated:function(p_oDD, bTargetsOnly) {
  var oDDs = [], i, j, dd;
  for (i in p_oDD.groups) {
    for (j in this.ids[i]) {
      dd = this.ids[i][j];
      if (!this.isTypeOfDD(dd)) {
        continue;
      }
      if (!bTargetsOnly || dd.isTarget) {
        oDDs[oDDs.length] = dd;
      }
    }
  }
  return oDDs;
}, isLegalTarget:function(oDD, oTargetDD) {
  var targets = this.getRelated(oDD, true), i, len;
  for (i = 0, len = targets.length; i < len; ++i) {
    if (targets[i].id == oTargetDD.id) {
      return true;
    }
  }
  return false;
}, isTypeOfDD:function(oDD) {
  return oDD && oDD.__ygDragDrop;
}, isHandle:function(sDDId, sHandleId) {
  return this.handleIds[sDDId] && this.handleIds[sDDId][sHandleId];
}, getDDById:function(id) {
  var i, dd;
  for (i in this.ids) {
    dd = this.ids[i][id];
    if (dd instanceof Ext.dd.DDTarget) {
      return dd;
    }
  }
  return null;
}, handleMouseDown:function(e, oDD) {
  var me = this, el;
  if (Ext.quickTipsActive) {
    Ext.tip.QuickTipManager.ddDisable();
  }
  if (me.dragCurrent) {
    me.handleMouseUp(e);
  }
  me.currentTarget = e.getTarget();
  me.dragCurrent = oDD;
  el = oDD.getEl();
  if (Ext.isIE9m && el.setCapture) {
    el.setCapture();
  }
  me.startX = e.getPageX();
  me.startY = e.getPageY();
  me.deltaX = me.startX - el.offsetLeft;
  me.deltaY = me.startY - el.offsetTop;
  me.dragThreshMet = false;
  me.clickTimeout = setTimeout(function() {
    me.startDrag(me.startX, me.startY);
  }, me.clickTimeThresh);
}, startDrag:function(x, y) {
  var me = this, current = me.dragCurrent, dragEl;
  clearTimeout(me.clickTimeout);
  if (current) {
    current.b4StartDrag(x, y);
    current.startDrag(x, y);
    dragEl = current.getDragEl();
    if (dragEl) {
      Ext.fly(dragEl).addCls(me.dragCls);
    }
  }
  me.dragThreshMet = true;
}, handleMouseUp:function(e) {
  var me = this;
  if (Ext.quickTipsActive) {
    Ext.tip.QuickTipManager.ddEnable();
  }
  if (!me.dragCurrent) {
    return;
  }
  if (Ext.isIE && document.releaseCapture) {
    document.releaseCapture();
  }
  clearTimeout(me.clickTimeout);
  if (me.dragThreshMet) {
    me.fireEvents(e, true);
  }
  me.stopDrag(e);
  me.stopEvent(e);
}, stopEvent:function(e) {
  if (this.stopPropagation) {
    e.stopPropagation();
  }
  if (this.preventDefault) {
    e.preventDefault();
  }
}, stopDrag:function(e) {
  var me = this, current = me.dragCurrent, dragEl;
  if (current) {
    if (me.dragThreshMet) {
      dragEl = current.getDragEl();
      if (dragEl) {
        Ext.fly(dragEl).removeCls(me.dragCls);
      }
      current.b4EndDrag(e);
      current.endDrag(e);
    }
    me.dragCurrent.onMouseUp(e);
  }
  me.dragCurrent = null;
  me.dragOvers = {};
}, handleMouseMove:function(e) {
  var me = this, current = me.dragCurrent, diffX, diffY;
  if (!current) {
    return true;
  }
  if (!me.dragThreshMet) {
    diffX = Math.abs(me.startX - e.getPageX());
    diffY = Math.abs(me.startY - e.getPageY());
    if (diffX > me.clickPixelThresh || diffY > me.clickPixelThresh) {
      me.startDrag(me.startX, me.startY);
    }
  }
  if (me.dragThreshMet) {
    current.b4Drag(e);
    current.onDrag(e);
    if (!current.moveOnly) {
      me.fireEvents(e, false);
    }
  }
  me.stopEvent(e);
  return true;
}, fireEvents:function(e, isDrop) {
  var me = this, dragCurrent = me.dragCurrent, dragEl, oldDragElTop, mousePoint = e.getPoint(), overTarget, overTargetEl, allTargets = [], oldOvers = [], outEvts = [], overEvts = [], dropEvts = [], enterEvts = [], xy, needsSort, i, len, sGroup;
  if (!dragCurrent || dragCurrent.isLocked()) {
    return;
  }
  if (!me.notifyOccluded && (!Ext.supports.PointerEvents || Ext.isIE10m || Ext.isOpera) && !(dragCurrent.deltaX < 0 || dragCurrent.deltaY < 0)) {
    dragEl = dragCurrent.getDragEl();
    oldDragElTop = dragEl.style.top;
    dragEl.style.top = '-10000px';
    xy = e.getXY();
    e.target = document.elementFromPoint(xy[0], xy[1]);
    dragEl.style.top = oldDragElTop;
  }
  for (i in me.dragOvers) {
    overTarget = me.dragOvers[i];
    if (!me.isTypeOfDD(overTarget)) {
      continue;
    }
    if (me.notifyOccluded) {
      if (!this.isOverTarget(mousePoint, overTarget, me.mode)) {
        outEvts.push(overTarget);
      }
    } else {
      if (!e.within(overTarget.getEl())) {
        outEvts.push(overTarget);
      }
    }
    oldOvers[i] = true;
    delete me.dragOvers[i];
  }
  for (sGroup in dragCurrent.groups) {
    if ('string' != typeof sGroup) {
      continue;
    }
    for (i in me.ids[sGroup]) {
      overTarget = me.ids[sGroup][i];
      if (me.isTypeOfDD(overTarget) && (overTargetEl = overTarget.getEl()) && overTarget.isTarget && !overTarget.isLocked() && Ext.fly(overTargetEl).isVisible(true) && (overTarget != dragCurrent || dragCurrent.ignoreSelf === false)) {
        if (me.notifyOccluded) {
          if ((overTarget.zIndex = me.getZIndex(overTargetEl)) !== -1) {
            needsSort = true;
          }
          allTargets.push(overTarget);
        } else {
          if (e.within(overTarget.getEl())) {
            allTargets.push(overTarget);
            break;
          }
        }
      }
    }
  }
  if (needsSort) {
    Ext.Array.sort(allTargets, me.byZIndex);
  }
  for (i = 0, len = allTargets.length; i < len; i++) {
    overTarget = allTargets[i];
    if (me.isOverTarget(mousePoint, overTarget, me.mode)) {
      if (isDrop) {
        dropEvts.push(overTarget);
      } else {
        if (!oldOvers[overTarget.id]) {
          enterEvts.push(overTarget);
        } else {
          overEvts.push(overTarget);
        }
        me.dragOvers[overTarget.id] = overTarget;
      }
      if (!me.notifyOccluded) {
        break;
      }
    }
  }
  if (me.mode) {
    if (outEvts.length) {
      dragCurrent.b4DragOut(e, outEvts);
      dragCurrent.onDragOut(e, outEvts);
    }
    if (enterEvts.length) {
      dragCurrent.onDragEnter(e, enterEvts);
    }
    if (overEvts.length) {
      dragCurrent.b4DragOver(e, overEvts);
      dragCurrent.onDragOver(e, overEvts);
    }
    if (dropEvts.length) {
      dragCurrent.b4DragDrop(e, dropEvts);
      dragCurrent.onDragDrop(e, dropEvts);
    }
  } else {
    for (i = 0, len = outEvts.length; i < len; ++i) {
      dragCurrent.b4DragOut(e, outEvts[i].id);
      dragCurrent.onDragOut(e, outEvts[i].id);
    }
    for (i = 0, len = enterEvts.length; i < len; ++i) {
      dragCurrent.onDragEnter(e, enterEvts[i].id);
    }
    for (i = 0, len = overEvts.length; i < len; ++i) {
      dragCurrent.b4DragOver(e, overEvts[i].id);
      dragCurrent.onDragOver(e, overEvts[i].id);
    }
    for (i = 0, len = dropEvts.length; i < len; ++i) {
      dragCurrent.b4DragDrop(e, dropEvts[i].id);
      dragCurrent.onDragDrop(e, dropEvts[i].id);
    }
  }
  if (isDrop && !dropEvts.length) {
    dragCurrent.onInvalidDrop(e);
  }
}, getZIndex:function(element) {
  var body = document.body, z, zIndex = -1;
  element = Ext.getDom(element);
  while (element !== body) {
    if (!isNaN(z = Number(Ext.fly(element).getStyle('zIndex')))) {
      zIndex = z;
    }
    element = element.parentNode;
  }
  return zIndex;
}, byZIndex:function(d1, d2) {
  return d1.zIndex < d2.zIndex;
}, getBestMatch:function(dds) {
  var winner = null, len = dds.length, i, dd;
  if (len == 1) {
    winner = dds[0];
  } else {
    for (i = 0; i < len; ++i) {
      dd = dds[i];
      if (dd.cursorIsOver) {
        winner = dd;
        break;
      } else {
        if (!winner || winner.overlap.getArea() < dd.overlap.getArea()) {
          winner = dd;
        }
      }
    }
  }
  return winner;
}, refreshCache:function(groups) {
  var sGroup, i, oDD, loc;
  for (sGroup in groups) {
    if ('string' != typeof sGroup) {
      continue;
    }
    for (i in this.ids[sGroup]) {
      oDD = this.ids[sGroup][i];
      if (this.isTypeOfDD(oDD)) {
        loc = this.getLocation(oDD);
        if (loc) {
          this.locationCache[oDD.id] = loc;
        } else {
          delete this.locationCache[oDD.id];
        }
      }
    }
  }
}, verifyEl:function(el) {
  if (el) {
    var parent;
    if (Ext.isIE) {
      try {
        parent = el.offsetParent;
      } catch (e$27) {
      }
    } else {
      parent = el.offsetParent;
    }
    if (parent) {
      return true;
    }
  }
  return false;
}, getLocation:function(oDD) {
  if (!this.isTypeOfDD(oDD)) {
    return null;
  }
  if (oDD.getRegion) {
    return oDD.getRegion();
  }
  var el = oDD.getEl(), pos, x1, x2, y1, y2, t, r, b, l;
  try {
    pos = Ext.Element.getXY(el);
  } catch (e$28) {
  }
  if (!pos) {
    return null;
  }
  x1 = pos[0];
  x2 = x1 + el.offsetWidth;
  y1 = pos[1];
  y2 = y1 + el.offsetHeight;
  t = y1 - oDD.padding[0];
  r = x2 + oDD.padding[1];
  b = y2 + oDD.padding[2];
  l = x1 - oDD.padding[3];
  return new Ext.util.Region(t, r, b, l);
}, isOverTarget:function(pt, oTarget, intersect) {
  var loc = this.locationCache[oTarget.id], dc, pos, el, curRegion, overlap;
  if (!loc || !this.useCache) {
    loc = this.getLocation(oTarget);
    this.locationCache[oTarget.id] = loc;
  }
  if (!loc) {
    return false;
  }
  oTarget.cursorIsOver = loc.contains(pt);
  dc = this.dragCurrent;
  if (!dc || !dc.getTargetCoord || !intersect && !dc.constrainX && !dc.constrainY) {
    return oTarget.cursorIsOver;
  }
  oTarget.overlap = null;
  pos = dc.getTargetCoord(pt.x, pt.y);
  el = dc.getDragEl();
  curRegion = new Ext.util.Region(pos.y, pos.x + el.offsetWidth, pos.y + el.offsetHeight, pos.x);
  overlap = curRegion.intersect(loc);
  if (overlap) {
    oTarget.overlap = overlap;
    return intersect ? true : oTarget.cursorIsOver;
  } else {
    return false;
  }
}, _onUnload:function(e, me) {
  Ext.dd.DragDropManager.unregAll();
}, unregAll:function() {
  if (this.dragCurrent) {
    this.stopDrag();
    this.dragCurrent = null;
  }
  this._execOnAll('unreg', []);
  for (var i in this.elementCache) {
    delete this.elementCache[i];
  }
  this.elementCache = {};
  this.ids = {};
}, elementCache:{}, getElWrapper:function(id) {
  var oWrapper = this.elementCache[id];
  if (!oWrapper || !oWrapper.el) {
    oWrapper = this.elementCache[id] = new this.ElementWrapper(Ext.getDom(id));
  }
  return oWrapper;
}, getElement:function(id) {
  return Ext.getDom(id);
}, getCss:function(id) {
  var el = Ext.getDom(id);
  return el ? el.style : null;
}, ElementWrapper:function(el) {
  this.el = el || null;
  this.id = this.el && el.id;
  this.css = this.el && el.style;
}, getPosX:function(el) {
  return Ext.Element.getX(el);
}, getPosY:function(el) {
  return Ext.Element.getY(el);
}, swapNode:function(n1, n2) {
  if (n1.swapNode) {
    n1.swapNode(n2);
  } else {
    var p = n2.parentNode, s = n2.nextSibling;
    if (s == n1) {
      p.insertBefore(n1, n2);
    } else {
      if (n2 == n1.nextSibling) {
        p.insertBefore(n2, n1);
      } else {
        n1.parentNode.replaceChild(n2, n1);
        p.insertBefore(n1, s);
      }
    }
  }
}, getScroll:function() {
  var doc = window.document, docEl = doc.documentElement, body = doc.body, top = 0, left = 0;
  if (Ext.isGecko4) {
    top = window.scrollYOffset;
    left = window.scrollXOffset;
  } else {
    if (docEl && (docEl.scrollTop || docEl.scrollLeft)) {
      top = docEl.scrollTop;
      left = docEl.scrollLeft;
    } else {
      if (body) {
        top = body.scrollTop;
        left = body.scrollLeft;
      }
    }
  }
  return {top:top, left:left};
}, getStyle:function(el, styleProp) {
  return Ext.fly(el).getStyle(styleProp);
}, getScrollTop:function() {
  return this.getScroll().top;
}, getScrollLeft:function() {
  return this.getScroll().left;
}, moveToEl:function(moveEl, targetEl) {
  var aCoord = Ext.Element.getXY(targetEl);
  Ext.Element.setXY(moveEl, aCoord);
}, numericSort:function(a, b) {
  return a - b;
}, _timeoutCount:0, _addListeners:function() {
  if (document) {
    this._onLoad();
  } else {
    if (this._timeoutCount <= 2000) {
      setTimeout(this._addListeners, 10);
      if (document && document.body) {
        this._timeoutCount += 1;
      }
    }
  }
}, handleWasClicked:function(node, id) {
  if (this.isHandle(id, node.id)) {
    return true;
  } else {
    var p = node.parentNode;
    while (p) {
      if (this.isHandle(id, p.id)) {
        return true;
      } else {
        p = p.parentNode;
      }
    }
  }
  return false;
}}, function() {
  this._addListeners();
});
Ext.define('Ext.layout.container.Box', {alias:['layout.box'], extend:Ext.layout.container.Container, alternateClassName:'Ext.layout.BoxLayout', defaultMargins:{top:0, right:0, bottom:0, left:0}, padding:0, pack:'start', flex:undefined, stretchMaxPartner:undefined, alignRoundingMethod:'round', type:'box', scrollOffset:0, itemCls:Ext.baseCSSPrefix + 'box-item', targetCls:Ext.baseCSSPrefix + 'box-layout-ct', targetElCls:Ext.baseCSSPrefix + 'box-target', innerCls:Ext.baseCSSPrefix + 'box-inner', availableSpaceOffset:0, 
reserveOffset:true, manageMargins:true, createsInnerCt:true, childEls:['innerCt', 'targetEl'], renderTpl:['{%var oc,l\x3dvalues.$comp.layout,oh\x3dl.overflowHandler;', 'if (oh.getPrefixConfig!\x3d\x3dExt.emptyFn) {', 'if(oc\x3doh.getPrefixConfig())dh.generateMarkup(oc, out)', '}%}', '\x3cdiv id\x3d"{ownerId}-innerCt" class\x3d"{[l.innerCls]} {[oh.getOverflowCls()]}" role\x3d"presentation"\x3e', '\x3cdiv id\x3d"{ownerId}-targetEl" class\x3d"{targetElCls}"\x3e', '{%this.renderBody(out, values)%}', 
'\x3c/div\x3e', '\x3c/div\x3e', '{%if (oh.getSuffixConfig!\x3d\x3dExt.emptyFn) {', 'if(oc\x3doh.getSuffixConfig())dh.generateMarkup(oc, out)', '}%}', {disableFormats:true, definitions:'var dh\x3dExt.DomHelper;'}], constructor:function(config) {
  var me = this, type;
  me.callParent(arguments);
  me.flexSortFn = Ext.Function.bind(me.flexSort, me);
  me.initOverflowHandler();
  type = typeof me.padding;
  if (type == 'string' || type == 'number') {
    me.padding = Ext.util.Format.parseBox(me.padding);
    me.padding.height = me.padding.top + me.padding.bottom;
    me.padding.width = me.padding.left + me.padding.right;
  }
}, _percentageRe:/^\s*(\d+(?:\.\d*)?)\s*[%]\s*$/, getItemSizePolicy:function(item, ownerSizeModel) {
  var me = this, policy = me.sizePolicy, align = me.align, flex = item.flex, key = align, names = me.names, width = item[names.width], height = item[names.height], percentageRe = me._percentageRe, percentageWidth = percentageRe.test(width), isStretch = align == 'stretch', isStretchMax = align == 'stretchmax', constrain = me.constrainAlign;
  if (!ownerSizeModel && (isStretch || flex || percentageWidth || constrain && !isStretchMax)) {
    ownerSizeModel = me.owner.getSizeModel();
  }
  if (isStretch) {
    if (!percentageRe.test(height) && ownerSizeModel[names.height].shrinkWrap) {
      key = 'stretchmax';
    }
  } else {
    if (!isStretchMax) {
      if (percentageRe.test(height)) {
        key = 'stretch';
      } else {
        if (constrain && !ownerSizeModel[names.height].shrinkWrap) {
          key = 'stretchmax';
        } else {
          key = '';
        }
      }
    }
  }
  if (flex || percentageWidth) {
    if (!ownerSizeModel[names.width].shrinkWrap) {
      policy = policy.flex;
    }
  }
  return policy[key];
}, flexSort:function(a, b) {
  var maxWidthName = this.names.maxWidth, minWidthName = this.names.minWidth, infiniteValue = Infinity, aTarget = a.target, bTarget = b.target, result = 0, aMin, bMin, aMax, bMax, hasMin, hasMax;
  aMax = aTarget[maxWidthName] || infiniteValue;
  bMax = bTarget[maxWidthName] || infiniteValue;
  aMin = aTarget[minWidthName] || 0;
  bMin = bTarget[minWidthName] || 0;
  hasMin = isFinite(aMin) || isFinite(bMin);
  hasMax = isFinite(aMax) || isFinite(bMax);
  if (hasMin || hasMax) {
    if (hasMax) {
      result = aMax - bMax;
    }
    if (result === 0 && hasMin) {
      result = bMin - aMin;
    }
  }
  return result;
}, isItemBoxParent:function(itemContext) {
  return true;
}, isItemShrinkWrap:function(item) {
  return true;
}, roundFlex:function(width) {
  return Math.ceil(width);
}, beginCollapse:function(child) {
  var me = this;
  if (me.direction === 'vertical' && child.collapsedVertical()) {
    child.collapseMemento.capture(['flex']);
    delete child.flex;
  } else {
    if (me.direction === 'horizontal' && child.collapsedHorizontal()) {
      child.collapseMemento.capture(['flex']);
      delete child.flex;
    }
  }
}, beginExpand:function(child) {
  child.collapseMemento.restore(['flex']);
}, beginLayout:function(ownerContext) {
  var me = this, owner = me.owner, smp = owner.stretchMaxPartner, style = me.innerCt.dom.style, names = me.names;
  ownerContext.boxNames = names;
  me.overflowHandler.beginLayout(ownerContext);
  if (typeof smp === 'string') {
    smp = Ext.getCmp(smp) || owner.query(smp)[0];
  }
  ownerContext.stretchMaxPartner = smp && ownerContext.context.getCmp(smp);
  me.callParent(arguments);
  ownerContext.innerCtContext = ownerContext.getEl('innerCt', me);
  me.scrollParallel = owner.scrollFlags[names.x];
  me.scrollPerpendicular = owner.scrollFlags[names.y];
  if (me.scrollParallel) {
    me.scrollPos = owner.getTargetEl().dom[names.scrollLeft];
  }
  style.width = '';
  style.height = '';
}, beginLayoutCycle:function(ownerContext, firstCycle) {
  var me = this, align = me.align, names = ownerContext.boxNames, pack = me.pack, heightModelName = names.heightModel;
  me.overflowHandler.beginLayoutCycle(ownerContext, firstCycle);
  me.callParent(arguments);
  ownerContext.parallelSizeModel = ownerContext[names.widthModel];
  ownerContext.perpendicularSizeModel = ownerContext[heightModelName];
  ownerContext.boxOptions = {align:align = {stretch:align == 'stretch', stretchmax:align == 'stretchmax', center:align == names.center, bottom:align == names.afterY}, pack:pack = {center:pack == 'center', end:pack == 'end'}};
  if (align.stretch && ownerContext.perpendicularSizeModel.shrinkWrap) {
    align.stretchmax = true;
    align.stretch = false;
  }
  align.nostretch = !(align.stretch || align.stretchmax);
  if (ownerContext.parallelSizeModel.shrinkWrap) {
    pack.center = pack.end = false;
  }
  me.cacheFlexes(ownerContext);
  me.targetEl.setWidth(20000);
}, cacheFlexes:function(ownerContext) {
  var me = this, names = ownerContext.boxNames, widthModelName = names.widthModel, heightModelName = names.heightModel, nostretch = ownerContext.boxOptions.align.nostretch, totalFlex = 0, childItems = ownerContext.childItems, i = childItems.length, flexedItems = [], minWidth = 0, minWidthName = names.minWidth, percentageRe = me._percentageRe, percentageWidths = 0, percentageHeights = 0, child, childContext, flex, match;
  while (i--) {
    childContext = childItems[i];
    child = childContext.target;
    if (childContext[widthModelName].calculated) {
      childContext.flex = flex = child.flex;
      if (flex) {
        totalFlex += flex;
        flexedItems.push(childContext);
        minWidth += child[minWidthName] || 0;
      } else {
        match = percentageRe.exec(child[names.width]);
        childContext.percentageParallel = parseFloat(match[1]) / 100;
        ++percentageWidths;
      }
    }
    if (nostretch && childContext[heightModelName].calculated) {
      match = percentageRe.exec(child[names.height]);
      childContext.percentagePerpendicular = parseFloat(match[1]) / 100;
      ++percentageHeights;
    }
  }
  ownerContext.flexedItems = flexedItems;
  ownerContext.flexedMinSize = minWidth;
  ownerContext.totalFlex = totalFlex;
  ownerContext.percentageWidths = percentageWidths;
  ownerContext.percentageHeights = percentageHeights;
  Ext.Array.sort(flexedItems, me.flexSortFn);
}, calculate:function(ownerContext) {
  var me = this, targetSize = me.getContainerSize(ownerContext), names = ownerContext.boxNames, state = ownerContext.state, plan = state.boxPlan || (state.boxPlan = {}), targetContext = ownerContext.targetContext;
  plan.targetSize = targetSize;
  if (!ownerContext.parallelSizeModel.shrinkWrap && !targetSize[names.gotWidth]) {
    me.done = false;
    return;
  }
  if (!state.parallelDone) {
    state.parallelDone = me.calculateParallel(ownerContext, names, plan);
  }
  if (!state.perpendicularDone) {
    state.perpendicularDone = me.calculatePerpendicular(ownerContext, names, plan);
  }
  if (state.parallelDone && state.perpendicularDone) {
    if (me.owner.dock && (Ext.isIE7m || Ext.isIEQuirks) && !me.owner.width && !me.horizontal) {
      plan.isIEVerticalDock = true;
      plan.calculatedWidth = plan.maxSize + ownerContext.getPaddingInfo().width + ownerContext.getFrameInfo().width;
      if (targetContext !== ownerContext) {
        plan.calculatedWidth += targetContext.getPaddingInfo().width;
      }
    }
    me.publishInnerCtSize(ownerContext, me.reserveOffset ? me.availableSpaceOffset : 0);
    if (me.done && (ownerContext.childItems.length > 1 || ownerContext.stretchMaxPartner) && ownerContext.boxOptions.align.stretchmax && !state.stretchMaxDone) {
      me.calculateStretchMax(ownerContext, names, plan);
      state.stretchMaxDone = true;
    }
    me.overflowHandler.calculate(ownerContext);
  } else {
    me.done = false;
  }
}, calculateParallel:function(ownerContext, names, plan) {
  var me = this, widthName = names.width, childItems = ownerContext.childItems, beforeXName = names.beforeX, afterXName = names.afterX, setWidthName = names.setWidth, childItemsLength = childItems.length, flexedItems = ownerContext.flexedItems, flexedItemsLength = flexedItems.length, pack = ownerContext.boxOptions.pack, padding = me.padding, containerWidth = plan.targetSize[widthName], totalMargin = 0, left = padding[beforeXName], nonFlexWidth = left + padding[afterXName] + me.scrollOffset + (me.reserveOffset ? 
  me.availableSpaceOffset : 0), scrollbarWidth = Ext.getScrollbarSize()[names.width], i, childMargins, remainingWidth, remainingFlex, childContext, flex, flexedWidth, contentWidth, mayNeedScrollbarAdjust, childWidth, percentageSpace;
  if (scrollbarWidth && me.scrollPerpendicular && ownerContext.parallelSizeModel.shrinkWrap && !ownerContext.boxOptions.align.stretch && !ownerContext.perpendicularSizeModel.shrinkWrap) {
    if (!ownerContext.state.perpendicularDone) {
      return false;
    }
    mayNeedScrollbarAdjust = true;
  }
  for (i = 0; i < childItemsLength; ++i) {
    childContext = childItems[i];
    childMargins = childContext.marginInfo || childContext.getMarginInfo();
    totalMargin += childMargins[widthName];
    if (!childContext[names.widthModel].calculated) {
      childWidth = childContext.getProp(widthName);
      nonFlexWidth += childWidth;
      if (isNaN(nonFlexWidth)) {
        return false;
      }
    }
  }
  nonFlexWidth += totalMargin;
  if (ownerContext.percentageWidths) {
    percentageSpace = containerWidth - totalMargin;
    if (isNaN(percentageSpace)) {
      return false;
    }
    for (i = 0; i < childItemsLength; ++i) {
      childContext = childItems[i];
      if (childContext.percentageParallel) {
        childWidth = Math.ceil(percentageSpace * childContext.percentageParallel);
        childWidth = childContext.setWidth(childWidth);
        nonFlexWidth += childWidth;
      }
    }
  }
  if (ownerContext.parallelSizeModel.shrinkWrap) {
    plan.availableSpace = 0;
    plan.tooNarrow = false;
  } else {
    plan.availableSpace = containerWidth - nonFlexWidth;
    plan.tooNarrow = plan.availableSpace < ownerContext.flexedMinSize;
    if (plan.tooNarrow && Ext.getScrollbarSize()[names.height] && me.scrollParallel && ownerContext.state.perpendicularDone) {
      ownerContext.state.perpendicularDone = false;
      for (i = 0; i < childItemsLength; ++i) {
        childItems[i].invalidate();
      }
    }
  }
  contentWidth = nonFlexWidth;
  remainingWidth = plan.availableSpace;
  remainingFlex = ownerContext.totalFlex;
  for (i = 0; i < flexedItemsLength; i++) {
    childContext = flexedItems[i];
    flex = childContext.flex;
    flexedWidth = me.roundFlex(flex / remainingFlex * remainingWidth);
    flexedWidth = childContext[setWidthName](flexedWidth);
    contentWidth += flexedWidth;
    remainingWidth = Math.max(0, remainingWidth - flexedWidth);
    remainingFlex -= flex;
  }
  if (pack.center) {
    left += remainingWidth / 2;
    if (left < 0) {
      left = 0;
    }
  } else {
    if (pack.end) {
      left += remainingWidth;
    }
  }
  for (i = 0; i < childItemsLength; ++i) {
    childContext = childItems[i];
    childMargins = childContext.marginInfo;
    left += childMargins[beforeXName];
    childContext.setProp(names.x, left);
    left += childMargins[afterXName] + childContext.props[widthName];
  }
  contentWidth += ownerContext.targetContext.getPaddingInfo()[widthName];
  ownerContext.state.contentWidth = contentWidth;
  if (mayNeedScrollbarAdjust && ownerContext.peek(names.contentHeight) > plan.targetSize[names.height]) {
    contentWidth += scrollbarWidth;
    ownerContext[names.hasOverflowY] = true;
    ownerContext.target.componentLayout[names.setWidthInDom] = true;
    ownerContext[names.invalidateScrollY] = Ext.isStrict && Ext.isIE8;
  }
  ownerContext[names.setContentWidth](contentWidth);
  return true;
}, calculatePerpendicular:function(ownerContext, names, plan) {
  var me = this, heightShrinkWrap = ownerContext.perpendicularSizeModel.shrinkWrap, targetSize = plan.targetSize, childItems = ownerContext.childItems, childItemsLength = childItems.length, mmax = Math.max, heightName = names.height, setHeightName = names.setHeight, beforeYName = names.beforeY, topPositionName = names.y, padding = me.padding, top = padding[beforeYName], availHeight = targetSize[heightName] - top - padding[names.afterY], align = ownerContext.boxOptions.align, isStretch = align.stretch, 
  isStretchMax = align.stretchmax, isCenter = align.center, isBottom = align.bottom, constrain = me.constrainAlign, maxHeight = 0, hasPercentageSizes = 0, onBeforeInvalidateChild = me.onBeforeConstrainInvalidateChild, onAfterInvalidateChild = me.onAfterConstrainInvalidateChild, scrollbarHeight = Ext.getScrollbarSize().height, childTop, i, childHeight, childMargins, diff, height, childContext, stretchMaxPartner, stretchMaxChildren, shrinkWrapParallelOverflow, percentagePerpendicular;
  if (isStretch || (isCenter || isBottom) && !heightShrinkWrap) {
    if (isNaN(availHeight)) {
      return false;
    }
  }
  if (me.scrollParallel && plan.tooNarrow) {
    if (heightShrinkWrap) {
      shrinkWrapParallelOverflow = true;
    } else {
      availHeight -= scrollbarHeight;
      plan.targetSize[heightName] -= scrollbarHeight;
    }
  }
  if (isStretch) {
    height = availHeight;
  } else {
    for (i = 0; i < childItemsLength; i++) {
      childContext = childItems[i];
      childMargins = (childContext.marginInfo || childContext.getMarginInfo())[heightName];
      if (!(percentagePerpendicular = childContext.percentagePerpendicular)) {
        childHeight = childContext.getProp(heightName);
      } else {
        ++hasPercentageSizes;
        if (heightShrinkWrap) {
          continue;
        } else {
          childHeight = percentagePerpendicular * availHeight - childMargins;
          childHeight = childContext[names.setHeight](childHeight);
        }
      }
      if (!heightShrinkWrap && constrain && childContext[names.heightModel].shrinkWrap && childHeight > availHeight) {
        childContext.invalidate({before:onBeforeInvalidateChild, after:onAfterInvalidateChild, layout:me, childHeight:availHeight, names:names});
        ownerContext.state.parallelDone = false;
      }
      if (isNaN(maxHeight = mmax(maxHeight, childHeight + childMargins, childContext.target[names.minHeight] || 0))) {
        return false;
      }
    }
    if (shrinkWrapParallelOverflow) {
      maxHeight += scrollbarHeight;
      ownerContext[names.hasOverflowX] = true;
      ownerContext.target.componentLayout[names.setHeightInDom] = true;
      ownerContext[names.invalidateScrollX] = Ext.isStrict && Ext.isIE8;
    }
    stretchMaxPartner = ownerContext.stretchMaxPartner;
    if (stretchMaxPartner) {
      ownerContext.setProp('maxChildHeight', maxHeight);
      stretchMaxChildren = stretchMaxPartner.childItems;
      if (stretchMaxChildren && stretchMaxChildren.length) {
        maxHeight = mmax(maxHeight, stretchMaxPartner.getProp('maxChildHeight'));
        if (isNaN(maxHeight)) {
          return false;
        }
      }
    }
    ownerContext[names.setContentHeight](maxHeight + me.padding[heightName] + ownerContext.targetContext.getPaddingInfo()[heightName]);
    if (shrinkWrapParallelOverflow) {
      maxHeight -= scrollbarHeight;
    }
    plan.maxSize = maxHeight;
    if (isStretchMax) {
      height = maxHeight;
    } else {
      if (isCenter || isBottom || hasPercentageSizes) {
        if (constrain) {
          height = heightShrinkWrap ? maxHeight : availHeight;
        } else {
          height = heightShrinkWrap ? maxHeight : mmax(availHeight, maxHeight);
        }
        height -= ownerContext.innerCtContext.getBorderInfo()[heightName];
      }
    }
  }
  for (i = 0; i < childItemsLength; i++) {
    childContext = childItems[i];
    childMargins = childContext.marginInfo || childContext.getMarginInfo();
    childTop = top + childMargins[beforeYName];
    if (isStretch) {
      childContext[setHeightName](height - childMargins[heightName]);
    } else {
      percentagePerpendicular = childContext.percentagePerpendicular;
      if (heightShrinkWrap && percentagePerpendicular) {
        childMargins = childContext.marginInfo || childContext.getMarginInfo();
        childHeight = percentagePerpendicular * height - childMargins[heightName];
        childHeight = childContext.setHeight(childHeight);
      }
      if (isCenter) {
        diff = height - childContext.props[heightName];
        if (diff > 0) {
          childTop = top + Math[me.alignRoundingMethod](diff / 2);
        }
      } else {
        if (isBottom) {
          childTop = mmax(0, height - childTop - childContext.props[heightName]);
        }
      }
    }
    childContext.setProp(topPositionName, childTop);
  }
  return true;
}, onBeforeConstrainInvalidateChild:function(childContext, options) {
  var heightModelName = options.names.heightModel;
  if (!childContext[heightModelName].constrainedMin) {
    childContext[heightModelName] = Ext.layout.SizeModel.calculated;
  }
}, onAfterConstrainInvalidateChild:function(childContext, options) {
  var names = options.names;
  childContext.setProp(names.beforeY, 0);
  if (childContext[names.heightModel].calculated) {
    childContext[names.setHeight](options.childHeight);
  }
}, calculateStretchMax:function(ownerContext, names, plan) {
  var me = this, heightName = names.height, widthName = names.width, childItems = ownerContext.childItems, length = childItems.length, height = plan.maxSize, onBeforeStretchMaxInvalidateChild = me.onBeforeStretchMaxInvalidateChild, onAfterStretchMaxInvalidateChild = me.onAfterStretchMaxInvalidateChild, childContext, props, i, childHeight;
  for (i = 0; i < length; ++i) {
    childContext = childItems[i];
    props = childContext.props;
    childHeight = height - childContext.getMarginInfo()[heightName];
    if (childHeight != props[heightName] || childContext[names.heightModel].constrained) {
      childContext.invalidate({before:onBeforeStretchMaxInvalidateChild, after:onAfterStretchMaxInvalidateChild, layout:me, childWidth:props[widthName], childHeight:childHeight, childX:props.x, childY:props.y, names:names});
    }
  }
}, onBeforeStretchMaxInvalidateChild:function(childContext, options) {
  var heightModelName = options.names.heightModel;
  if (!childContext[heightModelName].constrainedMax) {
    childContext[heightModelName] = Ext.layout.SizeModel.calculated;
  }
}, onAfterStretchMaxInvalidateChild:function(childContext, options) {
  var names = options.names, childHeight = options.childHeight, childWidth = options.childWidth;
  childContext.setProp('x', options.childX);
  childContext.setProp('y', options.childY);
  if (childContext[names.heightModel].calculated) {
    childContext[names.setHeight](childHeight);
  }
  if (childContext[names.widthModel].calculated) {
    childContext[names.setWidth](childWidth);
  }
}, completeLayout:function(ownerContext) {
  var me = this, names = ownerContext.boxNames, invalidateScrollX = ownerContext.invalidateScrollX, invalidateScrollY = ownerContext.invalidateScrollY, dom, el, overflowX, overflowY, styles;
  me.overflowHandler.completeLayout(ownerContext);
  if (invalidateScrollX || invalidateScrollY) {
    el = me.getTarget();
    dom = el.dom;
    styles = dom.style;
    if (invalidateScrollX) {
      overflowX = el.getStyle('overflowX');
      if (overflowX == 'auto') {
        overflowX = styles.overflowX;
        styles.overflowX = 'scroll';
      } else {
        invalidateScrollX = false;
      }
    }
    if (invalidateScrollY) {
      overflowY = el.getStyle('overflowY');
      if (overflowY == 'auto') {
        overflowY = styles.overflowY;
        styles.overflowY = 'scroll';
      } else {
        invalidateScrollY = false;
      }
    }
    if (invalidateScrollX || invalidateScrollY) {
      dom.scrollWidth;
      if (invalidateScrollX) {
        styles.overflowX = overflowX;
      }
      if (invalidateScrollY) {
        styles.overflowY = overflowY;
      }
    }
  }
  if (me.scrollParallel) {
    me.owner.getTargetEl().dom[names.scrollLeft] = me.scrollPos;
  }
}, finishedLayout:function(ownerContext) {
  this.overflowHandler.finishedLayout(ownerContext);
  this.callParent(arguments);
  this.targetEl.setWidth(ownerContext.innerCtContext.props.width);
}, publishInnerCtSize:function(ownerContext, reservedSpace) {
  var me = this, names = ownerContext.boxNames, heightName = names.height, widthName = names.width, align = ownerContext.boxOptions.align, dock = me.owner.dock, padding = me.padding, plan = ownerContext.state.boxPlan, targetSize = plan.targetSize, height = targetSize[heightName], innerCtContext = ownerContext.innerCtContext, innerCtWidth = (ownerContext.parallelSizeModel.shrinkWrap || plan.tooNarrow && me.scrollParallel ? ownerContext.state.contentWidth - ownerContext.targetContext.getPaddingInfo()[widthName] : 
  targetSize[widthName]) - (reservedSpace || 0), innerCtHeight;
  if (align.stretch) {
    innerCtHeight = height;
  } else {
    innerCtHeight = plan.maxSize + padding[names.beforeY] + padding[names.afterY] + innerCtContext.getBorderInfo()[heightName];
    if (!ownerContext.perpendicularSizeModel.shrinkWrap && (align.center || align.bottom)) {
      innerCtHeight = Math.max(height, innerCtHeight);
    }
  }
  innerCtContext[names.setWidth](innerCtWidth);
  innerCtContext[names.setHeight](innerCtHeight);
  if (isNaN(innerCtWidth + innerCtHeight)) {
    me.done = false;
  }
  if (plan.calculatedWidth && (dock == 'left' || dock == 'right')) {
    ownerContext.setWidth(plan.calculatedWidth, true, true);
  }
}, onRemove:function(comp) {
  var me = this;
  me.callParent(arguments);
  if (me.overflowHandler) {
    me.overflowHandler.onRemove(comp);
  }
  if (comp.layoutMarginCap == me.id) {
    delete comp.layoutMarginCap;
  }
}, initOverflowHandler:function() {
  var me = this, handler = me.overflowHandler, handlerType, constructor;
  if (typeof handler == 'string') {
    handler = {type:handler};
  }
  handlerType = 'None';
  if (handler && handler.type !== undefined) {
    handlerType = handler.type;
  }
  constructor = Ext.layout.container.boxOverflow[handlerType];
  if (constructor[me.type]) {
    constructor = constructor[me.type];
  }
  me.overflowHandler = Ext.create('Ext.layout.container.boxOverflow.' + handlerType, me, handler);
}, getRenderTarget:function() {
  return this.targetEl;
}, getElementTarget:function() {
  return this.innerCt;
}, calculateChildBox:Ext.deprecated(), calculateChildBoxes:Ext.deprecated(), updateChildBoxes:Ext.deprecated(), destroy:function() {
  Ext.destroy(this.innerCt, this.overflowHandler);
  this.callParent(arguments);
}, getRenderData:function() {
  var data = this.callParent();
  data.targetElCls = this.targetElCls;
  return data;
}});
Ext.define('Ext.layout.container.HBox', {alias:['layout.hbox'], extend:Ext.layout.container.Box, alternateClassName:'Ext.layout.HBoxLayout', align:'top', constrainAlign:false, type:'hbox', direction:'horizontal', horizontal:true, names:{beforeX:'left', beforeScrollX:'left', beforeScrollerSuffix:'-before-scroller', afterScrollerSuffix:'-after-scroller', leftCap:'Left', afterX:'right', width:'width', contentWidth:'contentWidth', minWidth:'minWidth', maxWidth:'maxWidth', widthCap:'Width', widthModel:'widthModel', 
widthIndex:0, x:'x', scrollLeft:'scrollLeft', overflowX:'overflowX', hasOverflowX:'hasOverflowX', invalidateScrollX:'invalidateScrollX', parallelMargins:'lr', center:'middle', beforeY:'top', afterY:'bottom', height:'height', contentHeight:'contentHeight', minHeight:'minHeight', maxHeight:'maxHeight', heightCap:'Height', heightModel:'heightModel', heightIndex:1, y:'y', overflowY:'overflowY', hasOverflowY:'hasOverflowY', invalidateScrollY:'invalidateScrollY', perpendicularMargins:'tb', getWidth:'getWidth', 
getHeight:'getHeight', setWidth:'setWidth', setHeight:'setHeight', gotWidth:'gotWidth', gotHeight:'gotHeight', setContentWidth:'setContentWidth', setContentHeight:'setContentHeight', setWidthInDom:'setWidthInDom', setHeightInDom:'setHeightInDom', getScrollLeft:'getScrollLeft', setScrollLeft:'setScrollLeft', scrollTo:'scrollTo'}, sizePolicy:{flex:{'':{readsWidth:0, readsHeight:1, setsWidth:1, setsHeight:0}, stretch:{readsWidth:0, readsHeight:0, setsWidth:1, setsHeight:1}, stretchmax:{readsWidth:0, 
readsHeight:1, setsWidth:1, setsHeight:1}}, '':{readsWidth:1, readsHeight:1, setsWidth:0, setsHeight:0}, stretch:{readsWidth:1, readsHeight:0, setsWidth:0, setsHeight:1}, stretchmax:{readsWidth:1, readsHeight:1, setsWidth:0, setsHeight:1}}});
Ext.define('Ext.layout.container.VBox', {alias:['layout.vbox'], extend:Ext.layout.container.Box, alternateClassName:'Ext.layout.VBoxLayout', align:'left', constrainAlign:false, type:'vbox', direction:'vertical', horizontal:false, names:{beforeX:'top', beforeScrollX:'top', beforeScrollerSuffix:'-before-scroller', afterScrollerSuffix:'-after-scroller', leftCap:'Top', afterX:'bottom', width:'height', contentWidth:'contentHeight', minWidth:'minHeight', maxWidth:'maxHeight', widthCap:'Height', widthModel:'heightModel', 
widthIndex:1, x:'y', scrollLeft:'scrollTop', overflowX:'overflowY', hasOverflowX:'hasOverflowY', invalidateScrollX:'invalidateScrollY', parallelMargins:'tb', center:'center', beforeY:'left', afterY:'right', height:'width', contentHeight:'contentWidth', minHeight:'minWidth', maxHeight:'maxWidth', heightCap:'Width', heightModel:'widthModel', heightIndex:0, y:'x', overflowY:'overflowX', hasOverflowY:'hasOverflowX', invalidateScrollY:'invalidateScrollX', perpendicularMargins:'lr', getWidth:'getHeight', 
getHeight:'getWidth', setWidth:'setHeight', setHeight:'setWidth', gotWidth:'gotHeight', gotHeight:'gotWidth', setContentWidth:'setContentHeight', setContentHeight:'setContentWidth', setWidthInDom:'setHeightInDom', setHeightInDom:'setWidthInDom', getScrollLeft:'getScrollTop', setScrollLeft:'setScrollTop', scrollTo:'scrollTo'}, sizePolicy:{flex:{'':{readsWidth:1, readsHeight:0, setsWidth:0, setsHeight:1}, stretch:{readsWidth:0, readsHeight:0, setsWidth:1, setsHeight:1}, stretchmax:{readsWidth:1, readsHeight:0, 
setsWidth:1, setsHeight:1}}, '':{readsWidth:1, readsHeight:1, setsWidth:0, setsHeight:0}, stretch:{readsWidth:0, readsHeight:1, setsWidth:1, setsHeight:0}, stretchmax:{readsWidth:1, readsHeight:1, setsWidth:1, setsHeight:0}}});
Ext.define('Ext.toolbar.Toolbar', {extend:Ext.container.Container, alias:'widget.toolbar', alternateClassName:'Ext.Toolbar', isToolbar:true, baseCls:Ext.baseCSSPrefix + 'toolbar', ariaRole:'toolbar', defaultType:'button', vertical:false, enableOverflow:false, menuTriggerCls:Ext.baseCSSPrefix + 'toolbar-more-icon', trackMenus:true, itemCls:Ext.baseCSSPrefix + 'toolbar-item', statics:{shortcuts:{'-':'tbseparator', ' ':'tbspacer'}, shortcutsHV:{0:{'-\x3e':{xtype:'tbfill', height:0}}, 1:{'-\x3e':{xtype:'tbfill', 
width:0}}}}, initComponent:function() {
  var me = this;
  if (!me.layout && me.enableOverflow) {
    me.layout = {overflowHandler:'Menu'};
  }
  if (me.dock === 'right' || me.dock === 'left') {
    me.vertical = true;
  }
  me.layout = Ext.applyIf(Ext.isString(me.layout) ? {type:me.layout} : me.layout || {}, {type:me.vertical ? 'vbox' : 'hbox', align:me.vertical ? 'stretchmax' : 'middle'});
  if (me.vertical) {
    me.addClsWithUI('vertical');
  }
  if (me.ui === 'footer') {
    me.ignoreBorderManagement = true;
  }
  me.callParent();
  me.addEvents('overflowchange');
}, getRefItems:function(deep) {
  var me = this, items = me.callParent(arguments), layout = me.layout, handler;
  if (deep && me.enableOverflow) {
    handler = layout.overflowHandler;
    if (handler && handler.menu) {
      items = items.concat(handler.menu.getRefItems(deep));
    }
  }
  return items;
}, lookupComponent:function(c) {
  var args = arguments;
  if (typeof c == 'string') {
    var T = Ext.toolbar.Toolbar, shortcut = T.shortcutsHV[this.vertical ? 1 : 0][c] || T.shortcuts[c];
    if (typeof shortcut == 'string') {
      c = {xtype:shortcut};
    } else {
      if (shortcut) {
        c = Ext.apply({}, shortcut);
      } else {
        c = {xtype:'tbtext', text:c};
      }
    }
    this.applyDefaults(c);
    args = [c];
  }
  return this.callParent(args);
}, applyDefaults:function(c) {
  if (!Ext.isString(c)) {
    c = this.callParent(arguments);
  }
  return c;
}, trackMenu:function(item, remove) {
  if (this.trackMenus && item.menu) {
    var method = remove ? 'mun' : 'mon', me = this;
    me[method](item, 'mouseover', me.onButtonOver, me);
    me[method](item, 'menushow', me.onButtonMenuShow, me);
    me[method](item, 'menuhide', me.onButtonMenuHide, me);
  }
}, onBeforeAdd:function(component) {
  var me = this, isButton = component.isButton;
  if (isButton && me.defaultButtonUI && component.ui === 'default' && !component.hasOwnProperty('ui')) {
    component.ui = me.defaultButtonUI;
  } else {
    if ((isButton || component.isFormField) && me.ui !== 'footer') {
      component.ui = component.ui + '-toolbar';
      component.addCls(component.baseCls + '-toolbar');
    }
  }
  if (component instanceof Ext.toolbar.Separator) {
    component.setUI(me.vertical ? 'vertical' : 'horizontal');
  }
  me.callParent(arguments);
}, onAdd:function(component) {
  this.callParent(arguments);
  this.trackMenu(component);
}, onRemove:function(c) {
  this.callParent(arguments);
  this.trackMenu(c, true);
}, getChildItemsToDisable:function() {
  return this.items.getRange();
}, onButtonOver:function(btn) {
  if (this.activeMenuBtn && this.activeMenuBtn != btn) {
    this.activeMenuBtn.hideMenu();
    btn.showMenu();
    this.activeMenuBtn = btn;
  }
}, onButtonMenuShow:function(btn) {
  this.activeMenuBtn = btn;
}, onButtonMenuHide:function(btn) {
  delete this.activeMenuBtn;
}});
Ext.define('Ext.panel.AbstractPanel', {extend:Ext.container.Container, mixins:{docking:Ext.container.DockingContainer}, baseCls:Ext.baseCSSPrefix + 'panel', isPanel:true, contentPaddingProperty:'bodyPadding', shrinkWrapDock:false, componentLayout:'dock', childEls:['body'], renderTpl:['{% this.renderDockedItems(out,values,0); %}', Ext.isIE7m || Ext.isIEQuirks ? '\x3cdiv style\x3d"position:relative"\x3e\x3c/div\x3e' : '', '\x3cdiv id\x3d"{id}-body" class\x3d"{baseCls}-body\x3ctpl if\x3d"bodyCls"\x3e {bodyCls}\x3c/tpl\x3e', 
' {baseCls}-body-{ui}\x3ctpl if\x3d"uiCls"\x3e', '\x3ctpl for\x3d"uiCls"\x3e {parent.baseCls}-body-{parent.ui}-{.}\x3c/tpl\x3e', '\x3c/tpl\x3e{childElCls}"', '\x3ctpl if\x3d"bodyStyle"\x3e style\x3d"{bodyStyle}"\x3c/tpl\x3e\x3e', '{%this.renderContainer(out,values);%}', '\x3c/div\x3e', '{% this.renderDockedItems(out,values,1); %}'], bodyPosProps:{x:'x', y:'y'}, border:true, emptyArray:[], initComponent:function() {
  this.initBorderProps();
  this.callParent();
}, initBorderProps:function() {
  var me = this;
  if (me.frame && me.border && me.bodyBorder === undefined) {
    me.bodyBorder = false;
  }
  if (me.frame && me.border && (me.bodyBorder === false || me.bodyBorder === 0)) {
    me.manageBodyBorders = true;
  }
}, beforeDestroy:function() {
  this.destroyDockedItems();
  this.callParent();
}, initItems:function() {
  this.callParent();
  this.initDockingItems();
}, initRenderData:function() {
  var me = this, data = me.callParent();
  me.initBodyStyles();
  me.protoBody.writeTo(data);
  delete me.protoBody;
  return data;
}, getComponent:function(comp) {
  var component = this.callParent(arguments);
  if (component === undefined && !Ext.isNumber(comp)) {
    component = this.getDockedComponent(comp);
  }
  return component;
}, getProtoBody:function() {
  var me = this, body = me.protoBody;
  if (!body) {
    me.protoBody = body = new Ext.util.ProtoElement({cls:me.bodyCls, style:me.bodyStyle, clsProp:'bodyCls', styleProp:'bodyStyle', styleIsText:true});
  }
  return body;
}, initBodyStyles:function() {
  var me = this, body = me.getProtoBody();
  if (me.bodyPadding !== undefined) {
    if (me.layout.managePadding) {
      body.setStyle('padding', 0);
    } else {
      body.setStyle('padding', this.unitizeBox(me.bodyPadding === true ? 5 : me.bodyPadding));
    }
  }
  me.initBodyBorder();
}, initBodyBorder:function() {
  var me = this;
  if (me.frame && me.bodyBorder) {
    if (!Ext.isNumber(me.bodyBorder)) {
      me.bodyBorder = 1;
    }
    me.getProtoBody().setStyle('border-width', this.unitizeBox(me.bodyBorder));
  }
}, getCollapsedDockedItems:function() {
  var me = this;
  return me.header === false || me.collapseMode == 'placeholder' ? me.emptyArray : [me.getReExpander()];
}, setBodyStyle:function(style, value) {
  var me = this, body = me.rendered ? me.body : me.getProtoBody();
  if (Ext.isFunction(style)) {
    style = style();
  }
  if (arguments.length == 1) {
    if (Ext.isString(style)) {
      style = Ext.Element.parseStyles(style);
    }
    body.setStyle(style);
  } else {
    body.setStyle(style, value);
  }
  return me;
}, addBodyCls:function(cls) {
  var me = this, body = me.rendered ? me.body : me.getProtoBody();
  body.addCls(cls);
  return me;
}, removeBodyCls:function(cls) {
  var me = this, body = me.rendered ? me.body : me.getProtoBody();
  body.removeCls(cls);
  return me;
}, addUIClsToElement:function(cls) {
  var me = this, result = me.callParent(arguments);
  me.addBodyCls([Ext.baseCSSPrefix + cls, me.baseCls + '-body-' + cls, me.baseCls + '-body-' + me.ui + '-' + cls]);
  return result;
}, removeUIClsFromElement:function(cls) {
  var me = this, result = me.callParent(arguments);
  me.removeBodyCls([Ext.baseCSSPrefix + cls, me.baseCls + '-body-' + cls, me.baseCls + '-body-' + me.ui + '-' + cls]);
  return result;
}, addUIToElement:function() {
  var me = this;
  me.callParent(arguments);
  me.addBodyCls(me.baseCls + '-body-' + me.ui);
}, removeUIFromElement:function() {
  var me = this;
  me.callParent(arguments);
  me.removeBodyCls(me.baseCls + '-body-' + me.ui);
}, getTargetEl:function() {
  return this.body;
}, applyTargetCls:function(targetCls) {
  this.getProtoBody().addCls(targetCls);
}, getRefItems:function(deep) {
  var items = this.callParent(arguments);
  return this.getDockingRefItems(deep, items);
}, setupRenderTpl:function(renderTpl) {
  this.callParent(arguments);
  this.setupDockingRenderTpl(renderTpl);
}});
Ext.define('Ext.panel.Header', {extend:Ext.container.Container, alias:'widget.header', isHeader:true, defaultType:'tool', indicateDrag:false, weight:-1, componentLayout:'body', childEls:['body'], renderTpl:['\x3cdiv id\x3d"{id}-body" class\x3d"{headerCls}-body {baseCls}-body {bodyCls} {bodyTargetCls}', '\x3ctpl for\x3d"uiCls"\x3e {parent.baseCls}-body-{parent.ui}-{.}\x3c/tpl\x3e"', '\x3ctpl if\x3d"bodyStyle"\x3e style\x3d"{bodyStyle}"\x3c/tpl\x3e\x3e', '{%this.renderContainer(out,values)%}', '\x3c/div\x3e'], 
headingTpl:['\x3cspan id\x3d"{id}-textEl" class\x3d"{headerCls}-text {cls}-text {cls}-text-{ui}" unselectable\x3d"on"\x3e{title}\x3c/span\x3e'], shrinkWrap:3, titlePosition:0, headerCls:Ext.baseCSSPrefix + 'header', initComponent:function() {
  var me = this, hasPosition = me.hasOwnProperty('titlePosition'), items = me.items, titlePosition = hasPosition ? me.titlePosition : items ? items.length : 0, uiClasses = [me.orientation, me.getDockName()], ownerCt = me.ownerCt;
  me.addEvents('click', 'dblclick');
  me.indicateDragCls = me.headerCls + '-draggable';
  me.title = me.title || '\x26#160;';
  me.tools = me.tools || [];
  items = me.items = items ? Ext.Array.slice(items) : [];
  me.orientation = me.orientation || 'horizontal';
  me.dock = me.dock ? me.dock : me.orientation == 'horizontal' ? 'top' : 'left';
  if (ownerCt ? !ownerCt.border && !ownerCt.frame : !me.border) {
    uiClasses.push(me.orientation + '-noborder');
  }
  me.addClsWithUI(uiClasses);
  me.addCls([me.headerCls, me.headerCls + '-' + me.orientation]);
  if (me.indicateDrag) {
    me.addCls(me.indicateDragCls);
  }
  if (me.iconCls || me.icon || me.glyph) {
    me.initIconCmp();
    if (!hasPosition && !items.length) {
      ++titlePosition;
    }
    items.push(me.iconCmp);
  }
  me.titleCmp = new Ext.Component({ariaRole:'heading', focusable:false, noWrap:true, flex:1, rtl:me.rtl, id:me.id + '_hd', style:me.titleAlign ? 'text-align:' + me.titleAlign : '', cls:me.headerCls + '-text-container ' + me.baseCls + '-text-container ' + me.baseCls + '-text-container-' + me.ui, renderTpl:me.getTpl('headingTpl'), renderData:{title:me.title, cls:me.baseCls, headerCls:me.headerCls, ui:me.ui}, childEls:['textEl'], autoEl:{unselectable:'on'}, listeners:{render:me.onTitleRender, scope:me}});
  me.layout = me.orientation == 'vertical' ? {type:'vbox', align:'center', alignRoundingMethod:'ceil'} : {type:'hbox', align:'middle', alignRoundingMethod:'floor'};
  Ext.Array.push(items, me.tools);
  me.tools.length = 0;
  me.callParent();
  if (items.length < titlePosition) {
    titlePosition = items.length;
  }
  me.titlePosition = titlePosition;
  me.insert(titlePosition, me.titleCmp);
  me.on({dblclick:me.onDblClick, click:me.onClick, element:'el', scope:me});
}, initIconCmp:function() {
  var me = this, cls = [me.headerCls + '-icon', me.baseCls + '-icon', me.iconCls], cfg;
  if (me.glyph) {
    cls.push(me.baseCls + '-glyph');
  }
  cfg = {focusable:false, src:Ext.BLANK_IMAGE_URL, cls:cls, baseCls:me.baseCls + '-icon', id:me.id + '-iconEl', iconCls:me.iconCls, glyph:me.glyph};
  if (!Ext.isEmpty(me.icon)) {
    delete cfg.iconCls;
    cfg.src = me.icon;
  }
  me.iconCmp = new Ext.Img(cfg);
}, beforeRender:function() {
  this.protoEl.unselectable();
  this.callParent();
}, afterLayout:function() {
  var me = this, frameBR, frameTR, frameTL, xPos;
  if (me.orientation === 'vertical') {
    me.adjustTitlePosition();
    frameTR = me.frameTR;
    if (frameTR) {
      frameBR = me.frameBR;
      frameTL = me.frameTL;
      xPos = me.getWidth() - frameTR.getPadding('r') - (frameTL ? frameTL.getPadding('l') : me.el.getBorderWidth('l')) + 'px';
      frameBR.setStyle('background-position-x', xPos);
      frameTR.setStyle('background-position-x', xPos);
    }
    if (Ext.isIE7 && Ext.isStrict && me.frame) {
      me.el.repaint();
    }
  }
}, beforeLayout:function() {
  this.callParent();
  this.syncBeforeAfterTitleClasses();
}, adjustTitlePosition:function() {
  var titleCmp = this.titleCmp, titleEl;
  if (!Ext.isIE9m && titleCmp) {
    titleEl = titleCmp.el;
    titleEl.setStyle('left', titleEl.getWidth() + 'px');
  }
}, onTitleRender:function() {
  if (this.orientation === 'vertical') {
    this.titleCmp.el.setVertical(90);
  }
}, addUIClsToElement:function(cls) {
  var me = this, result = me.callParent(arguments), classes = [me.baseCls + '-body-' + cls, me.baseCls + '-body-' + me.ui + '-' + cls], array, i;
  if (me.bodyCls) {
    array = me.bodyCls.split(' ');
    for (i = 0; i < classes.length; i++) {
      if (!Ext.Array.contains(array, classes[i])) {
        array.push(classes[i]);
      }
    }
    me.bodyCls = array.join(' ');
  } else {
    me.bodyCls = classes.join(' ');
  }
  return result;
}, removeUIClsFromElement:function(cls) {
  var me = this, result = me.callParent(arguments), classes = [me.baseCls + '-body-' + cls, me.baseCls + '-body-' + me.ui + '-' + cls], array, i;
  if (me.bodyCls) {
    array = me.bodyCls.split(' ');
    for (i = 0; i < classes.length; i++) {
      Ext.Array.remove(array, classes[i]);
    }
    me.bodyCls = array.join(' ');
  }
  return result;
}, addUIToElement:function() {
  var me = this, array, cls;
  me.callParent(arguments);
  cls = me.baseCls + '-body-' + me.ui;
  if (me.rendered) {
    if (me.bodyCls) {
      me.body.addCls(me.bodyCls);
    } else {
      me.body.addCls(cls);
    }
  } else {
    if (me.bodyCls) {
      array = me.bodyCls.split(' ');
      if (!Ext.Array.contains(array, cls)) {
        array.push(cls);
      }
      me.bodyCls = array.join(' ');
    } else {
      me.bodyCls = cls;
    }
  }
  if (me.titleCmp && me.titleCmp.rendered) {
    me.titleCmp.addCls(me.baseCls + '-text-container-' + me.ui);
  }
}, removeUIFromElement:function() {
  var me = this, array, cls;
  me.callParent(arguments);
  cls = me.baseCls + '-body-' + me.ui;
  if (me.rendered) {
    if (me.bodyCls) {
      me.body.removeCls(me.bodyCls);
    } else {
      me.body.removeCls(cls);
    }
  } else {
    if (me.bodyCls) {
      array = me.bodyCls.split(' ');
      Ext.Array.remove(array, cls);
      me.bodyCls = array.join(' ');
    } else {
      me.bodyCls = cls;
    }
  }
  if (me.titleCmp && me.titleCmp.rendered) {
    me.titleCmp.removeCls(me.baseCls + '-text-container-' + me.ui);
  }
}, onClick:function(e) {
  this.fireClickEvent('click', e);
}, onDblClick:function(e) {
  this.fireClickEvent('dblclick', e);
}, fireClickEvent:function(type, e) {
  var toolCls = '.' + Ext.panel.Tool.prototype.baseCls;
  if (!e.getTarget(toolCls)) {
    this.fireEvent(type, this, e);
  }
}, getFocusEl:function() {
  return this.el;
}, getTargetEl:function() {
  return this.body || this.frameBody || this.el;
}, applyTargetCls:function(targetCls) {
  this.bodyTargetCls = targetCls;
}, setTitle:function(title) {
  var me = this, titleCmp = me.titleCmp;
  me.title = title;
  if (titleCmp.rendered) {
    titleCmp.textEl.update(me.title || '\x26#160;');
    titleCmp.updateLayout();
  } else {
    me.titleCmp.on({render:function() {
      me.setTitle(title);
    }, single:true});
  }
}, getMinWidth:function() {
  var me = this, textEl = me.titleCmp.textEl.dom, result, tools = me.tools, l, i;
  textEl.style.display = 'inline';
  result = textEl.offsetWidth;
  textEl.style.display = '';
  if (tools && (l = tools.length)) {
    for (i = 0; i < l; i++) {
      if (tools[i].el) {
        result += tools[i].el.dom.offsetWidth;
      }
    }
  }
  if (me.iconCmp) {
    result += me.iconCmp.el.dom.offsetWidth;
  }
  return result + 10;
}, setIconCls:function(cls) {
  var me = this, isEmpty = !cls || !cls.length, iconCmp = me.iconCmp;
  me.iconCls = cls;
  if (!me.iconCmp && !isEmpty) {
    me.initIconCmp();
    me.insert(0, me.iconCmp);
  } else {
    if (iconCmp) {
      if (isEmpty) {
        me.iconCmp.destroy();
        delete me.iconCmp;
      } else {
        iconCmp.removeCls(iconCmp.iconCls);
        iconCmp.addCls(cls);
        iconCmp.iconCls = cls;
      }
    }
  }
}, setIcon:function(icon) {
  var me = this, isEmpty = !icon || !icon.length, iconCmp = me.iconCmp;
  me.icon = icon;
  if (!me.iconCmp && !isEmpty) {
    me.initIconCmp();
    me.insert(0, me.iconCmp);
  } else {
    if (iconCmp) {
      if (isEmpty) {
        me.iconCmp.destroy();
        delete me.iconCmp;
      } else {
        iconCmp.setSrc(me.icon);
      }
    }
  }
}, setGlyph:function(glyph) {
  var me = this, iconCmp = me.iconCmp;
  if (!me.iconCmp) {
    me.initIconCmp();
    me.insert(0, me.iconCmp);
  } else {
    if (iconCmp) {
      if (glyph) {
        me.iconCmp.setGlyph(glyph);
      } else {
        me.iconCmp.destroy();
        delete me.iconCmp;
      }
    }
  }
}, getTools:function() {
  return this.tools.slice();
}, addTool:function(tool) {
  this.add(Ext.ComponentManager.create(tool, 'tool'));
}, syncBeforeAfterTitleClasses:function() {
  var me = this, items = me.items, childItems = items.items, titlePosition = me.titlePosition, itemCount = childItems.length, itemGeneration = items.generation, syncGen = me.syncBeforeAfterGen, afterCls, beforeCls, i, item;
  if (syncGen === itemGeneration) {
    return;
  }
  me.syncBeforeAfterGen = itemGeneration;
  for (i = 0; i < itemCount; ++i) {
    item = childItems[i];
    afterCls = item.afterTitleCls || (item.afterTitleCls = item.baseCls + '-after-title');
    beforeCls = item.beforeTitleCls || (item.beforeTitleCls = item.baseCls + '-before-title');
    if (!me.title || i < titlePosition) {
      if (syncGen) {
        item.removeCls(afterCls);
      }
      item.addCls(beforeCls);
    } else {
      if (i > titlePosition) {
        if (syncGen) {
          item.removeCls(beforeCls);
        }
        item.addCls(afterCls);
      }
    }
  }
}, onAdd:function(component, index) {
  var tools = this.tools;
  this.callParent(arguments);
  if (component.isTool) {
    tools.push(component);
    tools[component.type] = component;
  }
}, initRenderData:function() {
  return Ext.applyIf(this.callParent(), {bodyCls:this.bodyCls, bodyTargetCls:this.bodyTargetCls, headerCls:this.headerCls});
}, getDockName:function() {
  return this.dock;
}, getFramingInfoCls:function() {
  var me = this, cls = me.callParent(), owner = me.ownerCt;
  if (!me.expanding && (owner && owner.collapsed) || me.isCollapsedExpander) {
    cls += '-' + owner.collapsedCls;
  }
  return cls + '-' + me.dock;
}});
Ext.define('Ext.dd.DragDrop', {constructor:function(id, sGroup, config) {
  if (id) {
    this.init(id, sGroup, config);
  }
}, id:null, config:null, dragElId:null, handleElId:null, invalidHandleTypes:null, invalidHandleIds:null, invalidHandleClasses:null, startPageX:0, startPageY:0, groups:null, locked:false, lock:function() {
  this.locked = true;
}, moveOnly:false, unlock:function() {
  this.locked = false;
}, isTarget:true, padding:null, _domRef:null, __ygDragDrop:true, constrainX:false, constrainY:false, minX:0, maxX:0, minY:0, maxY:0, maintainOffset:false, xTicks:null, yTicks:null, primaryButtonOnly:true, available:false, hasOuterHandles:false, b4StartDrag:function(x, y) {
}, startDrag:function(x, y) {
}, b4Drag:function(e) {
}, onDrag:function(e) {
}, onDragEnter:function(e, id) {
}, b4DragOver:function(e) {
}, onDragOver:function(e, id) {
}, b4DragOut:function(e) {
}, onDragOut:function(e, id) {
}, b4DragDrop:function(e) {
}, onDragDrop:function(e, id) {
}, onInvalidDrop:function(e) {
}, b4EndDrag:function(e) {
}, endDrag:function(e) {
}, b4MouseDown:function(e) {
}, onMouseDown:function(e) {
}, onMouseUp:function(e) {
}, onAvailable:function() {
}, defaultPadding:{left:0, right:0, top:0, bottom:0}, constrainTo:function(constrainTo, pad, inContent) {
  if (Ext.isNumber(pad)) {
    pad = {left:pad, right:pad, top:pad, bottom:pad};
  }
  pad = pad || this.defaultPadding;
  var b = Ext.get(this.getEl()).getBox(), ce = Ext.get(constrainTo), s = ce.getScroll(), c, cd = ce.dom, xy, topSpace, leftSpace;
  if (cd == document.body) {
    c = {x:s.left, y:s.top, width:Ext.Element.getViewWidth(), height:Ext.Element.getViewHeight()};
  } else {
    xy = ce.getXY();
    c = {x:xy[0], y:xy[1], width:cd.clientWidth, height:cd.clientHeight};
  }
  topSpace = b.y - c.y;
  leftSpace = b.x - c.x;
  this.resetConstraints();
  this.setXConstraint(leftSpace - (pad.left || 0), c.width - leftSpace - b.width - (pad.right || 0), this.xTickSize);
  this.setYConstraint(topSpace - (pad.top || 0), c.height - topSpace - b.height - (pad.bottom || 0), this.yTickSize);
}, getEl:function() {
  if (!this._domRef) {
    this._domRef = Ext.getDom(this.id);
  }
  return this._domRef;
}, getDragEl:function() {
  return Ext.getDom(this.dragElId);
}, init:function(id, sGroup, config) {
  this.initTarget(id, sGroup, config);
  Ext.EventManager.on(this.id, 'mousedown', this.handleMouseDown, this);
}, initTarget:function(id, sGroup, config) {
  this.config = config || {};
  this.DDMInstance = Ext.dd.DragDropManager;
  this.groups = {};
  if (typeof id !== 'string') {
    id = Ext.id(id);
  }
  this.id = id;
  this.addToGroup(sGroup ? sGroup : 'default');
  this.handleElId = id;
  this.setDragElId(id);
  this.invalidHandleTypes = {A:'A'};
  this.invalidHandleIds = {};
  this.invalidHandleClasses = [];
  this.applyConfig();
  this.handleOnAvailable();
}, applyConfig:function() {
  this.padding = this.config.padding || [0, 0, 0, 0];
  this.isTarget = this.config.isTarget !== false;
  this.maintainOffset = this.config.maintainOffset;
  this.primaryButtonOnly = this.config.primaryButtonOnly !== false;
}, handleOnAvailable:function() {
  this.available = true;
  this.resetConstraints();
  this.onAvailable();
}, setPadding:function(iTop, iRight, iBot, iLeft) {
  if (!iRight && 0 !== iRight) {
    this.padding = [iTop, iTop, iTop, iTop];
  } else {
    if (!iBot && 0 !== iBot) {
      this.padding = [iTop, iRight, iTop, iRight];
    } else {
      this.padding = [iTop, iRight, iBot, iLeft];
    }
  }
}, setInitPosition:function(diffX, diffY) {
  var el = this.getEl(), dx, dy, p;
  if (!this.DDMInstance.verifyEl(el)) {
    return;
  }
  dx = diffX || 0;
  dy = diffY || 0;
  p = Ext.Element.getXY(el);
  this.initPageX = p[0] - dx;
  this.initPageY = p[1] - dy;
  this.lastPageX = p[0];
  this.lastPageY = p[1];
  this.setStartPosition(p);
}, setStartPosition:function(pos) {
  var p = pos || Ext.Element.getXY(this.getEl());
  this.deltaSetXY = null;
  this.startPageX = p[0];
  this.startPageY = p[1];
}, addToGroup:function(sGroup) {
  this.groups[sGroup] = true;
  this.DDMInstance.regDragDrop(this, sGroup);
}, removeFromGroup:function(sGroup) {
  if (this.groups[sGroup]) {
    delete this.groups[sGroup];
  }
  this.DDMInstance.removeDDFromGroup(this, sGroup);
}, setDragElId:function(id) {
  this.dragElId = id;
}, setHandleElId:function(id) {
  if (typeof id !== 'string') {
    id = Ext.id(id);
  }
  this.handleElId = id;
  this.DDMInstance.regHandle(this.id, id);
}, setOuterHandleElId:function(id) {
  if (typeof id !== 'string') {
    id = Ext.id(id);
  }
  Ext.EventManager.on(id, 'mousedown', this.handleMouseDown, this);
  this.setHandleElId(id);
  this.hasOuterHandles = true;
}, unreg:function() {
  Ext.EventManager.un(this.id, 'mousedown', this.handleMouseDown, this);
  this._domRef = null;
  this.DDMInstance._remove(this);
}, destroy:function() {
  this.unreg();
}, isLocked:function() {
  return this.DDMInstance.isLocked() || this.locked;
}, handleMouseDown:function(e, oDD) {
  var me = this;
  if (me.primaryButtonOnly && e.button != 0 || me.isLocked()) {
    return;
  }
  me.DDMInstance.refreshCache(me.groups);
  if (me.hasOuterHandles || me.DDMInstance.isOverTarget(e.getPoint(), me)) {
    if (me.clickValidator(e)) {
      me.setStartPosition();
      me.b4MouseDown(e);
      me.onMouseDown(e);
      me.DDMInstance.handleMouseDown(e, me);
      me.DDMInstance.stopEvent(e);
    }
  }
}, clickValidator:function(e) {
  var target = e.getTarget();
  return this.isValidHandleChild(target) && (this.id == this.handleElId || this.DDMInstance.handleWasClicked(target, this.id));
}, addInvalidHandleType:function(tagName) {
  var type = tagName.toUpperCase();
  this.invalidHandleTypes[type] = type;
}, addInvalidHandleId:function(id) {
  if (typeof id !== 'string') {
    id = Ext.id(id);
  }
  this.invalidHandleIds[id] = id;
}, addInvalidHandleClass:function(cssClass) {
  this.invalidHandleClasses.push(cssClass);
}, removeInvalidHandleType:function(tagName) {
  var type = tagName.toUpperCase();
  delete this.invalidHandleTypes[type];
}, removeInvalidHandleId:function(id) {
  if (typeof id !== 'string') {
    id = Ext.id(id);
  }
  delete this.invalidHandleIds[id];
}, removeInvalidHandleClass:function(cssClass) {
  for (var i = 0, len = this.invalidHandleClasses.length; i < len; ++i) {
    if (this.invalidHandleClasses[i] == cssClass) {
      delete this.invalidHandleClasses[i];
    }
  }
}, isValidHandleChild:function(node) {
  var valid = true, nodeName, i, len;
  try {
    nodeName = node.nodeName.toUpperCase();
  } catch (e$29) {
    nodeName = node.nodeName;
  }
  valid = valid && !this.invalidHandleTypes[nodeName];
  valid = valid && !this.invalidHandleIds[node.id];
  for (i = 0, len = this.invalidHandleClasses.length; valid && i < len; ++i) {
    valid = !Ext.fly(node).hasCls(this.invalidHandleClasses[i]);
  }
  return valid;
}, setXTicks:function(iStartX, iTickSize) {
  this.xTicks = [];
  this.xTickSize = iTickSize;
  var tickMap = {}, i;
  for (i = this.initPageX; i >= this.minX; i = i - iTickSize) {
    if (!tickMap[i]) {
      this.xTicks[this.xTicks.length] = i;
      tickMap[i] = true;
    }
  }
  for (i = this.initPageX; i <= this.maxX; i = i + iTickSize) {
    if (!tickMap[i]) {
      this.xTicks[this.xTicks.length] = i;
      tickMap[i] = true;
    }
  }
  Ext.Array.sort(this.xTicks, this.DDMInstance.numericSort);
}, setYTicks:function(iStartY, iTickSize) {
  this.yTicks = [];
  this.yTickSize = iTickSize;
  var tickMap = {}, i;
  for (i = this.initPageY; i >= this.minY; i = i - iTickSize) {
    if (!tickMap[i]) {
      this.yTicks[this.yTicks.length] = i;
      tickMap[i] = true;
    }
  }
  for (i = this.initPageY; i <= this.maxY; i = i + iTickSize) {
    if (!tickMap[i]) {
      this.yTicks[this.yTicks.length] = i;
      tickMap[i] = true;
    }
  }
  Ext.Array.sort(this.yTicks, this.DDMInstance.numericSort);
}, setXConstraint:function(iLeft, iRight, iTickSize) {
  this.leftConstraint = iLeft;
  this.rightConstraint = iRight;
  this.minX = this.initPageX - iLeft;
  this.maxX = this.initPageX + iRight;
  if (iTickSize) {
    this.setXTicks(this.initPageX, iTickSize);
  }
  this.constrainX = true;
}, clearConstraints:function() {
  this.constrainX = false;
  this.constrainY = false;
  this.clearTicks();
}, clearTicks:function() {
  this.xTicks = null;
  this.yTicks = null;
  this.xTickSize = 0;
  this.yTickSize = 0;
}, setYConstraint:function(iUp, iDown, iTickSize) {
  this.topConstraint = iUp;
  this.bottomConstraint = iDown;
  this.minY = this.initPageY - iUp;
  this.maxY = this.initPageY + iDown;
  if (iTickSize) {
    this.setYTicks(this.initPageY, iTickSize);
  }
  this.constrainY = true;
}, resetConstraints:function() {
  if (this.initPageX || this.initPageX === 0) {
    var dx = this.maintainOffset ? this.lastPageX - this.initPageX : 0, dy = this.maintainOffset ? this.lastPageY - this.initPageY : 0;
    this.setInitPosition(dx, dy);
  } else {
    this.setInitPosition();
  }
  if (this.constrainX) {
    this.setXConstraint(this.leftConstraint, this.rightConstraint, this.xTickSize);
  }
  if (this.constrainY) {
    this.setYConstraint(this.topConstraint, this.bottomConstraint, this.yTickSize);
  }
}, getTick:function(val, tickArray) {
  if (!tickArray) {
    return val;
  } else {
    if (tickArray[0] >= val) {
      return tickArray[0];
    } else {
      var i, len, next, diff1, diff2;
      for (i = 0, len = tickArray.length; i < len; ++i) {
        next = i + 1;
        if (tickArray[next] && tickArray[next] >= val) {
          diff1 = val - tickArray[i];
          diff2 = tickArray[next] - val;
          return diff2 > diff1 ? tickArray[i] : tickArray[next];
        }
      }
      return tickArray[tickArray.length - 1];
    }
  }
}, toString:function() {
  return 'DragDrop ' + this.id;
}});
Ext.define('Ext.dd.DD', {extend:Ext.dd.DragDrop, constructor:function(id, sGroup, config) {
  if (id) {
    this.init(id, sGroup, config);
  }
}, scroll:true, autoOffset:function(iPageX, iPageY) {
  var x = iPageX - this.startPageX, y = iPageY - this.startPageY;
  this.setDelta(x, y);
}, setDelta:function(iDeltaX, iDeltaY) {
  this.deltaX = iDeltaX;
  this.deltaY = iDeltaY;
}, setDragElPos:function(iPageX, iPageY) {
  var el = this.getDragEl();
  this.alignElWithMouse(el, iPageX, iPageY);
}, alignElWithMouse:function(el, iPageX, iPageY) {
  var oCoord = this.getTargetCoord(iPageX, iPageY), fly = el.dom ? el : Ext.fly(el, '_dd'), elSize = fly.getSize(), EL = Ext.Element, vpSize, aCoord, newLeft, newTop;
  if (!this.deltaSetXY) {
    vpSize = this.cachedViewportSize = {width:EL.getDocumentWidth(), height:EL.getDocumentHeight()};
    aCoord = [Math.max(0, Math.min(oCoord.x, vpSize.width - elSize.width)), Math.max(0, Math.min(oCoord.y, vpSize.height - elSize.height))];
    fly.setXY(aCoord);
    newLeft = this.getLocalX(fly);
    newTop = fly.getLocalY();
    this.deltaSetXY = [newLeft - oCoord.x, newTop - oCoord.y];
  } else {
    vpSize = this.cachedViewportSize;
    this.setLocalXY(fly, Math.max(0, Math.min(oCoord.x + this.deltaSetXY[0], vpSize.width - elSize.width)), Math.max(0, Math.min(oCoord.y + this.deltaSetXY[1], vpSize.height - elSize.height)));
  }
  this.cachePosition(oCoord.x, oCoord.y);
  this.autoScroll(oCoord.x, oCoord.y, el.offsetHeight, el.offsetWidth);
  return oCoord;
}, cachePosition:function(iPageX, iPageY) {
  if (iPageX) {
    this.lastPageX = iPageX;
    this.lastPageY = iPageY;
  } else {
    var aCoord = Ext.Element.getXY(this.getEl());
    this.lastPageX = aCoord[0];
    this.lastPageY = aCoord[1];
  }
}, autoScroll:function(x, y, h, w) {
  if (this.scroll) {
    var clientH = Ext.Element.getViewHeight(), clientW = Ext.Element.getViewWidth(), st = this.DDMInstance.getScrollTop(), sl = this.DDMInstance.getScrollLeft(), bot = h + y, right = w + x, toBot = clientH + st - y - this.deltaY, toRight = clientW + sl - x - this.deltaX, thresh = 40, scrAmt = document.all ? 80 : 30;
    if (bot > clientH && toBot < thresh) {
      window.scrollTo(sl, st + scrAmt);
    }
    if (y < st && st > 0 && y - st < thresh) {
      window.scrollTo(sl, st - scrAmt);
    }
    if (right > clientW && toRight < thresh) {
      window.scrollTo(sl + scrAmt, st);
    }
    if (x < sl && sl > 0 && x - sl < thresh) {
      window.scrollTo(sl - scrAmt, st);
    }
  }
}, getTargetCoord:function(iPageX, iPageY) {
  var x = iPageX - this.deltaX, y = iPageY - this.deltaY;
  if (this.constrainX) {
    if (x < this.minX) {
      x = this.minX;
    }
    if (x > this.maxX) {
      x = this.maxX;
    }
  }
  if (this.constrainY) {
    if (y < this.minY) {
      y = this.minY;
    }
    if (y > this.maxY) {
      y = this.maxY;
    }
  }
  x = this.getTick(x, this.xTicks);
  y = this.getTick(y, this.yTicks);
  return {x:x, y:y};
}, applyConfig:function() {
  this.callParent();
  this.scroll = this.config.scroll !== false;
}, b4MouseDown:function(e) {
  this.autoOffset(e.getPageX(), e.getPageY());
}, b4Drag:function(e) {
  this.setDragElPos(e.getPageX(), e.getPageY());
}, toString:function() {
  return 'DD ' + this.id;
}, getLocalX:function(el) {
  return el.getLocalX();
}, setLocalXY:function(el, x, y) {
  el.setLocalXY(x, y);
}});
Ext.define('Ext.dd.DDProxy', {extend:Ext.dd.DD, statics:{dragElId:'ygddfdiv'}, constructor:function(id, sGroup, config) {
  if (id) {
    this.init(id, sGroup, config);
    this.initFrame();
  }
}, resizeFrame:true, centerFrame:false, createFrame:function() {
  var self = this, body = document.body, div, s;
  if (!body || !body.firstChild) {
    setTimeout(function() {
      self.createFrame();
    }, 50);
    return;
  }
  div = this.getDragEl();
  if (!div) {
    div = document.createElement('div');
    div.id = this.dragElId;
    s = div.style;
    s.position = 'absolute';
    s.visibility = 'hidden';
    s.cursor = 'move';
    s.border = '2px solid #aaa';
    s.zIndex = 999;
    body.insertBefore(div, body.firstChild);
  }
}, initFrame:function() {
  this.createFrame();
}, applyConfig:function() {
  this.callParent();
  this.resizeFrame = this.config.resizeFrame !== false;
  this.centerFrame = this.config.centerFrame;
  this.setDragElId(this.config.dragElId || Ext.dd.DDProxy.dragElId);
}, showFrame:function(iPageX, iPageY) {
  var el = this.getEl(), dragEl = this.getDragEl(), s = dragEl.style;
  this._resizeProxy();
  if (this.centerFrame) {
    this.setDelta(Math.round(parseInt(s.width, 10) / 2), Math.round(parseInt(s.height, 10) / 2));
  }
  this.setDragElPos(iPageX, iPageY);
  Ext.fly(dragEl).show();
}, _resizeProxy:function() {
  if (this.resizeFrame) {
    var el = this.getEl();
    Ext.fly(this.getDragEl()).setSize(el.offsetWidth, el.offsetHeight);
  }
}, b4MouseDown:function(e) {
  var x = e.getPageX(), y = e.getPageY();
  this.autoOffset(x, y);
  this.setDragElPos(x, y);
}, b4StartDrag:function(x, y) {
  this.showFrame(x, y);
}, b4EndDrag:function(e) {
  Ext.fly(this.getDragEl()).hide();
}, endDrag:function(e) {
  var lel = this.getEl(), del = this.getDragEl();
  del.style.visibility = '';
  this.beforeMove();
  lel.style.visibility = 'hidden';
  Ext.dd.DDM.moveToEl(lel, del);
  del.style.visibility = 'hidden';
  lel.style.visibility = '';
  this.afterDrag();
}, beforeMove:function() {
}, afterDrag:function() {
}, toString:function() {
  return 'DDProxy ' + this.id;
}});
Ext.define('Ext.dd.StatusProxy', {extend:Ext.Component, animRepair:false, childEls:['ghost'], renderTpl:['\x3cdiv class\x3d"' + Ext.baseCSSPrefix + 'dd-drop-icon"\x3e\x3c/div\x3e' + '\x3cdiv id\x3d"{id}-ghost" class\x3d"' + Ext.baseCSSPrefix + 'dd-drag-ghost"\x3e\x3c/div\x3e'], repairCls:Ext.baseCSSPrefix + 'dd-drag-repair', constructor:function(config) {
  var me = this;
  config = config || {};
  Ext.apply(me, {hideMode:'visibility', hidden:true, floating:true, id:me.id || Ext.id(), cls:Ext.baseCSSPrefix + 'dd-drag-proxy ' + this.dropNotAllowed, shadow:config.shadow || false, renderTo:Ext.getDetachedBody()});
  me.callParent(arguments);
  this.dropStatus = this.dropNotAllowed;
}, dropAllowed:Ext.baseCSSPrefix + 'dd-drop-ok', dropNotAllowed:Ext.baseCSSPrefix + 'dd-drop-nodrop', setStatus:function(cssClass) {
  cssClass = cssClass || this.dropNotAllowed;
  if (this.dropStatus != cssClass) {
    this.el.replaceCls(this.dropStatus, cssClass);
    this.dropStatus = cssClass;
  }
}, reset:function(clearGhost) {
  var me = this, clsPrefix = Ext.baseCSSPrefix + 'dd-drag-proxy ';
  me.el.replaceCls(clsPrefix + me.dropAllowed, clsPrefix + me.dropNotAllowed);
  me.dropStatus = me.dropNotAllowed;
  if (clearGhost) {
    me.ghost.update('');
  }
}, update:function(html) {
  if (typeof html == 'string') {
    this.ghost.update(html);
  } else {
    this.ghost.update('');
    html.style.margin = '0';
    this.ghost.dom.appendChild(html);
  }
  var el = this.ghost.dom.firstChild;
  if (el) {
    Ext.fly(el).setStyle('float', 'none');
  }
}, getGhost:function() {
  return this.ghost;
}, hide:function(clear) {
  this.callParent();
  if (clear) {
    this.reset(true);
  }
}, stop:function() {
  if (this.anim && this.anim.isAnimated && this.anim.isAnimated()) {
    this.anim.stop();
  }
}, sync:function() {
  this.el.sync();
}, repair:function(xy, callback, scope) {
  var me = this;
  me.callback = callback;
  me.scope = scope;
  if (xy && me.animRepair !== false) {
    me.el.addCls(me.repairCls);
    me.el.hideUnders(true);
    me.anim = me.el.animate({duration:me.repairDuration || 500, easing:'ease-out', to:{x:xy[0], y:xy[1]}, stopAnimation:true, callback:me.afterRepair, scope:me});
  } else {
    me.afterRepair();
  }
}, afterRepair:function() {
  var me = this;
  me.hide(true);
  me.el.removeCls(me.repairCls);
  if (typeof me.callback == 'function') {
    me.callback.call(me.scope || me);
  }
  delete me.callback;
  delete me.scope;
}});
Ext.define('Ext.dd.DragSource', {extend:Ext.dd.DDProxy, dropAllowed:Ext.baseCSSPrefix + 'dd-drop-ok', dropNotAllowed:Ext.baseCSSPrefix + 'dd-drop-nodrop', animRepair:true, repairHighlightColor:'c3daf9', constructor:function(el, config) {
  this.el = Ext.get(el);
  if (!this.dragData) {
    this.dragData = {};
  }
  Ext.apply(this, config);
  if (!this.proxy) {
    this.proxy = new Ext.dd.StatusProxy({id:this.el.id + '-drag-status-proxy', animRepair:this.animRepair});
  }
  this.callParent([this.el.dom, this.ddGroup || this.group, {dragElId:this.proxy.id, resizeFrame:false, isTarget:false, scroll:this.scroll === true}]);
  this.dragging = false;
}, getDragData:function(e) {
  return this.dragData;
}, onDragEnter:function(e, id) {
  var target = Ext.dd.DragDropManager.getDDById(id), status;
  this.cachedTarget = target;
  if (this.beforeDragEnter(target, e, id) !== false) {
    if (target.isNotifyTarget) {
      status = target.notifyEnter(this, e, this.dragData);
      this.proxy.setStatus(status);
    } else {
      this.proxy.setStatus(this.dropAllowed);
    }
    if (this.afterDragEnter) {
      this.afterDragEnter(target, e, id);
    }
  }
}, beforeDragEnter:function(target, e, id) {
  return true;
}, onDragOver:function(e, id) {
  var target = this.cachedTarget || Ext.dd.DragDropManager.getDDById(id), status;
  if (this.beforeDragOver(target, e, id) !== false) {
    if (target.isNotifyTarget) {
      status = target.notifyOver(this, e, this.dragData);
      this.proxy.setStatus(status);
    }
    if (this.afterDragOver) {
      this.afterDragOver(target, e, id);
    }
  }
}, beforeDragOver:function(target, e, id) {
  return true;
}, onDragOut:function(e, id) {
  var target = this.cachedTarget || Ext.dd.DragDropManager.getDDById(id);
  if (this.beforeDragOut(target, e, id) !== false) {
    if (target.isNotifyTarget) {
      target.notifyOut(this, e, this.dragData);
    }
    this.proxy.reset();
    if (this.afterDragOut) {
      this.afterDragOut(target, e, id);
    }
  }
  this.cachedTarget = null;
}, beforeDragOut:function(target, e, id) {
  return true;
}, onDragDrop:function(e, id) {
  var target = this.cachedTarget || Ext.dd.DragDropManager.getDDById(id);
  if (this.beforeDragDrop(target, e, id) !== false) {
    if (target.isNotifyTarget) {
      if (target.notifyDrop(this, e, this.dragData) !== false) {
        this.onValidDrop(target, e, id);
      } else {
        this.onInvalidDrop(target, e, id);
      }
    } else {
      this.onValidDrop(target, e, id);
    }
    if (this.afterDragDrop) {
      this.afterDragDrop(target, e, id);
    }
  }
  delete this.cachedTarget;
}, beforeDragDrop:function(target, e, id) {
  return true;
}, onValidDrop:function(target, e, id) {
  this.hideProxy();
  if (this.afterValidDrop) {
    this.afterValidDrop(target, e, id);
  }
}, getRepairXY:function(e, data) {
  return this.el.getXY();
}, onInvalidDrop:function(target, e, id) {
  var me = this;
  if (!e) {
    e = target;
    target = null;
    id = e.getTarget().id;
  }
  if (me.beforeInvalidDrop(target, e, id) !== false) {
    if (me.cachedTarget) {
      if (me.cachedTarget.isNotifyTarget) {
        me.cachedTarget.notifyOut(me, e, me.dragData);
      }
      me.cacheTarget = null;
    }
    me.proxy.repair(me.getRepairXY(e, me.dragData), me.afterRepair, me);
    if (me.afterInvalidDrop) {
      me.afterInvalidDrop(e, id);
    }
  }
}, afterRepair:function() {
  var me = this;
  if (Ext.enableFx) {
    me.el.highlight(me.repairHighlightColor);
  }
  me.dragging = false;
}, beforeInvalidDrop:function(target, e, id) {
  return true;
}, handleMouseDown:function(e) {
  if (this.dragging) {
    return;
  }
  var data = this.getDragData(e);
  if (data && this.onBeforeDrag(data, e) !== false) {
    this.dragData = data;
    this.proxy.stop();
    this.callParent(arguments);
  }
}, onBeforeDrag:function(data, e) {
  return true;
}, onStartDrag:Ext.emptyFn, alignElWithMouse:function() {
  this.proxy.ensureAttachedToBody(true);
  return this.callParent(arguments);
}, startDrag:function(x, y) {
  this.proxy.reset();
  this.proxy.hidden = false;
  this.dragging = true;
  this.proxy.update('');
  this.onInitDrag(x, y);
  this.proxy.show();
}, onInitDrag:function(x, y) {
  var clone = this.el.dom.cloneNode(true);
  clone.id = Ext.id();
  this.proxy.update(clone);
  this.onStartDrag(x, y);
  return true;
}, getProxy:function() {
  return this.proxy;
}, hideProxy:function() {
  this.proxy.hide();
  this.proxy.reset(true);
  this.dragging = false;
}, triggerCacheRefresh:function() {
  Ext.dd.DDM.refreshCache(this.groups);
}, b4EndDrag:function(e) {
}, endDrag:function(e) {
  this.onEndDrag(this.dragData, e);
}, onEndDrag:function(data, e) {
}, autoOffset:function(x, y) {
  this.setDelta(-12, -20);
}, destroy:function() {
  this.callParent();
  Ext.destroy(this.proxy);
}});
Ext.define('Ext.panel.Proxy', {alternateClassName:'Ext.dd.PanelProxy', moveOnDrag:true, constructor:function(panel, config) {
  var me = this;
  me.panel = panel;
  me.id = me.panel.id + '-ddproxy';
  Ext.apply(me, config);
}, insertProxy:true, setStatus:Ext.emptyFn, reset:Ext.emptyFn, update:Ext.emptyFn, stop:Ext.emptyFn, sync:Ext.emptyFn, getEl:function() {
  return this.ghost.el;
}, getGhost:function() {
  return this.ghost;
}, getProxy:function() {
  return this.proxy;
}, hide:function() {
  var me = this;
  if (me.ghost) {
    if (me.proxy) {
      me.proxy.remove();
      delete me.proxy;
    }
    me.panel.unghost(null, me.moveOnDrag);
    delete me.ghost;
  }
}, show:function() {
  var me = this, panelSize;
  if (!me.ghost) {
    panelSize = me.panel.getSize();
    me.panel.el.setVisibilityMode(Ext.Element.DISPLAY);
    me.ghost = me.panel.ghost();
    if (me.insertProxy) {
      me.proxy = me.panel.el.insertSibling({cls:Ext.baseCSSPrefix + 'panel-dd-spacer'});
      me.proxy.setSize(panelSize);
    }
  }
}, repair:function(xy, callback, scope) {
  this.hide();
  Ext.callback(callback, scope || this);
}, moveProxy:function(parentNode, before) {
  if (this.proxy) {
    parentNode.insertBefore(this.proxy.dom, before);
  }
}});
Ext.define('Ext.panel.DD', {extend:Ext.dd.DragSource, constructor:function(panel, cfg) {
  var me = this;
  me.panel = panel;
  me.dragData = {panel:panel};
  me.panelProxy = new Ext.panel.Proxy(panel, cfg);
  me.proxy = me.panelProxy.proxy;
  me.callParent([panel.el, cfg]);
  me.setupEl(panel);
}, setupEl:function(panel) {
  var me = this, header = panel.header, el = panel.body;
  if (header) {
    me.setHandleElId(header.id);
    el = header.el;
  }
  if (el) {
    el.setStyle('cursor', 'move');
    me.scroll = false;
  } else {
    panel.on('boxready', me.setupEl, me, {single:true});
  }
}, showFrame:Ext.emptyFn, startDrag:Ext.emptyFn, b4StartDrag:function(x, y) {
  this.panelProxy.show();
}, b4MouseDown:function(e) {
  var x = e.getPageX(), y = e.getPageY();
  this.autoOffset(x, y);
}, onInitDrag:function(x, y) {
  this.onStartDrag(x, y);
  return true;
}, createFrame:Ext.emptyFn, getDragEl:function(e) {
  var ghost = this.panelProxy.ghost;
  if (ghost) {
    return ghost.el.dom;
  }
}, endDrag:function(e) {
  this.panelProxy.hide();
  this.panel.saveState();
}, autoOffset:function(x, y) {
  x -= this.startPageX;
  y -= this.startPageY;
  this.setDelta(x, y);
}, onInvalidDrop:function(target, e, id) {
  var me = this;
  if (me.beforeInvalidDrop(target, e, id) !== false) {
    if (me.cachedTarget) {
      if (me.cachedTarget.isNotifyTarget) {
        me.cachedTarget.notifyOut(me, e, me.dragData);
      }
      me.cacheTarget = null;
    }
    if (me.afterInvalidDrop) {
      me.afterInvalidDrop(e, id);
    }
  }
}});
Ext.define('Ext.layout.component.Dock', {extend:Ext.layout.component.Component, alias:'layout.dock', alternateClassName:'Ext.layout.component.AbstractDock', type:'dock', horzAxisProps:{name:'horz', oppositeName:'vert', dockBegin:'left', dockEnd:'right', horizontal:true, marginBegin:'margin-left', maxSize:'maxWidth', minSize:'minWidth', pos:'x', setSize:'setWidth', shrinkWrapDock:'shrinkWrapDockWidth', size:'width', sizeModel:'widthModel'}, vertAxisProps:{name:'vert', oppositeName:'horz', dockBegin:'top', 
dockEnd:'bottom', horizontal:false, marginBegin:'margin-top', maxSize:'maxHeight', minSize:'minHeight', pos:'y', setSize:'setHeight', shrinkWrapDock:'shrinkWrapDockHeight', size:'height', sizeModel:'heightModel'}, initializedBorders:-1, horizontalCollapsePolicy:{width:true, x:true}, verticalCollapsePolicy:{height:true, y:true}, finishRender:function() {
  var me = this, target, items;
  me.callParent();
  target = me.getRenderTarget();
  items = me.getDockedItems();
  me.finishRenderItems(target, items);
}, isItemBoxParent:function(itemContext) {
  return true;
}, isItemShrinkWrap:function(item) {
  return true;
}, noBorderClasses:[Ext.baseCSSPrefix + 'docked-noborder-top', Ext.baseCSSPrefix + 'docked-noborder-right', Ext.baseCSSPrefix + 'docked-noborder-bottom', Ext.baseCSSPrefix + 'docked-noborder-left'], noBorderClassesSides:{top:Ext.baseCSSPrefix + 'docked-noborder-top', right:Ext.baseCSSPrefix + 'docked-noborder-right', bottom:Ext.baseCSSPrefix + 'docked-noborder-bottom', left:Ext.baseCSSPrefix + 'docked-noborder-left'}, borderWidthProps:{top:'border-top-width', right:'border-right-width', bottom:'border-bottom-width', 
left:'border-left-width'}, handleItemBorders:function() {
  var me = this, owner = me.owner, borders, docked, lastItems = me.lastDockedItems, oldBorders = me.borders, currentGeneration = owner.dockedItems.generation, noBorderClassesSides = me.noBorderClassesSides, borderWidthProps = me.borderWidthProps, i, ln, item, dock, side, collapsed = me.collapsed;
  if (me.initializedBorders == currentGeneration || owner.border && !owner.manageBodyBorders) {
    return;
  }
  me.initializedBorders = currentGeneration;
  me.collapsed = false;
  me.lastDockedItems = docked = me.getLayoutItems();
  me.collapsed = collapsed;
  borders = {top:[], right:[], bottom:[], left:[]};
  for (i = 0, ln = docked.length; i < ln; i++) {
    item = docked[i];
    dock = item.dock;
    if (item.ignoreBorderManagement) {
      continue;
    }
    if (!borders[dock].satisfied) {
      borders[dock].push(item);
      borders[dock].satisfied = true;
    }
    if (!borders.top.satisfied && dock !== 'bottom') {
      borders.top.push(item);
    }
    if (!borders.right.satisfied && dock !== 'left') {
      borders.right.push(item);
    }
    if (!borders.bottom.satisfied && dock !== 'top') {
      borders.bottom.push(item);
    }
    if (!borders.left.satisfied && dock !== 'right') {
      borders.left.push(item);
    }
  }
  if (lastItems) {
    for (i = 0, ln = lastItems.length; i < ln; i++) {
      item = lastItems[i];
      if (!item.isDestroyed && !item.ignoreBorderManagement && !owner.manageBodyBorders) {
        item.removeCls(me.noBorderClasses);
      }
    }
  }
  if (oldBorders) {
    for (side in oldBorders) {
      if (owner.manageBodyBorders && oldBorders[side].satisfied) {
        owner.setBodyStyle(borderWidthProps[side], '');
      }
    }
  }
  for (side in borders) {
    ln = borders[side].length;
    if (!owner.manageBodyBorders) {
      for (i = 0; i < ln; i++) {
        borders[side][i].addCls(noBorderClassesSides[side]);
      }
      if (!borders[side].satisfied && !owner.bodyBorder || owner.bodyBorder === false) {
        owner.addBodyCls(noBorderClassesSides[side]);
      }
    } else {
      if (borders[side].satisfied) {
        owner.setBodyStyle(borderWidthProps[side], '1px');
      }
    }
  }
  me.borders = borders;
}, beforeLayoutCycle:function(ownerContext) {
  var me = this, owner = me.owner, shrinkWrap = me.sizeModels.shrinkWrap, shrinkWrapDock = owner.shrinkWrapDock, collapsedHorz, collapsedVert;
  if (owner.collapsed) {
    if (owner.collapsedVertical()) {
      collapsedVert = true;
      ownerContext.measureDimensions = 1;
    } else {
      collapsedHorz = true;
      ownerContext.measureDimensions = 2;
    }
  }
  ownerContext.collapsedVert = collapsedVert;
  ownerContext.collapsedHorz = collapsedHorz;
  if (collapsedVert) {
    ownerContext.heightModel = shrinkWrap;
  } else {
    if (collapsedHorz) {
      ownerContext.widthModel = shrinkWrap;
    }
  }
  shrinkWrapDock = shrinkWrapDock === true ? 3 : shrinkWrapDock || 0;
  ownerContext.shrinkWrapDockHeight = shrinkWrapDock & 1 && ownerContext.heightModel.shrinkWrap;
  ownerContext.shrinkWrapDockWidth = shrinkWrapDock & 2 && ownerContext.widthModel.shrinkWrap;
}, beginLayout:function(ownerContext) {
  var me = this, owner = me.owner, docked = me.getLayoutItems(), layoutContext = ownerContext.context, dockedItemCount = docked.length, dockedItems, i, item, itemContext, offsets, collapsed, dock;
  me.callParent(arguments);
  collapsed = owner.getCollapsed();
  if (collapsed !== me.lastCollapsedState && Ext.isDefined(me.lastCollapsedState)) {
    if (me.owner.collapsed) {
      ownerContext.isCollapsingOrExpanding = 1;
      owner.addClsWithUI(owner.collapsedCls);
    } else {
      ownerContext.isCollapsingOrExpanding = 2;
      owner.removeClsWithUI(owner.collapsedCls);
      ownerContext.lastCollapsedState = me.lastCollapsedState;
    }
  }
  me.lastCollapsedState = collapsed;
  ownerContext.dockedItems = dockedItems = [];
  for (i = 0; i < dockedItemCount; i++) {
    item = docked[i];
    if (item.rendered) {
      dock = item.dock;
      itemContext = layoutContext.getCmp(item);
      itemContext.dockedAt = {x:0, y:0};
      itemContext.offsets = offsets = Ext.Element.parseBox(item.offsets || 0);
      itemContext.horizontal = dock == 'top' || dock == 'bottom';
      offsets.width = offsets.left + offsets.right;
      offsets.height = offsets.top + offsets.bottom;
      dockedItems.push(itemContext);
    }
  }
  ownerContext.bodyContext = ownerContext.getEl('body');
}, beginLayoutCycle:function(ownerContext) {
  var me = this, docked = ownerContext.dockedItems, len = docked.length, owner = me.owner, frameBody = owner.frameBody, lastHeightModel = me.lastHeightModel, i, item, dock;
  me.callParent(arguments);
  if (me.owner.manageHeight) {
    if (me.lastBodyDisplay) {
      owner.body.dom.style.display = me.lastBodyDisplay = '';
    }
  } else {
    if (me.lastBodyDisplay !== 'inline-block') {
      owner.body.dom.style.display = me.lastBodyDisplay = 'inline-block';
    }
    if (lastHeightModel && lastHeightModel.shrinkWrap && !ownerContext.heightModel.shrinkWrap) {
      owner.body.dom.style.marginBottom = '';
    }
  }
  if (ownerContext.widthModel.auto) {
    if (ownerContext.widthModel.shrinkWrap) {
      owner.el.setWidth(null);
    }
    owner.body.setWidth(null);
    if (frameBody) {
      frameBody.setWidth(null);
    }
  }
  if (ownerContext.heightModel.auto) {
    owner.body.setHeight(null);
    if (frameBody) {
      frameBody.setHeight(null);
    }
  }
  if (ownerContext.collapsedVert) {
    ownerContext.setContentHeight(0);
  } else {
    if (ownerContext.collapsedHorz) {
      ownerContext.setContentWidth(0);
    }
  }
  for (i = 0; i < len; i++) {
    item = docked[i].target;
    dock = item.dock;
    if (dock == 'right') {
      item.setLocalX(0);
    } else {
      if (dock != 'left') {
        continue;
      }
    }
  }
}, calculate:function(ownerContext) {
  var me = this, measure = me.measureAutoDimensions(ownerContext, ownerContext.measureDimensions), state = ownerContext.state, horzDone = state.horzDone, vertDone = state.vertDone, bodyContext = ownerContext.bodyContext, framing, horz, vert, forward, backward;
  ownerContext.borderInfo || ownerContext.getBorderInfo();
  ownerContext.paddingInfo || ownerContext.getPaddingInfo();
  ownerContext.frameInfo || ownerContext.getFrameInfo();
  bodyContext.borderInfo || bodyContext.getBorderInfo();
  bodyContext.paddingInfo || bodyContext.getPaddingInfo();
  if (!ownerContext.frameBorder) {
    if (!(framing = ownerContext.framing)) {
      ownerContext.frameBorder = ownerContext.borderInfo;
      ownerContext.framePadding = ownerContext.paddingInfo;
    } else {
      ownerContext.frameBorder = framing.border;
      ownerContext.framePadding = framing.padding;
    }
  }
  horz = !horzDone && me.createAxis(ownerContext, measure.contentWidth, ownerContext.widthModel, me.horzAxisProps, ownerContext.collapsedHorz);
  vert = !vertDone && me.createAxis(ownerContext, measure.contentHeight, ownerContext.heightModel, me.vertAxisProps, ownerContext.collapsedVert);
  for (forward = 0, backward = ownerContext.dockedItems.length; backward--; ++forward) {
    if (horz) {
      me.dockChild(ownerContext, horz, backward, forward);
    }
    if (vert) {
      me.dockChild(ownerContext, vert, backward, forward);
    }
  }
  if (horz && me.finishAxis(ownerContext, horz)) {
    state.horzDone = horzDone = horz;
  }
  if (vert && me.finishAxis(ownerContext, vert)) {
    state.vertDone = vertDone = vert;
  }
  if (horzDone && vertDone && me.finishConstraints(ownerContext, horzDone, vertDone)) {
    me.finishPositions(ownerContext, horzDone, vertDone);
  } else {
    me.done = false;
  }
}, createAxis:function(ownerContext, contentSize, sizeModel, axisProps, collapsedAxis) {
  var me = this, begin = 0, owner = me.owner, maxSize = owner[axisProps.maxSize], minSize = owner[axisProps.minSize] || 0, dockBegin = axisProps.dockBegin, dockEnd = axisProps.dockEnd, posProp = axisProps.pos, sizeProp = axisProps.size, hasMaxSize = maxSize != null, shrinkWrap = sizeModel.shrinkWrap, bodyContext, framing, padding, end;
  if (shrinkWrap) {
    if (collapsedAxis) {
      end = 0;
    } else {
      bodyContext = ownerContext.bodyContext;
      end = contentSize + bodyContext.borderInfo[sizeProp];
    }
  } else {
    framing = ownerContext.frameBorder;
    padding = ownerContext.framePadding;
    begin = framing[dockBegin] + padding[dockBegin];
    end = ownerContext.getProp(sizeProp) - (framing[dockEnd] + padding[dockEnd]);
  }
  return {shrinkWrap:sizeModel.shrinkWrap, sizeModel:sizeModel, initialBegin:begin, begin:begin, end:end, collapsed:collapsedAxis, horizontal:axisProps.horizontal, ignoreFrameBegin:null, ignoreFrameEnd:null, initialSize:end - begin, maxChildSize:0, hasMinMaxConstraints:(minSize || hasMaxSize) && sizeModel.shrinkWrap, minSize:minSize, maxSize:hasMaxSize ? maxSize : 1000000000, bodyPosProp:me.owner.manageHeight ? posProp : axisProps.marginBegin, dockBegin:dockBegin, dockEnd:dockEnd, posProp:posProp, 
  sizeProp:sizeProp, setSize:axisProps.setSize, shrinkWrapDock:ownerContext[axisProps.shrinkWrapDock], sizeModelName:axisProps.sizeModel, dockedPixelsEnd:0};
}, dockChild:function(ownerContext, axis, backward, forward) {
  var me = this, itemContext = ownerContext.dockedItems[axis.shrinkWrap ? backward : forward], item = itemContext.target, dock = item.dock, sizeProp = axis.sizeProp, pos, size;
  if (item.ignoreParentFrame && ownerContext.isCollapsingOrExpanding) {
    itemContext.clearMarginCache();
  }
  itemContext.marginInfo || itemContext.getMarginInfo();
  if (dock == axis.dockBegin) {
    if (axis.shrinkWrap) {
      pos = me.dockOutwardBegin(ownerContext, itemContext, item, axis);
    } else {
      pos = me.dockInwardBegin(ownerContext, itemContext, item, axis);
    }
  } else {
    if (dock == axis.dockEnd) {
      if (axis.shrinkWrap) {
        pos = me.dockOutwardEnd(ownerContext, itemContext, item, axis);
      } else {
        pos = me.dockInwardEnd(ownerContext, itemContext, item, axis);
      }
    } else {
      if (axis.shrinkWrapDock) {
        size = itemContext.getProp(sizeProp) + itemContext.marginInfo[sizeProp];
        axis.maxChildSize = Math.max(axis.maxChildSize, size);
        pos = 0;
      } else {
        pos = me.dockStretch(ownerContext, itemContext, item, axis);
      }
    }
  }
  itemContext.dockedAt[axis.posProp] = pos;
}, dockInwardBegin:function(ownerContext, itemContext, item, axis) {
  var pos = axis.begin, sizeProp = axis.sizeProp, ignoreParentFrame = item.ignoreParentFrame, delta, size, dock;
  if (ignoreParentFrame) {
    axis.ignoreFrameBegin = itemContext;
    dock = item.dock;
    delta = ownerContext.frameBorder[dock];
    pos -= delta + ownerContext.framePadding[dock];
  }
  if (!item.overlay) {
    size = itemContext.getProp(sizeProp) + itemContext.marginInfo[sizeProp];
    axis.begin += size;
    if (ignoreParentFrame) {
      axis.begin -= delta;
    }
  }
  return pos;
}, dockInwardEnd:function(ownerContext, itemContext, item, axis) {
  var sizeProp = axis.sizeProp, size = itemContext.getProp(sizeProp) + itemContext.marginInfo[sizeProp], pos = axis.end - size, frameEnd;
  if (!item.overlay) {
    axis.end = pos;
  }
  if (item.ignoreParentFrame) {
    axis.ignoreFrameEnd = itemContext;
    frameEnd = ownerContext.frameBorder[item.dock];
    pos += frameEnd + ownerContext.framePadding[item.dock];
    axis.end += frameEnd;
  }
  return pos;
}, dockOutwardBegin:function(ownerContext, itemContext, item, axis) {
  var pos = axis.begin, sizeProp = axis.sizeProp, size;
  if (axis.collapsed) {
    axis.ignoreFrameBegin = axis.ignoreFrameEnd = itemContext;
  } else {
    if (item.ignoreParentFrame) {
      axis.ignoreFrameBegin = itemContext;
    }
  }
  if (!item.overlay) {
    size = itemContext.getProp(sizeProp) + itemContext.marginInfo[sizeProp];
    pos -= size;
    axis.begin = pos;
  }
  return pos;
}, dockOutwardEnd:function(ownerContext, itemContext, item, axis) {
  var pos = axis.end, sizeProp = axis.sizeProp, size;
  size = itemContext.getProp(sizeProp) + itemContext.marginInfo[sizeProp];
  if (axis.collapsed) {
    axis.ignoreFrameBegin = axis.ignoreFrameEnd = itemContext;
  } else {
    if (item.ignoreParentFrame) {
      axis.ignoreFrameEnd = itemContext;
    }
  }
  if (!item.overlay) {
    axis.end = pos + size;
    axis.dockedPixelsEnd += size;
  }
  return pos;
}, dockStretch:function(ownerContext, itemContext, item, axis) {
  var dock = item.dock, sizeProp = axis.sizeProp, horizontal = dock == 'top' || dock == 'bottom', border = ownerContext.frameBorder, offsets = itemContext.offsets, padding = ownerContext.framePadding, endProp = horizontal ? 'right' : 'bottom', startProp = horizontal ? 'left' : 'top', pos = axis.begin + offsets[startProp], margin, size;
  if (item.stretch !== false) {
    size = axis.end - pos - offsets[endProp];
    if (item.ignoreParentFrame) {
      pos -= padding[startProp] + border[startProp];
      size += padding[sizeProp] + border[sizeProp];
    }
    margin = itemContext.marginInfo;
    size -= margin[sizeProp];
    itemContext[axis.setSize](size);
  }
  return pos;
}, finishAxis:function(ownerContext, axis) {
  if (isNaN(axis.maxChildSize)) {
    return false;
  }
  var axisBegin = axis.begin, size = axis.end - axisBegin, collapsed = axis.collapsed, setSizeMethod = axis.setSize, beginName = axis.dockBegin, endName = axis.dockEnd, padding = ownerContext.framePadding, border = ownerContext.frameBorder, borderBegin = border[beginName], framing = ownerContext.framing, framingBegin = framing && framing[beginName], paddingBegin = collapsed ? 0 : padding[beginName], sizeProp = axis.sizeProp, ignoreFrameBegin = axis.ignoreFrameBegin, ignoreFrameEnd = axis.ignoreFrameEnd, 
  bodyContext = ownerContext.bodyContext, extraPaddingBegin = Math.max(borderBegin + paddingBegin - framingBegin, 0), bodyPos, bodySize, delta, dirty;
  if (axis.shrinkWrap) {
    bodySize = axis.initialSize;
    if (framing) {
      delta = -axisBegin + borderBegin + paddingBegin;
      bodyPos = delta - framingBegin - extraPaddingBegin;
    } else {
      bodyPos = -axisBegin;
      delta = bodyPos + paddingBegin;
    }
    if (!collapsed) {
      size += padding[sizeProp];
    }
    if (ignoreFrameBegin) {
      delta -= borderBegin;
      bodyPos -= borderBegin;
      ignoreFrameBegin.dockedAt[axis.posProp] -= paddingBegin;
    } else {
      size += borderBegin;
    }
    if (collapsed) {
    } else {
      if (ignoreFrameEnd) {
        ignoreFrameEnd.dockedAt[axis.posProp] += padding[endName];
      } else {
        size += border[endName];
      }
    }
    axis.size = size;
    if (!axis.horizontal && !this.owner.manageHeight) {
      dirty = false;
    }
  } else {
    if (framing) {
      delta = 0;
      bodyPos = axisBegin - framingBegin - extraPaddingBegin;
    } else {
      delta = -borderBegin;
      bodyPos = axisBegin - paddingBegin - borderBegin;
    }
    bodySize = size;
  }
  axis.delta = delta;
  bodyContext[setSizeMethod](bodySize, dirty);
  bodyContext.setProp(axis.bodyPosProp, bodyPos);
  return !isNaN(size);
}, beforeInvalidateShrinkWrapDock:function(itemContext, options) {
  var sizeModelName = options.axis.sizeModelName;
  if (!itemContext[sizeModelName].constrainedMin) {
    itemContext[sizeModelName] = Ext.layout.SizeModel.calculated;
  }
}, afterInvalidateShrinkWrapDock:function(itemContext, options) {
  var axis = options.axis, me = options.layout, pos;
  if (itemContext[axis.sizeModelName].calculated) {
    pos = me.dockStretch(options.ownerContext, itemContext, itemContext.target, axis);
    itemContext.setProp(axis.posProp, axis.delta + pos);
  }
}, finishConstraints:function(ownerContext, horz, vert) {
  var me = this, sizeModels = me.sizeModels, publishWidth = horz.shrinkWrap, publishHeight = vert.shrinkWrap, owner = me.owner, dirty, height, width, heightModel, widthModel, size, minSize, maxSize, maxChildSize, desiredSize;
  if (publishWidth) {
    size = horz.size;
    minSize = horz.collapsed ? 0 : horz.minSize;
    maxSize = horz.maxSize;
    maxChildSize = horz.maxChildSize;
    desiredSize = Math.max(size, maxChildSize);
    if (desiredSize > maxSize) {
      widthModel = sizeModels.constrainedMax;
      width = maxSize;
    } else {
      if (desiredSize < minSize) {
        widthModel = sizeModels.constrainedMin;
        width = minSize;
      } else {
        if (size < maxChildSize) {
          widthModel = sizeModels.constrainedDock;
          owner.dockConstrainedWidth = width = maxChildSize;
        } else {
          width = size;
        }
      }
    }
  }
  if (publishHeight) {
    size = vert.size;
    minSize = vert.collapsed ? 0 : vert.minSize;
    maxSize = vert.maxSize;
    maxChildSize = vert.maxChildSize;
    desiredSize = Math.max(size, maxChildSize + size - vert.initialSize);
    if (desiredSize > maxSize) {
      heightModel = sizeModels.constrainedMax;
      height = maxSize;
    } else {
      if (desiredSize < minSize) {
        heightModel = sizeModels.constrainedMin;
        height = minSize;
      } else {
        if (size < maxChildSize) {
          heightModel = sizeModels.constrainedDock;
          owner.dockConstrainedHeight = height = maxChildSize;
        } else {
          if (!ownerContext.collapsedVert && !owner.manageHeight) {
            dirty = false;
            ownerContext.bodyContext.setProp('margin-bottom', vert.dockedPixelsEnd);
          }
          height = size;
        }
      }
    }
  }
  if (widthModel || heightModel) {
    if (widthModel && heightModel && widthModel.constrainedMax && heightModel.constrainedByMin) {
      ownerContext.invalidate({widthModel:widthModel});
      return false;
    }
    if (!ownerContext.widthModel.calculatedFromShrinkWrap && !ownerContext.heightModel.calculatedFromShrinkWrap) {
      ownerContext.invalidate({widthModel:widthModel, heightModel:heightModel});
      return false;
    }
  } else {
    me.invalidateAxes(ownerContext, horz, vert);
  }
  if (publishWidth) {
    ownerContext.setWidth(width);
    if (widthModel) {
      ownerContext.widthModel = widthModel;
    }
  }
  if (publishHeight) {
    ownerContext.setHeight(height, dirty);
    if (heightModel) {
      ownerContext.heightModel = heightModel;
    }
  }
  return true;
}, invalidateAxes:function(ownerContext, horz, vert) {
  var before = this.beforeInvalidateShrinkWrapDock, after = this.afterInvalidateShrinkWrapDock, horzSize = horz.end - horz.begin, vertSize = vert.initialSize, invalidateHorz = horz.shrinkWrapDock && horz.maxChildSize < horzSize, invalidateVert = vert.shrinkWrapDock && vert.maxChildSize < vertSize, dockedItems, len, i, itemContext, itemSize, isHorz, axis, sizeProp;
  if (invalidateHorz || invalidateVert) {
    if (invalidateVert) {
      vert.begin = vert.initialBegin;
      vert.end = vert.begin + vert.initialSize;
    }
    dockedItems = ownerContext.dockedItems;
    for (i = 0, len = dockedItems.length; i < len; ++i) {
      itemContext = dockedItems[i];
      isHorz = itemContext.horizontal;
      axis = null;
      if (invalidateHorz && isHorz) {
        sizeProp = horz.sizeProp;
        itemSize = horzSize;
        axis = horz;
      } else {
        if (invalidateVert && !isHorz) {
          sizeProp = vert.sizeProp;
          itemSize = vertSize;
          axis = vert;
        }
      }
      if (axis) {
        itemSize -= itemContext.getMarginInfo()[sizeProp];
        if (itemSize !== itemContext.props[sizeProp]) {
          itemContext.invalidate({before:before, after:after, axis:axis, ownerContext:ownerContext, layout:this});
        }
      }
    }
  }
}, finishPositions:function(ownerContext, horz, vert) {
  var dockedItems = ownerContext.dockedItems, length = dockedItems.length, deltaX = horz.delta, deltaY = vert.delta, index, itemContext;
  for (index = 0; index < length; ++index) {
    itemContext = dockedItems[index];
    itemContext.setProp('x', deltaX + itemContext.dockedAt.x);
    itemContext.setProp('y', deltaY + itemContext.dockedAt.y);
  }
}, finishedLayout:function(ownerContext) {
  var me = this, target = ownerContext.target;
  me.callParent(arguments);
  if (!ownerContext.animatePolicy) {
    if (ownerContext.isCollapsingOrExpanding === 1) {
      target.afterCollapse(false);
    } else {
      if (ownerContext.isCollapsingOrExpanding === 2) {
        target.afterExpand(false);
      }
    }
  }
}, getAnimatePolicy:function(ownerContext) {
  var me = this, lastCollapsedState, policy;
  if (ownerContext.isCollapsingOrExpanding == 1) {
    lastCollapsedState = me.lastCollapsedState;
  } else {
    if (ownerContext.isCollapsingOrExpanding == 2) {
      lastCollapsedState = ownerContext.lastCollapsedState;
    }
  }
  if (lastCollapsedState == 'left' || lastCollapsedState == 'right') {
    policy = me.horizontalCollapsePolicy;
  } else {
    if (lastCollapsedState == 'top' || lastCollapsedState == 'bottom') {
      policy = me.verticalCollapsePolicy;
    }
  }
  return policy;
}, getDockedItems:function(order, beforeBody) {
  var me = this, renderedOnly = order === 'visual', all = renderedOnly ? Ext.ComponentQuery.query('[rendered]', me.owner.dockedItems.items) : me.owner.dockedItems.items, sort = all && all.length && order !== false, renderOrder, dock, dockedItems, i, isBefore, length;
  if (beforeBody == null) {
    dockedItems = sort && !renderedOnly ? all.slice() : all;
  } else {
    dockedItems = [];
    for (i = 0, length = all.length; i < length; ++i) {
      dock = all[i].dock;
      isBefore = dock == 'top' || dock == 'left';
      if (beforeBody ? isBefore : !isBefore) {
        dockedItems.push(all[i]);
      }
    }
    sort = sort && dockedItems.length;
  }
  if (sort) {
    renderOrder = (order = order || 'render') == 'render';
    Ext.Array.sort(dockedItems, function(a, b) {
      var aw, bw;
      if (renderOrder && (aw = me.owner.dockOrder[a.dock]) !== (bw = me.owner.dockOrder[b.dock])) {
        if (!(aw + bw)) {
          return aw - bw;
        }
      }
      aw = me.getItemWeight(a, order);
      bw = me.getItemWeight(b, order);
      if (aw !== undefined && bw !== undefined) {
        return aw - bw;
      }
      return 0;
    });
  }
  return dockedItems || [];
}, getItemWeight:function(item, order) {
  var weight = item.weight || this.owner.defaultDockWeights[item.dock];
  return weight[order] || weight;
}, getLayoutItems:function() {
  var me = this, items, itemCount, item, i, result;
  if (me.owner.collapsed) {
    result = me.owner.getCollapsedDockedItems();
  } else {
    items = me.getDockedItems('visual');
    itemCount = items.length;
    result = [];
    for (i = 0; i < itemCount; i++) {
      item = items[i];
      if (!item.hidden) {
        result.push(item);
      }
    }
  }
  return result;
}, measureContentWidth:function(ownerContext) {
  var bodyContext = ownerContext.bodyContext;
  return bodyContext.el.getWidth() - bodyContext.getBorderInfo().width;
}, measureContentHeight:function(ownerContext) {
  var bodyContext = ownerContext.bodyContext;
  return bodyContext.el.getHeight() - bodyContext.getBorderInfo().height;
}, redoLayout:function(ownerContext) {
  var me = this, owner = me.owner;
  if (ownerContext.isCollapsingOrExpanding == 1) {
    if (owner.reExpander) {
      owner.reExpander.el.show();
    }
    owner.addClsWithUI(owner.collapsedCls);
    ownerContext.redo(true);
  } else {
    if (ownerContext.isCollapsingOrExpanding == 2) {
      owner.removeClsWithUI(owner.collapsedCls);
      ownerContext.bodyContext.redo();
    }
  }
}, renderChildren:function() {
  var me = this, items = me.getDockedItems(), target = me.getRenderTarget();
  me.handleItemBorders();
  me.renderItems(items, target);
}, renderItems:function(items, target) {
  var me = this, dockedItemCount = items.length, itemIndex = 0, correctPosition = 0, staticNodeCount = 0, targetNodes = me.getRenderTarget().dom.childNodes, targetChildCount = targetNodes.length, i, j, targetChildNode, item;
  for (i = 0, j = 0; i < targetChildCount; i++) {
    targetChildNode = targetNodes[i];
    if (Ext.fly(targetChildNode).hasCls(Ext.baseCSSPrefix + 'resizable-handle')) {
      break;
    }
    for (j = 0; j < dockedItemCount; j++) {
      item = items[j];
      if (item.rendered && item.el.dom === targetChildNode) {
        break;
      }
    }
    if (j === dockedItemCount) {
      staticNodeCount++;
    }
  }
  for (; itemIndex < dockedItemCount; itemIndex++, correctPosition++) {
    item = items[itemIndex];
    if (itemIndex === correctPosition && (item.dock === 'right' || item.dock === 'bottom')) {
      correctPosition += staticNodeCount;
    }
    if (item && !item.rendered) {
      me.renderItem(item, target, correctPosition);
    } else {
      if (!me.isValidParent(item, target, correctPosition)) {
        me.moveItem(item, target, correctPosition);
      }
    }
  }
}, undoLayout:function(ownerContext) {
  var me = this, owner = me.owner;
  if (ownerContext.isCollapsingOrExpanding == 1) {
    if (owner.reExpander) {
      owner.reExpander.el.hide();
    }
    owner.removeClsWithUI(owner.collapsedCls);
    ownerContext.undo(true);
  } else {
    if (ownerContext.isCollapsingOrExpanding == 2) {
      owner.addClsWithUI(owner.collapsedCls);
      ownerContext.bodyContext.undo();
    }
  }
}, sizePolicy:{nostretch:{setsWidth:0, setsHeight:0}, horz:{shrinkWrap:{setsWidth:1, setsHeight:0, readsWidth:1}, stretch:{setsWidth:1, setsHeight:0}}, vert:{shrinkWrap:{setsWidth:0, setsHeight:1, readsHeight:1}, stretch:{setsWidth:0, setsHeight:1}}, stretchV:{setsWidth:0, setsHeight:1}, autoStretchH:{readsWidth:1, setsWidth:1, setsHeight:0}, autoStretchV:{readsHeight:1, setsWidth:0, setsHeight:1}}, getItemSizePolicy:function(item, ownerSizeModel) {
  var me = this, policy = me.sizePolicy, shrinkWrapDock = me.owner.shrinkWrapDock, dock, vertical;
  if (item.stretch === false) {
    return policy.nostretch;
  }
  dock = item.dock;
  vertical = dock == 'left' || dock == 'right';
  shrinkWrapDock = shrinkWrapDock === true ? 3 : shrinkWrapDock || 0;
  if (vertical) {
    policy = policy.vert;
    shrinkWrapDock = shrinkWrapDock & 1;
  } else {
    policy = policy.horz;
    shrinkWrapDock = shrinkWrapDock & 2;
  }
  if (shrinkWrapDock) {
    if (!ownerSizeModel) {
      ownerSizeModel = me.owner.getSizeModel();
    }
    if (ownerSizeModel[vertical ? 'height' : 'width'].shrinkWrap) {
      return policy.shrinkWrap;
    }
  }
  return policy.stretch;
}, configureItem:function(item, pos) {
  this.callParent(arguments);
  item.addCls(Ext.baseCSSPrefix + 'docked');
  item.addClsWithUI(this.getDockCls(item.dock));
}, getDockCls:function(dock) {
  return 'docked-' + dock;
}, afterRemove:function(item) {
  this.callParent(arguments);
  if (this.itemCls) {
    item.el.removeCls(this.itemCls + '-' + item.dock);
  }
  var dom = item.el.dom;
  if (!item.destroying && dom) {
    dom.parentNode.removeChild(dom);
  }
  this.childrenChanged = true;
}, borderCollapseMap:{}, getBorderCollapseTable:function() {
  var me = this, map = me.borderCollapseMap, owner = me.owner, baseCls = owner.baseCls, ui = owner.ui, table;
  map = map[baseCls] || (map[baseCls] = {});
  table = map[ui];
  if (!table) {
    baseCls += '-' + ui + '-outer-border-';
    map[ui] = table = [0, baseCls + 'l', baseCls + 'b', baseCls + 'bl', baseCls + 'r', baseCls + 'rl', baseCls + 'rb', baseCls + 'rbl', baseCls + 't', baseCls + 'tl', baseCls + 'tb', baseCls + 'tbl', baseCls + 'tr', baseCls + 'trl', baseCls + 'trb', baseCls + 'trbl'];
  }
  return table;
}});
Ext.define('Ext.util.Memento', function() {
  function captureOne(src, target, prop, prefix) {
    src[prefix ? prefix + prop : prop] = target[prop];
  }
  function removeOne(src, target, prop) {
    delete src[prop];
  }
  function restoreOne(src, target, prop, prefix) {
    var name = prefix ? prefix + prop : prop, value = src[name];
    if (value || src.hasOwnProperty(name)) {
      restoreValue(target, prop, value);
    }
  }
  function restoreValue(target, prop, value) {
    if (Ext.isDefined(value)) {
      target[prop] = value;
    } else {
      delete target[prop];
    }
  }
  function doMany(doOne, src, target, props, prefix) {
    if (src) {
      if (Ext.isArray(props)) {
        var p, pLen = props.length;
        for (p = 0; p < pLen; p++) {
          doOne(src, target, props[p], prefix);
        }
      } else {
        doOne(src, target, props, prefix);
      }
    }
  }
  return {data:null, target:null, constructor:function(target, props) {
    if (target) {
      this.target = target;
      if (props) {
        this.capture(props);
      }
    }
  }, capture:function(props, target, prefix) {
    var me = this;
    doMany(captureOne, me.data || (me.data = {}), target || me.target, props, prefix);
  }, remove:function(props) {
    doMany(removeOne, this.data, null, props);
  }, restore:function(props, clear, target, prefix) {
    doMany(restoreOne, this.data, target || this.target, props, prefix);
    if (clear !== false) {
      this.remove(props);
    }
  }, restoreAll:function(clear, target) {
    var me = this, t = target || this.target, data = me.data, prop;
    for (prop in data) {
      if (data.hasOwnProperty(prop)) {
        restoreValue(t, prop, data[prop]);
      }
    }
    if (clear !== false) {
      delete me.data;
    }
  }};
}());
Ext.define('Ext.panel.Panel', {extend:Ext.panel.AbstractPanel, alias:'widget.panel', alternateClassName:'Ext.Panel', collapsedCls:'collapsed', animCollapse:Ext.enableFx, minButtonWidth:75, collapsed:false, collapseFirst:true, hideCollapseTool:false, titleCollapse:undefined, floatable:true, collapsible:undefined, closable:false, closeAction:'destroy', placeholderCollapseHideMode:Ext.Element.VISIBILITY, preventHeader:false, header:undefined, headerPosition:'top', frame:false, frameHeader:true, manageHeight:true, 
constrain:false, constrainHeader:false, initComponent:function() {
  var me = this;
  me.addEvents('beforeclose', 'close', 'beforeexpand', 'beforecollapse', 'expand', 'collapse', 'titlechange', 'iconchange', 'iconclschange', 'glyphchange', 'float', 'unfloat');
  if (me.collapsible) {
    this.addStateEvents(['expand', 'collapse']);
  }
  if (me.unstyled) {
    me.setUI('plain');
  }
  if (me.frame) {
    me.setUI(me.ui + '-framed');
  }
  me.bridgeToolbars();
  me.callParent();
  me.collapseDirection = me.collapseDirection || me.headerPosition || Ext.Component.DIRECTION_TOP;
  me.hiddenOnCollapse = new Ext.dom.CompositeElement;
}, beforeDestroy:function() {
  var me = this;
  Ext.destroy(me.placeholder, me.ghostPanel, me.dd);
  me.callParent();
}, initAria:function() {
  this.callParent();
  this.initHeaderAria();
}, getFocusEl:function() {
  return this.el;
}, initHeaderAria:function() {
  var me = this, el = me.el, header = me.header;
  if (el && header) {
    el.dom.setAttribute('aria-labelledby', header.titleCmp.id);
  }
}, getHeader:function() {
  return this.header;
}, setTitle:function(newTitle) {
  var me = this, oldTitle = me.title, header = me.header, reExpander = me.reExpander, placeholder = me.placeholder;
  me.title = newTitle;
  if (header) {
    if (header.isHeader) {
      header.setTitle(newTitle);
    } else {
      header.title = newTitle;
    }
  } else {
    if (me.rendered) {
      me.updateHeader();
    }
  }
  if (reExpander) {
    reExpander.setTitle(newTitle);
  }
  if (placeholder && placeholder.setTitle) {
    placeholder.setTitle(newTitle);
  }
  me.fireEvent('titlechange', me, newTitle, oldTitle);
}, setIconCls:function(newIconCls) {
  var me = this, oldIconCls = me.iconCls, header = me.header, placeholder = me.placeholder;
  me.iconCls = newIconCls;
  if (header) {
    if (header.isHeader) {
      header.setIconCls(newIconCls);
    } else {
      header.iconCls = newIconCls;
    }
  } else {
    me.updateHeader();
  }
  if (placeholder && placeholder.setIconCls) {
    placeholder.setIconCls(newIconCls);
  }
  me.fireEvent('iconclschange', me, newIconCls, oldIconCls);
}, setIcon:function(newIcon) {
  var me = this, oldIcon = me.icon, header = me.header, placeholder = me.placeholder;
  me.icon = newIcon;
  if (header) {
    if (header.isHeader) {
      header.setIcon(newIcon);
    } else {
      header.icon = newIcon;
    }
  } else {
    me.updateHeader();
  }
  if (placeholder && placeholder.setIcon) {
    placeholder.setIcon(newIcon);
  }
  me.fireEvent('iconchange', me, newIcon, oldIcon);
}, setGlyph:function(newGlyph) {
  var me = this, oldGlyph = me.glyph, header = me.header, placeholder = me.placeholder;
  me.glyph = newGlyph;
  if (header) {
    if (header.isHeader) {
      header.setGlyph(newGlyph);
    } else {
      header.glyph = newGlyph;
    }
  } else {
    me.updateHeader();
  }
  if (placeholder && placeholder.setGlyph) {
    placeholder.setIcon(newGlyph);
  }
  me.fireEvent('glyphchange', me, newGlyph, oldGlyph);
}, bridgeToolbars:function() {
  var me = this, docked = [], fbar, fbarDefaults, minButtonWidth = me.minButtonWidth;
  function initToolbar(toolbar, pos, useButtonAlign) {
    if (Ext.isArray(toolbar)) {
      toolbar = {xtype:'toolbar', items:toolbar};
    } else {
      if (!toolbar.xtype) {
        toolbar.xtype = 'toolbar';
      }
    }
    toolbar.dock = pos;
    if (pos == 'left' || pos == 'right') {
      toolbar.vertical = true;
    }
    if (useButtonAlign) {
      toolbar.layout = Ext.applyIf(toolbar.layout || {}, {pack:{left:'start', center:'center'}[me.buttonAlign] || 'end'});
    }
    return toolbar;
  }
  if (me.tbar) {
    docked.push(initToolbar(me.tbar, 'top'));
    me.tbar = null;
  }
  if (me.bbar) {
    docked.push(initToolbar(me.bbar, 'bottom'));
    me.bbar = null;
  }
  if (me.buttons) {
    me.fbar = me.buttons;
    me.buttons = null;
  }
  if (me.fbar) {
    fbar = initToolbar(me.fbar, 'bottom', true);
    fbar.ui = 'footer';
    if (minButtonWidth) {
      fbarDefaults = fbar.defaults;
      fbar.defaults = function(config) {
        var defaults = fbarDefaults || {};
        if ((!config.xtype || config.xtype === 'button' || config.isComponent && config.isXType('button')) && !('minWidth' in defaults)) {
          defaults = Ext.apply({minWidth:minButtonWidth}, defaults);
        }
        return defaults;
      };
    }
    docked.push(fbar);
    me.fbar = null;
  }
  if (me.lbar) {
    docked.push(initToolbar(me.lbar, 'left'));
    me.lbar = null;
  }
  if (me.rbar) {
    docked.push(initToolbar(me.rbar, 'right'));
    me.rbar = null;
  }
  if (me.dockedItems) {
    if (!Ext.isArray(me.dockedItems)) {
      me.dockedItems = [me.dockedItems];
    }
    me.dockedItems = me.dockedItems.concat(docked);
  } else {
    me.dockedItems = docked;
  }
}, isPlaceHolderCollapse:function() {
  return this.collapseMode == 'placeholder';
}, onBoxReady:function() {
  this.callParent();
  if (this.collapsed) {
    this.setHiddenDocked();
  }
}, beforeRender:function() {
  var me = this, wasCollapsed;
  me.callParent();
  me.initTools();
  if (!(me.preventHeader || me.header === false)) {
    me.updateHeader();
  }
  if (me.collapsed) {
    if (me.isPlaceHolderCollapse()) {
      if (!me.hidden) {
        me.setHiddenState(true);
        me.preventCollapseFire = true;
        me.placeholderCollapse();
        delete me.preventCollapseFire;
        wasCollapsed = me.collapsed;
        me.collapsed = false;
      }
    } else {
      me.beginCollapse();
      me.addClsWithUI(me.collapsedCls);
    }
  }
  if (wasCollapsed) {
    me.collapsed = wasCollapsed;
  }
}, initTools:function() {
  var me = this, tools = me.tools, i, tool;
  me.tools = [];
  for (i = tools && tools.length; i;) {
    --i;
    me.tools[i] = tool = tools[i];
    tool.toolOwner = me;
  }
  if (me.collapsible && !(me.hideCollapseTool || me.header === false || me.preventHeader)) {
    me.collapseDirection = me.collapseDirection || me.headerPosition || 'top';
    me.collapseTool = me.expandTool = Ext.widget({xtype:'tool', handler:me.toggleCollapse, scope:me});
    me.updateCollapseTool();
    if (me.collapseFirst) {
      me.tools.unshift(me.collapseTool);
    }
  }
  me.addTools();
  if (me.closable) {
    me.addClsWithUI('closable');
    me.addTool(Ext.widget({xtype:'tool', type:'close', handler:Ext.Function.bind(me.close, me, [])}));
  }
  if (me.collapseTool && !me.collapseFirst) {
    me.addTool(me.collapseTool);
  }
}, addTools:Ext.emptyFn, updateCollapseTool:function() {
  var me = this, collapseTool = me.collapseTool;
  if (collapseTool) {
    if (me.collapsed && !me.isPlaceHolderCollapse()) {
      collapseTool.setType('expand-' + me.getOppositeDirection(me.collapseDirection));
    } else {
      collapseTool.setType('collapse-' + me.collapseDirection);
    }
  }
}, close:function() {
  if (this.fireEvent('beforeclose', this) !== false) {
    this.doClose();
  }
}, doClose:function() {
  this.fireEvent('close', this);
  this[this.closeAction]();
}, updateHeader:function(force) {
  var me = this, header = me.header, title = me.title, tools = me.tools, icon = me.icon || me.iconCls, vertical = me.headerPosition === 'left' || me.headerPosition === 'right';
  if (Ext.isObject(header) || header !== false && (force || (title || icon) || tools && tools.length || me.collapsible && !me.titleCollapse)) {
    if (header && header.isHeader) {
      header.show();
    } else {
      header = me.header = Ext.widget(Ext.apply({xtype:'header', title:title, titleAlign:me.titleAlign, orientation:vertical ? 'vertical' : 'horizontal', dock:me.headerPosition || 'top', textCls:me.headerTextCls, iconCls:me.iconCls, icon:me.icon, glyph:me.glyph, baseCls:me.baseCls + '-header', tools:tools, ui:me.ui, id:me.id + '_header', overCls:me.headerOverCls, indicateDrag:me.draggable, frame:(me.frame || me.alwaysFramed) && me.frameHeader, ignoreParentFrame:me.frame || me.overlapHeader, ignoreBorderManagement:me.frame || 
      me.ignoreHeaderBorderManagement, ownerCt:me, listeners:me.collapsible && me.titleCollapse ? {click:me.toggleCollapse, scope:me} : null}, me.header));
      me.addDocked(header, 0);
    }
    me.initHeaderAria();
  } else {
    if (header) {
      header.hide();
    }
  }
}, setUI:function(ui) {
  var me = this;
  me.callParent(arguments);
  if (me.header && me.header.rendered) {
    me.header.setUI(ui);
  }
}, getDefaultContentTarget:function() {
  return this.body;
}, getTargetEl:function() {
  var me = this;
  return me.body || me.protoBody || me.frameBody || me.el;
}, isVisible:function(deep) {
  var me = this;
  if (me.collapsed && me.placeholder) {
    return me.placeholder.isVisible(deep);
  }
  return me.callParent(arguments);
}, onHide:function() {
  var me = this;
  if (me.collapsed && me.placeholder) {
    me.placeholder.hide();
  } else {
    me.callParent(arguments);
  }
}, onShow:function() {
  var me = this;
  if (me.collapsed && me.isPlaceHolderCollapse()) {
    me.setHiddenState(true);
    me.placeholderCollapse();
  } else {
    me.callParent(arguments);
  }
}, onRemoved:function(destroying) {
  var me = this;
  if (me.placeholder && !destroying) {
    me.ownerCt.remove(me.placeholder, false);
  }
  me.callParent(arguments);
}, addTool:function(tools) {
  if (!Ext.isArray(tools)) {
    tools = [tools];
  }
  var me = this, header = me.header, t, tLen = tools.length, tool;
  for (t = 0; t < tLen; t++) {
    tool = tools[t];
    tool.toolOwner = me;
    if (header && header.isHeader) {
      header.addTool(tool);
    } else {
      me.tools.push(tool);
    }
  }
  me.updateHeader();
}, getOppositeDirection:function(d) {
  var c = Ext.Component;
  switch(d) {
    case c.DIRECTION_TOP:
      return c.DIRECTION_BOTTOM;
    case c.DIRECTION_RIGHT:
      return c.DIRECTION_LEFT;
    case c.DIRECTION_BOTTOM:
      return c.DIRECTION_TOP;
    case c.DIRECTION_LEFT:
      return c.DIRECTION_RIGHT;
  }
}, getWidthAuthority:function() {
  if (this.collapsed && this.collapsedHorizontal()) {
    return 1;
  }
  return this.callParent();
}, getHeightAuthority:function() {
  if (this.collapsed && this.collapsedVertical()) {
    return 1;
  }
  return this.callParent();
}, collapsedHorizontal:function() {
  var dir = this.getCollapsed();
  return dir === 'left' || dir === 'right';
}, collapsedVertical:function() {
  var dir = this.getCollapsed();
  return dir === 'top' || dir === 'bottom';
}, restoreDimension:function() {
  var dir = this.collapseDirection;
  return dir === 'top' || dir === 'bottom' ? 'height' : 'width';
}, getCollapsed:function() {
  var me = this;
  if (me.collapsed === true) {
    return me.collapseDirection;
  }
  return me.collapsed;
}, getState:function() {
  var me = this, state = me.callParent(), memento;
  state = me.addPropertyToState(state, 'collapsed');
  if (me.collapsed) {
    memento = me.collapseMemento;
    memento = memento && memento.data;
    if (me.collapsedVertical()) {
      if (state) {
        delete state.height;
      }
      if (memento) {
        state = me.addPropertyToState(state, 'height', memento.height);
      }
    } else {
      if (state) {
        delete state.width;
      }
      if (memento) {
        state = me.addPropertyToState(state, 'width', memento.width);
      }
    }
  }
  return state;
}, findReExpander:function(direction) {
  var me = this, c = Ext.Component, dockedItems = me.dockedItems.items, dockedItemCount = dockedItems.length, comp, i;
  if (me.collapseMode === 'mini') {
    return;
  }
  switch(direction) {
    case c.DIRECTION_TOP:
    case c.DIRECTION_BOTTOM:
      for (i = 0; i < dockedItemCount; i++) {
        comp = dockedItems[i];
        if (!comp.hidden) {
          if (comp.isHeader && (!comp.dock || comp.dock === 'top' || comp.dock === 'bottom')) {
            return comp;
          }
        }
      }
      break;
    case c.DIRECTION_LEFT:
    case c.DIRECTION_RIGHT:
      for (i = 0; i < dockedItemCount; i++) {
        comp = dockedItems[i];
        if (!comp.hidden) {
          if (comp.isHeader && (comp.dock === 'left' || comp.dock === 'right')) {
            return comp;
          }
        }
      }
      break;
    default:
      throw 'Panel#findReExpander must be passed a valid collapseDirection';
  }
}, getReExpander:function(direction) {
  var me = this, collapseDir = direction || me.collapseDirection, reExpander = me.reExpander || me.findReExpander(collapseDir);
  me.expandDirection = me.getOppositeDirection(collapseDir);
  if (!reExpander) {
    me.reExpander = reExpander = me.createReExpander(collapseDir, {dock:collapseDir, cls:Ext.baseCSSPrefix + 'docked ' + me.baseCls + '-' + me.ui + '-collapsed', isCollapsedExpander:true});
    me.dockedItems.insert(0, reExpander);
  }
  return reExpander;
}, createReExpander:function(direction, defaults) {
  var me = this, isLeft = direction === 'left', isRight = direction === 'right', isVertical = isLeft || isRight, result = Ext.apply({hideMode:'offsets', title:me.title || '\x26#160;', titleAlign:me.titleAlign, orientation:isVertical ? 'vertical' : 'horizontal', textCls:me.headerTextCls, icon:me.icon, iconCls:me.iconCls, glyph:me.glyph, baseCls:me.self.prototype.baseCls + '-header', ui:me.ui, frame:me.frame && me.frameHeader, ignoreParentFrame:me.frame || me.overlapHeader, indicateDrag:me.draggable, 
  collapseImmune:true, ownerCt:me.ownerCt, ownerLayout:me.componentLayout, margin:me.margin}, defaults);
  if (me.collapseMode === 'mini') {
    if (isVertical) {
      result.width = 1;
    } else {
      result.height = 1;
    }
  }
  if (!me.hideCollapseTool) {
    if (isLeft || isRight && me.isPlaceHolderCollapse()) {
      result.titlePosition = 1;
    }
    result.tools = [{xtype:'tool', type:'expand-' + me.getOppositeDirection(direction), uiCls:['top'], handler:me.toggleCollapse, scope:me}];
  }
  result = new Ext.panel.Header(result);
  result.addClsWithUI(me.getHeaderCollapsedClasses(result));
  return result;
}, getHeaderCollapsedClasses:function(header) {
  var me = this, collapsedCls = me.collapsedCls, collapsedClasses;
  collapsedClasses = [collapsedCls, collapsedCls + '-' + header.getDockName()];
  if (me.border && (!me.frame || me.frame && Ext.supports.CSS3BorderRadius)) {
    collapsedClasses.push(collapsedCls + '-border-' + header.getDockName());
  }
  return collapsedClasses;
}, beginCollapse:function() {
  var me = this, lastBox = me.lastBox, rendered = me.rendered, collapseMemento = me.collapseMemento || (me.collapseMemento = new Ext.util.Memento(me)), sizeModel = me.getSizeModel(), header = me.header, reExpander;
  collapseMemento.capture(['height', 'minHeight', 'width', 'minWidth']);
  if (lastBox) {
    collapseMemento.capture(me.restoreDimension(), lastBox, 'last.');
  }
  if (me.collapsedVertical()) {
    if (sizeModel.width.shrinkWrap) {
      me.width = rendered ? me.getWidth() : me.width || me.minWidth || 100;
    }
    delete me.height;
    me.minHeight = 0;
  } else {
    if (me.collapsedHorizontal()) {
      if (sizeModel.height.shrinkWrap) {
        me.height = rendered ? me.getHeight() : me.height || me.minHeight || 100;
      }
      delete me.width;
      me.minWidth = 0;
    }
  }
  if (me.ownerCt) {
    me.ownerCt.getLayout().beginCollapse(me);
  }
  if (!me.isPlaceHolderCollapse() && header !== false) {
    if (header === (reExpander = me.getReExpander())) {
      header.collapseImmune = true;
      header.getHierarchyState().collapseImmune = true;
      header.addClsWithUI(me.getHeaderCollapsedClasses(header));
      if (header.rendered) {
        header.updateFrame();
      }
    } else {
      if (reExpander.el) {
        reExpander.el.show();
        reExpander.hidden = false;
      }
    }
  }
  if (me.resizer) {
    me.resizer.disable();
  }
}, beginExpand:function() {
  var me = this, lastBox = me.lastBox, collapseMemento = me.collapseMemento, restoreDimension = this.restoreDimension(), header = me.header, reExpander;
  if (collapseMemento) {
    collapseMemento.restore(['minHeight', 'minWidth', restoreDimension]);
    if (lastBox) {
      collapseMemento.restore(restoreDimension, true, lastBox, 'last.');
    }
  }
  if (me.ownerCt) {
    me.ownerCt.getLayout().beginExpand(me);
  }
  if (!me.isPlaceHolderCollapse() && header !== false) {
    if (header === (reExpander = me.getReExpander())) {
      delete header.collapseImmune;
      delete header.getHierarchyState().collapseImmune;
      header.removeClsWithUI(me.getHeaderCollapsedClasses(header));
      if (header.rendered) {
        header.expanding = true;
        header.updateFrame();
        delete header.expanding;
      }
    } else {
      reExpander.hidden = true;
      reExpander.el.hide();
    }
  }
  if (me.resizer) {
    me.resizer.enable();
  }
}, collapse:function(direction, animate) {
  var me = this, collapseDir = direction || me.collapseDirection, ownerCt = me.ownerCt;
  if (me.isCollapsingOrExpanding) {
    return me;
  }
  if (arguments.length < 2) {
    animate = me.animCollapse;
  }
  if (me.collapsed || me.fireEvent('beforecollapse', me, direction, animate) === false) {
    return me;
  }
  if (ownerCt && me.isPlaceHolderCollapse()) {
    return me.placeholderCollapse(direction, animate);
  }
  me.collapsed = collapseDir;
  me.beginCollapse();
  me.getHierarchyState().collapsed = true;
  me.fireHierarchyEvent('collapse');
  return me.doCollapseExpand(1, animate);
}, doCollapseExpand:function(flags, animate) {
  var me = this, originalAnimCollapse = me.animCollapse, ownerLayout = me.ownerLayout;
  me.animCollapse = animate;
  me.isCollapsingOrExpanding = flags;
  if (animate) {
    me.addCls(Ext.baseCSSPrefix + 'animating-size');
  }
  if (ownerLayout && !animate) {
    ownerLayout.onContentChange(me);
  } else {
    me.updateLayout({isRoot:true});
  }
  me.animCollapse = originalAnimCollapse;
  return me;
}, afterCollapse:function(animated) {
  var me = this, ownerLayout = me.ownerLayout;
  me.isCollapsingOrExpanding = 0;
  me.updateCollapseTool();
  if (animated) {
    me.removeCls(Ext.baseCSSPrefix + 'animating-size');
  }
  if (ownerLayout && animated) {
    ownerLayout.onContentChange(me);
  }
  me.setHiddenDocked();
  me.fireEvent('collapse', me);
}, setHiddenDocked:function() {
  var me = this, toHide = me.hiddenOnCollapse, items = me.getDockedItems(), len = items.length, i = 0, item, reExpander;
  if (me.header !== false) {
    reExpander = me.getReExpander();
  }
  toHide.add(me.body);
  for (; i < len; i++) {
    item = items[i];
    if (item && item !== reExpander && item.el) {
      toHide.add(item.el);
    }
  }
  toHide.setStyle('visibility', 'hidden');
}, restoreHiddenDocked:function() {
  var toShow = this.hiddenOnCollapse;
  toShow.setStyle('visibility', '');
  toShow.clear();
}, getPlaceholder:function(direction) {
  var me = this, collapseDir = direction || me.collapseDirection, listeners = null, placeholder = me.placeholder, floatable = me.floatable, titleCollapse = me.titleCollapse;
  if (!placeholder) {
    if (floatable || me.collapsible && titleCollapse) {
      listeners = {click:{fn:!titleCollapse && floatable ? me.floatCollapsedPanel : me.toggleCollapse, element:'el', scope:me}};
    }
    me.placeholder = placeholder = Ext.widget(me.createReExpander(collapseDir, {id:me.id + '-placeholder', listeners:listeners}));
  }
  if (!placeholder.placeholderFor) {
    if (!placeholder.isComponent) {
      me.placeholder = placeholder = me.lookupComponent(placeholder);
    }
    Ext.applyIf(placeholder, {margins:me.margins, placeholderFor:me});
    placeholder.addCls([Ext.baseCSSPrefix + 'region-collapsed-placeholder', Ext.baseCSSPrefix + 'region-collapsed-' + collapseDir + '-placeholder', me.collapsedCls]);
  }
  return placeholder;
}, placeholderCollapse:function(direction, animate) {
  var me = this, ownerCt = me.ownerCt, collapseDir = direction || me.collapseDirection, floatCls = Ext.baseCSSPrefix + 'border-region-slide-in', placeholder = me.getPlaceholder(collapseDir), slideInDirection;
  me.isCollapsingOrExpanding = 1;
  me.setHiddenState(true);
  me.collapsed = collapseDir;
  if (placeholder.rendered) {
    if (placeholder.el.dom.parentNode !== me.el.dom.parentNode) {
      me.el.dom.parentNode.insertBefore(placeholder.el.dom, me.el.dom);
    }
    placeholder.hidden = false;
    placeholder.el.show();
    ownerCt.updateLayout();
  } else {
    ownerCt.insert(ownerCt.items.indexOf(me), placeholder);
  }
  if (me.rendered) {
    me.el.setVisibilityMode(me.placeholderCollapseHideMode);
    if (animate) {
      me.el.addCls(floatCls);
      placeholder.el.hide();
      slideInDirection = me.convertCollapseDir(collapseDir);
      me.el.slideOut(slideInDirection, {preserveScroll:true, duration:Ext.Number.from(animate, Ext.fx.Anim.prototype.duration), listeners:{afteranimate:function() {
        me.el.removeCls(floatCls);
        placeholder.el.show().setStyle('display', 'none').slideIn(slideInDirection, {easing:'linear', duration:100, listeners:{afteranimate:function() {
          placeholder.focus();
          me.isCollapsingOrExpanding = 0;
          me.fireEvent('collapse', me);
        }}});
      }}});
    } else {
      me.el.hide();
      me.isCollapsingOrExpanding = 0;
      me.fireEvent('collapse', me);
    }
  } else {
    me.isCollapsingOrExpanding = 0;
    if (!me.preventCollapseFire) {
      me.fireEvent('collapse', me);
    }
  }
  return me;
}, floatCollapsedPanel:function() {
  var me = this, placeholder = me.placeholder, ps = placeholder.getSize(), myBox, floatCls = Ext.baseCSSPrefix + 'border-region-slide-in', collapsed = me.collapsed, layoutOwner = me.ownerCt || me, slideDirection;
  if (me.isSliding) {
    return;
  }
  if (me.el.hasCls(floatCls)) {
    me.slideOutFloatedPanel();
    return;
  }
  me.isSliding = true;
  placeholder.el.hide();
  placeholder.hidden = true;
  me.el.show();
  me.setHiddenState(false);
  me.collapsed = false;
  layoutOwner.updateLayout();
  myBox = me.getBox(false, true);
  placeholder.el.show();
  placeholder.hidden = false;
  me.el.hide();
  me.setHiddenState(true);
  me.collapsed = collapsed;
  layoutOwner.updateLayout();
  me.slideOutTask = me.slideOutTask || new Ext.util.DelayedTask(me.slideOutFloatedPanel, me);
  placeholder.el.on('mouseleave', me.onMouseLeaveFloated, me);
  me.el.on('mouseleave', me.onMouseLeaveFloated, me);
  placeholder.el.on('mouseenter', me.onMouseEnterFloated, me);
  me.el.on('mouseenter', me.onMouseEnterFloated, me);
  me.el.addCls(floatCls);
  me.floated = true;
  if (me.collapseTool) {
    me.collapseTool.el.hide();
  }
  switch(me.collapsed) {
    case 'top':
      me.setLocalXY(myBox.x, myBox.y + ps.height - 1);
      break;
    case 'right':
      me.setLocalXY(myBox.x - ps.width + 1, myBox.y);
      break;
    case 'bottom':
      me.setLocalXY(myBox.x, myBox.y - ps.height + 1);
      break;
    case 'left':
      me.setLocalXY(myBox.x + ps.width - 1, myBox.y);
      break;
  }
  slideDirection = me.convertCollapseDir(me.collapsed);
  me.floatedFromCollapse = me.collapsed;
  me.collapsed = false;
  me.setHiddenState(false);
  me.el.slideIn(slideDirection, {preserveScroll:true, duration:Ext.Number.from(me.animCollapse, Ext.fx.Anim.prototype.duration), listeners:{afteranimate:function() {
    me.isSliding = false;
    me.fireEvent('float', me);
  }}});
}, onMouseLeaveFloated:function(e) {
  this.slideOutTask.delay(500);
}, onMouseEnterFloated:function(e) {
  this.slideOutTask.cancel();
}, isLayoutRoot:function() {
  if (this.floatedFromCollapse) {
    return true;
  }
  return this.callParent();
}, slideOutFloatedPanel:function() {
  var me = this, compEl = this.el, collapseDirection;
  if (me.isSliding || me.isDestroyed) {
    return;
  }
  me.isSliding = true;
  me.floated = false;
  me.slideOutFloatedPanelBegin();
  if (typeof me.collapsed == 'string') {
    collapseDirection = me.convertCollapseDir(me.collapsed);
  }
  compEl.slideOut(collapseDirection, {preserveScroll:true, duration:Ext.Number.from(me.animCollapse, Ext.fx.Anim.prototype.duration), listeners:{afteranimate:function() {
    me.slideOutFloatedPanelEnd();
    me.el.removeCls(Ext.baseCSSPrefix + 'border-region-slide-in');
  }}});
}, slideOutFloatedPanelBegin:function() {
  var me = this, placeholderEl = me.placeholder.el, el = me.el;
  me.collapsed = me.floatedFromCollapse;
  me.setHiddenState(true);
  me.floatedFromCollapse = null;
  placeholderEl.un('mouseleave', me.onMouseLeaveFloated, me);
  el.un('mouseleave', me.onMouseLeaveFloated, me);
  placeholderEl.un('mouseenter', me.onMouseEnterFloated, me);
  el.un('mouseenter', me.onMouseEnterFloated, me);
}, slideOutFloatedPanelEnd:function() {
  var me = this;
  if (me.collapseTool) {
    me.collapseTool.el.show();
  }
  me.slideOutTask.cancel();
  me.isSliding = false;
  me.fireEvent('unfloat', me);
}, expand:function(animate) {
  var me = this;
  if (me.isCollapsingOrExpanding) {
    return me;
  }
  if (!arguments.length) {
    animate = me.animCollapse;
  }
  if (!me.collapsed && !me.floatedFromCollapse) {
    return me;
  }
  if (me.fireEvent('beforeexpand', me, animate) === false) {
    return me;
  }
  delete this.getHierarchyState().collapsed;
  if (me.isPlaceHolderCollapse()) {
    return me.placeholderExpand(animate);
  }
  me.restoreHiddenDocked();
  me.beginExpand();
  me.collapsed = false;
  return me.doCollapseExpand(2, animate);
}, placeholderExpand:function(animate) {
  var me = this, collapseDir = me.collapsed, floatCls = Ext.baseCSSPrefix + 'border-region-slide-in', finalPos, floatedPos, center = me.ownerLayout ? me.ownerLayout.centerRegion : null;
  if (Ext.AbstractComponent.layoutSuspendCount) {
    animate = false;
  }
  if (me.floatedFromCollapse) {
    floatedPos = me.getPosition(true);
    me.slideOutFloatedPanelBegin();
    me.slideOutFloatedPanelEnd();
    me.floated = false;
  }
  if (animate) {
    Ext.suspendLayouts();
    me.placeholder.hide();
    me.el.show();
    me.collapsed = false;
    me.setHiddenState(false);
    if (center && !floatedPos) {
      center.hidden = true;
    }
    Ext.resumeLayouts(true);
    center.hidden = false;
    me.el.addCls(floatCls);
    me.isCollapsingOrExpanding = 2;
    if (floatedPos) {
      finalPos = me.getXY();
      me.setLocalXY(floatedPos[0], floatedPos[1]);
      me.setXY([finalPos[0], finalPos[1]], {duration:Ext.Number.from(animate, Ext.fx.Anim.prototype.duration), listeners:{afteranimate:function() {
        me.el.removeCls(floatCls);
        me.isCollapsingOrExpanding = 0;
        me.fireEvent('expand', me);
      }}});
    } else {
      me.el.hide();
      me.placeholder.el.show();
      me.placeholder.hidden = false;
      me.setHiddenState(false);
      me.el.slideIn(me.convertCollapseDir(collapseDir), {preserveScroll:true, duration:Ext.Number.from(animate, Ext.fx.Anim.prototype.duration), listeners:{afteranimate:function() {
        me.el.removeCls(floatCls);
        me.placeholder.hide();
        me.updateLayout();
        me.isCollapsingOrExpanding = 0;
        me.fireEvent('expand', me);
      }}});
    }
  } else {
    me.floated = me.collapsed = false;
    me.el.removeCls(floatCls);
    Ext.suspendLayouts();
    me.placeholder.hide();
    me.show();
    Ext.resumeLayouts(true);
    me.fireEvent('expand', me);
  }
  return me;
}, afterExpand:function(animated) {
  var me = this, ownerLayout = me.ownerLayout;
  me.isCollapsingOrExpanding = 0;
  me.updateCollapseTool();
  if (animated) {
    me.removeCls(Ext.baseCSSPrefix + 'animating-size');
  }
  if (ownerLayout && animated) {
    ownerLayout.onContentChange(me);
  }
  me.fireEvent('expand', me);
  me.fireHierarchyEvent('expand');
}, setBorder:function(border, targetEl) {
  if (targetEl) {
    return;
  }
  var me = this, header = me.header;
  if (!border) {
    border = 0;
  } else {
    if (border === true) {
      border = '1px';
    } else {
      border = me.unitizeBox(border);
    }
  }
  if (header) {
    if (header.isHeader) {
      header.setBorder(border);
    } else {
      header.border = border;
    }
  }
  if (me.rendered && me.bodyBorder !== false) {
    me.body.setStyle('border-width', border);
  }
  me.updateLayout();
  me.border = border;
}, toggleCollapse:function() {
  return this.collapsed || this.floatedFromCollapse ? this.expand() : this.collapse();
}, getKeyMap:function() {
  return this.keyMap || (this.keyMap = new Ext.util.KeyMap(Ext.apply({target:this.el}, this.keys)));
}, initDraggable:function() {
  if (this.simpleDrag) {
    this.initSimpleDraggable();
  } else {
    this.dd = new Ext.panel.DD(this, Ext.isBoolean(this.draggable) ? null : this.draggable);
  }
}, initSimpleDraggable:function() {
  var me = this, ddConfig, dd;
  if (!me.header) {
    me.updateHeader(true);
  }
  if (me.header) {
    ddConfig = Ext.applyIf({el:me.el, delegate:'#' + Ext.escapeId(me.header.id)}, me.draggable);
    if (me.constrain || me.constrainHeader) {
      ddConfig.constrain = me.constrain;
      ddConfig.constrainDelegate = me.constrainHeader;
      ddConfig.constrainTo = me.constrainTo || me.container;
    }
    dd = me.dd = new Ext.util.ComponentDragger(this, ddConfig);
    me.relayEvents(dd, ['dragstart', 'drag', 'dragend']);
    if (me.maximized) {
      dd.disable();
    }
  }
}, ghostTools:function() {
  var tools = [], header = this.header, headerTools = header ? header.query('tool[hidden\x3dfalse]') : [], t, tLen, tool;
  if (headerTools.length) {
    t = 0;
    tLen = headerTools.length;
    for (; t < tLen; t++) {
      tool = headerTools[t];
      tools.push({type:tool.type});
    }
  } else {
    tools = [{type:'placeholder'}];
  }
  return tools;
}, ghost:function(cls) {
  var me = this, ghostPanel = me.ghostPanel, box = me.getBox(), header;
  if (!ghostPanel) {
    ghostPanel = new Ext.panel.Panel({renderTo:Ext.getBody(), floating:{shadow:false}, frame:me.frame && !me.alwaysFramed, alwaysFramed:me.alwaysFramed, overlapHeader:me.overlapHeader, headerPosition:me.headerPosition, baseCls:me.baseCls, cls:me.baseCls + '-ghost ' + (cls || '')});
    me.ghostPanel = ghostPanel;
  } else {
    ghostPanel.el.show();
  }
  me.ghostPanel.hidden = false;
  ghostPanel.floatParent = me.floatParent;
  if (me.floating) {
    ghostPanel.zIndexManager.assignZIndices();
  } else {
    ghostPanel.toFront();
  }
  if (!(me.preventHeader || me.header === false)) {
    header = ghostPanel.header;
    if (header) {
      header.suspendLayouts();
      Ext.Array.forEach(header.query('tool'), header.remove, header);
      header.resumeLayouts();
    }
    ghostPanel.addTool(me.ghostTools());
    ghostPanel.setTitle(me.title);
    if (me.iconCls) {
      ghostPanel.setIconCls(me.iconCls);
    } else {
      if (me.icon) {
        ghostPanel.setIcon(me.icon);
      } else {
        if (me.glyph) {
          ghostPanel.setGlyph(me.glyph);
        }
      }
    }
    ghostPanel.header.addCls(Ext.baseCSSPrefix + 'header-ghost');
  }
  ghostPanel.setPagePosition(box.x, box.y);
  ghostPanel.setSize(box.width, box.height);
  me.el.hide();
  return ghostPanel;
}, unghost:function(show, matchPosition) {
  var me = this;
  if (!me.ghostPanel) {
    return;
  }
  if (show !== false) {
    me.el.show();
    if (matchPosition !== false) {
      me.setPagePosition(me.ghostPanel.getXY());
      if (me.hideMode == 'offsets') {
        delete me.el.hideModeStyles;
      }
    }
    Ext.defer(me.focus, 10, me);
  }
  me.ghostPanel.el.hide();
  me.ghostPanel.hidden = true;
}, beginDrag:function() {
  if (this.floatingDescendants) {
    this.floatingDescendants.hide();
  }
}, endDrag:function() {
  if (this.floatingDescendants) {
    this.floatingDescendants.show();
  }
}, initResizable:function() {
  this.callParent(arguments);
  if (this.collapsed) {
    this.resizer.disable();
  }
}, convertCollapseDir:function(collapseDir) {
  return collapseDir.substr(0, 1);
}}, function() {
  this.prototype.animCollapse = Ext.enableFx;
});
Ext.define('Ext.tip.Tip', {extend:Ext.panel.Panel, alternateClassName:'Ext.Tip', minWidth:40, maxWidth:500, shadow:'sides', defaultAlign:'tl-bl?', constrainPosition:true, autoRender:true, hidden:true, baseCls:Ext.baseCSSPrefix + 'tip', floating:{shadow:true, shim:true}, focusOnToFront:false, closeAction:'hide', ariaRole:'tooltip', alwaysFramed:true, frameHeader:false, initComponent:function() {
  var me = this;
  me.floating = Ext.apply({}, {shadow:me.shadow, constrain:me.constrainPosition}, me.self.prototype.floating);
  me.callParent(arguments);
  me.constrain = me.constrain || me.constrainPosition;
}, showAt:function(xy) {
  var me = this;
  this.callParent(arguments);
  if (me.isVisible()) {
    me.setPagePosition(xy[0], xy[1]);
    if (me.constrainPosition || me.constrain) {
      me.doConstrain();
    }
    me.toFront(true);
  }
}, initDraggable:function() {
  var me = this;
  me.draggable = {el:me.getDragEl(), delegate:me.header.el, constrain:me, constrainTo:me.el.dom.parentNode};
  Ext.Component.prototype.initDraggable.call(me);
}, ghost:undefined, unghost:undefined});
Ext.define('Ext.tip.ToolTip', {extend:Ext.tip.Tip, alias:'widget.tooltip', alternateClassName:'Ext.ToolTip', autoHide:true, showDelay:500, hideDelay:200, dismissDelay:5000, trackMouse:false, anchorToTarget:true, anchorOffset:0, targetCounter:0, quickShowInterval:250, initComponent:function() {
  var me = this;
  me.callParent(arguments);
  me.lastActive = new Date;
  me.setTarget(me.target);
  me.origAnchor = me.anchor;
}, onRender:function(ct, position) {
  var me = this;
  me.callParent(arguments);
  me.anchorCls = Ext.baseCSSPrefix + 'tip-anchor-' + me.getAnchorPosition();
  me.anchorEl = me.el.createChild({cls:Ext.baseCSSPrefix + 'tip-anchor ' + me.anchorCls});
}, setTarget:function(target) {
  var me = this, t = Ext.get(target), tg;
  if (me.target) {
    tg = Ext.get(me.target);
    me.mun(tg, 'mouseover', me.onTargetOver, me);
    me.mun(tg, 'mouseout', me.onTargetOut, me);
    me.mun(tg, 'mousemove', me.onMouseMove, me);
  }
  me.target = t;
  if (t) {
    me.mon(t, {freezeEvent:true, mouseover:me.onTargetOver, mouseout:me.onTargetOut, mousemove:me.onMouseMove, scope:me});
  }
  if (me.anchor) {
    me.anchorTarget = me.target;
  }
}, onMouseMove:function(e) {
  var me = this, t = me.delegate ? e.getTarget(me.delegate) : me.triggerElement = true, xy;
  if (t) {
    me.targetXY = e.getXY();
    if (t === me.triggerElement) {
      if (!me.hidden && me.trackMouse) {
        xy = me.getTargetXY();
        if (me.constrainPosition) {
          xy = me.el.adjustForConstraints(xy, me.el.parent());
        }
        me.setPagePosition(xy);
      }
    } else {
      me.hide();
      me.lastActive = new Date(0);
      me.onTargetOver(e);
    }
  } else {
    if (!me.closable && me.isVisible() && me.autoHide !== false) {
      me.hide();
    }
  }
}, getTargetXY:function() {
  var me = this, mouseOffset, offsets, xy, dw, dh, de, bd, scrollX, scrollY, axy, sz, constrainPosition;
  if (me.delegate) {
    me.anchorTarget = me.triggerElement;
  }
  if (me.anchor) {
    me.targetCounter++;
    offsets = me.getOffsets();
    xy = me.anchorToTarget && !me.trackMouse ? me.getAlignToXY(me.anchorTarget, me.getAnchorAlign()) : me.targetXY;
    dw = Ext.Element.getViewWidth() - 5;
    dh = Ext.Element.getViewHeight() - 5;
    de = document.documentElement;
    bd = document.body;
    scrollX = (de.scrollLeft || bd.scrollLeft || 0) + 5;
    scrollY = (de.scrollTop || bd.scrollTop || 0) + 5;
    axy = [xy[0] + offsets[0], xy[1] + offsets[1]];
    sz = me.getSize();
    constrainPosition = me.constrainPosition;
    me.anchorEl.removeCls(me.anchorCls);
    if (me.targetCounter < 2 && constrainPosition) {
      if (axy[0] < scrollX) {
        if (me.anchorToTarget) {
          me.defaultAlign = 'l-r';
          if (me.mouseOffset) {
            me.mouseOffset[0] *= -1;
          }
        }
        me.anchor = 'left';
        return me.getTargetXY();
      }
      if (axy[0] + sz.width > dw) {
        if (me.anchorToTarget) {
          me.defaultAlign = 'r-l';
          if (me.mouseOffset) {
            me.mouseOffset[0] *= -1;
          }
        }
        me.anchor = 'right';
        return me.getTargetXY();
      }
      if (axy[1] < scrollY) {
        if (me.anchorToTarget) {
          me.defaultAlign = 't-b';
          if (me.mouseOffset) {
            me.mouseOffset[1] *= -1;
          }
        }
        me.anchor = 'top';
        return me.getTargetXY();
      }
      if (axy[1] + sz.height > dh) {
        if (me.anchorToTarget) {
          me.defaultAlign = 'b-t';
          if (me.mouseOffset) {
            me.mouseOffset[1] *= -1;
          }
        }
        me.anchor = 'bottom';
        return me.getTargetXY();
      }
    }
    me.anchorCls = Ext.baseCSSPrefix + 'tip-anchor-' + me.getAnchorPosition();
    me.anchorEl.addCls(me.anchorCls);
    me.targetCounter = 0;
    return axy;
  } else {
    mouseOffset = me.getMouseOffset();
    return me.targetXY ? [me.targetXY[0] + mouseOffset[0], me.targetXY[1] + mouseOffset[1]] : mouseOffset;
  }
}, getMouseOffset:function() {
  var me = this, offset = me.anchor ? [0, 0] : [15, 18];
  if (me.mouseOffset) {
    offset[0] += me.mouseOffset[0];
    offset[1] += me.mouseOffset[1];
  }
  return offset;
}, getAnchorPosition:function() {
  var me = this, m;
  if (me.anchor) {
    me.tipAnchor = me.anchor.charAt(0);
  } else {
    m = me.defaultAlign.match(/^([a-z]+)-([a-z]+)(\?)?$/);
    if (!m) {
      Ext.Error.raise('The AnchorTip.defaultAlign value "' + me.defaultAlign + '" is invalid.');
    }
    me.tipAnchor = m[1].charAt(0);
  }
  switch(me.tipAnchor) {
    case 't':
      return 'top';
    case 'b':
      return 'bottom';
    case 'r':
      return 'right';
  }
  return 'left';
}, getAnchorAlign:function() {
  switch(this.anchor) {
    case 'top':
      return 'tl-bl';
    case 'left':
      return 'tl-tr';
    case 'right':
      return 'tr-tl';
    default:
      return 'bl-tl';
  }
}, getOffsets:function() {
  var me = this, mouseOffset, offsets, ap = me.getAnchorPosition().charAt(0);
  if (me.anchorToTarget && !me.trackMouse) {
    switch(ap) {
      case 't':
        offsets = [0, 9];
        break;
      case 'b':
        offsets = [0, -13];
        break;
      case 'r':
        offsets = [-13, 0];
        break;
      default:
        offsets = [9, 0];
        break;
    }
  } else {
    switch(ap) {
      case 't':
        offsets = [-15 - me.anchorOffset, 30];
        break;
      case 'b':
        offsets = [-19 - me.anchorOffset, -13 - me.el.dom.offsetHeight];
        break;
      case 'r':
        offsets = [-15 - me.el.dom.offsetWidth, -13 - me.anchorOffset];
        break;
      default:
        offsets = [25, -13 - me.anchorOffset];
        break;
    }
  }
  mouseOffset = me.getMouseOffset();
  offsets[0] += mouseOffset[0];
  offsets[1] += mouseOffset[1];
  return offsets;
}, onTargetOver:function(e) {
  var me = this, delegate = me.delegate, t;
  if (me.disabled || e.within(me.target.dom, true)) {
    return;
  }
  t = delegate ? e.getTarget(delegate) : true;
  if (t) {
    me.triggerElement = t;
    me.triggerEvent = e;
    me.clearTimer('hide');
    me.targetXY = e.getXY();
    me.delayShow();
  }
}, delayShow:function() {
  var me = this;
  if (me.hidden && !me.showTimer) {
    if (Ext.Date.getElapsed(me.lastActive) < me.quickShowInterval) {
      me.show();
    } else {
      me.showTimer = Ext.defer(me.showFromDelay, me.showDelay, me);
    }
  } else {
    if (!me.hidden && me.autoHide !== false) {
      me.show();
    }
  }
}, showFromDelay:function() {
  this.fromDelayShow = true;
  this.show();
  delete this.fromDelayShow;
}, onShowVeto:function() {
  this.callParent();
  delete this.triggerElement;
  this.clearTimer('show');
}, onTargetOut:function(e) {
  var me = this, triggerEl = me.triggerElement, target = triggerEl === true ? me.target : triggerEl;
  if (me.disabled || !triggerEl || e.within(target, true)) {
    return;
  }
  if (me.showTimer) {
    me.clearTimer('show');
    me.triggerElement = null;
  }
  if (me.autoHide !== false) {
    me.delayHide();
  }
}, delayHide:function() {
  var me = this;
  if (!me.hidden && !me.hideTimer) {
    me.hideTimer = Ext.defer(me.hide, me.hideDelay, me);
  }
}, hide:function() {
  var me = this;
  me.clearTimer('dismiss');
  me.lastActive = new Date;
  if (me.anchorEl) {
    me.anchorEl.hide();
  }
  me.callParent(arguments);
  delete me.triggerElement;
}, show:function() {
  var me = this;
  this.callParent();
  if (this.hidden === false) {
    me.setPagePosition(-10000, -10000);
    if (me.anchor) {
      me.anchor = me.origAnchor;
    }
    if (!me.calledFromShowAt) {
      me.showAt(me.getTargetXY());
    }
    if (me.anchor) {
      me.syncAnchor();
      me.anchorEl.show();
    } else {
      me.anchorEl.hide();
    }
  }
}, showAt:function(xy) {
  var me = this;
  me.lastActive = new Date;
  me.clearTimers();
  me.calledFromShowAt = true;
  if (!me.isVisible()) {
    this.callParent(arguments);
  }
  if (me.isVisible()) {
    me.setPagePosition(xy[0], xy[1]);
    if (me.constrainPosition || me.constrain) {
      me.doConstrain();
    }
    me.toFront(true);
    me.el.sync(true);
    if (me.dismissDelay && me.autoHide !== false) {
      me.dismissTimer = Ext.defer(me.hide, me.dismissDelay, me);
    }
    if (me.anchor) {
      me.syncAnchor();
      if (!me.anchorEl.isVisible()) {
        me.anchorEl.show();
      }
    } else {
      me.anchorEl.hide();
    }
  }
  delete me.calledFromShowAt;
}, syncAnchor:function() {
  var me = this, anchorPos, targetPos, offset;
  switch(me.tipAnchor.charAt(0)) {
    case 't':
      anchorPos = 'b';
      targetPos = 'tl';
      offset = [20 + me.anchorOffset, 1];
      break;
    case 'r':
      anchorPos = 'l';
      targetPos = 'tr';
      offset = [-1, 12 + me.anchorOffset];
      break;
    case 'b':
      anchorPos = 't';
      targetPos = 'bl';
      offset = [20 + me.anchorOffset, -1];
      break;
    default:
      anchorPos = 'r';
      targetPos = 'tl';
      offset = [1, 12 + me.anchorOffset];
      break;
  }
  me.anchorEl.alignTo(me.el, anchorPos + '-' + targetPos, offset);
  me.anchorEl.setStyle('z-index', parseInt(me.el.getZIndex(), 10) || 0 + 1).setVisibilityMode(Ext.Element.DISPLAY);
}, setPagePosition:function(x, y) {
  var me = this;
  me.callParent(arguments);
  if (me.anchor) {
    me.syncAnchor();
  }
}, _timerNames:{}, clearTimer:function(name) {
  var me = this, names = me._timerNames, propName = names[name] || (names[name] = name + 'Timer'), timer = me[propName];
  if (timer) {
    clearTimeout(timer);
    me[propName] = null;
  }
}, clearTimers:function() {
  var me = this;
  me.clearTimer('show');
  me.clearTimer('dismiss');
  me.clearTimer('hide');
}, onShow:function() {
  var me = this;
  me.callParent();
  me.mon(Ext.getDoc(), 'mousedown', me.onDocMouseDown, me);
}, onHide:function() {
  var me = this;
  me.callParent();
  me.mun(Ext.getDoc(), 'mousedown', me.onDocMouseDown, me);
}, onDocMouseDown:function(e) {
  var me = this;
  if (!me.closable && !e.within(me.el.dom)) {
    me.disable();
    Ext.defer(me.doEnable, 100, me);
  }
}, doEnable:function() {
  if (!this.isDestroyed) {
    this.enable();
  }
}, onDisable:function() {
  this.callParent();
  this.clearTimers();
  this.hide();
}, beforeDestroy:function() {
  var me = this;
  me.clearTimers();
  Ext.destroy(me.anchorEl);
  delete me.anchorEl;
  delete me.target;
  delete me.anchorTarget;
  delete me.triggerElement;
  me.callParent();
}, onDestroy:function() {
  Ext.getDoc().un('mousedown', this.onDocMouseDown, this);
  this.callParent();
}});
Ext.define('Ext.tip.QuickTip', {extend:Ext.tip.ToolTip, alias:'widget.quicktip', alternateClassName:'Ext.QuickTip', interceptTitles:false, title:'\x26#160;', tagConfig:{namespace:'data-', attribute:'qtip', width:'qwidth', target:'target', title:'qtitle', hide:'hide', cls:'qclass', align:'qalign', anchor:'anchor', showDelay:'qshowDelay'}, initComponent:function() {
  var me = this;
  me.target = me.target || Ext.getDoc();
  me.targets = me.targets || {};
  me.callParent();
}, register:function(config) {
  var configs = Ext.isArray(config) ? config : arguments, i = 0, len = configs.length, target, j, targetLen;
  for (; i < len; i++) {
    config = configs[i];
    target = config.target;
    if (target) {
      if (Ext.isArray(target)) {
        for (j = 0, targetLen = target.length; j < targetLen; j++) {
          this.targets[Ext.id(target[j])] = config;
        }
      } else {
        this.targets[Ext.id(target)] = config;
      }
    }
  }
}, unregister:function(el) {
  delete this.targets[Ext.id(el)];
}, cancelShow:function(el) {
  var me = this, activeTarget = me.activeTarget;
  el = Ext.get(el).dom;
  if (me.isVisible()) {
    if (activeTarget && activeTarget.el == el) {
      me.hide();
    }
  } else {
    if (activeTarget && activeTarget.el == el) {
      me.clearTimer('show');
    }
  }
}, getTipCfg:function(e) {
  var t = e.getTarget(), titleText = t.title, cfg;
  if (this.interceptTitles && titleText && Ext.isString(titleText)) {
    t.qtip = titleText;
    t.removeAttribute('title');
    e.preventDefault();
    return {text:titleText};
  } else {
    cfg = this.tagConfig;
    t = e.getTarget('[' + cfg.namespace + cfg.attribute + ']');
    if (t) {
      return {target:t, text:t.getAttribute(cfg.namespace + cfg.attribute)};
    }
  }
}, onTargetOver:function(e) {
  var me = this, target = e.getTarget(me.delegate), hasShowDelay, delay, elTarget, cfg, ns, tipConfig, autoHide, targets, targetEl, value, key;
  if (me.disabled) {
    return;
  }
  me.targetXY = e.getXY();
  if (!target || target.nodeType !== 1 || target == document.documentElement || target == document.body) {
    return;
  }
  if (me.activeTarget && (target == me.activeTarget.el || Ext.fly(me.activeTarget.el).contains(target))) {
    if (me.targetTextEmpty()) {
      me.onShowVeto();
      delete me.activeTarget;
    } else {
      me.clearTimer('hide');
      me.show();
    }
    return;
  }
  if (target) {
    targets = me.targets;
    for (key in targets) {
      if (targets.hasOwnProperty(key)) {
        value = targets[key];
        targetEl = Ext.fly(value.target);
        if (targetEl && (targetEl.dom === target || targetEl.contains(target))) {
          elTarget = targetEl.dom;
          break;
        }
      }
    }
    if (elTarget) {
      me.activeTarget = me.targets[elTarget.id];
      me.activeTarget.el = target;
      me.anchor = me.activeTarget.anchor;
      if (me.anchor) {
        me.anchorTarget = target;
      }
      hasShowDelay = parseInt(me.activeTarget.showDelay, 10);
      if (hasShowDelay) {
        delay = me.showDelay;
        me.showDelay = hasShowDelay;
      }
      me.delayShow();
      if (hasShowDelay) {
        me.showDelay = delay;
      }
      return;
    }
  }
  elTarget = Ext.fly(target, '_quicktip-target');
  cfg = me.tagConfig;
  ns = cfg.namespace;
  tipConfig = me.getTipCfg(e);
  if (tipConfig) {
    if (tipConfig.target) {
      target = tipConfig.target;
      elTarget = Ext.fly(target, '_quicktip-target');
    }
    autoHide = elTarget.getAttribute(ns + cfg.hide);
    me.activeTarget = {el:target, text:tipConfig.text, width:+elTarget.getAttribute(ns + cfg.width) || null, autoHide:autoHide != 'user' && autoHide !== 'false', title:elTarget.getAttribute(ns + cfg.title), cls:elTarget.getAttribute(ns + cfg.cls), align:elTarget.getAttribute(ns + cfg.align), showDelay:parseInt(elTarget.getAttribute(ns + cfg.showDelay), 10)};
    me.anchor = elTarget.getAttribute(ns + cfg.anchor);
    if (me.anchor) {
      me.anchorTarget = target;
    }
    hasShowDelay = parseInt(me.activeTarget.showDelay, 10);
    if (hasShowDelay) {
      delay = me.showDelay;
      me.showDelay = hasShowDelay;
    }
    me.delayShow();
    if (hasShowDelay) {
      me.showDelay = delay;
    }
  }
}, onTargetOut:function(e) {
  var me = this, active = me.activeTarget, hasHideDelay, delay;
  if (active && e.within(me.activeTarget.el) && !me.getTipCfg(e)) {
    return;
  }
  me.clearTimer('show');
  delete me.activeTarget;
  if (me.autoHide !== false) {
    hasHideDelay = active && parseInt(active.hideDelay, 10);
    if (hasHideDelay) {
      delay = me.hideDelay;
      me.hideDelay = hasHideDelay;
    }
    me.delayHide();
    if (hasHideDelay) {
      me.hideDelay = delay;
    }
  }
}, targetTextEmpty:function() {
  var me = this, target = me.activeTarget, cfg = me.tagConfig, el, text;
  if (target) {
    el = target.el;
    if (el) {
      text = el.getAttribute(cfg.namespace + cfg.attribute);
      if (!text && !me.targets[target.target]) {
        return true;
      }
    }
  }
  return false;
}, show:function() {
  var me = this, fromDelay = me.fromDelayShow;
  if (fromDelay && me.targetTextEmpty()) {
    me.onShowVeto();
    delete me.activeTarget;
    return;
  }
  me.callParent(arguments);
}, showAt:function(xy) {
  var me = this, target = me.activeTarget, header = me.header, cls;
  if (target) {
    if (!me.rendered) {
      me.render(Ext.getBody());
      me.activeTarget = target;
    }
    me.suspendLayouts();
    if (target.title) {
      me.setTitle(target.title);
      header.show();
    } else {
      if (header) {
        header.hide();
      }
    }
    me.update(target.text);
    me.autoHide = target.autoHide;
    me.dismissDelay = target.dismissDelay || me.dismissDelay;
    if (target.mouseOffset) {
      xy[0] += target.mouseOffset[0];
      xy[1] += target.mouseOffset[1];
    }
    cls = me.lastCls;
    if (cls) {
      me.removeCls(cls);
      delete me.lastCls;
    }
    cls = target.cls;
    if (cls) {
      me.addCls(cls);
      me.lastCls = cls;
    }
    me.setWidth(target.width);
    if (me.anchor) {
      me.constrainPosition = false;
    } else {
      if (target.align) {
        xy = me.getAlignToXY(target.el, target.align);
        me.constrainPosition = false;
      } else {
        me.constrainPosition = true;
      }
    }
    me.resumeLayouts(true);
  }
  me.callParent([xy]);
}, hide:function() {
  delete this.activeTarget;
  this.callParent();
}});
Ext.define('Ext.tip.QuickTipManager', {singleton:true, alternateClassName:'Ext.QuickTips', disabled:false, init:function(autoRender, config) {
  var me = this;
  if (!me.tip) {
    if (!Ext.isReady) {
      Ext.onReady(function() {
        Ext.tip.QuickTipManager.init(autoRender, config);
      });
      return;
    }
    var tipConfig = Ext.apply({disabled:me.disabled, id:'ext-quicktips-tip'}, config), className = tipConfig.className, xtype = tipConfig.xtype;
    if (className) {
      delete tipConfig.className;
    } else {
      if (xtype) {
        className = 'widget.' + xtype;
        delete tipConfig.xtype;
      }
    }
    if (autoRender !== false) {
      tipConfig.renderTo = document.body;
      if (tipConfig.renderTo.tagName.toUpperCase() != 'BODY') {
        Ext.Error.raise({sourceClass:'Ext.tip.QuickTipManager', sourceMethod:'init', msg:'Cannot init QuickTipManager: no document body'});
      }
    }
    me.tip = Ext.create(className || 'Ext.tip.QuickTip', tipConfig);
    Ext.quickTipsActive = true;
  }
}, destroy:function() {
  Ext.destroy(this.tip);
  this.tip = undefined;
}, ddDisable:function() {
  var me = this, tip = me.tip;
  if (tip && !me.disabled) {
    tip.disable();
  }
}, ddEnable:function() {
  var me = this, tip = me.tip;
  if (tip && !me.disabled) {
    tip.enable();
  }
}, enable:function() {
  var me = this, tip = me.tip;
  if (tip) {
    tip.enable();
  }
  me.disabled = false;
}, disable:function() {
  var me = this, tip = me.tip;
  if (tip) {
    tip.disable();
  }
  me.disabled = true;
}, isEnabled:function() {
  var tip = this.tip;
  return tip !== undefined && !tip.disabled;
}, getQuickTip:function() {
  return this.tip;
}, register:function() {
  var tip = this.tip;
  tip.register.apply(tip, arguments);
}, unregister:function() {
  var tip = this.tip;
  tip.unregister.apply(tip, arguments);
}, tips:function() {
  var tip = this.tip;
  tip.register.apply(tip, arguments);
}});
Ext.define('Ext.app.Application', {extend:Ext.app.Controller, scope:undefined, enableQuickTips:true, appFolder:'app', appProperty:'app', namespaces:[], autoCreateViewport:false, paths:null, onClassExtended:function(cls, data, hooks) {
  var Controller = Ext.app.Controller, proto = cls.prototype, requires = [], onBeforeClassCreated, paths, namespace, ns, appFolder;
  namespace = data.name || cls.superclass.name;
  appFolder = data.appFolder || cls.superclass.appFolder;
  if (namespace) {
    data.$namespace = namespace;
    Ext.app.addNamespaces(namespace);
  }
  if (data.namespaces) {
    Ext.app.addNamespaces(data.namespaces);
  }
  if (!data['paths processed']) {
    if (namespace && appFolder) {
      Ext.Loader.setPath(namespace, appFolder);
    }
    paths = data.paths;
    if (paths) {
      for (ns in paths) {
        if (paths.hasOwnProperty(ns)) {
          Ext.Loader.setPath(ns, paths[ns]);
        }
      }
    }
  } else {
    delete data['paths processed'];
  }
  if (data.autoCreateViewport) {
    if (!namespace) {
      Ext.Error.raise("[Ext.app.Application] Can't resolve namespace for " + data.$className + ", did you forget to specify 'name' property?");
    }
    Controller.processDependencies(proto, requires, namespace, 'view', ['Viewport']);
  }
  if (requires.length) {
    onBeforeClassCreated = hooks.onBeforeCreated;
    hooks.onBeforeCreated = function(cls, data) {
      var args = Ext.Array.clone(arguments);
      Ext.require(requires, function() {
        return onBeforeClassCreated.apply(this, args);
      });
    };
  }
}, constructor:function(config) {
  var me = this;
  if (Ext.isEmpty(me.name)) {
    Ext.Error.raise('[Ext.app.Application] Name property is required');
  }
  me.callParent(arguments);
  me.doInit(me);
  me.initNamespace();
  me.initControllers();
  me.onBeforeLaunch();
  me.finishInitControllers();
}, initNamespace:function() {
  var me = this, appProperty = me.appProperty, ns;
  ns = Ext.namespace(me.name);
  if (ns) {
    ns.getApplication = function() {
      return me;
    };
    if (appProperty) {
      if (!ns[appProperty]) {
        ns[appProperty] = me;
      } else {
        if (ns[appProperty] !== me) {
          Ext.log.warn('An existing reference is being overwritten for ' + name + '.' + appProperty + '. See the appProperty config.');
        }
      }
    }
  }
}, initControllers:function() {
  var me = this, controllers = Ext.Array.from(me.controllers);
  me.controllers = new Ext.util.MixedCollection;
  for (var i = 0, ln = controllers.length; i < ln; i++) {
    me.getController(controllers[i]);
  }
}, finishInitControllers:function() {
  var me = this, controllers, i, l;
  controllers = me.controllers.getRange();
  for (i = 0, l = controllers.length; i < l; i++) {
    controllers[i].finishInit(me);
  }
}, launch:Ext.emptyFn, onBeforeLaunch:function() {
  var me = this, controllers, c, cLen, controller;
  if (me.enableQuickTips) {
    me.initQuickTips();
  }
  if (me.autoCreateViewport) {
    me.initViewport();
  }
  me.launch.call(me.scope || me);
  me.launched = true;
  me.fireEvent('launch', me);
  controllers = me.controllers.items;
  cLen = controllers.length;
  for (c = 0; c < cLen; c++) {
    controller = controllers[c];
    controller.onLaunch(me);
  }
}, getModuleClassName:function(name, kind) {
  return Ext.app.Controller.getFullName(name, kind, this.name).absoluteName;
}, initQuickTips:function() {
  Ext.tip.QuickTipManager.init();
}, initViewport:function() {
  var viewport = this.getView('Viewport');
  if (viewport) {
    viewport.create();
  }
}, getController:function(name) {
  var me = this, controllers = me.controllers, className, controller;
  controller = controllers.get(name);
  if (!controller) {
    className = me.getModuleClassName(name, 'controller');
    controller = Ext.create(className, {application:me, id:name});
    controllers.add(controller);
    if (me._initialized) {
      controller.doInit(me);
    }
  }
  return controller;
}, getApplication:function() {
  return this;
}});
Ext.define('Ext.app.domain.Controller', {extend:Ext.app.EventDomain, singleton:true, type:'controller', idProperty:'id', constructor:function() {
  var me = this;
  me.callParent();
  me.monitor(Ext.app.Controller);
}});
Ext.define('Ext.button.Split', {alias:'widget.splitbutton', extend:Ext.button.Button, alternateClassName:'Ext.SplitButton', arrowCls:'split', split:true, initComponent:function() {
  this.callParent();
  this.addEvents('arrowclick');
}, setArrowHandler:function(handler, scope) {
  this.arrowHandler = handler;
  this.scope = scope;
}, onClick:function(e, t) {
  var me = this;
  e.preventDefault();
  if (!me.disabled) {
    if (me.overMenuTrigger) {
      me.maybeShowMenu();
      me.fireEvent('arrowclick', me, e);
      if (me.arrowHandler) {
        me.arrowHandler.call(me.scope || me, me, e);
      }
    } else {
      me.doToggle();
      me.fireHandler(e);
    }
  }
}});
Ext.define('Ext.container.Viewport', {extend:Ext.container.Container, alias:'widget.viewport', alternateClassName:'Ext.Viewport', isViewport:true, ariaRole:'application', preserveElOnDestroy:true, viewportCls:Ext.baseCSSPrefix + 'viewport', initComponent:function() {
  var me = this, html = document.body.parentNode, el = me.el = Ext.getBody();
  Ext.getScrollbarSize();
  me.width = me.height = undefined;
  me.callParent(arguments);
  Ext.fly(html).addCls(me.viewportCls);
  if (me.autoScroll) {
    Ext.fly(html).setStyle(me.getOverflowStyle());
    delete me.autoScroll;
  }
  el.setHeight = el.setWidth = Ext.emptyFn;
  el.dom.scroll = 'no';
  me.allowDomMove = false;
  me.renderTo = me.el;
}, applyTargetCls:function(targetCls) {
  this.el.addCls(targetCls);
}, onRender:function() {
  var me = this;
  me.callParent(arguments);
  me.width = Ext.Element.getViewportWidth();
  me.height = Ext.Element.getViewportHeight();
}, afterFirstLayout:function() {
  var me = this;
  me.callParent(arguments);
  setTimeout(function() {
    Ext.EventManager.onWindowResize(me.fireResize, me);
  }, 1);
}, fireResize:function(width, height) {
  if (width != this.width || height != this.height) {
    this.setSize(width, height);
  }
}, initHierarchyState:function(hierarchyState) {
  this.callParent([this.hierarchyState = Ext.rootHierarchyState]);
}, beforeDestroy:function() {
  var me = this;
  me.removeUIFromElement();
  me.el.removeCls(me.baseCls);
  Ext.fly(document.body.parentNode).removeCls(me.viewportCls);
  me.callParent();
}});
Ext.define('Ext.data.IdGenerator', {isGenerator:true, constructor:function(config) {
  var me = this;
  Ext.apply(me, config);
  if (me.id) {
    Ext.data.IdGenerator.all[me.id] = me;
  }
}, getRecId:function(rec) {
  return rec.modelName + '-' + rec.internalId;
}, statics:{all:{}, get:function(config) {
  var generator, id, type;
  if (typeof config == 'string') {
    id = type = config;
    config = null;
  } else {
    if (config.isGenerator) {
      return config;
    } else {
      id = config.id || config.type;
      type = config.type;
    }
  }
  generator = this.all[id];
  if (!generator) {
    generator = Ext.create('idgen.' + type, config);
  }
  return generator;
}}});
Ext.define('Ext.data.SortTypes', {singleton:true, none:Ext.identityFn, stripTagsRE:/<\/?[^>]+>/gi, asText:function(s) {
  return String(s).replace(this.stripTagsRE, '');
}, asUCText:function(s) {
  return String(s).toUpperCase().replace(this.stripTagsRE, '');
}, asUCString:function(s) {
  return String(s).toUpperCase();
}, asDate:function(s) {
  if (!s) {
    return 0;
  }
  if (Ext.isDate(s)) {
    return s.getTime();
  }
  return Date.parse(String(s));
}, asFloat:function(s) {
  var val = parseFloat(String(s).replace(/,/g, ''));
  return isNaN(val) ? 0 : val;
}, asInt:function(s) {
  var val = parseInt(String(s).replace(/,/g, ''), 10);
  return isNaN(val) ? 0 : val;
}});
Ext.define('Ext.data.Types', {singleton:true}, function() {
  var st = Ext.data.SortTypes;
  Ext.apply(Ext.data.Types, {stripRe:/[\$,%]/g, AUTO:{sortType:st.none, type:'auto'}, STRING:{convert:function(v) {
    var defaultValue = this.useNull ? null : '';
    return v === undefined || v === null ? defaultValue : String(v);
  }, sortType:st.asUCString, type:'string'}, INT:{convert:function(v) {
    if (typeof v == 'number') {
      return parseInt(v);
    }
    return v !== undefined && v !== null && v !== '' ? parseInt(String(v).replace(Ext.data.Types.stripRe, ''), 10) : this.useNull ? null : 0;
  }, sortType:st.none, type:'int'}, FLOAT:{convert:function(v) {
    if (typeof v === 'number') {
      return v;
    }
    return v !== undefined && v !== null && v !== '' ? parseFloat(String(v).replace(Ext.data.Types.stripRe, ''), 10) : this.useNull ? null : 0;
  }, sortType:st.none, type:'float'}, BOOL:{convert:function(v) {
    if (typeof v === 'boolean') {
      return v;
    }
    if (this.useNull && (v === undefined || v === null || v === '')) {
      return null;
    }
    return v === 'true' || v == 1;
  }, sortType:st.none, type:'bool'}, DATE:{convert:function(v) {
    var df = this.dateReadFormat || this.dateFormat, parsed;
    if (!v) {
      return null;
    }
    if (v instanceof Date) {
      return v;
    }
    if (df) {
      return Ext.Date.parse(v, df);
    }
    parsed = Date.parse(v);
    return parsed ? new Date(parsed) : null;
  }, sortType:st.asDate, type:'date'}});
  Ext.apply(Ext.data.Types, {BOOLEAN:this.BOOL, INTEGER:this.INT, NUMBER:this.FLOAT});
});
Ext.define('Ext.data.Field', {alias:'data.field', isField:true, constructor:function(config) {
  var me = this, types = Ext.data.Types, st;
  if (Ext.isString(config)) {
    config = {name:config};
  }
  Ext.apply(me, config);
  st = me.sortType;
  if (me.type) {
    if (Ext.isString(me.type)) {
      me.type = types[me.type.toUpperCase()] || types.AUTO;
    }
  } else {
    me.type = types.AUTO;
  }
  if (Ext.isString(st)) {
    me.sortType = Ext.data.SortTypes[st];
  } else {
    if (Ext.isEmpty(st)) {
      me.sortType = me.type.sortType;
    }
  }
  if (!config.hasOwnProperty('convert')) {
    me.convert = me.type.convert;
  } else {
    if (!me.convert && me.type.convert && !config.hasOwnProperty('defaultValue')) {
      me.defaultValue = me.type.convert(me.defaultValue);
    }
  }
  if (config.convert) {
    me.hasCustomConvert = true;
  }
}, dateFormat:null, dateReadFormat:null, dateWriteFormat:null, useNull:false, defaultValue:'', mapping:null, sortType:null, sortDir:'ASC', allowBlank:true, persist:true});
Ext.define('Ext.data.Errors', {extend:Ext.util.MixedCollection, isValid:function() {
  return this.length === 0;
}, getByField:function(fieldName) {
  var errors = [], error, i;
  for (i = 0; i < this.length; i++) {
    error = this.items[i];
    if (error.field == fieldName) {
      errors.push(error);
    }
  }
  return errors;
}});
Ext.define('Ext.data.validations', {singleton:true, presenceMessage:'must be present', lengthMessage:'is the wrong length', formatMessage:'is the wrong format', inclusionMessage:'is not included in the list of acceptable values', exclusionMessage:'is not an acceptable value', emailMessage:'is not a valid email address', emailRe:/^([a-zA-Z0-9_\.\-])+@(([a-zA-Z0-9\-])+\.)+([a-zA-Z0-9]{2,4})+$/, presence:function(config, value) {
  if (arguments.length === 1) {
    value = config;
  }
  return !!value || value === 0 || value === false;
}, length:function(config, value) {
  if (value === undefined || value === null) {
    return false;
  }
  var length = value.length, min = config.min, max = config.max;
  if (min && length < min || max && length > max) {
    return false;
  } else {
    return true;
  }
}, email:function(config, email) {
  return Ext.data.validations.emailRe.test(email);
}, format:function(config, value) {
  return !!(config.matcher && config.matcher.test(value));
}, inclusion:function(config, value) {
  return config.list && Ext.Array.indexOf(config.list, value) != -1;
}, exclusion:function(config, value) {
  return config.list && Ext.Array.indexOf(config.list, value) == -1;
}});
Ext.define('Ext.data.Model', {alternateClassName:'Ext.data.Record', mixins:{observable:Ext.util.Observable}, compareConvertFields:function(f1, f2) {
  var f1SpecialConvert = f1.convert && f1.type && f1.convert !== f1.type.convert, f2SpecialConvert = f2.convert && f2.type && f2.convert !== f2.type.convert;
  if (f1SpecialConvert && !f2SpecialConvert) {
    return 1;
  }
  if (!f1SpecialConvert && f2SpecialConvert) {
    return -1;
  }
  return 0;
}, itemNameFn:function(item) {
  return item.name;
}, onClassExtended:function(cls, data, hooks) {
  var onBeforeClassCreated = hooks.onBeforeCreated;
  hooks.onBeforeCreated = function(cls, data) {
    var me = this, name = Ext.getClassName(cls), prototype = cls.prototype, superCls = cls.prototype.superclass, validations = data.validations || [], fields = data.fields || [], field, associationsConfigs = data.associations || [], addAssociations = function(items, type) {
      var i = 0, len, item;
      if (items) {
        items = Ext.Array.from(items);
        for (len = items.length; i < len; ++i) {
          item = items[i];
          if (!Ext.isObject(item)) {
            item = {model:item};
          }
          item.type = type;
          associationsConfigs.push(item);
        }
      }
    }, idgen = data.idgen, fieldsMixedCollection = new Ext.util.MixedCollection(false, prototype.itemNameFn), associationsMixedCollection = new Ext.util.MixedCollection(false, prototype.itemNameFn), superValidations = superCls.validations, superFields = superCls.fields, superAssociations = superCls.associations, associationConfig, i, ln, dependencies = [], idProperty = 'idProperty' in data ? data.idProperty : prototype.idProperty, idField = idProperty ? idProperty.isField ? idProperty : new Ext.data.Field(idProperty) : 
    null, idFieldDefined = false, onFieldAddReplace = function(arg0, arg1, arg2) {
      var newField, pos;
      if (fieldsMixedCollection.events.add.firing) {
        pos = arg0;
        newField = arg1;
      } else {
        newField = arg2;
        pos = arg1.originalIndex;
      }
      newField.originalIndex = pos;
      if (idField && (newField.mapping && newField.mapping === idField.mapping || newField.name === idField.name)) {
        prototype.idField = newField;
        idFieldDefined = true;
        newField.defaultValue = undefined;
      }
    }, clsProxy = data.proxy, fieldConvertSortFn = function() {
      fieldsMixedCollection.sortBy(prototype.compareConvertFields);
    };
    cls.modelName = name;
    prototype.modelName = name;
    if (superValidations) {
      validations = superValidations.concat(validations);
    }
    data.validations = validations;
    if (superFields) {
      fields = superFields.items.concat(fields);
    }
    fieldsMixedCollection.on({add:onFieldAddReplace, replace:onFieldAddReplace});
    for (i = 0, ln = fields.length; i < ln; ++i) {
      field = fields[i];
      fieldsMixedCollection.add(field.isField ? field : new Ext.data.Field(field));
    }
    if (idField && !idFieldDefined) {
      prototype.idField = idField;
      idField.defaultValue = undefined;
      fieldsMixedCollection.add(idField);
    }
    fieldConvertSortFn();
    fieldsMixedCollection.on({add:fieldConvertSortFn, replace:fieldConvertSortFn});
    data.fields = fieldsMixedCollection;
    if (idgen) {
      data.idgen = Ext.data.IdGenerator.get(idgen);
    }
    addAssociations(data.belongsTo, 'belongsTo');
    delete data.belongsTo;
    addAssociations(data.hasMany, 'hasMany');
    delete data.hasMany;
    addAssociations(data.hasOne, 'hasOne');
    delete data.hasOne;
    if (superAssociations) {
      associationsConfigs = superAssociations.items.concat(associationsConfigs);
    }
    for (i = 0, ln = associationsConfigs.length; i < ln; ++i) {
      dependencies.push('association.' + associationsConfigs[i].type.toLowerCase());
    }
    if (clsProxy) {
      if (!clsProxy.isProxy) {
        dependencies.push('proxy.' + (clsProxy.type || clsProxy));
      }
    } else {
      if (!cls.prototype.proxy) {
        cls.prototype.proxy = cls.prototype.defaultProxyType;
        dependencies.push('proxy.' + cls.prototype.defaultProxyType);
      }
    }
    Ext.require(dependencies, function() {
      Ext.ModelManager.registerType(name, cls);
      for (i = 0, ln = associationsConfigs.length; i < ln; ++i) {
        associationConfig = associationsConfigs[i];
        if (associationConfig.isAssociation) {
          associationConfig = Ext.applyIf({ownerModel:name, associatedModel:associationConfig.model}, associationConfig.initialConfig);
        } else {
          Ext.apply(associationConfig, {ownerModel:name, associatedModel:associationConfig.model});
        }
        if (Ext.ModelManager.getModel(associationConfig.model) === undefined) {
          Ext.ModelManager.registerDeferredAssociation(associationConfig);
        } else {
          associationsMixedCollection.add(Ext.data.association.Association.create(associationConfig));
        }
      }
      data.associations = associationsMixedCollection;
      onBeforeClassCreated.call(me, cls, data, hooks);
      if (clsProxy && clsProxy.isProxy) {
        cls.setProxy(clsProxy);
      }
      Ext.ModelManager.onModelDefined(cls);
    });
  };
}, inheritableStatics:{setProxy:function(proxy) {
  if (!proxy.isProxy) {
    if (typeof proxy == 'string') {
      proxy = {type:proxy};
    }
    proxy = Ext.createByAlias('proxy.' + proxy.type, proxy);
  }
  proxy.setModel(this);
  this.proxy = this.prototype.proxy = proxy;
  return proxy;
}, getProxy:function() {
  var proxy = this.proxy;
  if (!proxy) {
    proxy = this.prototype.proxy;
    if (proxy.isProxy) {
      proxy = proxy.clone();
    }
    return this.setProxy(proxy);
  }
  return proxy;
}, setFields:function(fields, idProperty, clientIdProperty) {
  var me = this, newField, idField, idFieldDefined = false, proto = me.prototype, prototypeFields = proto.fields, superFields = proto.superclass.fields, len, i;
  if (idProperty) {
    proto.idProperty = idProperty;
    idField = idProperty.isField ? idProperty : new Ext.data.Field(idProperty);
  }
  if (clientIdProperty) {
    proto.clientIdProperty = clientIdProperty;
  }
  if (prototypeFields) {
    prototypeFields.clear();
  } else {
    prototypeFields = me.prototype.fields = new Ext.util.MixedCollection(false, function(field) {
      return field.name;
    });
  }
  if (superFields) {
    fields = superFields.items.concat(fields);
  }
  for (i = 0, len = fields.length; i < len; i++) {
    newField = new Ext.data.Field(fields[i]);
    if (idField && (newField.mapping && newField.mapping === idField.mapping || newField.name === idField.name)) {
      idFieldDefined = true;
      newField.defaultValue = undefined;
    }
    prototypeFields.add(newField);
  }
  if (idField && !idFieldDefined) {
    idField.defaultValue = undefined;
    prototypeFields.add(idField);
  }
  me.fields = prototypeFields;
  return prototypeFields;
}, getFields:function() {
  return this.prototype.fields.items;
}, load:function(id, config) {
  config = Ext.apply({}, config);
  config = Ext.applyIf(config, {action:'read', id:id});
  var operation = new Ext.data.Operation(config), scope = config.scope || this, callback;
  callback = function(operation) {
    var record = null, success = operation.wasSuccessful();
    if (success) {
      record = operation.getRecords()[0];
      if (!record.hasId()) {
        record.setId(id);
      }
      Ext.callback(config.success, scope, [record, operation]);
    } else {
      Ext.callback(config.failure, scope, [record, operation]);
    }
    Ext.callback(config.callback, scope, [record, operation, success]);
  };
  this.getProxy().read(operation, callback, this);
}}, statics:{PREFIX:'ext-record', AUTO_ID:1, EDIT:'edit', REJECT:'reject', COMMIT:'commit', id:function(rec) {
  var id = [this.PREFIX, '-', this.AUTO_ID++].join('');
  rec.phantom = true;
  rec.internalId = id;
  return id;
}}, idgen:{isGenerator:true, type:'default', generate:function() {
  return null;
}, getRecId:function(rec) {
  return rec.modelName + '-' + rec.internalId;
}}, editing:false, dirty:false, persistenceProperty:'data', evented:false, isModel:true, phantom:false, idProperty:'id', clientIdProperty:null, defaultProxyType:'ajax', emptyData:[], constructor:function(data, id, raw, convertedData) {
  var me = this, passedId = id || id === 0, hasId, fields, length, field, name, value, newId, persistenceProperty, idProperty = me.idProperty, idField = me.idField, i;
  me.raw = raw || data;
  me.modified = {};
  if (me.persistenceProperty !== 'data') {
    Ext.log.warn(this.$className, 'The persistenceProperty will be deprecated, all data will be stored in the underlying data property.');
  }
  persistenceProperty = me[me.persistenceProperty] = convertedData || {};
  me.data = me[me.persistenceProperty];
  me.mixins.observable.constructor.call(me);
  if (!convertedData) {
    if (data) {
      if (!passedId && idProperty) {
        id = data[idProperty];
        hasId = id || id === 0;
      }
    } else {
      data = me.emptyData;
    }
    fields = me.fields.items;
    length = fields.length;
    i = 0;
    if (Ext.isArray(data)) {
      for (; i < length; i++) {
        field = fields[i];
        name = field.name;
        value = data[field.originalIndex];
        if (value === undefined) {
          value = field.defaultValue;
        }
        if (field.convert) {
          value = field.convert(value, me);
        }
        if (value !== undefined) {
          persistenceProperty[name] = value;
        }
      }
    } else {
      for (; i < length; i++) {
        field = fields[i];
        name = field.name;
        value = data[name];
        if (value === undefined) {
          value = field.defaultValue;
        }
        if (field.convert) {
          value = field.convert(value, me);
        }
        if (value !== undefined) {
          persistenceProperty[name] = value;
        }
      }
    }
  }
  me.stores = [];
  if (passedId) {
    hasId = true;
    persistenceProperty[idProperty] = idField && idField.convert ? idField.convert(id) : id;
  } else {
    if (!hasId) {
      newId = me.idgen.generate();
      if (newId != null) {
        me.preventInternalUpdate = true;
        me.setId(newId);
        delete me.preventInternalUpdate;
      }
    }
  }
  me.internalId = hasId ? id : Ext.data.Model.id(me);
  if (typeof me.init == 'function') {
    me.init();
  }
  me.id = me.idgen.getRecId(me);
}, get:function(field) {
  return this[this.persistenceProperty][field];
}, _singleProp:{}, set:function(fieldName, newValue) {
  var me = this, data = me[me.persistenceProperty], fields = me.fields, modified = me.modified, single = typeof fieldName == 'string', currentValue, field, idChanged, key, modifiedFieldNames, name, oldId, newId, value, values;
  if (single) {
    values = me._singleProp;
    values[fieldName] = newValue;
  } else {
    values = fieldName;
  }
  for (name in values) {
    if (values.hasOwnProperty(name)) {
      value = values[name];
      if (fields && (field = fields.get(name)) && field.convert) {
        value = field.convert(value, me);
      }
      currentValue = data[name];
      if (me.isEqual(currentValue, value)) {
        continue;
      }
      data[name] = value;
      (modifiedFieldNames || (modifiedFieldNames = [])).push(name);
      if (field && field.persist) {
        if (modified.hasOwnProperty(name)) {
          if (me.isEqual(modified[name], value)) {
            delete modified[name];
            me.dirty = false;
            for (key in modified) {
              if (modified.hasOwnProperty(key)) {
                me.dirty = true;
                break;
              }
            }
          }
        } else {
          me.dirty = true;
          modified[name] = currentValue;
        }
      }
      if (name == me.idProperty) {
        idChanged = true;
        oldId = currentValue;
        newId = value;
      }
    }
  }
  if (single) {
    delete values[fieldName];
  }
  if (idChanged) {
    me.changeId(oldId, newId);
  }
  if (!me.editing && modifiedFieldNames) {
    me.afterEdit(modifiedFieldNames);
  }
  return modifiedFieldNames || null;
}, copyFrom:function(sourceRecord) {
  var me = this, fields = me.fields.items, fieldCount = fields.length, modifiedFieldNames = [], field, i = 0, myData, sourceData, idProperty = me.idProperty, name, value;
  if (sourceRecord) {
    myData = me[me.persistenceProperty];
    sourceData = sourceRecord[sourceRecord.persistenceProperty];
    for (; i < fieldCount; i++) {
      field = fields[i];
      name = field.name;
      if (name != idProperty) {
        value = sourceData[name];
        if (value !== undefined && !me.isEqual(myData[name], value)) {
          myData[name] = value;
          modifiedFieldNames.push(name);
        }
      }
    }
    if (me.phantom && !sourceRecord.phantom) {
      me.beginEdit();
      me.setId(sourceRecord.getId());
      me.endEdit(true);
      me.commit(true);
    }
  }
  return modifiedFieldNames;
}, isEqual:function(a, b) {
  if (a instanceof Date && b instanceof Date) {
    return a.getTime() === b.getTime();
  }
  return a === b;
}, beginEdit:function() {
  var me = this, key, data, o;
  if (!me.editing) {
    me.editing = true;
    me.dirtySave = me.dirty;
    o = me[me.persistenceProperty];
    data = me.dataSave = {};
    for (key in o) {
      if (o.hasOwnProperty(key)) {
        data[key] = o[key];
      }
    }
    o = me.modified;
    data = me.modifiedSave = {};
    for (key in o) {
      if (o.hasOwnProperty(key)) {
        data[key] = o[key];
      }
    }
  }
}, cancelEdit:function() {
  var me = this;
  if (me.editing) {
    me.editing = false;
    me.modified = me.modifiedSave;
    me[me.persistenceProperty] = me.dataSave;
    me.dirty = me.dirtySave;
    me.modifiedSave = me.dataSave = me.dirtySave = null;
  }
}, endEdit:function(silent, modifiedFieldNames) {
  var me = this, dataSave, changed;
  silent = silent === true;
  if (me.editing) {
    me.editing = false;
    dataSave = me.dataSave;
    me.modifiedSave = me.dataSave = me.dirtySave = null;
    if (!silent) {
      if (!modifiedFieldNames) {
        modifiedFieldNames = me.getModifiedFieldNames(dataSave);
      }
      changed = me.dirty || modifiedFieldNames.length > 0;
      if (changed) {
        me.afterEdit(modifiedFieldNames);
      }
    }
  }
}, getModifiedFieldNames:function(saved) {
  var me = this, data = me[me.persistenceProperty], modified = [], key;
  saved = saved || me.dataSave;
  for (key in data) {
    if (data.hasOwnProperty(key)) {
      if (!me.isEqual(data[key], saved[key])) {
        modified.push(key);
      }
    }
  }
  return modified;
}, getChanges:function() {
  var modified = this.modified, changes = {}, field;
  for (field in modified) {
    if (modified.hasOwnProperty(field)) {
      changes[field] = this.get(field);
    }
  }
  return changes;
}, isModified:function(fieldName) {
  return this.modified.hasOwnProperty(fieldName);
}, setDirty:function() {
  var me = this, fields = me.fields.items, fLen = fields.length, field, name, f;
  me.dirty = true;
  for (f = 0; f < fLen; f++) {
    field = fields[f];
    if (field.persist) {
      name = field.name;
      me.modified[name] = me.get(name);
    }
  }
}, markDirty:function() {
  Ext.log.warn('Ext.data.Model: markDirty has been deprecated. Use setDirty instead.');
  return this.setDirty.apply(this, arguments);
}, reject:function(silent) {
  var me = this, modified = me.modified, field;
  for (field in modified) {
    if (modified.hasOwnProperty(field)) {
      if (typeof modified[field] != 'function') {
        me[me.persistenceProperty][field] = modified[field];
      }
    }
  }
  me.dirty = false;
  me.editing = false;
  me.modified = {};
  if (silent !== true) {
    me.afterReject();
  }
}, commit:function(silent, modifiedFieldNames) {
  var me = this;
  me.phantom = me.dirty = me.editing = false;
  me.modified = {};
  if (silent !== true) {
    me.afterCommit(modifiedFieldNames);
  }
}, copy:function(newId) {
  var me = this;
  return new me.self(me.raw, newId, null, Ext.apply({}, me[me.persistenceProperty]));
}, setProxy:function(proxy) {
  if (!proxy.isProxy) {
    if (typeof proxy === 'string') {
      proxy = {type:proxy};
    }
    proxy = Ext.createByAlias('proxy.' + proxy.type, proxy);
  }
  proxy.setModel(this.self);
  this.proxy = proxy;
  return proxy;
}, getProxy:function() {
  return this.hasOwnProperty('proxy') ? this.proxy : this.self.getProxy();
}, validate:function() {
  var errors = new Ext.data.Errors, validations = this.validations, validators = Ext.data.validations, length, validation, field, valid, type, i;
  if (validations) {
    length = validations.length;
    for (i = 0; i < length; i++) {
      validation = validations[i];
      field = validation.field || validation.name;
      type = validation.type;
      valid = validators[type](validation, this.get(field));
      if (!valid) {
        errors.add({field:field, message:validation.message || validators[type + 'Message']});
      }
    }
  }
  return errors;
}, isValid:function() {
  return this.validate().isValid();
}, save:function(options) {
  options = Ext.apply({}, options);
  var me = this, action = me.phantom ? 'create' : 'update', scope = options.scope || me, stores = me.stores, i = 0, storeCount, store, operation, callback;
  Ext.apply(options, {records:[me], action:action});
  operation = new Ext.data.Operation(options);
  callback = function(operation) {
    var success = operation.wasSuccessful();
    if (success) {
      for (storeCount = stores.length; i < storeCount; i++) {
        store = stores[i];
        store.fireEvent('write', store, operation);
        store.fireEvent('datachanged', store);
      }
      Ext.callback(options.success, scope, [me, operation]);
    } else {
      Ext.callback(options.failure, scope, [me, operation]);
    }
    Ext.callback(options.callback, scope, [me, operation, success]);
  };
  me.getProxy()[action](operation, callback, me);
  return me;
}, destroy:function(options) {
  options = Ext.apply({records:[this], action:'destroy'}, options);
  var me = this, isNotPhantom = me.phantom !== true, scope = options.scope || me, stores, i = 0, storeCount, store, args, operation, callback;
  operation = new Ext.data.Operation(options);
  callback = function(operation) {
    args = [me, operation];
    stores = Ext.Array.clone(me.stores);
    if (operation.wasSuccessful()) {
      for (storeCount = stores.length; i < storeCount; i++) {
        store = stores[i];
        if (store.remove) {
          store.remove(me, true);
        }
        store.fireEvent('bulkremove', store, [me], [store.indexOf(me)], false);
        if (isNotPhantom) {
          store.fireEvent('write', store, operation);
        }
      }
      me.clearListeners();
      Ext.callback(options.success, scope, args);
    } else {
      Ext.callback(options.failure, scope, args);
    }
    Ext.callback(options.callback, scope, args);
  };
  if (isNotPhantom) {
    me.getProxy().destroy(operation, callback, me);
  } else {
    operation.complete = operation.success = true;
    operation.resultSet = me.getProxy().reader.nullResultSet;
    callback(operation);
  }
  return me;
}, getId:function() {
  return this.get(this.idField.name);
}, getObservableId:function() {
  return this.id;
}, setId:function(id) {
  this.set(this.idProperty, id);
}, changeId:function(oldId, newId) {
  var me = this, hasOldId, hasId, oldInternalId;
  if (!me.preventInternalUpdate) {
    hasOldId = me.hasId(oldId);
    hasId = me.hasId(newId);
    oldInternalId = me.internalId;
    me.phantom = !hasId;
    if (hasId !== hasOldId || hasId && hasOldId) {
      me.internalId = hasId ? newId : Ext.data.Model.id(me);
    }
    me.fireEvent('idchanged', me, oldId, newId, oldInternalId);
    me.callStore('onIdChanged', oldId, newId, oldInternalId);
  }
}, hasId:function(id) {
  if (arguments.length === 0) {
    id = this.getId();
  }
  return !!(id || id === 0);
}, join:function(store) {
  var me = this;
  if (!me.stores.length) {
    me.stores[0] = store;
  } else {
    Ext.Array.include(this.stores, store);
  }
  this.store = this.stores[0];
}, unjoin:function(store) {
  Ext.Array.remove(this.stores, store);
  this.store = this.stores[0] || null;
}, afterEdit:function(modifiedFieldNames) {
  this.callStore('afterEdit', modifiedFieldNames);
}, afterReject:function() {
  this.callStore('afterReject');
}, afterCommit:function(modifiedFieldNames) {
  this.callStore('afterCommit', modifiedFieldNames);
}, callStore:function(fn) {
  var args = Ext.Array.clone(arguments), stores = this.stores, i = 0, len = stores.length, store;
  args[0] = this;
  for (; i < len; ++i) {
    store = stores[i];
    if (store && Ext.isFunction(store[fn])) {
      store[fn].apply(store, args);
    }
  }
}, getData:function(includeAssociated) {
  var me = this, fields = me.fields.items, fLen = fields.length, data = {}, name, f;
  for (f = 0; f < fLen; f++) {
    name = fields[f].name;
    data[name] = me.get(name);
  }
  if (includeAssociated === true) {
    Ext.apply(data, me.getAssociatedData());
  }
  return data;
}, getAssociatedData:function() {
  return this.prepareAssociatedData({}, 1);
}, prepareAssociatedData:function(seenKeys, depth) {
  var me = this, associations = me.associations.items, associationCount = associations.length, associationData = {}, toRead = [], toReadKey = [], toReadIndex = [], associatedStore, associatedRecords, associatedRecord, o, index, result, seenDepth, associationId, associatedRecordCount, association, i, j, type, name;
  for (i = 0; i < associationCount; i++) {
    association = associations[i];
    associationId = association.associationId;
    seenDepth = seenKeys[associationId];
    if (seenDepth && seenDepth !== depth) {
      continue;
    }
    seenKeys[associationId] = depth;
    type = association.type;
    name = association.name;
    if (type == 'hasMany') {
      associatedStore = me[association.storeName];
      associationData[name] = [];
      if (associatedStore && associatedStore.getCount() > 0) {
        associatedRecords = associatedStore.data.items;
        associatedRecordCount = associatedRecords.length;
        for (j = 0; j < associatedRecordCount; j++) {
          associatedRecord = associatedRecords[j];
          associationData[name][j] = associatedRecord.getData();
          toRead.push(associatedRecord);
          toReadKey.push(name);
          toReadIndex.push(j);
        }
      }
    } else {
      if (type == 'belongsTo' || type == 'hasOne') {
        associatedRecord = me[association.instanceName];
        if (associatedRecord !== undefined) {
          associationData[name] = associatedRecord.getData();
          toRead.push(associatedRecord);
          toReadKey.push(name);
          toReadIndex.push(-1);
        }
      }
    }
  }
  for (i = 0, associatedRecordCount = toRead.length; i < associatedRecordCount; ++i) {
    associatedRecord = toRead[i];
    o = associationData[toReadKey[i]];
    index = toReadIndex[i];
    result = associatedRecord.prepareAssociatedData(seenKeys, depth + 1);
    if (index === -1) {
      Ext.apply(o, result);
    } else {
      Ext.apply(o[index], result);
    }
  }
  return associationData;
}});
Ext.define('Ext.data.proxy.Server', {extend:Ext.data.proxy.Proxy, alias:'proxy.server', alternateClassName:'Ext.data.ServerProxy', pageParam:'page', startParam:'start', limitParam:'limit', groupParam:'group', groupDirectionParam:'groupDir', sortParam:'sort', filterParam:'filter', directionParam:'dir', idParam:'id', simpleSortMode:false, simpleGroupMode:false, noCache:true, cacheString:'_dc', timeout:30000, constructor:function(config) {
  var me = this;
  config = config || {};
  me.callParent([config]);
  me.extraParams = config.extraParams || {};
  me.api = Ext.apply({}, config.api || me.api);
  me.nocache = me.noCache;
}, create:function() {
  return this.doRequest.apply(this, arguments);
}, read:function() {
  return this.doRequest.apply(this, arguments);
}, update:function() {
  return this.doRequest.apply(this, arguments);
}, destroy:function() {
  return this.doRequest.apply(this, arguments);
}, setExtraParam:function(name, value) {
  this.extraParams[name] = value;
}, buildRequest:function(operation) {
  var me = this, params = operation.params = Ext.apply({}, operation.params, me.extraParams), request;
  Ext.applyIf(params, me.getParams(operation));
  if (operation.id !== undefined && params[me.idParam] === undefined) {
    params[me.idParam] = operation.id;
  }
  request = new Ext.data.Request({params:params, action:operation.action, records:operation.records, operation:operation, url:operation.url, proxy:me});
  request.url = me.buildUrl(request);
  operation.request = request;
  return request;
}, processResponse:function(success, operation, request, response, callback, scope) {
  var me = this, reader, result;
  if (success === true) {
    reader = me.getReader();
    reader.applyDefaults = operation.action === 'read';
    result = reader.read(me.extractResponseData(response));
    if (result.success !== false) {
      Ext.apply(operation, {response:response, resultSet:result});
      operation.commitRecords(result.records);
      operation.setCompleted();
      operation.setSuccessful();
    } else {
      operation.setException(result.message);
      me.fireEvent('exception', this, response, operation);
    }
  } else {
    me.setException(operation, response);
    me.fireEvent('exception', this, response, operation);
  }
  if (typeof callback == 'function') {
    callback.call(scope || me, operation);
  }
  me.afterRequest(request, success);
}, setException:function(operation, response) {
  operation.setException({status:response.status, statusText:response.statusText});
}, extractResponseData:Ext.identityFn, applyEncoding:function(value) {
  return Ext.encode(value);
}, encodeSorters:function(sorters) {
  var min = [], length = sorters.length, i = 0;
  for (; i < length; i++) {
    min[i] = {property:sorters[i].property, direction:sorters[i].direction};
  }
  return this.applyEncoding(min);
}, encodeFilters:function(filters) {
  var min = [], length = filters.length, i = 0;
  for (; i < length; i++) {
    min[i] = {property:filters[i].property, value:filters[i].value};
  }
  return this.applyEncoding(min);
}, getParams:function(operation) {
  var me = this, params = {}, isDef = Ext.isDefined, groupers = operation.groupers, sorters = operation.sorters, filters = operation.filters, page = operation.page, start = operation.start, limit = operation.limit, simpleSortMode = me.simpleSortMode, simpleGroupMode = me.simpleGroupMode, pageParam = me.pageParam, startParam = me.startParam, limitParam = me.limitParam, groupParam = me.groupParam, groupDirectionParam = me.groupDirectionParam, sortParam = me.sortParam, filterParam = me.filterParam, 
  directionParam = me.directionParam, hasGroups, index;
  if (pageParam && isDef(page)) {
    params[pageParam] = page;
  }
  if (startParam && isDef(start)) {
    params[startParam] = start;
  }
  if (limitParam && isDef(limit)) {
    params[limitParam] = limit;
  }
  hasGroups = groupParam && groupers && groupers.length > 0;
  if (hasGroups) {
    if (simpleGroupMode) {
      params[groupParam] = groupers[0].property;
      params[groupDirectionParam] = groupers[0].direction || 'ASC';
    } else {
      params[groupParam] = me.encodeSorters(groupers);
    }
  }
  if (sortParam && sorters && sorters.length > 0) {
    if (simpleSortMode) {
      index = 0;
      if (sorters.length > 1 && hasGroups) {
        index = 1;
      }
      params[sortParam] = sorters[index].property;
      params[directionParam] = sorters[index].direction;
    } else {
      params[sortParam] = me.encodeSorters(sorters);
    }
  }
  if (filterParam && filters && filters.length > 0) {
    params[filterParam] = me.encodeFilters(filters);
  }
  return params;
}, buildUrl:function(request) {
  var me = this, url = me.getUrl(request);
  if (!url) {
    Ext.Error.raise('You are using a ServerProxy but have not supplied it with a url.');
  }
  if (me.noCache) {
    url = Ext.urlAppend(url, Ext.String.format('{0}\x3d{1}', me.cacheString, Ext.Date.now()));
  }
  return url;
}, getUrl:function(request) {
  return request.url || this.api[request.action] || this.url;
}, doRequest:function(operation, callback, scope) {
  Ext.Error.raise('The doRequest function has not been implemented on your Ext.data.proxy.Server subclass. See src/data/ServerProxy.js for details');
}, afterRequest:Ext.emptyFn, onDestroy:function() {
  Ext.destroy(this.reader, this.writer);
}});
Ext.define('Ext.data.proxy.Ajax', {extend:Ext.data.proxy.Server, alias:'proxy.ajax', alternateClassName:['Ext.data.HttpProxy', 'Ext.data.AjaxProxy'], actionMethods:{create:'POST', read:'GET', update:'POST', destroy:'POST'}, binary:false, doRequest:function(operation, callback, scope) {
  var writer = this.getWriter(), request = this.buildRequest(operation);
  if (operation.allowWrite()) {
    request = writer.write(request);
  }
  Ext.apply(request, {binary:this.binary, headers:this.headers, timeout:this.timeout, scope:this, callback:this.createRequestCallback(request, operation, callback, scope), method:this.getMethod(request), disableCaching:false});
  Ext.Ajax.request(request);
  return request;
}, getMethod:function(request) {
  return this.actionMethods[request.action];
}, createRequestCallback:function(request, operation, callback, scope) {
  var me = this;
  return function(options, success, response) {
    me.processResponse(success, operation, request, response, callback, scope);
  };
}}, function() {
  Ext.data.HttpProxy = this;
});
Ext.define('Ext.data.proxy.Client', {extend:Ext.data.proxy.Proxy, alternateClassName:'Ext.data.ClientProxy', isSynchronous:true, clear:function() {
  Ext.Error.raise("The Ext.data.proxy.Client subclass that you are using has not defined a 'clear' function. See src/data/ClientProxy.js for details.");
}});
Ext.define('Ext.data.proxy.Memory', {extend:Ext.data.proxy.Client, alias:'proxy.memory', alternateClassName:'Ext.data.MemoryProxy', constructor:function(config) {
  this.callParent([config]);
  this.setReader(this.reader);
}, updateOperation:function(operation, callback, scope) {
  var i = 0, recs = operation.getRecords(), len = recs.length;
  for (i; i < len; i++) {
    recs[i].commit();
  }
  operation.setCompleted();
  operation.setSuccessful();
  Ext.callback(callback, scope || this, [operation]);
}, create:function() {
  this.updateOperation.apply(this, arguments);
}, update:function() {
  this.updateOperation.apply(this, arguments);
}, destroy:function() {
  this.updateOperation.apply(this, arguments);
}, read:function(operation, callback, scope) {
  var me = this, resultSet = operation.resultSet = me.getReader().read(me.data), records = resultSet.records, sorters = operation.sorters, groupers = operation.groupers, filters = operation.filters;
  operation.setCompleted();
  if (resultSet.success) {
    if (filters && filters.length) {
      records = resultSet.records = Ext.Array.filter(records, Ext.util.Filter.createFilterFn(filters));
    }
    if (groupers && groupers.length) {
      sorters = sorters ? sorters.concat(groupers) : sorters;
    }
    if (sorters && sorters.length) {
      resultSet.records = Ext.Array.sort(records, Ext.util.Sortable.createComparator(sorters));
    }
    if (me.enablePaging && operation.start !== undefined && operation.limit !== undefined) {
      if (operation.start >= resultSet.total) {
        resultSet.success = false;
        resultSet.count = 0;
        resultSet.records = [];
      } else {
        resultSet.records = Ext.Array.slice(resultSet.records, operation.start, operation.start + operation.limit);
        resultSet.count = resultSet.records.length;
      }
    }
  }
  if (resultSet.success) {
    operation.setSuccessful();
  } else {
    me.fireEvent('exception', me, null, operation);
  }
  Ext.callback(callback, scope || me, [operation]);
}, clear:Ext.emptyFn});
Ext.define('Ext.util.LruCache', {extend:Ext.util.HashMap, constructor:function(config) {
  Ext.apply(this, config);
  this.callParent([config]);
}, add:function(key, newValue) {
  var me = this, existingKey = me.findKey(newValue), entry;
  if (existingKey) {
    me.unlinkEntry(entry = me.map[existingKey]);
    entry.prev = me.last;
    entry.next = null;
  } else {
    entry = {prev:me.last, next:null, key:key, value:newValue};
  }
  if (me.last) {
    me.last.next = entry;
  } else {
    me.first = entry;
  }
  me.last = entry;
  me.callParent([key, entry]);
  me.prune();
  return newValue;
}, insertBefore:function(key, newValue, sibling) {
  var me = this, existingKey, entry;
  if (sibling = this.map[this.findKey(sibling)]) {
    existingKey = me.findKey(newValue);
    if (existingKey) {
      me.unlinkEntry(entry = me.map[existingKey]);
    } else {
      entry = {prev:sibling.prev, next:sibling, key:key, value:newValue};
    }
    if (sibling.prev) {
      entry.prev.next = entry;
    } else {
      me.first = entry;
    }
    entry.next = sibling;
    sibling.prev = entry;
    me.prune();
    return newValue;
  } else {
    return me.add(key, newValue);
  }
}, get:function(key) {
  var entry = this.map[key];
  if (entry) {
    if (entry.next) {
      this.moveToEnd(entry);
    }
    return entry.value;
  }
}, removeAtKey:function(key) {
  this.unlinkEntry(this.map[key]);
  return this.callParent(arguments);
}, clear:function(initial) {
  this.first = this.last = null;
  return this.callParent(arguments);
}, unlinkEntry:function(entry) {
  if (entry) {
    if (entry.next) {
      entry.next.prev = entry.prev;
    } else {
      this.last = entry.prev;
    }
    if (entry.prev) {
      entry.prev.next = entry.next;
    } else {
      this.first = entry.next;
    }
    entry.prev = entry.next = null;
  }
}, moveToEnd:function(entry) {
  this.unlinkEntry(entry);
  if (entry.prev = this.last) {
    this.last.next = entry;
  } else {
    this.first = entry;
  }
  this.last = entry;
}, getArray:function(isKey) {
  var arr = [], entry = this.first;
  while (entry) {
    arr.push(isKey ? entry.key : entry.value);
    entry = entry.next;
  }
  return arr;
}, each:function(fn, scope, reverse) {
  var me = this, entry = reverse ? me.last : me.first, length = me.length;
  scope = scope || me;
  while (entry) {
    if (fn.call(scope, entry.key, entry.value, length) === false) {
      break;
    }
    entry = reverse ? entry.prev : entry.next;
  }
  return me;
}, findKey:function(value) {
  var key, map = this.map;
  for (key in map) {
    if (map.hasOwnProperty(key) && map[key].value === value) {
      return key;
    }
  }
  return undefined;
}, clone:function() {
  var newCache = new this.self(this.initialConfig), map = this.map, key;
  newCache.suspendEvents();
  for (key in map) {
    if (map.hasOwnProperty(key)) {
      newCache.add(key, map[key].value);
    }
  }
  newCache.resumeEvents();
  return newCache;
}, prune:function() {
  var me = this, purgeCount = me.maxSize ? me.length - me.maxSize : 0;
  if (purgeCount > 0) {
    for (; me.first && purgeCount; purgeCount--) {
      me.removeAtKey(me.first.key);
    }
  }
}});
Ext.define('Ext.data.PageMap', {extend:Ext.util.LruCache, clear:function(initial) {
  var me = this;
  me.pageMapGeneration = (me.pageMapGeneration || 0) + 1;
  me.callParent(arguments);
}, forEach:function(fn, scope) {
  var me = this, pageNumbers = Ext.Object.getKeys(me.map), pageCount = pageNumbers.length, i, j, pageNumber, page, pageSize;
  for (i = 0; i < pageCount; i++) {
    pageNumbers[i] = Number(pageNumbers[i]);
  }
  Ext.Array.sort(pageNumbers);
  scope = scope || me;
  for (i = 0; i < pageCount; i++) {
    pageNumber = pageNumbers[i];
    page = me.getPage(pageNumber);
    pageSize = page.length;
    for (j = 0; j < pageSize; j++) {
      if (fn.call(scope, page[j], (pageNumber - 1) * me.pageSize + j) === false) {
        return;
      }
    }
  }
}, findBy:function(fn, scope) {
  var me = this, result = null;
  scope = scope || me;
  me.forEach(function(rec, index) {
    if (fn.call(scope, rec, index)) {
      result = rec;
      return false;
    }
  });
  return result;
}, findIndexBy:function(fn, scope) {
  var me = this, result = -1;
  scope = scope || me;
  me.forEach(function(rec, index) {
    if (fn.call(scope, rec)) {
      result = index;
      return false;
    }
  });
  return result;
}, getPageFromRecordIndex:function() {
  return Ext.data.Store.prototype.getPageFromRecordIndex.apply(this, arguments);
}, addAll:function(records) {
  if (this.getCount()) {
    Ext.Error.raise('Cannot addAll to a non-empty PageMap');
  }
  this.addPage(1, records);
}, addPage:function(pageNumber, records) {
  var me = this, lastPage = pageNumber + Math.floor((records.length - 1) / me.pageSize), startIdx, page;
  for (startIdx = 0; pageNumber <= lastPage; pageNumber++, startIdx += me.pageSize) {
    page = Ext.Array.slice(records, startIdx, startIdx + me.pageSize);
    me.add(pageNumber, page);
    me.fireEvent('pageAdded', pageNumber, page);
  }
}, getCount:function() {
  var result = this.callParent();
  if (result) {
    result = (result - 1) * this.pageSize + this.last.value.length;
  }
  return result;
}, indexOf:function(record) {
  return record ? record.index : -1;
}, insert:function() {
  Ext.Error.raise('insert operation not suppported into buffered Store');
}, remove:function() {
  Ext.Error.raise('remove operation not suppported from buffered Store');
}, removeAt:function() {
  Ext.Error.raise('removeAt operation not suppported from buffered Store');
}, getPage:function(pageNumber) {
  return this.get(pageNumber);
}, hasRange:function(start, end) {
  var pageNumber = this.getPageFromRecordIndex(start), endPageNumber = this.getPageFromRecordIndex(end);
  for (; pageNumber <= endPageNumber; pageNumber++) {
    if (!this.hasPage(pageNumber)) {
      return false;
    }
  }
  return true;
}, hasPage:function(pageNumber) {
  return !!this.get(pageNumber);
}, getAt:function(index) {
  return this.getRange(index, index)[0];
}, getRange:function(start, end) {
  if (!this.hasRange(start, end)) {
    Ext.Error.raise('PageMap asked for range which it does not have');
  }
  var me = this, startPageNumber = me.getPageFromRecordIndex(start), endPageNumber = me.getPageFromRecordIndex(end), dataStart = (startPageNumber - 1) * me.pageSize, dataEnd = endPageNumber * me.pageSize - 1, pageNumber = startPageNumber, result = [], sliceBegin, sliceEnd, doSlice, i = 0, len;
  for (; pageNumber <= endPageNumber; pageNumber++) {
    if (pageNumber == startPageNumber) {
      sliceBegin = start - dataStart;
      doSlice = true;
    } else {
      sliceBegin = 0;
      doSlice = false;
    }
    if (pageNumber == endPageNumber) {
      sliceEnd = me.pageSize - (dataEnd - end);
      doSlice = true;
    }
    if (doSlice) {
      Ext.Array.push(result, Ext.Array.slice(me.getPage(pageNumber), sliceBegin, sliceEnd));
    } else {
      Ext.Array.push(result, me.getPage(pageNumber));
    }
  }
  for (len = result.length; i < len; i++) {
    result[i].index = start++;
  }
  return result;
}});
Ext.define('Ext.data.Group', {extend:Ext.util.Observable, key:undefined, dirty:true, constructor:function() {
  this.callParent(arguments);
  this.records = [];
}, contains:function(record) {
  return Ext.Array.indexOf(this.records, record) !== -1;
}, add:function(records) {
  Ext.Array.push(this.records, records);
  this.dirty = true;
}, remove:function(records) {
  if (!Ext.isArray(records)) {
    records = [records];
  }
  var len = records.length, i;
  for (i = 0; i < len; ++i) {
    Ext.Array.remove(this.records, records[i]);
  }
  this.dirty = true;
}, isDirty:function() {
  return this.dirty;
}, hasAggregate:function() {
  return !!this.aggregate;
}, setDirty:function() {
  this.dirty = true;
}, commit:function() {
  this.dirty = false;
}, isCollapsed:function() {
  return this.collapsed;
}, getAggregateRecord:function(forceNew) {
  var me = this, Model;
  if (forceNew === true || me.dirty || !me.aggregate) {
    Model = me.store.model;
    me.aggregate = new Model;
    me.aggregate.isSummary = true;
  }
  return me.aggregate;
}});
Ext.define('Ext.data.Store', {extend:Ext.data.AbstractStore, alias:'store.store', remoteSort:false, remoteFilter:false, remoteGroup:false, groupField:undefined, groupDir:'ASC', trailingBufferZone:25, leadingBufferZone:200, pageSize:undefined, currentPage:1, clearOnPageLoad:true, loading:false, sortOnFilter:true, buffered:false, purgePageCount:5, clearRemovedOnLoad:true, defaultPageSize:25, defaultViewSize:100, addRecordsOptions:{addRecords:true}, statics:{recordIdFn:function(record) {
  return record.internalId;
}, recordIndexFn:function(record) {
  return record.index;
}, grouperIdFn:function(grouper) {
  return grouper.id || grouper.property;
}, groupIdFn:function(group) {
  return group.key;
}}, constructor:function(config) {
  config = Ext.apply({}, config);
  var me = this, groupers = config.groupers || me.groupers, groupField = config.groupField || me.groupField, proxy, data;
  data = config.data || me.data;
  if (data) {
    me.inlineData = data;
    delete config.data;
  }
  if (!groupers && groupField) {
    groupers = [{property:groupField, direction:config.groupDir || me.groupDir}];
    if (config.getGroupString || me.getGroupString !== Ext.data.Store.prototype.getGroupString) {
      groupers[0].getGroupString = function(record) {
        return me.getGroupString(record);
      };
    }
  }
  delete config.groupers;
  me.groupers = new Ext.util.MixedCollection(false, Ext.data.Store.grouperIdFn);
  me.groupers.addAll(me.decodeGroupers(groupers));
  me.groups = new Ext.util.MixedCollection(false, Ext.data.Store.groupIdFn);
  me.callParent([config]);
  if (me.buffered) {
    me.data = new Ext.data.PageMap({store:me, keyFn:Ext.data.Store.recordIdFn, pageSize:me.pageSize, maxSize:me.purgePageCount, listeners:{clear:me.onPageMapClear, scope:me}});
    me.pageRequests = {};
    me.remoteSort = me.remoteGroup = me.remoteFilter = true;
    me.sortOnLoad = false;
    me.filterOnLoad = false;
  } else {
    me.data = new Ext.util.MixedCollection({getKey:Ext.data.Store.recordIdFn, maintainIndices:true});
    me.data.pageSize = me.pageSize;
  }
  if (me.remoteGroup) {
    me.remoteSort = true;
  }
  me.sorters.insert(0, me.groupers.getRange());
  proxy = me.proxy;
  data = me.inlineData;
  if (!me.buffered && !me.pageSize) {
    me.pageSize = me.defaultPageSize;
  }
  if (data) {
    if (proxy instanceof Ext.data.proxy.Memory) {
      proxy.data = data;
      me.read();
    } else {
      me.add.apply(me, [data]);
    }
    if (me.sorters.items.length && !me.remoteSort) {
      me.group(null, null, true);
    }
    delete me.inlineData;
  } else {
    if (me.autoLoad) {
      Ext.defer(me.load, 1, me, [typeof me.autoLoad === 'object' ? me.autoLoad : undefined]);
    }
  }
}, onBeforeSort:function() {
  var groupers = this.groupers;
  if (groupers.getCount() > 0) {
    this.sort(groupers.items, 'prepend', false);
  }
}, decodeGroupers:function(groupers) {
  if (!Ext.isArray(groupers)) {
    if (groupers === undefined) {
      groupers = [];
    } else {
      groupers = [groupers];
    }
  }
  var length = groupers.length, Grouper = Ext.util.Grouper, config, i, result = [];
  for (i = 0; i < length; i++) {
    config = groupers[i];
    if (!(config instanceof Grouper)) {
      if (Ext.isString(config)) {
        config = {property:config};
      }
      config = Ext.apply({root:'data', direction:'ASC'}, config);
      if (config.fn) {
        config.sorterFn = config.fn;
      }
      if (typeof config == 'function') {
        config = {sorterFn:config};
      }
      result.push(new Grouper(config));
    } else {
      result.push(config);
    }
  }
  return result;
}, group:function(groupers, direction, suppressEvent) {
  var me = this, grouper, newGroupers;
  if (groupers) {
    me.sorters.removeAll(me.groupers.items);
    if (Ext.isArray(groupers)) {
      newGroupers = groupers;
    } else {
      if (Ext.isObject(groupers)) {
        newGroupers = [groupers];
      } else {
        if (Ext.isString(groupers)) {
          grouper = me.groupers.get(groupers);
          if (!grouper) {
            grouper = {property:groupers, direction:direction || 'ASC'};
            newGroupers = [grouper];
          } else {
            if (direction === undefined) {
              grouper.toggle();
            } else {
              grouper.setDirection(direction);
            }
          }
        }
      }
    }
    if (newGroupers && newGroupers.length) {
      me.groupers.clear();
      me.groupers.addAll(me.decodeGroupers(newGroupers));
    }
    me.sorters.insert(0, me.groupers.items);
  }
  if (me.remoteGroup) {
    if (me.buffered) {
      me.data.clear();
      me.loadPage(1, {groupChange:true});
    } else {
      me.load({scope:me, callback:suppressEvent ? null : me.fireGroupChange});
    }
  } else {
    me.doSort(me.generateComparator());
    me.constructGroups();
    if (!suppressEvent) {
      me.fireGroupChange();
    }
  }
}, getGroupField:function() {
  var first = this.groupers.first(), group;
  if (first) {
    group = first.property;
  }
  return group;
}, constructGroups:function() {
  var me = this, data = this.data.items, len = data.length, groups = me.groups, groupValue, i, group, rec;
  groups.clear();
  if (me.isGrouped()) {
    for (i = 0; i < len; ++i) {
      rec = data[i];
      groupValue = me.getGroupString(rec);
      group = groups.get(groupValue);
      if (!group) {
        group = new Ext.data.Group({key:groupValue, store:me});
        groups.add(groupValue, group);
      }
      group.add(rec);
    }
  }
}, clearGrouping:function() {
  var me = this, groupers = me.groupers.items, gLen = groupers.length, g;
  for (g = 0; g < gLen; g++) {
    me.sorters.remove(groupers[g]);
  }
  me.groupers.clear();
  if (me.remoteGroup) {
    if (me.buffered) {
      me.data.clear();
      me.loadPage(1, {groupChange:true});
    } else {
      me.load({scope:me, callback:me.fireGroupChange});
    }
  } else {
    me.groups.clear();
    if (me.sorters.length) {
      me.sort();
    } else {
      me.fireEvent('datachanged', me);
      me.fireEvent('refresh', me);
    }
    me.fireGroupChange();
  }
}, isGrouped:function() {
  return this.groupers.getCount() > 0;
}, fireGroupChange:function() {
  this.fireEvent('groupchange', this, this.groupers);
}, getGroups:function(requestGroupString) {
  var records = this.data.items, length = records.length, groups = [], pointers = {}, record, groupStr, group, i;
  for (i = 0; i < length; i++) {
    record = records[i];
    groupStr = this.getGroupString(record);
    group = pointers[groupStr];
    if (group === undefined) {
      group = {name:groupStr, children:[]};
      groups.push(group);
      pointers[groupStr] = group;
    }
    group.children.push(record);
  }
  return requestGroupString ? pointers[requestGroupString] : groups;
}, getGroupsForGrouper:function(records, grouper) {
  var length = records.length, groups = [], oldValue, newValue, record, group, i;
  for (i = 0; i < length; i++) {
    record = records[i];
    newValue = grouper.getGroupString(record);
    if (newValue !== oldValue) {
      group = {name:newValue, grouper:grouper, records:[]};
      groups.push(group);
    }
    group.records.push(record);
    oldValue = newValue;
  }
  return groups;
}, getGroupsForGrouperIndex:function(records, grouperIndex) {
  var me = this, groupers = me.groupers, grouper = groupers.getAt(grouperIndex), groups = me.getGroupsForGrouper(records, grouper), length = groups.length, i;
  if (grouperIndex + 1 < groupers.length) {
    for (i = 0; i < length; i++) {
      groups[i].children = me.getGroupsForGrouperIndex(groups[i].records, grouperIndex + 1);
    }
  }
  for (i = 0; i < length; i++) {
    groups[i].depth = grouperIndex;
  }
  return groups;
}, getGroupData:function(sort) {
  var me = this;
  if (sort !== false) {
    me.sort();
  }
  return me.getGroupsForGrouperIndex(me.data.items, 0);
}, getGroupString:function(instance) {
  var group = this.groupers.first();
  if (group) {
    return group.getGroupString(instance);
  }
  return '';
}, insert:function(index, records) {
  var me = this, sync = false, i, len, record, defaults = me.modelDefaults, out;
  if (!Ext.isIterable(records)) {
    out = records = [records];
  } else {
    out = [];
  }
  len = records.length;
  if (len) {
    for (i = 0; i < len; i++) {
      record = records[i];
      if (!record.isModel) {
        record = me.createModel(record);
      }
      out[i] = record;
      if (defaults) {
        record.set(defaults);
      }
      record.join(me);
      sync = sync || record.phantom === true;
    }
    me.data.insert(index, out);
    if (me.snapshot) {
      me.snapshot.addAll(out);
    }
    if (me.requireSort) {
      me.suspendEvents();
      me.sort();
      me.resumeEvents();
    }
    if (me.isGrouped()) {
      me.updateGroupsOnAdd(out);
    }
    me.fireEvent('add', me, out, index);
    me.fireEvent('datachanged', me);
    if (me.autoSync && sync && !me.autoSyncSuspended) {
      me.sync();
    }
  }
  return out;
}, updateGroupsOnAdd:function(records) {
  var me = this, groups = me.groups, len = records.length, i, groupName, group, rec;
  for (i = 0; i < len; ++i) {
    rec = records[i];
    groupName = me.getGroupString(rec);
    group = groups.getByKey(groupName);
    if (!group) {
      group = groups.add(new Ext.data.Group({key:groupName, store:me}));
    }
    group.add(rec);
  }
}, updateGroupsOnRemove:function(records) {
  var me = this, groups = me.groups, len = records.length, i, groupName, group, rec;
  for (i = 0; i < len; ++i) {
    rec = records[i];
    groupName = me.getGroupString(rec);
    group = groups.getByKey(groupName);
    if (group) {
      group.remove(rec);
      if (group.records.length === 0) {
        groups.remove(group);
      }
    }
  }
}, updateGroupsOnUpdate:function(record, modifiedFieldNames) {
  var me = this, groupField = me.getGroupField(), groupName = me.getGroupString(record), groups = me.groups, len, i, items, group;
  if (modifiedFieldNames && Ext.Array.indexOf(modifiedFieldNames, groupField) !== -1) {
    if (me.buffered) {
      Ext.Error.raise({msg:'Cannot move records between groups in a buffered store record'});
    }
    items = groups.items;
    for (i = 0, len = items.length; i < len; ++i) {
      group = items[i];
      if (group.contains(record)) {
        group.remove(record);
        break;
      }
    }
    group = groups.getByKey(groupName);
    if (!group) {
      group = groups.add(new Ext.data.Group({key:groupName, store:me}));
    }
    group.add(record);
    me.data.remove(record);
    me.data.insert(me.data.findInsertionIndex(record, me.generateComparator()), record);
    for (i = 0, len = this.getCount(); i < len; i++) {
      me.data.items[i].index = i;
    }
  } else {
    groups.getByKey(groupName).setDirty();
  }
}, add:function(arg) {
  var me = this, records, length, isSorted;
  if (me.buffered) {
    Ext.Error.raise({msg:'add method may not be called on a buffered store'});
  }
  if (Ext.isArray(arg)) {
    records = arg;
  } else {
    records = arguments;
  }
  length = records.length;
  isSorted = !me.remoteSort && me.sorters && me.sorters.items.length;
  if (isSorted && length === 1) {
    return [me.addSorted(me.createModel(records[0]))];
  }
  if (isSorted) {
    me.requireSort = true;
  }
  records = me.insert(me.data.length, records);
  delete me.requireSort;
  return records;
}, addSorted:function(record) {
  var me = this, index = me.data.findInsertionIndex(record, me.generateComparator());
  me.insert(index, record);
  return record;
}, createModel:function(record) {
  if (!record.isModel) {
    record = Ext.ModelManager.create(record, this.model);
  }
  return record;
}, onUpdate:function(record, type, modifiedFieldNames) {
  if (this.isGrouped()) {
    this.updateGroupsOnUpdate(record, modifiedFieldNames);
  }
}, each:function(fn, scope) {
  var data = this.data.items, dLen = data.length, record, d;
  for (d = 0; d < dLen; d++) {
    record = data[d];
    if (fn.call(scope || record, record, d, dLen) === false) {
      break;
    }
  }
}, remove:function(records, isMove, silent) {
  isMove = isMove === true;
  var me = this, sync = false, snapshot = me.snapshot, data = me.data, i = 0, length, info = [], allRecords = [], indexes = [], item, isNotPhantom, index, record, removeRange, removeCount, fireRemoveEvent = !silent && me.hasListeners.remove;
  if (records.isModel) {
    records = [records];
    length = 1;
  } else {
    if (Ext.isIterable(records)) {
      length = records.length;
    } else {
      if (typeof records === 'object') {
        removeRange = true;
        i = records.start;
        length = records.end + 1;
        removeCount = length - i;
      }
    }
  }
  if (!removeRange) {
    for (i = 0; i < length; ++i) {
      record = records[i];
      if (typeof record == 'number') {
        index = record;
        record = data.getAt(index);
      } else {
        index = me.indexOf(record);
      }
      if (record && index > -1) {
        info.push({record:record, index:index});
      }
      if (snapshot) {
        snapshot.remove(record);
      }
    }
    info = Ext.Array.sort(info, function(o1, o2) {
      var index1 = o1.index, index2 = o2.index;
      return index1 === o2.index2 ? 0 : index1 < index2 ? -1 : 1;
    });
    i = 0;
    length = info.length;
  }
  for (; i < length; i++) {
    if (removeRange) {
      record = data.getAt(i);
      index = i;
    } else {
      item = info[i];
      record = item.record;
      index = item.index;
    }
    allRecords.push(record);
    indexes.push(index);
    isNotPhantom = record.phantom !== true;
    if (!isMove && isNotPhantom) {
      record.removedFrom = index;
      me.removed.push(record);
    }
    record.unjoin(me);
    index -= i;
    sync = sync || isNotPhantom;
    if (!removeRange) {
      data.removeAt(index);
      if (fireRemoveEvent) {
        me.fireEvent('remove', me, record, index, !!isMove);
      }
    }
  }
  if (removeRange) {
    data.removeRange(records.start, removeCount);
  }
  if (!silent) {
    me.fireEvent('bulkremove', me, allRecords, indexes, !!isMove);
    me.fireEvent('datachanged', me);
  }
  if (!isMove && me.autoSync && sync && !me.autoSyncSuspended) {
    me.sync();
  }
}, removeAt:function(index, count) {
  var me = this, storeCount = me.getCount();
  if (index <= storeCount) {
    if (arguments.length === 1) {
      me.remove([index]);
    } else {
      if (count) {
        me.remove({start:index, end:Math.min(index + count, storeCount) - 1});
      }
    }
  }
}, removeAll:function(silent) {
  var me = this, snapshot = me.snapshot, data = me.data;
  if (snapshot) {
    snapshot.removeAll(data.getRange());
  }
  if (me.buffered) {
    if (data) {
      if (silent) {
        me.suspendEvent('clear');
      }
      data.clear();
      if (silent) {
        me.resumeEvent('clear');
      }
    }
  } else {
    me.remove({start:0, end:me.getCount() - 1}, false, silent);
    if (silent !== true) {
      me.fireEvent('clear', me);
    }
  }
}, load:function(options) {
  var me = this;
  options = options || {};
  if (typeof options == 'function') {
    options = {callback:options};
  }
  options.groupers = options.groupers || me.groupers.items;
  options.page = options.page || me.currentPage;
  options.start = options.start !== undefined ? options.start : (options.page - 1) * me.pageSize;
  options.limit = options.limit || me.pageSize;
  options.addRecords = options.addRecords || false;
  if (me.buffered) {
    options.limit = me.viewSize || me.defaultViewSize;
    return me.loadToPrefetch(options);
  }
  return me.callParent([options]);
}, reload:function(options) {
  var me = this, startIdx, endIdx, startPage, endPage, i, waitForReload, bufferZone, records, count = me.getCount();
  if (!options) {
    options = {};
  }
  if (me.buffered) {
    delete me.totalCount;
    waitForReload = function() {
      if (me.rangeCached(startIdx, endIdx)) {
        me.loading = false;
        me.data.un('pageAdded', waitForReload);
        records = me.data.getRange(startIdx, endIdx);
        me.fireEvent('load', me, records, true);
      }
    };
    bufferZone = Math.ceil((me.leadingBufferZone + me.trailingBufferZone) / 2);
    startIdx = options.start || (count ? me.getAt(0).index : 0);
    endIdx = startIdx + (options.count || (count ? count : me.pageSize)) - 1;
    startPage = me.getPageFromRecordIndex(Math.max(startIdx - bufferZone, 0));
    endPage = me.getPageFromRecordIndex(endIdx + bufferZone);
    me.data.clear(true);
    if (me.fireEvent('beforeload', me, options) !== false) {
      me.loading = true;
      me.data.on('pageAdded', waitForReload);
      for (i = startPage; i <= endPage; i++) {
        me.prefetchPage(i, options);
      }
    }
  } else {
    return me.callParent(arguments);
  }
}, onProxyLoad:function(operation) {
  var me = this, resultSet = operation.getResultSet(), records = operation.getRecords(), successful = operation.wasSuccessful();
  if (me.isDestroyed) {
    return;
  }
  if (resultSet) {
    me.totalCount = resultSet.total;
  }
  me.loading = false;
  if (successful) {
    me.loadRecords(records, operation);
  }
  if (me.hasListeners.load) {
    me.fireEvent('load', me, records, successful);
  }
  if (me.hasListeners.read) {
    me.fireEvent('read', me, records, successful);
  }
  Ext.callback(operation.callback, operation.scope || me, [records, operation, successful]);
}, getNewRecords:function() {
  return this.data.filterBy(this.filterNew).items;
}, getUpdatedRecords:function() {
  return this.data.filterBy(this.filterUpdated).items;
}, filter:function(filters, value) {
  if (Ext.isString(filters)) {
    filters = {property:filters, value:value};
  }
  var me = this, decoded = me.decodeFilters(filters), i, doLocalSort = me.sorters.length && me.sortOnFilter && !me.remoteSort, length = decoded.length;
  for (i = 0; i < length; i++) {
    me.filters.replace(decoded[i]);
  }
  filters = me.filters.items;
  if (filters.length) {
    if (me.remoteFilter) {
      delete me.totalCount;
      if (me.buffered) {
        me.data.clear();
        me.loadPage(1);
      } else {
        me.currentPage = 1;
        me.load();
      }
    } else {
      me.snapshot = me.snapshot || me.data.clone();
      me.data = me.snapshot.filter(filters);
      me.constructGroups();
      if (doLocalSort) {
        me.sort();
      } else {
        me.fireEvent('datachanged', me);
        me.fireEvent('refresh', me);
      }
    }
    me.fireEvent('filterchange', me, filters);
  }
}, clearFilter:function(suppressEvent) {
  var me = this;
  me.filters.clear();
  if (me.remoteFilter) {
    if (suppressEvent) {
      return;
    }
    delete me.totalCount;
    if (me.buffered) {
      me.data.clear();
      me.loadPage(1);
    } else {
      me.currentPage = 1;
      me.load();
    }
  } else {
    if (me.isFiltered()) {
      me.data = me.snapshot;
      delete me.snapshot;
      me.constructGroups();
      if (suppressEvent !== true) {
        me.fireEvent('datachanged', me);
        me.fireEvent('refresh', me);
      }
    }
  }
  me.fireEvent('filterchange', me, me.filters.items);
}, removeFilter:function(toRemove, applyFilters) {
  var me = this;
  if (!me.remoteFilter && me.isFiltered()) {
    if (toRemove instanceof Ext.util.Filter) {
      me.filters.remove(toRemove);
    } else {
      me.filters.removeAtKey(toRemove);
    }
    if (applyFilters !== false) {
      if (me.filters.length) {
        me.filter();
      } else {
        me.clearFilter();
      }
    } else {
      me.fireEvent('filterchange', me, me.filters.items);
    }
  }
}, addFilter:function(filters, applyFilters) {
  var me = this, decoded, i, length;
  decoded = me.decodeFilters(filters);
  length = decoded.length;
  for (i = 0; i < length; i++) {
    me.filters.replace(decoded[i]);
  }
  if (applyFilters !== false && me.filters.length) {
    me.filter();
  } else {
    me.fireEvent('filterchange', me, me.filters.items);
  }
}, isFiltered:function() {
  var snapshot = this.snapshot;
  return !!(snapshot && snapshot !== this.data);
}, filterBy:function(fn, scope) {
  var me = this;
  me.snapshot = me.snapshot || me.data.clone();
  me.data = me.queryBy(fn, scope || me);
  me.fireEvent('datachanged', me);
  me.fireEvent('refresh', me);
}, queryBy:function(fn, scope) {
  var me = this;
  return (me.snapshot || me.data).filterBy(fn, scope || me);
}, query:function(property, value, anyMatch, caseSensitive, exactMatch) {
  var me = this, queryFn = me.createFilterFn(property, value, anyMatch, caseSensitive, exactMatch), results = me.queryBy(queryFn);
  if (!results) {
    results = new Ext.util.MixedCollection;
  }
  return results;
}, loadData:function(data, append) {
  var length = data.length, newData = [], i;
  for (i = 0; i < length; i++) {
    newData.push(this.createModel(data[i]));
  }
  this.loadRecords(newData, append ? this.addRecordsOptions : undefined);
}, loadRawData:function(data, append) {
  var me = this, result = me.proxy.reader.read(data), records = result.records;
  if (result.success) {
    me.totalCount = result.total;
    me.loadRecords(records, append ? me.addRecordsOptions : undefined);
  }
}, loadRecords:function(records, options) {
  var me = this, i = 0, length = records.length, start, addRecords, snapshot = me.snapshot;
  if (options) {
    start = options.start;
    addRecords = options.addRecords;
  }
  if (!addRecords) {
    delete me.snapshot;
    me.clearData(true);
  } else {
    if (snapshot) {
      snapshot.addAll(records);
    }
  }
  me.data.addAll(records);
  if (start !== undefined) {
    for (; i < length; i++) {
      records[i].index = start + i;
      records[i].join(me);
    }
  } else {
    for (; i < length; i++) {
      records[i].join(me);
    }
  }
  me.suspendEvents();
  if (me.filterOnLoad && !me.remoteFilter) {
    me.filter();
  }
  if (me.sortOnLoad && !me.remoteSort) {
    me.sort(undefined, undefined, undefined, true);
  }
  me.resumeEvents();
  if (me.isGrouped()) {
    me.constructGroups();
  }
  me.fireEvent('datachanged', me);
  me.fireEvent('refresh', me);
}, loadPage:function(page, options) {
  var me = this;
  me.currentPage = page;
  options = Ext.apply({page:page, start:(page - 1) * me.pageSize, limit:me.pageSize, addRecords:!me.clearOnPageLoad}, options);
  if (me.buffered) {
    options.limit = me.viewSize || me.defaultViewSize;
    return me.loadToPrefetch(options);
  }
  me.read(options);
}, nextPage:function(options) {
  this.loadPage(this.currentPage + 1, options);
}, previousPage:function(options) {
  this.loadPage(this.currentPage - 1, options);
}, clearData:function(isLoad) {
  var me = this, records, i;
  if (!me.buffered && me.data) {
    records = me.data.items;
    i = records.length;
    while (i--) {
      records[i].unjoin(me);
    }
  }
  if (me.data) {
    me.data.clear();
  }
  if (isLoad !== true || me.clearRemovedOnLoad) {
    me.removed.length = 0;
  }
}, loadToPrefetch:function(options) {
  var me = this, i, records, dataSetSize, prefetchOptions = options, startIdx = options.start, endIdx = options.start + options.limit - 1, loadEndIdx = Math.min(endIdx, options.start + (me.viewSize || options.limit) - 1), startPage = me.getPageFromRecordIndex(Math.max(startIdx - me.trailingBufferZone, 0)), endPage = me.getPageFromRecordIndex(endIdx + me.leadingBufferZone), waitForRequestedRange = function() {
    if (me.rangeCached(startIdx, loadEndIdx)) {
      me.loading = false;
      records = me.data.getRange(startIdx, loadEndIdx);
      me.data.un('pageAdded', waitForRequestedRange);
      if (me.hasListeners.guaranteedrange) {
        me.guaranteeRange(startIdx, loadEndIdx, options.callback, options.scope);
      }
      if (options.callback) {
        options.callback.call(options.scope || me, records, startIdx, endIdx, options);
      }
      me.fireEvent('datachanged', me);
      me.fireEvent('refresh', me);
      me.fireEvent('load', me, records, true);
      if (options.groupChange) {
        me.fireGroupChange();
      }
    }
  };
  if (me.fireEvent('beforeload', me, options) !== false) {
    delete me.totalCount;
    me.loading = true;
    if (options.callback) {
      prefetchOptions = Ext.apply({}, options);
      delete prefetchOptions.callback;
    }
    me.on('prefetch', function(store, records, successful, operation) {
      if (successful) {
        if (dataSetSize = me.getTotalCount()) {
          me.data.on('pageAdded', waitForRequestedRange);
          loadEndIdx = Math.min(loadEndIdx, dataSetSize - 1);
          endPage = me.getPageFromRecordIndex(Math.min(loadEndIdx + me.leadingBufferZone, dataSetSize - 1));
          for (i = startPage + 1; i <= endPage; ++i) {
            me.prefetchPage(i, prefetchOptions);
          }
        } else {
          me.fireEvent('datachanged', me);
          me.fireEvent('refresh', me);
          me.fireEvent('load', me, records, true);
        }
      } else {
        me.fireEvent('load', me, records, false);
      }
    }, null, {single:true});
    me.prefetchPage(startPage, prefetchOptions);
  }
}, prefetch:function(options) {
  var me = this, pageSize = me.pageSize, proxy, operation;
  if (pageSize) {
    if (me.lastPageSize && pageSize != me.lastPageSize) {
      Ext.Error.raise('pageSize cannot be dynamically altered');
    }
    if (!me.data.pageSize) {
      me.data.pageSize = pageSize;
    }
  } else {
    me.pageSize = me.data.pageSize = pageSize = options.limit;
  }
  me.lastPageSize = pageSize;
  if (!options.page) {
    options.page = me.getPageFromRecordIndex(options.start);
    options.start = (options.page - 1) * pageSize;
    options.limit = Math.ceil(options.limit / pageSize) * pageSize;
  }
  if (!me.pageRequests[options.page]) {
    options = Ext.apply({action:'read', filters:me.filters.items, sorters:me.sorters.items, groupers:me.groupers.items, pageMapGeneration:me.data.pageMapGeneration}, options);
    operation = new Ext.data.Operation(options);
    if (me.fireEvent('beforeprefetch', me, operation) !== false) {
      proxy = me.proxy;
      me.pageRequests[options.page] = proxy.read(operation, me.onProxyPrefetch, me);
      if (proxy.isSynchronous) {
        delete me.pageRequests[options.page];
      }
    }
  }
  return me;
}, onPageMapClear:function() {
  var me = this, loadingFlag = me.wasLoading, reqs = me.pageRequests, req, page;
  if (me.data.events.pageadded) {
    me.data.events.pageadded.clearListeners();
  }
  me.loading = true;
  me.totalCount = 0;
  for (page in reqs) {
    if (reqs.hasOwnProperty(page)) {
      req = reqs[page];
      delete reqs[page];
      delete req.callback;
    }
  }
  me.fireEvent('clear', me);
  me.loading = loadingFlag;
}, prefetchPage:function(page, options) {
  var me = this, pageSize = me.pageSize || me.defaultPageSize, start = (page - 1) * me.pageSize, total = me.totalCount;
  if (total !== undefined && me.getCount() === total) {
    return;
  }
  me.prefetch(Ext.applyIf({page:page, start:start, limit:pageSize}, options));
}, onProxyPrefetch:function(operation) {
  var me = this, resultSet = operation.getResultSet(), records = operation.getRecords(), successful = operation.wasSuccessful(), page = operation.page;
  if (operation.pageMapGeneration === me.data.pageMapGeneration) {
    if (resultSet) {
      me.totalCount = resultSet.total;
      me.fireEvent('totalcountchange', me.totalCount);
    }
    if (page !== undefined) {
      delete me.pageRequests[page];
    }
    me.loading = false;
    me.fireEvent('prefetch', me, records, successful, operation);
    if (successful) {
      me.cachePage(records, operation.page);
    }
    Ext.callback(operation.callback, operation.scope || me, [records, operation, successful]);
  }
}, cachePage:function(records, page) {
  var me = this, len = records.length, i;
  if (!Ext.isDefined(me.totalCount)) {
    me.totalCount = records.length;
    me.fireEvent('totalcountchange', me.totalCount);
  }
  for (i = 0; i < len; i++) {
    records[i].join(me);
  }
  me.data.addPage(page, records);
}, rangeCached:function(start, end) {
  return this.data && this.data.hasRange(start, end);
}, pageCached:function(page) {
  return this.data && this.data.hasPage(page);
}, pagePending:function(page) {
  return !!this.pageRequests[page];
}, rangeSatisfied:function(start, end) {
  return this.rangeCached(start, end);
}, getPageFromRecordIndex:function(index) {
  return Math.floor(index / this.pageSize) + 1;
}, onGuaranteedRange:function(options) {
  var me = this, totalCount = me.getTotalCount(), start = options.prefetchStart, end = options.prefetchEnd > totalCount - 1 ? totalCount - 1 : options.prefetchEnd, range;
  end = Math.max(0, end);
  if (start > end) {
    Ext.log({level:'warn', msg:'Start (' + start + ') was greater than end (' + end + ') for the range of records requested (' + start + '-' + options.prefetchEnd + ')' + (this.storeId ? ' from store "' + this.storeId + '"' : '')});
  }
  range = me.data.getRange(start, end);
  if (options.fireEvent !== false) {
    me.fireEvent('guaranteedrange', range, start, end, options);
  }
  if (options.callback) {
    options.callback.call(options.scope || me, range, start, end, options);
  }
}, guaranteeRange:function(start, end, callback, scope, options) {
  options = Ext.apply({callback:callback, scope:scope}, options);
  this.getRange(start, end, options);
}, prefetchRange:function(start, end) {
  var me = this, startPage, endPage, page;
  if (!me.rangeCached(start, end)) {
    startPage = me.getPageFromRecordIndex(start);
    endPage = me.getPageFromRecordIndex(end);
    me.data.maxSize = me.purgePageCount ? endPage - startPage + 1 + me.purgePageCount : 0;
    for (page = startPage; page <= endPage; page++) {
      if (!me.pageCached(page)) {
        me.prefetchPage(page);
      }
    }
  }
}, primeCache:function(start, end, direction) {
  var me = this;
  if (direction === -1) {
    start = Math.max(start - me.leadingBufferZone, 0);
    end = Math.min(end + me.trailingBufferZone, me.totalCount - 1);
  } else {
    if (direction === 1) {
      start = Math.max(Math.min(start - me.trailingBufferZone, me.totalCount - me.pageSize), 0);
      end = Math.min(end + me.leadingBufferZone, me.totalCount - 1);
    } else {
      start = Math.min(Math.max(Math.floor(start - (me.leadingBufferZone + me.trailingBufferZone) / 2), 0), me.totalCount - me.pageSize);
      end = Math.min(Math.max(Math.ceil(end + (me.leadingBufferZone + me.trailingBufferZone) / 2), 0), me.totalCount - 1);
    }
  }
  me.prefetchRange(start, end);
}, sort:function() {
  var me = this;
  if (me.buffered && me.remoteSort) {
    me.data.clear();
  }
  return me.callParent(arguments);
}, doSort:function(sorterFn) {
  var me = this, range, ln, i;
  if (me.remoteSort) {
    if (me.buffered) {
      me.data.clear();
      me.loadPage(1);
    } else {
      me.load();
    }
  } else {
    if (me.buffered) {
      Ext.Error.raise({msg:'Local sorting may not be used on a buffered store'});
    }
    me.data.sortBy(sorterFn);
    if (!me.buffered) {
      range = me.getRange();
      ln = range.length;
      for (i = 0; i < ln; i++) {
        range[i].index = i;
      }
    }
    me.fireEvent('datachanged', me);
    me.fireEvent('refresh', me);
  }
}, find:function(property, value, start, anyMatch, caseSensitive, exactMatch) {
  var fn = this.createFilterFn(property, value, anyMatch, caseSensitive, exactMatch);
  return fn ? this.data.findIndexBy(fn, null, start) : -1;
}, findRecord:function() {
  var me = this, index = me.find.apply(me, arguments);
  return index !== -1 ? me.getAt(index) : null;
}, createFilterFn:function(property, value, anyMatch, caseSensitive, exactMatch) {
  if (Ext.isEmpty(value)) {
    return false;
  }
  value = this.data.createValueMatcher(value, anyMatch, caseSensitive, exactMatch);
  return function(r) {
    return value.test(r.data[property]);
  };
}, findExact:function(property, value, start) {
  return this.data.findIndexBy(function(rec) {
    return rec.isEqual(rec.get(property), value);
  }, this, start);
}, findBy:function(fn, scope, start) {
  return this.data.findIndexBy(fn, scope, start);
}, collect:function(dataIndex, allowNull, bypassFilter) {
  var me = this, data = bypassFilter === true && me.snapshot ? me.snapshot : me.data;
  return data.collect(dataIndex, 'data', allowNull);
}, getCount:function() {
  return this.data.getCount();
}, getTotalCount:function() {
  return this.totalCount || 0;
}, getAt:function(index) {
  return this.data.getAt(index);
}, getRange:function(start, end, options) {
  if (options && options.cb) {
    options.callback = options.cb;
    Ext.Error.raise({msg:'guaranteeRange options.cb is deprecated, use options.callback'});
  }
  var me = this, requiredStart, requiredEnd, maxIndex = me.totalCount - 1, lastRequestStart = me.lastRequestStart, pageAddHandler, result;
  options = Ext.apply({prefetchStart:start, prefetchEnd:end}, options);
  if (me.buffered) {
    end = end >= me.totalCount ? maxIndex : end;
    requiredStart = start === 0 ? 0 : start - 1;
    requiredEnd = end === maxIndex ? end : end + 1;
    me.lastRequestStart = start;
    if (me.rangeCached(requiredStart, requiredEnd)) {
      me.onGuaranteedRange(options);
      result = me.data.getRange(start, end);
    } else {
      me.fireEvent('cachemiss', me, start, end);
      pageAddHandler = function(page, records) {
        if (me.rangeCached(requiredStart, requiredEnd)) {
          me.fireEvent('cachefilled', me, start, end);
          me.data.un('pageAdded', pageAddHandler);
          me.onGuaranteedRange(options);
        }
      };
      me.data.on('pageAdded', pageAddHandler);
      me.prefetchRange(start, end);
    }
    me.primeCache(start, end, start < lastRequestStart ? -1 : 1);
  } else {
    result = me.data.getRange(start, end);
    if (options.callback) {
      options.callback.call(options.scope || me, result, start, end, options);
    }
  }
  return result;
}, getById:function(id) {
  var result = (this.snapshot || this.data).findBy(function(record) {
    return record.getId() === id;
  });
  if (this.buffered && !result) {
    Ext.Error.raise('getById called for ID that is not present in local cache');
  }
  return result;
}, indexOf:function(record) {
  return this.data.indexOf(record);
}, indexOfTotal:function(record) {
  var index = record.index;
  if (index || index === 0) {
    return index;
  }
  return this.indexOf(record);
}, indexOfId:function(id) {
  return this.indexOf(this.getById(id));
}, first:function(grouped) {
  var me = this;
  if (grouped && me.isGrouped()) {
    return me.aggregate(function(records) {
      return records.length ? records[0] : undefined;
    }, me, true);
  } else {
    return me.data.first();
  }
}, last:function(grouped) {
  var me = this;
  if (grouped && me.isGrouped()) {
    return me.aggregate(function(records) {
      var len = records.length;
      return len ? records[len - 1] : undefined;
    }, me, true);
  } else {
    return me.data.last();
  }
}, sum:function(field, grouped) {
  var me = this;
  if (grouped && me.isGrouped()) {
    return me.aggregate(me.getSum, me, true, [field]);
  } else {
    return me.getSum(me.data.items, field);
  }
}, getSum:function(records, field) {
  var total = 0, i = 0, len = records.length;
  for (; i < len; ++i) {
    total += records[i].get(field);
  }
  return total;
}, count:function(grouped) {
  var me = this;
  if (grouped && me.isGrouped()) {
    return me.aggregate(function(records) {
      return records.length;
    }, me, true);
  } else {
    return me.getCount();
  }
}, min:function(field, grouped) {
  var me = this;
  if (grouped && me.isGrouped()) {
    return me.aggregate(me.getMin, me, true, [field]);
  } else {
    return me.getMin(me.data.items, field);
  }
}, getMin:function(records, field) {
  var i = 1, len = records.length, value, min;
  if (len > 0) {
    min = records[0].get(field);
  }
  for (; i < len; ++i) {
    value = records[i].get(field);
    if (value < min) {
      min = value;
    }
  }
  return min;
}, max:function(field, grouped) {
  var me = this;
  if (grouped && me.isGrouped()) {
    return me.aggregate(me.getMax, me, true, [field]);
  } else {
    return me.getMax(me.data.items, field);
  }
}, getMax:function(records, field) {
  var i = 1, len = records.length, value, max;
  if (len > 0) {
    max = records[0].get(field);
  }
  for (; i < len; ++i) {
    value = records[i].get(field);
    if (value > max) {
      max = value;
    }
  }
  return max;
}, average:function(field, grouped) {
  var me = this;
  if (grouped && me.isGrouped()) {
    return me.aggregate(me.getAverage, me, true, [field]);
  } else {
    return me.getAverage(me.data.items, field);
  }
}, getAverage:function(records, field) {
  var i = 0, len = records.length, sum = 0;
  if (records.length > 0) {
    for (; i < len; ++i) {
      sum += records[i].get(field);
    }
    return sum / len;
  }
  return 0;
}, aggregate:function(fn, scope, grouped, args) {
  args = args || [];
  if (grouped && this.isGrouped()) {
    var groups = this.getGroups(), len = groups.length, out = {}, group, i;
    for (i = 0; i < len; ++i) {
      group = groups[i];
      out[group.name] = this.getAggregate(fn, scope || this, group.children, args);
    }
    return out;
  } else {
    return this.getAggregate(fn, scope, this.data.items, args);
  }
}, getAggregate:function(fn, scope, records, args) {
  args = args || [];
  return fn.apply(scope || this, [records].concat(args));
}, onIdChanged:function(rec, oldId, newId, oldInternalId) {
  var snapshot = this.snapshot;
  if (snapshot) {
    snapshot.updateKey(oldInternalId, newId);
  }
  this.data.updateKey(oldInternalId, newId);
  this.callParent(arguments);
}, commitChanges:function() {
  var me = this, recs = me.getModifiedRecords(), len = recs.length, i = 0;
  for (; i < len; i++) {
    recs[i].commit();
  }
  me.removed.length = 0;
}, filterNewOnly:function(item) {
  return item.phantom === true;
}, getRejectRecords:function() {
  return Ext.Array.push(this.data.filterBy(this.filterNewOnly).items, this.getUpdatedRecords());
}, rejectChanges:function() {
  var me = this, recs = me.getRejectRecords(), len = recs.length, i = 0, rec;
  for (; i < len; i++) {
    rec = recs[i];
    rec.reject();
    if (rec.phantom) {
      me.remove(rec);
    }
  }
  recs = me.removed;
  len = recs.length;
  for (i = 0; i < len; i++) {
    rec = recs[i];
    me.insert(rec.removedFrom || 0, rec);
    rec.reject();
  }
  me.removed.length = 0;
}}, function() {
  Ext.regStore('ext-empty-store', {fields:[], proxy:'memory'});
});
Ext.define('Ext.data.reader.Array', {extend:Ext.data.reader.Json, alternateClassName:'Ext.data.ArrayReader', alias:'reader.array', totalProperty:undefined, successProperty:undefined, createFieldAccessExpression:function(field, fieldVarName, dataName) {
  var index = field.mapping == null ? field.originalIndex : field.mapping, result;
  if (typeof index === 'function') {
    result = fieldVarName + '.mapping(' + dataName + ', this)';
  } else {
    if (isNaN(index)) {
      index = '"' + index + '"';
    }
    result = dataName + '[' + index + ']';
  }
  return result;
}});
Ext.define('Ext.data.ArrayStore', {extend:Ext.data.Store, alias:'store.array', constructor:function(config) {
  config = Ext.apply({proxy:{type:'memory', reader:'array'}}, config);
  this.callParent([config]);
}, loadData:function(data, append) {
  if (this.expandData === true) {
    var r = [], i = 0, ln = data.length;
    for (; i < ln; i++) {
      r[r.length] = [data[i]];
    }
    data = r;
  }
  this.callParent([data, append]);
}}, function() {
  Ext.data.SimpleStore = Ext.data.ArrayStore;
});
Ext.define('Ext.data.Batch', {mixins:{observable:Ext.util.Observable}, autoStart:false, pauseOnException:false, current:-1, total:0, isRunning:false, isComplete:false, hasException:false, constructor:function(config) {
  var me = this;
  me.mixins.observable.constructor.call(me, config);
  me.operations = [];
  me.exceptions = [];
}, add:function(operation) {
  this.total++;
  operation.setBatch(this);
  this.operations.push(operation);
  return this;
}, start:function(index) {
  var me = this;
  if (me.isRunning) {
    return me;
  }
  me.exceptions.length = 0;
  me.hasException = false;
  me.isRunning = true;
  return me.runOperation(Ext.isDefined(index) ? index : me.current + 1);
}, retry:function() {
  return this.start(this.current);
}, runNextOperation:function() {
  return this.runOperation(this.current + 1);
}, pause:function() {
  this.isRunning = false;
  return this;
}, runOperation:function(index) {
  var me = this, operations = me.operations, operation = operations[index], onProxyReturn;
  if (operation === undefined) {
    me.isRunning = false;
    me.isComplete = true;
    me.fireEvent('complete', me, operations[operations.length - 1]);
  } else {
    me.current = index;
    onProxyReturn = function(operation) {
      var hasException = operation.hasException();
      if (hasException) {
        me.hasException = true;
        me.exceptions.push(operation);
        me.fireEvent('exception', me, operation);
      }
      if (hasException && me.pauseOnException) {
        me.pause();
      } else {
        operation.setCompleted();
        me.fireEvent('operationcomplete', me, operation);
        me.runNextOperation();
      }
    };
    operation.setStarted();
    me.proxy[operation.action](operation, onProxyReturn, me);
  }
  return me;
}});
Ext.define('Ext.data.NodeInterface', {statics:{decorate:function(modelClass) {
  var idName, idField, idType;
  if (typeof modelClass == 'string') {
    modelClass = Ext.ModelManager.getModel(modelClass);
  } else {
    if (modelClass.isModel) {
      modelClass = Ext.ModelManager.getModel(modelClass.modelName);
    }
  }
  if (modelClass.prototype.isNode) {
    return;
  }
  idName = modelClass.prototype.idProperty;
  idField = modelClass.prototype.fields.get(idName);
  idType = modelClass.prototype.fields.get(idName).type.type;
  modelClass.override(this.getPrototypeBody());
  this.applyFields(modelClass, [{name:'parentId', type:idType, defaultValue:null, useNull:idField.useNull}, {name:'index', type:'int', defaultValue:0, persist:false, convert:null}, {name:'depth', type:'int', defaultValue:0, persist:false, convert:null}, {name:'expanded', type:'bool', defaultValue:false, persist:false, convert:null}, {name:'expandable', type:'bool', defaultValue:true, persist:false, convert:null}, {name:'checked', type:'auto', defaultValue:null, persist:false, convert:null}, {name:'leaf', 
  type:'bool', defaultValue:false}, {name:'cls', type:'string', defaultValue:'', persist:false, convert:null}, {name:'iconCls', type:'string', defaultValue:'', persist:false, convert:null}, {name:'icon', type:'string', defaultValue:'', persist:false, convert:null}, {name:'root', type:'boolean', defaultValue:false, persist:false, convert:null}, {name:'isLast', type:'boolean', defaultValue:false, persist:false, convert:null}, {name:'isFirst', type:'boolean', defaultValue:false, persist:false, convert:null}, 
  {name:'allowDrop', type:'boolean', defaultValue:true, persist:false, convert:null}, {name:'allowDrag', type:'boolean', defaultValue:true, persist:false, convert:null}, {name:'loaded', type:'boolean', defaultValue:false, persist:false, convert:null}, {name:'loading', type:'boolean', defaultValue:false, persist:false, convert:null}, {name:'href', type:'string', defaultValue:'', persist:false, convert:null}, {name:'hrefTarget', type:'string', defaultValue:'', persist:false, convert:null}, {name:'qtip', 
  type:'string', defaultValue:'', persist:false, convert:null}, {name:'qtitle', type:'string', defaultValue:'', persist:false, convert:null}, {name:'qshowDelay', type:'int', defaultValue:0, persist:false, convert:null}, {name:'children', type:'auto', defaultValue:null, persist:false, convert:null}]);
}, applyFields:function(modelClass, addFields) {
  var modelPrototype = modelClass.prototype, fields = modelPrototype.fields, keys = fields.keys, ln = addFields.length, addField, i;
  for (i = 0; i < ln; i++) {
    addField = addFields[i];
    if (!Ext.Array.contains(keys, addField.name)) {
      fields.add(new Ext.data.Field(addField));
    }
  }
}, getPrototypeBody:function() {
  var bubbledEvents = {idchanged:true, append:true, remove:true, move:true, insert:true, beforeappend:true, beforeremove:true, beforemove:true, beforeinsert:true, expand:true, collapse:true, beforeexpand:true, beforecollapse:true, sort:true, rootchange:true};
  return {isNode:true, constructor:function() {
    var me = this;
    me.callParent(arguments);
    me.firstChild = me.lastChild = me.parentNode = me.previousSibling = me.nextSibling = null;
    me.childNodes = [];
    return me;
  }, createNode:function(node) {
    if (!node.isModel) {
      node = Ext.ModelManager.create(node, this.modelName);
    }
    if (!node.childNodes) {
      node.firstChild = node.lastChild = node.parentNode = node.previousSibling = node.nextSibling = null;
      node.childNodes = [];
    }
    return node;
  }, isLeaf:function() {
    return this.get('leaf') === true;
  }, setFirstChild:function(node) {
    this.firstChild = node;
  }, setLastChild:function(node) {
    this.lastChild = node;
  }, updateInfo:function(commit, info) {
    var me = this, oldDepth = me.data.depth, childInfo = {}, children = me.childNodes, childCount = children.length, i, phantom = me.phantom, dataObject = me[me.persistenceProperty], propName, newValue, field;
    if (!info) {
      Ext.Error.raise('NodeInterface expects update info to be passed');
    }
    for (propName in info) {
      field = me.fields.get(propName);
      newValue = info[propName];
      if (field && field.persist) {
        me.dirty = me.dirty || !me.isEqual(dataObject[propName], newValue);
      }
      dataObject[propName] = newValue;
    }
    if (commit) {
      me.commit();
      me.phantom = phantom;
    }
    if (me.data.depth !== oldDepth) {
      childInfo = {depth:me.data.depth + 1};
      for (i = 0; i < childCount; i++) {
        children[i].updateInfo(commit, childInfo);
      }
    }
  }, isLast:function() {
    return this.get('isLast');
  }, isFirst:function() {
    return this.get('isFirst');
  }, hasChildNodes:function() {
    return !this.isLeaf() && this.childNodes.length > 0;
  }, isExpandable:function() {
    var me = this;
    if (me.get('expandable')) {
      return !(me.isLeaf() || me.isLoaded() && !me.hasChildNodes());
    }
    return false;
  }, triggerUIUpdate:function() {
    this.afterEdit([]);
  }, appendChild:function(node, suppressEvents, commit) {
    var me = this, i, ln, index, oldParent, previousSibling, childInfo = {isLast:true, parentId:me.getId(), depth:(me.data.depth || 0) + 1};
    if (Ext.isArray(node)) {
      me.callStore('suspendAutoSync');
      for (i = 0, ln = node.length - 1; i < ln; i++) {
        me.appendChild(node[i], suppressEvents, commit);
      }
      me.callStore('resumeAutoSync');
      me.appendChild(node[ln], suppressEvents, commit);
    } else {
      node = me.createNode(node);
      if (suppressEvents !== true && me.fireEventArgs('beforeappend', [me, node]) === false) {
        return false;
      }
      index = me.childNodes.length;
      oldParent = node.parentNode;
      if (oldParent) {
        if (suppressEvents !== true && node.fireEventArgs('beforemove', [node, oldParent, me, index]) === false) {
          return false;
        }
        oldParent.removeChild(node, false, false, true);
      }
      Ext.suspendLayouts();
      index = me.childNodes.length;
      if (index === 0) {
        me.setFirstChild(node);
      }
      me.childNodes[index] = node;
      node.parentNode = me;
      node.nextSibling = null;
      me.setLastChild(node);
      previousSibling = me.childNodes[index - 1];
      if (previousSibling) {
        node.previousSibling = previousSibling;
        previousSibling.nextSibling = node;
        previousSibling.updateInfo(commit, {isLast:false});
        previousSibling.triggerUIUpdate();
      } else {
        node.previousSibling = null;
      }
      childInfo.isFirst = index === 0;
      childInfo.index = index;
      node.updateInfo(commit, childInfo);
      if (!me.isLoaded()) {
        me.set('loaded', true);
      } else {
        if (me.childNodes.length === 1) {
          me.triggerUIUpdate();
        }
      }
      if (index && me.childNodes[index - 1].isExpanded()) {
        me.childNodes[index - 1].cascadeBy(me.triggerUIUpdate);
      }
      if (!node.isLeaf() && node.phantom) {
        node.set('loaded', true);
      }
      Ext.resumeLayouts(true);
      if (suppressEvents !== true) {
        me.fireEventArgs('append', [me, node, index]);
        if (oldParent) {
          node.fireEventArgs('move', [node, oldParent, me, index]);
        }
      }
      return node;
    }
  }, getOwnerTree:function() {
    var node = this, store;
    while (node.parentNode) {
      node = node.parentNode;
    }
    store = node.store;
    if (store) {
      if (store.treeStore) {
        store = store.treeStore;
      }
      if (store.tree) {
        return store.ownerTree;
      }
    }
    return undefined;
  }, removeChild:function(node, destroy, suppressEvents, isMove) {
    var me = this, index = me.indexOf(node), i, childCount, previousSibling;
    if (index === -1 || suppressEvents !== true && me.fireEventArgs('beforeremove', [me, node, !!isMove]) === false) {
      return false;
    }
    Ext.suspendLayouts();
    Ext.Array.erase(me.childNodes, index, 1);
    if (me.firstChild === node) {
      me.setFirstChild(node.nextSibling);
    }
    if (me.lastChild === node) {
      me.setLastChild(node.previousSibling);
    }
    if (previousSibling = node.previousSibling) {
      node.previousSibling.nextSibling = node.nextSibling;
    }
    if (node.nextSibling) {
      node.nextSibling.previousSibling = node.previousSibling;
      if (index === 0) {
        node.nextSibling.updateInfo(false, {isFirst:true});
      }
      for (i = index, childCount = me.childNodes.length; i < childCount; i++) {
        me.childNodes[i].updateInfo(false, {index:i});
      }
    } else {
      if (previousSibling) {
        previousSibling.updateInfo(false, {isLast:true});
        if (previousSibling.isExpanded()) {
          previousSibling.cascadeBy(me.triggerUIUpdate);
        } else {
          previousSibling.triggerUIUpdate();
        }
      }
    }
    if (!me.childNodes.length) {
      me.triggerUIUpdate();
    }
    Ext.resumeLayouts(true);
    if (suppressEvents !== true) {
      node.removeContext = {parentNode:node.parentNode, previousSibling:node.previousSibling, nextSibling:node.nextSibling};
      node.previousSibling = node.nextSibling = node.parentNode = null;
      me.fireEventArgs('remove', [me, node, !!isMove]);
      node.removeContext = null;
    }
    if (destroy) {
      node.destroy(true);
    } else {
      node.clear();
    }
    return node;
  }, copy:function(newId, deep) {
    var me = this, result = me.callParent(arguments), len = me.childNodes ? me.childNodes.length : 0, i;
    if (deep) {
      for (i = 0; i < len; i++) {
        result.appendChild(me.childNodes[i].copy(undefined, true));
      }
    }
    return result;
  }, clear:function(destroy) {
    var me = this;
    me.parentNode = me.previousSibling = me.nextSibling = null;
    if (destroy) {
      me.firstChild = me.lastChild = null;
    }
  }, destroy:function(silent) {
    var me = this, options = me.destroyOptions, nodes = me.childNodes, nLen = nodes.length, n;
    if (silent === true) {
      me.clear(true);
      for (n = 0; n < nLen; n++) {
        nodes[n].destroy(true);
      }
      me.childNodes = null;
      delete me.destroyOptions;
      me.callParent([options]);
    } else {
      me.destroyOptions = silent;
      me.remove(true);
    }
  }, insertBefore:function(node, refNode, suppressEvents) {
    var me = this, index = me.indexOf(refNode), oldParent = node.parentNode, refIndex = index, childCount, previousSibling, i;
    if (!refNode) {
      return me.appendChild(node);
    }
    if (node === refNode) {
      return false;
    }
    node = me.createNode(node);
    if (suppressEvents !== true && me.fireEventArgs('beforeinsert', [me, node, refNode]) === false) {
      return false;
    }
    if (oldParent === me && me.indexOf(node) < index) {
      refIndex--;
    }
    if (oldParent) {
      if (suppressEvents !== true && node.fireEventArgs('beforemove', [node, oldParent, me, index, refNode]) === false) {
        return false;
      }
      oldParent.removeChild(node, false, false, true);
    }
    if (refIndex === 0) {
      me.setFirstChild(node);
    }
    Ext.Array.splice(me.childNodes, refIndex, 0, node);
    node.parentNode = me;
    node.nextSibling = refNode;
    refNode.previousSibling = node;
    previousSibling = me.childNodes[refIndex - 1];
    if (previousSibling) {
      node.previousSibling = previousSibling;
      previousSibling.nextSibling = node;
    } else {
      node.previousSibling = null;
    }
    node.updateInfo(false, {parentId:me.getId(), index:refIndex, isFirst:refIndex === 0, isLast:false, depth:(me.data.depth || 0) + 1});
    for (i = refIndex + 1, childCount = me.childNodes.length; i < childCount; i++) {
      me.childNodes[i].updateInfo(false, {index:i});
    }
    if (!me.isLoaded()) {
      me.set('loaded', true);
    } else {
      if (me.childNodes.length === 1) {
        me.triggerUIUpdate();
      }
    }
    if (!node.isLeaf() && node.phantom) {
      node.set('loaded', true);
    }
    if (suppressEvents !== true) {
      me.fireEventArgs('insert', [me, node, refNode]);
      if (oldParent) {
        node.fireEventArgs('move', [node, oldParent, me, refIndex, refNode]);
      }
    }
    return node;
  }, insertChild:function(index, node) {
    var sibling = this.childNodes[index];
    if (sibling) {
      return this.insertBefore(node, sibling);
    } else {
      return this.appendChild(node);
    }
  }, remove:function(destroy, suppressEvents) {
    var me = this, parentNode = me.parentNode;
    if (parentNode) {
      parentNode.removeChild(me, destroy, suppressEvents);
    } else {
      if (destroy) {
        me.destroy(true);
      }
    }
    return me;
  }, removeAll:function(destroy, suppressEvents, fromParent) {
    var me = this, childNodes = me.childNodes, i = 0, len = childNodes.length, node;
    if (!len) {
      return;
    }
    me.fireEventArgs('bulkremove', [me, childNodes, false]);
    for (; i < len; ++i) {
      node = childNodes[i];
      node.removeContext = {parentNode:node.parentNode, previousSibling:node.previousSibling, nextSibling:node.nextSibling};
      node.previousSibling = node.nextSibling = node.parentNode = null;
      me.fireEventArgs('remove', [me, node, false]);
      node.removeContext = null;
      if (destroy) {
        node.destroy(true);
      } else {
        node.removeAll(false, suppressEvents, true);
      }
    }
    me.firstChild = me.lastChild = null;
    if (fromParent) {
      me.childNodes = null;
    } else {
      me.childNodes.length = 0;
      me.triggerUIUpdate();
    }
    return me;
  }, getChildAt:function(index) {
    return this.childNodes[index];
  }, replaceChild:function(newChild, oldChild, suppressEvents) {
    var s = oldChild ? oldChild.nextSibling : null;
    this.removeChild(oldChild, false, suppressEvents);
    this.insertBefore(newChild, s, suppressEvents);
    return oldChild;
  }, indexOf:function(child) {
    return Ext.Array.indexOf(this.childNodes, child);
  }, indexOfId:function(id) {
    var childNodes = this.childNodes, len = childNodes.length, i = 0;
    for (; i < len; ++i) {
      if (childNodes[i].getId() === id) {
        return i;
      }
    }
    return -1;
  }, getPath:function(field, separator) {
    field = field || this.idProperty;
    separator = separator || '/';
    var path = [this.get(field)], parent = this.parentNode;
    while (parent) {
      path.unshift(parent.get(field));
      parent = parent.parentNode;
    }
    return separator + path.join(separator);
  }, getDepth:function() {
    return this.get('depth');
  }, bubble:function(fn, scope, args) {
    var p = this;
    while (p) {
      if (fn.apply(scope || p, args || [p]) === false) {
        break;
      }
      p = p.parentNode;
    }
  }, cascadeBy:function(fn, scope, args) {
    if (fn.apply(scope || this, args || [this]) !== false) {
      var childNodes = this.childNodes, length = childNodes.length, i;
      for (i = 0; i < length; i++) {
        childNodes[i].cascadeBy(fn, scope, args);
      }
    }
  }, eachChild:function(fn, scope, args) {
    var childNodes = this.childNodes, length = childNodes.length, i;
    for (i = 0; i < length; i++) {
      if (fn.apply(scope || this, args || [childNodes[i]]) === false) {
        break;
      }
    }
  }, findChild:function(attribute, value, deep) {
    return this.findChildBy(function() {
      return this.get(attribute) == value;
    }, null, deep);
  }, findChildBy:function(fn, scope, deep) {
    var cs = this.childNodes, len = cs.length, i = 0, n, res;
    for (; i < len; i++) {
      n = cs[i];
      if (fn.call(scope || n, n) === true) {
        return n;
      } else {
        if (deep) {
          res = n.findChildBy(fn, scope, deep);
          if (res !== null) {
            return res;
          }
        }
      }
    }
    return null;
  }, contains:function(node) {
    return node.isAncestor(this);
  }, isAncestor:function(node) {
    var p = this.parentNode;
    while (p) {
      if (p === node) {
        return true;
      }
      p = p.parentNode;
    }
    return false;
  }, sort:function(sortFn, recursive, suppressEvent) {
    var cs = this.childNodes, ln = cs.length, i, n, info = {isFirst:true};
    if (ln > 0) {
      Ext.Array.sort(cs, sortFn);
      this.setFirstChild(cs[0]);
      this.setLastChild(cs[ln - 1]);
      for (i = 0; i < ln; i++) {
        n = cs[i];
        n.previousSibling = cs[i - 1];
        n.nextSibling = cs[i + 1];
        info.isLast = i === ln - 1;
        info.index = i;
        n.updateInfo(false, info);
        info.isFirst = false;
        if (recursive && !n.isLeaf()) {
          n.sort(sortFn, true, true);
        }
      }
      if (suppressEvent !== true) {
        this.fireEventArgs('sort', [this, cs]);
      }
    }
  }, isExpanded:function() {
    return this.get('expanded');
  }, isLoaded:function() {
    return this.get('loaded');
  }, isLoading:function() {
    return this.get('loading');
  }, isRoot:function() {
    return !this.parentNode;
  }, isVisible:function() {
    var parent = this.parentNode;
    while (parent) {
      if (!parent.isExpanded()) {
        return false;
      }
      parent = parent.parentNode;
    }
    return true;
  }, expand:function(recursive, callback, scope) {
    var me = this, owner;
    if (!me.isLeaf()) {
      if (me.isLoading()) {
        me.on('expand', function() {
          me.expand(recursive, callback, scope);
        }, me, {single:true});
      } else {
        if (!me.isExpanded()) {
          me.fireEventArgs('beforeexpand', [me, me.onChildNodesAvailable, me, [recursive, callback, scope]]);
        } else {
          if (recursive) {
            owner = me.getOwnerTree();
            me.expandChildren(true, owner ? owner.singleExpand : false, callback, scope);
          } else {
            Ext.callback(callback, scope || me, [me.childNodes]);
          }
        }
      }
    } else {
      Ext.callback(callback, scope || me);
    }
  }, onChildNodesAvailable:function(records, recursive, callback, scope) {
    var me = this, owner;
    Ext.suspendLayouts();
    me.set('expanded', true);
    me.fireEventArgs('expand', [me, me.childNodes, false]);
    if (recursive) {
      owner = me.getOwnerTree();
      me.expandChildren(true, owner ? owner.singleExpand : false, callback, scope);
    } else {
      Ext.callback(callback, scope || me, [me.childNodes]);
    }
    Ext.resumeLayouts(true);
  }, expandChildren:function(recursive, singleExpand, callback, scope) {
    var me = this, i, allNodes = me.childNodes, expandNodes = [], ln = singleExpand ? Math.min(allNodes.length, 1) : allNodes.length, node;
    for (i = 0; i < ln; ++i) {
      node = allNodes[i];
      if (!node.isLeaf()) {
        expandNodes[expandNodes.length] = node;
      }
    }
    ln = expandNodes.length;
    for (i = 0; i < ln; ++i) {
      expandNodes[i].expand(recursive);
    }
    if (callback) {
      Ext.callback(callback, scope || me, [me.childNodes]);
    }
  }, collapse:function(recursive, callback, scope) {
    var me = this, expanded = me.isExpanded(), len = me.childNodes.length, i, collapseChildren;
    if (!me.isLeaf() && (!expanded && recursive || me.fireEventArgs('beforecollapse', [me]) !== false)) {
      Ext.suspendLayouts();
      if (me.isExpanded()) {
        if (recursive) {
          collapseChildren = function() {
            for (i = 0; i < len; i++) {
              me.childNodes[i].setCollapsed(true);
            }
          };
          if (callback) {
            callback = Ext.Function.createSequence(collapseChildren, callback);
          } else {
            callback = collapseChildren;
          }
        }
        me.set('expanded', false);
        me.fireEventArgs('collapse', [me, me.childNodes, false, callback ? Ext.Function.bind(callback, scope, [me.childNodes]) : null, null]);
        callback = null;
      } else {
        if (recursive) {
          for (i = 0; i < len; i++) {
            me.childNodes[i].setCollapsed(true);
          }
        }
      }
      Ext.resumeLayouts(true);
    }
    Ext.callback(callback, scope || me, [me.childNodes]);
  }, setCollapsed:function(recursive) {
    var me = this, len = me.childNodes.length, i;
    if (!me.isLeaf() && me.fireEventArgs('beforecollapse', [me, Ext.emptyFn]) !== false) {
      me.data.expanded = false;
      me.fireEventArgs('collapse', [me, me.childNodes, false, null, null]);
      if (recursive) {
        for (i = 0; i < len; i++) {
          me.childNodes[i].setCollapsed(true);
        }
      }
    }
  }, collapseChildren:function(recursive, callback, scope) {
    var me = this, i, allNodes = me.childNodes, ln = allNodes.length, collapseNodes = [], node;
    for (i = 0; i < ln; ++i) {
      node = allNodes[i];
      if (!node.isLeaf() && node.isLoaded() && node.isExpanded()) {
        collapseNodes.push(node);
      }
    }
    ln = collapseNodes.length;
    for (i = 0; i < ln; ++i) {
      node = collapseNodes[i];
      if (i === ln - 1) {
        node.collapse(recursive, callback, scope);
      } else {
        node.collapse(recursive);
      }
    }
  }, fireEventArgs:function(eventName, args) {
    var fireEventArgs = Ext.data.Model.prototype.fireEventArgs, result, eventSource, tree, treeStore, rootNode;
    if (bubbledEvents[eventName]) {
      for (eventSource = this; result !== false && eventSource; eventSource = (rootNode = eventSource).parentNode) {
        if (eventSource.hasListeners[eventName]) {
          result = fireEventArgs.call(eventSource, eventName, args);
        }
      }
      tree = rootNode.rootOf;
      if (result !== false && tree) {
        treeStore = tree.treeStore;
        if (treeStore && treeStore.hasListeners[eventName]) {
          result = treeStore.fireEventArgs.call(treeStore, eventName, args);
        }
        if (result !== false && tree.hasListeners[eventName]) {
          result = tree.fireEventArgs.call(tree, eventName, args);
        }
      }
      return result;
    } else {
      return fireEventArgs.apply(this, arguments);
    }
  }, serialize:function() {
    var result = Ext.data.writer.Json.prototype.getRecordData(this), childNodes = this.childNodes, len = childNodes.length, children, i;
    if (len > 0) {
      children = [];
      for (i = 0; i < len; i++) {
        children.push(childNodes[i].serialize());
      }
      result.children = children;
    }
    return result;
  }};
}}});
Ext.define('Ext.data.NodeStore', {extend:Ext.data.Store, alias:'store.node', isNodeStore:true, node:null, recursive:false, rootVisible:false, isExpandingOrCollapsing:0, constructor:function(config) {
  var me = this, node;
  config = config || {};
  Ext.apply(me, config);
  if (Ext.isDefined(me.proxy)) {
    Ext.Error.raise('A NodeStore cannot be bound to a proxy. Instead bind it to a record ' + 'decorated with the NodeInterface by setting the node config.');
  }
  me.useModelWarning = false;
  config.proxy = {type:'proxy'};
  me.callParent([config]);
  node = me.node;
  if (node) {
    me.node = null;
    me.setNode(node);
  }
}, getTotalCount:function() {
  return this.getCount();
}, setNode:function(node) {
  var me = this;
  if (me.node && me.node != node) {
    me.mun(me.node, {expand:me.onNodeExpand, collapse:me.onNodeCollapse, append:me.onNodeAppend, insert:me.onNodeInsert, bulkremove:me.onBulkRemove, remove:me.onNodeRemove, sort:me.onNodeSort, scope:me});
    me.node = null;
  }
  if (node) {
    Ext.data.NodeInterface.decorate(node.self);
    me.removeAll();
    if (me.rootVisible) {
      me.add(node);
    } else {
      if (!node.isExpanded() && me.treeStore.autoLoad !== false) {
        node.expand();
      }
    }
    me.mon(node, {expand:me.onNodeExpand, collapse:me.onNodeCollapse, append:me.onNodeAppend, insert:me.onNodeInsert, bulkremove:me.onBulkRemove, remove:me.onNodeRemove, sort:me.onNodeSort, scope:me});
    me.node = node;
    if (node.isExpanded() && node.isLoaded()) {
      me.onNodeExpand(node, node.childNodes, true);
    }
  }
}, onNodeSort:function(node, childNodes) {
  var me = this;
  if (me.indexOf(node) !== -1 || node === me.node && !me.rootVisible && node.isExpanded()) {
    Ext.suspendLayouts();
    me.onNodeCollapse(node, childNodes, true);
    me.onNodeExpand(node, childNodes, true);
    Ext.resumeLayouts(true);
  }
}, onNodeExpand:function(parent, records, suppressEvent) {
  var me = this, insertIndex = me.indexOf(parent) + 1, toAdd = [];
  if (!suppressEvent) {
    me.fireEvent('beforeexpand', parent, records, insertIndex);
  }
  me.handleNodeExpand(parent, records, toAdd);
  me.insert(insertIndex, toAdd);
  if (!suppressEvent) {
    me.fireEvent('expand', parent, records);
  }
}, handleNodeExpand:function(parent, records, toAdd) {
  var me = this, ln = records ? records.length : 0, i, record;
  if (!me.recursive && parent !== me.node) {
    return;
  }
  if (parent !== this.node && !me.isVisible(parent)) {
    return;
  }
  if (ln) {
    for (i = 0; i < ln; i++) {
      record = records[i];
      toAdd.push(record);
      if (record.isExpanded()) {
        if (record.isLoaded()) {
          me.handleNodeExpand(record, record.childNodes, toAdd);
        } else {
          record.set('expanded', false);
          record.expand();
        }
      }
    }
  }
}, onBulkRemove:function(parent, childNodes, isMove) {
  this.onNodeCollapse(parent, childNodes, true);
}, onNodeCollapse:function(parent, records, suppressEvent, callback, scope) {
  var me = this, collapseIndex = me.indexOf(parent) + 1, node, lastNodeIndexPlus, sibling, found;
  if (!me.recursive && parent !== me.node) {
    return;
  }
  if (!suppressEvent) {
    me.fireEvent('beforecollapse', parent, records, collapseIndex, callback, scope);
  }
  if (records.length && me.data.contains(records[0])) {
    node = parent;
    while (node.parentNode) {
      sibling = node.nextSibling;
      if (sibling) {
        found = true;
        lastNodeIndexPlus = me.indexOf(sibling);
        break;
      } else {
        node = node.parentNode;
      }
    }
    if (!found) {
      lastNodeIndexPlus = me.getCount();
    }
    me.removeAt(collapseIndex, lastNodeIndexPlus - collapseIndex);
  }
  if (!suppressEvent) {
    me.fireEvent('collapse', parent, records, collapseIndex);
  }
}, onNodeAppend:function(parent, node, index) {
  var me = this, refNode, sibling;
  if (me.isVisible(node)) {
    if (index === 0) {
      refNode = parent;
    } else {
      sibling = node.previousSibling;
      while (sibling.isExpanded() && sibling.lastChild) {
        sibling = sibling.lastChild;
      }
      refNode = sibling;
    }
    me.insert(me.indexOf(refNode) + 1, node);
    if (!node.isLeaf() && node.isExpanded()) {
      if (node.isLoaded()) {
        me.onNodeExpand(node, node.childNodes, true);
      } else {
        if (!me.treeStore.fillCount) {
          node.set('expanded', false);
          node.expand();
        }
      }
    }
  }
}, onNodeInsert:function(parent, node, refNode) {
  var me = this, index = this.indexOf(refNode);
  if (index != -1 && me.isVisible(node)) {
    me.insert(index, node);
    if (!node.isLeaf() && node.isExpanded()) {
      if (node.isLoaded()) {
        me.onNodeExpand(node, node.childNodes, true);
      } else {
        node.set('expanded', false);
        node.expand();
      }
    }
  }
}, onNodeRemove:function(parent, node, isMove) {
  var me = this;
  if (me.indexOf(node) != -1) {
    if (!node.isLeaf() && node.isExpanded()) {
      node.parentNode = node.removeContext.parentNode;
      node.nextSibling = node.removeContext.nextSibling;
      me.onNodeCollapse(node, node.childNodes, true);
      node.parentNode = node.nextSibling = null;
    }
    me.remove(node);
  }
}, isVisible:function(node) {
  var parent = node.parentNode;
  while (parent) {
    if (parent === this.node && parent.data.expanded) {
      return true;
    }
    if (!parent.data.expanded) {
      return false;
    }
    parent = parent.parentNode;
  }
  return false;
}});
Ext.define('Ext.data.Request', {action:undefined, params:undefined, method:'GET', url:undefined, constructor:function(config) {
  Ext.apply(this, config);
}});
Ext.define('Ext.data.Tree', {alias:'data.tree', mixins:{observable:Ext.util.Observable}, root:null, constructor:function(root) {
  var me = this;
  me.mixins.observable.constructor.call(me);
  if (root) {
    me.setRootNode(root);
  }
  me.on({scope:me, idchanged:me.onNodeIdChanged, insert:me.onNodeInsert, append:me.onNodeAppend, remove:me.onNodeRemove});
}, getRootNode:function() {
  return this.root;
}, setRootNode:function(node) {
  var me = this;
  me.root = node;
  if (node.rootOf) {
    node.rootOf.removeRootNode();
  } else {
    if (node.parentNode) {
      node.parentNode.removeChild(node);
    }
  }
  node.rootOf = me;
  if (node.fireEventArgs('beforeappend', [null, node]) !== false) {
    node.set('root', true);
    node.updateInfo(true, {isFirst:true, isLast:true, depth:0, index:0, parentId:null});
    me.nodeHash = {};
    node.fireEvent('append', null, node);
    node.fireEvent('rootchange', node);
  }
  return node;
}, removeRootNode:function() {
  var me = this, root = me.root;
  root.set('root', false);
  root.fireEvent('remove', null, root, false);
  root.fireEvent('rootchange', null);
  root.rootOf = me.root = null;
  return root;
}, flatten:function() {
  return Ext.Object.getValues(this.nodeHash);
}, onNodeInsert:function(parent, node) {
  this.registerNode(node, true);
}, onNodeAppend:function(parent, node) {
  this.registerNode(node, true);
}, onNodeRemove:function(parent, node) {
  this.unregisterNode(node, true);
}, onNodeIdChanged:function(node, oldId, newId, oldInternalId) {
  var nodeHash = this.nodeHash;
  nodeHash[node.internalId] = node;
  delete nodeHash[oldInternalId];
}, getNodeById:function(id) {
  return this.nodeHash[id];
}, registerNode:function(node, includeChildren) {
  var me = this, children, length, i;
  me.nodeHash[node.internalId] = node;
  if (includeChildren === true) {
    children = node.childNodes;
    length = children.length;
    for (i = 0; i < length; i++) {
      me.registerNode(children[i], true);
    }
  }
}, unregisterNode:function(node, includeChildren) {
  var me = this, children, length, i;
  delete me.nodeHash[node.internalId];
  if (includeChildren === true) {
    children = node.childNodes;
    length = children.length;
    for (i = 0; i < length; i++) {
      me.unregisterNode(children[i], true);
    }
  }
}, sort:function(sorterFn, recursive) {
  this.getRootNode().sort(sorterFn, recursive);
}, filter:function(filters, recursive) {
  this.getRootNode().filter(filters, recursive);
}});
Ext.define('Ext.data.TreeStore', {extend:Ext.data.AbstractStore, alias:'store.tree', clearOnLoad:true, clearRemovedOnLoad:true, nodeParam:'node', defaultRootId:'root', defaultRootText:'Root', defaultRootProperty:'children', rootProperty:'children', fillCount:0, folderSort:false, constructor:function(config) {
  var me = this, root, fields, defaultRoot;
  config = Ext.apply({}, config);
  fields = config.fields || me.fields;
  if (!fields) {
    config.fields = [{name:'text', type:'string'}];
    defaultRoot = config.defaultRootProperty || me.defaultRootProperty;
    if (defaultRoot !== me.defaultRootProperty) {
      config.fields.push({name:defaultRoot, type:'auto', defaultValue:null, persist:false});
    }
  }
  me.callParent([config]);
  me.tree = new Ext.data.Tree;
  me.tree.treeStore = me;
  me.tree.on({scope:me, remove:me.onNodeRemove, beforeexpand:me.onBeforeNodeExpand, append:me.onNodeAdded, insert:me.onNodeAdded, sort:me.onNodeSort});
  me.onBeforeSort();
  root = me.root;
  if (root) {
    delete me.root;
    me.setRootNode(root);
  }
}, setProxy:function(proxy) {
  var reader, needsRoot;
  if (proxy instanceof Ext.data.proxy.Proxy) {
    needsRoot = Ext.isEmpty(proxy.getReader().root);
  } else {
    if (Ext.isString(proxy)) {
      needsRoot = true;
    } else {
      reader = proxy.reader;
      needsRoot = !(reader && !Ext.isEmpty(reader.root));
    }
  }
  proxy = this.callParent(arguments);
  proxy.idParam = this.nodeParam;
  if (needsRoot) {
    reader = proxy.getReader();
    reader.root = this.defaultRootProperty;
    reader.buildExtractors(true);
  }
  return proxy;
}, onBeforeSort:function() {
  if (this.folderSort) {
    this.sort({property:'leaf', direction:'ASC'}, 'prepend', false);
  }
}, onBeforeNodeExpand:function(node, callback, scope, args) {
  var me = this, reader, dataRoot, data, callbackArgs;
  if (node.isLoaded()) {
    callbackArgs = [node.childNodes];
    if (args) {
      callbackArgs.push.apply(callbackArgs, args);
    }
    Ext.callback(callback, scope || node, callbackArgs);
  } else {
    if (dataRoot = data = (node.raw || node[node.persistenceProperty])[(reader = me.getProxy().getReader()).root]) {
      me.fillNode(node, reader.extractData(dataRoot));
      delete data[reader.root];
      callbackArgs = [node.childNodes];
      if (args) {
        callbackArgs.push.apply(callbackArgs, args);
      }
      Ext.callback(callback, scope || node, callbackArgs);
    } else {
      if (node.isLoading()) {
        me.on('load', function() {
          callbackArgs = [node.childNodes];
          if (args) {
            callbackArgs.push.apply(callbackArgs, args);
          }
          Ext.callback(callback, scope || node, callbackArgs);
        }, me, {single:true});
      } else {
        me.read({node:node, callback:function() {
          delete me.lastOptions.callback;
          callbackArgs = [node.childNodes];
          if (args) {
            callbackArgs.push.apply(callbackArgs, args);
          }
          Ext.callback(callback, scope || node, callbackArgs);
        }});
      }
    }
  }
}, getNewRecords:function() {
  return Ext.Array.filter(this.tree.flatten(), this.filterNew);
}, getUpdatedRecords:function() {
  return Ext.Array.filter(this.tree.flatten(), this.filterUpdated);
}, onNodeRemove:function(parent, node, isMove) {
  var me = this;
  node.unjoin(me);
  if (!node.phantom && !isMove) {
    Ext.Array.include(me.removed, node);
  }
  if (me.autoSync && !me.autoSyncSuspended && !isMove) {
    me.sync();
  }
}, onNodeAdded:function(parent, node) {
  var me = this, proxy = me.getProxy(), reader = proxy.getReader(), data = node.raw || node[node.persistenceProperty], dataRoot;
  Ext.Array.remove(me.removed, node);
  node.join(me);
  if (!node.isLeaf() && !me.lazyFill) {
    dataRoot = reader.getRoot(data);
    if (dataRoot) {
      me.fillNode(node, reader.extractData(dataRoot));
      delete data[reader.root];
    }
  }
  if (me.autoSync && !me.autoSyncSuspended && (node.phantom || node.dirty)) {
    me.sync();
  }
}, onNodeSort:function() {
  if (this.autoSync && !this.autoSyncSuspended) {
    this.sync();
  }
}, setRootNode:function(root, preventLoad) {
  var me = this, model = me.model, idProperty = model.prototype.idProperty;
  root = root || {};
  if (!root.isModel) {
    root = Ext.apply({}, root);
    Ext.applyIf(root, {id:me.defaultRootId, text:me.defaultRootText, allowDrag:false});
    if (root[idProperty] === undefined) {
      root[idProperty] = me.defaultRootId;
    }
    Ext.data.NodeInterface.decorate(model);
    root = Ext.ModelManager.create(root, model);
  } else {
    if (root.isModel && !root.isNode) {
      Ext.data.NodeInterface.decorate(model);
    }
  }
  me.getProxy().getReader().buildExtractors(true);
  me.tree.setRootNode(root);
  if (preventLoad !== true && !root.isLoaded() && (me.autoLoad === true || root.isExpanded())) {
    root.data.expanded = false;
    root.expand();
  }
  return root;
}, getRootNode:function() {
  return this.tree.getRootNode();
}, getNodeById:function(id) {
  return this.tree.getNodeById(id);
}, getById:function(id) {
  return this.getNodeById(id);
}, load:function(options) {
  options = options || {};
  options.params = options.params || {};
  var me = this, node = options.node || me.tree.getRootNode();
  if (!node) {
    node = me.setRootNode({expanded:true}, true);
  }
  options.id = node.getId();
  if (me.clearOnLoad) {
    if (me.clearRemovedOnLoad) {
      me.clearRemoved(node);
    }
    me.tree.un('remove', me.onNodeRemove, me);
    node.removeAll(false);
    me.tree.on('remove', me.onNodeRemove, me);
  }
  Ext.applyIf(options, {node:node});
  me.callParent([options]);
  if (me.loading && node) {
    node.set('loading', true);
  }
  return me;
}, clearRemoved:function(node) {
  var me = this, removed = me.removed, id = node.getId(), removedLength = removed.length, i = removedLength, recordsToClear = {}, newRemoved = [], removedHash = {}, removedNode, targetNode, targetId;
  if (node === me.getRootNode()) {
    me.removed = [];
    return;
  }
  for (; i--;) {
    removedNode = removed[i];
    removedHash[removedNode.getId()] = removedNode;
  }
  for (i = removedLength; i--;) {
    removedNode = removed[i];
    targetNode = removedNode;
    while (targetNode && targetNode.getId() !== id) {
      targetId = targetNode.get('parentId');
      targetNode = targetNode.parentNode || me.getNodeById(targetId) || removedHash[targetId];
    }
    if (targetNode) {
      recordsToClear[removedNode.getId()] = removedNode;
    }
  }
  for (i = 0; i < removedLength; i++) {
    removedNode = removed[i];
    if (!recordsToClear[removedNode.getId()]) {
      newRemoved.push(removedNode);
    }
  }
  me.removed = newRemoved;
}, fillNode:function(node, newNodes) {
  var me = this, ln = newNodes ? newNodes.length : 0, sorters = me.sorters, i, sortCollection, needsIndexSort = false, performLocalSort = ln && me.sortOnLoad && !me.remoteSort && sorters && sorters.items && sorters.items.length, node1, node2, rootFill;
  for (i = 1; i < ln; i++) {
    node1 = newNodes[i];
    node2 = newNodes[i - 1];
    needsIndexSort = node1[node1.persistenceProperty].index != node2[node2.persistenceProperty].index;
    if (needsIndexSort) {
      break;
    }
  }
  if (performLocalSort) {
    if (needsIndexSort) {
      me.sorters.insert(0, me.indexSorter);
    }
    sortCollection = new Ext.util.MixedCollection;
    sortCollection.addAll(newNodes);
    sortCollection.sort(me.sorters.items);
    newNodes = sortCollection.items;
    me.sorters.remove(me.indexSorter);
  } else {
    if (needsIndexSort) {
      Ext.Array.sort(newNodes, me.sortByIndex);
    }
  }
  node.set('loaded', true);
  rootFill = me.fillCount === 0;
  if (rootFill) {
    me.fireEvent('beforefill', me, node, newNodes);
  }
  ++me.fillCount;
  if (newNodes.length) {
    node.appendChild(newNodes, undefined, true);
  }
  if (rootFill) {
    me.fireEvent('fillcomplete', me, node, newNodes);
  }
  --me.fillCount;
  return newNodes;
}, sortByIndex:function(node1, node2) {
  return node1[node1.persistenceProperty].index - node2[node2.persistenceProperty].index;
}, onIdChanged:function(model, oldId, newId, oldInternalId) {
  this.tree.onNodeIdChanged(model, oldId, newId, oldInternalId);
  this.callParent(arguments);
}, onProxyLoad:function(operation) {
  var me = this, successful = operation.wasSuccessful(), records = operation.getRecords(), node = operation.node;
  me.loading = false;
  node.set('loading', false);
  if (successful) {
    if (!me.clearOnLoad) {
      records = me.cleanRecords(node, records);
    }
    records = me.fillNode(node, records);
  }
  me.fireEvent('read', me, operation.node, records, successful);
  me.fireEvent('load', me, operation.node, records, successful);
  Ext.callback(operation.callback, operation.scope || me, [records, operation, successful]);
}, cleanRecords:function(node, records) {
  var nodeHash = {}, childNodes = node.childNodes, i = 0, len = childNodes.length, out = [], rec;
  for (; i < len; ++i) {
    nodeHash[childNodes[i].getId()] = true;
  }
  for (i = 0, len = records.length; i < len; ++i) {
    rec = records[i];
    if (!nodeHash[rec.getId()]) {
      out.push(rec);
    }
  }
  return out;
}, removeAll:function() {
  var root = this.getRootNode();
  if (root) {
    root.destroy(true);
  }
  this.fireEvent('clear', this);
}, doSort:function(sorterFn) {
  var me = this;
  if (me.remoteSort) {
    me.load();
  } else {
    me.tree.sort(sorterFn, true);
    me.fireEvent('datachanged', me);
    me.fireEvent('refresh', me);
  }
  me.fireEvent('sort', me, me.sorters.getRange());
}}, function() {
  var proto = this.prototype;
  proto.indexSorter = new Ext.util.Sorter({sorterFn:proto.sortByIndex});
});
Ext.define('Ext.data.association.BelongsTo', {extend:Ext.data.association.Association, alternateClassName:'Ext.data.BelongsToAssociation', alias:'association.belongsto', constructor:function(config) {
  this.callParent(arguments);
  var me = this, ownerProto = me.ownerModel.prototype, associatedName = me.associatedName, getterName = me.getterName || 'get' + associatedName, setterName = me.setterName || 'set' + associatedName;
  Ext.applyIf(me, {name:associatedName, foreignKey:associatedName.toLowerCase() + '_id', instanceName:associatedName + 'BelongsToInstance', associationKey:associatedName.toLowerCase()});
  ownerProto[getterName] = me.createGetter();
  ownerProto[setterName] = me.createSetter();
}, createSetter:function() {
  var me = this, foreignKey = me.foreignKey, instanceName = me.instanceName;
  return function(value, options, scope) {
    var setByRecord = value && value.isModel, valueToSet = setByRecord ? value.getId() : value;
    if (setByRecord) {
      this[instanceName] = value;
    } else {
      if (this[instanceName] instanceof Ext.data.Model && !this.isEqual(this.get(foreignKey), valueToSet)) {
        delete this[instanceName];
      }
    }
    this.set(foreignKey, valueToSet);
    if (Ext.isFunction(options)) {
      options = {callback:options, scope:scope || this};
    }
    if (Ext.isObject(options)) {
      return this.save(options);
    }
  };
}, createGetter:function() {
  var me = this, associatedName = me.associatedName, associatedModel = me.associatedModel, foreignKey = me.foreignKey, primaryKey = me.primaryKey, instanceName = me.instanceName;
  return function(options, scope) {
    options = options || {};
    var model = this, foreignKeyId = model.get(foreignKey), success, instance, args;
    if (options.reload === true || model[instanceName] === undefined) {
      instance = Ext.ModelManager.create({}, associatedName);
      instance.set(primaryKey, foreignKeyId);
      if (typeof options == 'function') {
        options = {callback:options, scope:scope || model};
      }
      success = options.success;
      options.success = function(rec) {
        model[instanceName] = rec;
        if (success) {
          success.apply(this, arguments);
        }
      };
      associatedModel.load(foreignKeyId, options);
      model[instanceName] = instance;
      return instance;
    } else {
      instance = model[instanceName];
      args = [instance];
      scope = scope || options.scope || model;
      Ext.callback(options, scope, args);
      Ext.callback(options.success, scope, args);
      Ext.callback(options.failure, scope, args);
      Ext.callback(options.callback, scope, args);
      return instance;
    }
  };
}, read:function(record, reader, associationData) {
  record[this.instanceName] = reader.read([associationData]).records[0];
}});
Ext.define('Ext.util.Inflector', {singleton:true, plurals:[[/(quiz)$/i, '$1zes'], [/^(ox)$/i, '$1en'], [/([m|l])ouse$/i, '$1ice'], [/(matr|vert|ind)ix|ex$/i, '$1ices'], [/(x|ch|ss|sh)$/i, '$1es'], [/([^aeiouy]|qu)y$/i, '$1ies'], [/(hive)$/i, '$1s'], [/(?:([^f])fe|([lr])f)$/i, '$1$2ves'], [/sis$/i, 'ses'], [/([ti])um$/i, '$1a'], [/(buffal|tomat|potat)o$/i, '$1oes'], [/(bu)s$/i, '$1ses'], [/(alias|status|sex)$/i, '$1es'], [/(octop|vir)us$/i, '$1i'], [/(ax|test)is$/i, '$1es'], [/^person$/, 'people'], 
[/^man$/, 'men'], [/^(child)$/, '$1ren'], [/s$/i, 's'], [/$/, 's']], singulars:[[/(quiz)zes$/i, '$1'], [/(matr)ices$/i, '$1ix'], [/(vert|ind)ices$/i, '$1ex'], [/^(ox)en/i, '$1'], [/(alias|status)es$/i, '$1'], [/(octop|vir)i$/i, '$1us'], [/(cris|ax|test)es$/i, '$1is'], [/(shoe)s$/i, '$1'], [/(o)es$/i, '$1'], [/(bus)es$/i, '$1'], [/([m|l])ice$/i, '$1ouse'], [/(x|ch|ss|sh)es$/i, '$1'], [/(m)ovies$/i, '$1ovie'], [/(s)eries$/i, '$1eries'], [/([^aeiouy]|qu)ies$/i, '$1y'], [/([lr])ves$/i, '$1f'], [/(tive)s$/i, 
'$1'], [/(hive)s$/i, '$1'], [/([^f])ves$/i, '$1fe'], [/(^analy)ses$/i, '$1sis'], [/((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$/i, '$1$2sis'], [/([ti])a$/i, '$1um'], [/(n)ews$/i, '$1ews'], [/people$/i, 'person'], [/s$/i, '']], uncountable:['sheep', 'fish', 'series', 'species', 'money', 'rice', 'information', 'equipment', 'grass', 'mud', 'offspring', 'deer', 'means'], singular:function(matcher, replacer) {
  this.singulars.unshift([matcher, replacer]);
}, plural:function(matcher, replacer) {
  this.plurals.unshift([matcher, replacer]);
}, clearSingulars:function() {
  this.singulars = [];
}, clearPlurals:function() {
  this.plurals = [];
}, isTransnumeral:function(word) {
  return Ext.Array.indexOf(this.uncountable, word) != -1;
}, pluralize:function(word) {
  if (this.isTransnumeral(word)) {
    return word;
  }
  var plurals = this.plurals, length = plurals.length, tuple, regex, i;
  for (i = 0; i < length; i++) {
    tuple = plurals[i];
    regex = tuple[0];
    if (regex == word || regex.test && regex.test(word)) {
      return word.replace(regex, tuple[1]);
    }
  }
  return word;
}, singularize:function(word) {
  if (this.isTransnumeral(word)) {
    return word;
  }
  var singulars = this.singulars, length = singulars.length, tuple, regex, i;
  for (i = 0; i < length; i++) {
    tuple = singulars[i];
    regex = tuple[0];
    if (regex == word || regex.test && regex.test(word)) {
      return word.replace(regex, tuple[1]);
    }
  }
  return word;
}, classify:function(word) {
  return Ext.String.capitalize(this.singularize(word));
}, ordinalize:function(number) {
  var parsed = parseInt(number, 10), mod10 = parsed % 10, mod100 = parsed % 100;
  if (11 <= mod100 && mod100 <= 13) {
    return number + 'th';
  } else {
    switch(mod10) {
      case 1:
        return number + 'st';
      case 2:
        return number + 'nd';
      case 3:
        return number + 'rd';
      default:
        return number + 'th';
    }
  }
}}, function() {
  var irregulars = {alumnus:'alumni', cactus:'cacti', focus:'foci', nucleus:'nuclei', radius:'radii', stimulus:'stimuli', ellipsis:'ellipses', paralysis:'paralyses', oasis:'oases', appendix:'appendices', index:'indexes', beau:'beaux', bureau:'bureaux', tableau:'tableaux', woman:'women', child:'children', man:'men', corpus:'corpora', criterion:'criteria', curriculum:'curricula', genus:'genera', memorandum:'memoranda', phenomenon:'phenomena', foot:'feet', goose:'geese', tooth:'teeth', antenna:'antennae', 
  formula:'formulae', nebula:'nebulae', vertebra:'vertebrae', vita:'vitae'}, singular;
  for (singular in irregulars) {
    this.plural(singular, irregulars[singular]);
    this.singular(irregulars[singular], singular);
  }
});
Ext.define('Ext.data.association.HasMany', {extend:Ext.data.association.Association, alternateClassName:'Ext.data.HasManyAssociation', alias:'association.hasmany', constructor:function(config) {
  var me = this, ownerProto, name;
  me.callParent(arguments);
  me.name = me.name || Ext.util.Inflector.pluralize(me.associatedName.toLowerCase());
  ownerProto = me.ownerModel.prototype;
  name = me.name;
  Ext.applyIf(me, {storeName:name + 'Store', foreignKey:me.ownerName.toLowerCase() + '_id'});
  ownerProto[name] = me.createStore();
}, createStore:function() {
  var that = this, associatedModel = that.associatedModel, storeName = that.storeName, foreignKey = that.foreignKey, primaryKey = that.primaryKey, filterProperty = that.filterProperty, autoLoad = that.autoLoad, storeConfig = that.storeConfig || {};
  return function() {
    var me = this, config, filter, modelDefaults = {};
    if (me[storeName] === undefined) {
      if (filterProperty) {
        filter = {property:filterProperty, value:me.get(filterProperty), exactMatch:true};
      } else {
        filter = {property:foreignKey, value:me.get(primaryKey), exactMatch:true};
      }
      modelDefaults[foreignKey] = me.get(primaryKey);
      config = Ext.apply({}, storeConfig, {model:associatedModel, filters:[filter], remoteFilter:false, modelDefaults:modelDefaults, disableMetaChangeEvent:true});
      me[storeName] = Ext.data.AbstractStore.create(config);
      if (autoLoad) {
        me[storeName].load();
      }
    }
    return me[storeName];
  };
}, read:function(record, reader, associationData) {
  var store = record[this.name](), inverse, items, iLen, i;
  store.add(reader.read(associationData).records);
  inverse = this.associatedModel.prototype.associations.findBy(function(assoc) {
    return assoc.type === 'belongsTo' && assoc.associatedName === record.$className;
  });
  if (inverse) {
    items = store.data.items;
    iLen = items.length;
    for (i = 0; i < iLen; i++) {
      items[i][inverse.instanceName] = record;
    }
  }
}});
Ext.define('Ext.data.association.HasOne', {extend:Ext.data.association.Association, alternateClassName:'Ext.data.HasOneAssociation', alias:'association.hasone', constructor:function(config) {
  this.callParent(arguments);
  var me = this, ownerProto = me.ownerModel.prototype, associatedName = me.associatedName, getterName = me.getterName || 'get' + associatedName, setterName = me.setterName || 'set' + associatedName;
  Ext.applyIf(me, {name:associatedName, foreignKey:associatedName.toLowerCase() + '_id', instanceName:associatedName + 'HasOneInstance', associationKey:associatedName.toLowerCase()});
  ownerProto[getterName] = me.createGetter();
  ownerProto[setterName] = me.createSetter();
}, createSetter:function() {
  var me = this, foreignKey = me.foreignKey, instanceName = me.instanceName;
  return function(value, options, scope) {
    var setByRecord = value && value.isModel, valueToSet = setByRecord ? value.getId() : value;
    if (setByRecord) {
      this[instanceName] = value;
    } else {
      if (this[instanceName] instanceof Ext.data.Model && !this.isEqual(this.get(foreignKey), valueToSet)) {
        delete this[instanceName];
      }
    }
    this.set(foreignKey, valueToSet);
    if (Ext.isFunction(options)) {
      options = {callback:options, scope:scope || this};
    }
    if (Ext.isObject(options)) {
      return this.save(options);
    }
  };
}, createGetter:function() {
  var me = this, ownerModel = me.ownerModel, associatedName = me.associatedName, associatedModel = me.associatedModel, foreignKey = me.foreignKey, primaryKey = me.primaryKey, instanceName = me.instanceName;
  return function(options, scope) {
    options = options || {};
    var model = this, foreignKeyId = model.get(foreignKey), success, instance, args;
    if (options.reload === true || model[instanceName] === undefined) {
      instance = Ext.ModelManager.create({}, associatedName);
      instance.set(primaryKey, foreignKeyId);
      if (typeof options == 'function') {
        options = {callback:options, scope:scope || model};
      }
      success = options.success;
      options.success = function(rec) {
        model[instanceName] = rec;
        if (success) {
          success.apply(this, arguments);
        }
      };
      associatedModel.load(foreignKeyId, options);
      model[instanceName] = instance;
      return instance;
    } else {
      instance = model[instanceName];
      args = [instance];
      scope = scope || options.scope || model;
      Ext.callback(options, scope, args);
      Ext.callback(options.success, scope, args);
      Ext.callback(options.failure, scope, args);
      Ext.callback(options.callback, scope, args);
      return instance;
    }
  };
}, read:function(record, reader, associationData) {
  var inverse = this.associatedModel.prototype.associations.findBy(function(assoc) {
    return assoc.type === 'belongsTo' && assoc.associatedName === record.$className;
  }), newRecord = reader.read([associationData]).records[0];
  record[this.instanceName] = newRecord;
  if (inverse) {
    newRecord[inverse.instanceName] = record;
  }
}});
Ext.define('Ext.dd.DDTarget', {extend:Ext.dd.DragDrop, constructor:function(id, sGroup, config) {
  if (id) {
    this.initTarget(id, sGroup, config);
  }
}, getDragEl:Ext.emptyFn, isValidHandleChild:Ext.emptyFn, startDrag:Ext.emptyFn, endDrag:Ext.emptyFn, onDrag:Ext.emptyFn, onDragDrop:Ext.emptyFn, onDragEnter:Ext.emptyFn, onDragOut:Ext.emptyFn, onDragOver:Ext.emptyFn, onInvalidDrop:Ext.emptyFn, onMouseDown:Ext.emptyFn, onMouseUp:Ext.emptyFn, setXConstraint:Ext.emptyFn, setYConstraint:Ext.emptyFn, resetConstraints:Ext.emptyFn, clearConstraints:Ext.emptyFn, clearTicks:Ext.emptyFn, setInitPosition:Ext.emptyFn, setDragElId:Ext.emptyFn, setHandleElId:Ext.emptyFn, 
setOuterHandleElId:Ext.emptyFn, addInvalidHandleClass:Ext.emptyFn, addInvalidHandleId:Ext.emptyFn, addInvalidHandleType:Ext.emptyFn, removeInvalidHandleClass:Ext.emptyFn, removeInvalidHandleId:Ext.emptyFn, removeInvalidHandleType:Ext.emptyFn, toString:function() {
  return 'DDTarget ' + this.id;
}});
Ext.define('Ext.dd.DragTracker', {mixins:{observable:Ext.util.Observable}, active:false, trackOver:false, tolerance:5, autoStart:false, constructor:function(config) {
  var me = this;
  Ext.apply(me, config);
  me.addEvents('mouseover', 'mouseout', 'mousedown', 'mouseup', 'mousemove', 'beforedragstart', 'dragstart', 'dragend', 'drag');
  me.dragRegion = new Ext.util.Region(0, 0, 0, 0);
  if (me.el) {
    me.initEl(me.el);
  }
  me.mixins.observable.constructor.call(me);
  if (me.disabled) {
    me.disable();
  }
}, initEl:function(el) {
  var me = this;
  me.el = Ext.get(el);
  me.handle = Ext.get(me.delegate);
  me.delegate = me.handle ? undefined : me.delegate;
  if (!me.handle) {
    me.handle = me.el;
  }
  me.handleListeners = {scope:me, delegate:me.delegate, mousedown:me.onMouseDown};
  if (me.trackOver || me.overCls) {
    Ext.apply(me.handleListeners, {mouseover:me.onMouseOver, mouseout:me.onMouseOut});
  }
  me.mon(me.handle, me.handleListeners);
}, disable:function() {
  this.disabled = true;
}, enable:function() {
  this.disabled = false;
}, destroy:function() {
  var me = this;
  if (me.active) {
    me.endDrag({});
  }
  me.clearListeners();
  me.mun(me.handle, me.handleListeners);
  me.el = me.handle = null;
}, onMouseOver:function(e, target) {
  var me = this;
  if (!me.disabled) {
    if (Ext.EventManager.contains(e) || me.delegate) {
      me.mouseIsOut = false;
      if (me.overCls) {
        me.el.addCls(me.overCls);
      }
      me.fireEvent('mouseover', me, e, me.delegate ? e.getTarget(me.delegate, target) : me.handle);
    }
  }
}, onMouseOut:function(e) {
  var me = this;
  if (me.mouseIsDown) {
    me.mouseIsOut = true;
  } else {
    if (me.overCls) {
      me.el.removeCls(me.overCls);
    }
    me.fireEvent('mouseout', me, e);
  }
}, onMouseDown:function(e, target) {
  var me = this, el;
  if (me.disabled || e.dragTracked) {
    return;
  }
  me.dragTarget = me.delegate ? target : me.handle.dom;
  me.startXY = me.lastXY = e.getXY();
  me.startRegion = Ext.fly(me.dragTarget).getRegion();
  if (me.fireEvent('mousedown', me, e) === false || me.fireEvent('beforedragstart', me, e) === false || me.onBeforeStart(e) === false) {
    return;
  }
  me.mouseIsDown = true;
  e.dragTracked = true;
  el = me.el.dom;
  if (Ext.isIE && el.setCapture) {
    el.setCapture();
  }
  if (me.preventDefault !== false) {
    e.preventDefault();
  }
  Ext.getDoc().on({scope:me, mouseup:me.onMouseUp, mousemove:me.onMouseMove, selectstart:me.stopSelect});
  if (me.autoStart) {
    me.timer = Ext.defer(me.triggerStart, me.autoStart === true ? 1000 : me.autoStart, me, [e]);
  }
}, onMouseMove:function(e, target) {
  var me = this, xy = e.getXY(), s = me.startXY;
  e.preventDefault();
  me.lastXY = xy;
  if (!me.active) {
    if (Math.max(Math.abs(s[0] - xy[0]), Math.abs(s[1] - xy[1])) > me.tolerance) {
      me.triggerStart(e);
    } else {
      return;
    }
  }
  if (me.fireEvent('mousemove', me, e) === false) {
    me.onMouseUp(e);
  } else {
    me.onDrag(e);
    me.fireEvent('drag', me, e);
  }
}, onMouseUp:function(e) {
  var me = this;
  me.mouseIsDown = false;
  if (me.mouseIsOut) {
    me.mouseIsOut = false;
    me.onMouseOut(e);
  }
  e.preventDefault();
  if (Ext.isIE && document.releaseCapture) {
    document.releaseCapture();
  }
  me.fireEvent('mouseup', me, e);
  me.endDrag(e);
}, endDrag:function(e) {
  var me = this, wasActive = me.active;
  Ext.getDoc().un({mousemove:me.onMouseMove, mouseup:me.onMouseUp, selectstart:me.stopSelect, scope:me});
  me.clearStart();
  me.active = false;
  if (wasActive) {
    me.onEnd(e);
    me.fireEvent('dragend', me, e);
  }
  me._constrainRegion = Ext.EventObject.dragTracked = null;
}, triggerStart:function(e) {
  var me = this;
  me.clearStart();
  me.active = true;
  me.onStart(e);
  me.fireEvent('dragstart', me, e);
}, clearStart:function() {
  var timer = this.timer;
  if (timer) {
    clearTimeout(timer);
    this.timer = null;
  }
}, stopSelect:function(e) {
  e.stopEvent();
  return false;
}, onBeforeStart:function(e) {
}, onStart:function(xy) {
}, onDrag:function(e) {
}, onEnd:function(e) {
}, getDragTarget:function() {
  return this.dragTarget;
}, getDragCt:function() {
  return this.el;
}, getConstrainRegion:function() {
  var me = this;
  if (me.constrainTo) {
    if (me.constrainTo instanceof Ext.util.Region) {
      return me.constrainTo;
    }
    if (!me._constrainRegion) {
      me._constrainRegion = Ext.fly(me.constrainTo).getViewRegion();
    }
  } else {
    if (!me._constrainRegion) {
      me._constrainRegion = me.getDragCt().getViewRegion();
    }
  }
  return me._constrainRegion;
}, getXY:function(constrain) {
  return constrain ? this.constrainModes[constrain](this, this.lastXY) : this.lastXY;
}, getOffset:function(constrain) {
  var xy = this.getXY(constrain), s = this.startXY;
  return [xy[0] - s[0], xy[1] - s[1]];
}, constrainModes:{point:function(me, xy) {
  var dr = me.dragRegion, constrainTo = me.getConstrainRegion();
  if (!constrainTo) {
    return xy;
  }
  dr.x = dr.left = dr[0] = dr.right = xy[0];
  dr.y = dr.top = dr[1] = dr.bottom = xy[1];
  dr.constrainTo(constrainTo);
  return [dr.left, dr.top];
}, dragTarget:function(me, xy) {
  var s = me.startXY, dr = me.startRegion.copy(), constrainTo = me.getConstrainRegion(), adjust;
  if (!constrainTo) {
    return xy;
  }
  dr.translateBy(xy[0] - s[0], xy[1] - s[1]);
  if (dr.right > constrainTo.right) {
    xy[0] += adjust = constrainTo.right - dr.right;
    dr.left += adjust;
  }
  if (dr.left < constrainTo.left) {
    xy[0] += constrainTo.left - dr.left;
  }
  if (dr.bottom > constrainTo.bottom) {
    xy[1] += adjust = constrainTo.bottom - dr.bottom;
    dr.top += adjust;
  }
  if (dr.top < constrainTo.top) {
    xy[1] += constrainTo.top - dr.top;
  }
  return xy;
}}});
Ext.define('Ext.dd.DragZone', {extend:Ext.dd.DragSource, constructor:function(el, config) {
  var me = this, scroll = me.containerScroll;
  me.callParent([el, config]);
  if (scroll) {
    el = me.scrollEl || el;
    el = Ext.get(el);
    if (Ext.isObject(scroll)) {
      el.ddScrollConfig = scroll;
    }
    Ext.dd.ScrollManager.register(el);
  }
}, getDragData:function(e) {
  return Ext.dd.Registry.getHandleFromEvent(e);
}, onInitDrag:function(x, y) {
  this.proxy.update(this.dragData.ddel.cloneNode(true));
  this.onStartDrag(x, y);
  return true;
}, getRepairXY:function(e) {
  return Ext.fly(this.dragData.ddel).getXY();
}, destroy:function() {
  this.callParent();
  if (this.containerScroll) {
    Ext.dd.ScrollManager.unregister(this.scrollEl || this.el);
  }
}});
Ext.define('Ext.dd.ScrollManager', {singleton:true, constructor:function() {
  var ddm = Ext.dd.DragDropManager;
  ddm.fireEvents = Ext.Function.createSequence(ddm.fireEvents, this.onFire, this);
  ddm.stopDrag = Ext.Function.createSequence(ddm.stopDrag, this.onStop, this);
  this.doScroll = Ext.Function.bind(this.doScroll, this);
  this.ddmInstance = ddm;
  this.els = {};
  this.dragEl = null;
  this.proc = {};
}, onStop:function(e) {
  var sm = Ext.dd.ScrollManager;
  sm.dragEl = null;
  sm.clearProc();
}, triggerRefresh:function() {
  if (this.ddmInstance.dragCurrent) {
    this.ddmInstance.refreshCache(this.ddmInstance.dragCurrent.groups);
  }
}, doScroll:function() {
  if (this.ddmInstance.dragCurrent) {
    var proc = this.proc, procEl = proc.el, ddScrollConfig = proc.el.ddScrollConfig, inc = ddScrollConfig ? ddScrollConfig.increment : this.increment;
    if (!this.animate) {
      if (procEl.scroll(proc.dir, inc)) {
        this.triggerRefresh();
      }
    } else {
      procEl.scroll(proc.dir, inc, true, this.animDuration, this.triggerRefresh);
    }
  }
}, clearProc:function() {
  var proc = this.proc;
  if (proc.id) {
    clearInterval(proc.id);
  }
  proc.id = 0;
  proc.el = null;
  proc.dir = '';
}, startProc:function(el, dir) {
  this.clearProc();
  this.proc.el = el;
  this.proc.dir = dir;
  var group = el.ddScrollConfig ? el.ddScrollConfig.ddGroup : undefined, freq = el.ddScrollConfig && el.ddScrollConfig.frequency ? el.ddScrollConfig.frequency : this.frequency;
  if (group === undefined || this.ddmInstance.dragCurrent.ddGroup == group) {
    this.proc.id = setInterval(this.doScroll, freq);
  }
}, onFire:function(e, isDrop) {
  if (isDrop || !this.ddmInstance.dragCurrent) {
    return;
  }
  if (!this.dragEl || this.dragEl != this.ddmInstance.dragCurrent) {
    this.dragEl = this.ddmInstance.dragCurrent;
    this.refreshCache();
  }
  var xy = e.getXY(), pt = e.getPoint(), proc = this.proc, els = this.els, id, el, r, c;
  for (id in els) {
    el = els[id];
    r = el._region;
    c = el.ddScrollConfig ? el.ddScrollConfig : this;
    if (r && r.contains(pt) && el.isScrollable()) {
      if (r.bottom - pt.y <= c.vthresh) {
        if (proc.el != el) {
          this.startProc(el, 'down');
        }
        return;
      } else {
        if (r.right - pt.x <= c.hthresh) {
          if (proc.el != el) {
            this.startProc(el, 'left');
          }
          return;
        } else {
          if (pt.y - r.top <= c.vthresh) {
            if (proc.el != el) {
              this.startProc(el, 'up');
            }
            return;
          } else {
            if (pt.x - r.left <= c.hthresh) {
              if (proc.el != el) {
                this.startProc(el, 'right');
              }
              return;
            }
          }
        }
      }
    }
  }
  this.clearProc();
}, register:function(el) {
  if (Ext.isArray(el)) {
    for (var i = 0, len = el.length; i < len; i++) {
      this.register(el[i]);
    }
  } else {
    el = Ext.get(el);
    this.els[el.id] = el;
  }
}, unregister:function(el) {
  if (Ext.isArray(el)) {
    for (var i = 0, len = el.length; i < len; i++) {
      this.unregister(el[i]);
    }
  } else {
    el = Ext.get(el);
    delete this.els[el.id];
  }
}, vthresh:25, hthresh:25, increment:100, frequency:500, animate:true, animDuration:0.4, ddGroup:undefined, refreshCache:function() {
  var els = this.els, id;
  for (id in els) {
    if (typeof els[id] == 'object') {
      els[id]._region = els[id].getRegion();
    }
  }
}});
Ext.define('Ext.dd.DropTarget', {extend:Ext.dd.DDTarget, constructor:function(el, config) {
  this.el = Ext.get(el);
  Ext.apply(this, config);
  if (this.containerScroll) {
    Ext.dd.ScrollManager.register(this.el);
  }
  this.callParent([this.el.dom, this.ddGroup || this.group, {isTarget:true}]);
}, dropAllowed:Ext.baseCSSPrefix + 'dd-drop-ok', dropNotAllowed:Ext.baseCSSPrefix + 'dd-drop-nodrop', isTarget:true, isNotifyTarget:true, notifyEnter:function(dd, e, data) {
  if (this.overClass) {
    this.el.addCls(this.overClass);
  }
  return this.dropAllowed;
}, notifyOver:function(dd, e, data) {
  return this.dropAllowed;
}, notifyOut:function(dd, e, data) {
  if (this.overClass) {
    this.el.removeCls(this.overClass);
  }
}, notifyDrop:function(dd, e, data) {
  return false;
}, destroy:function() {
  this.callParent();
  if (this.containerScroll) {
    Ext.dd.ScrollManager.unregister(this.el);
  }
}});
Ext.define('Ext.dd.Registry', {singleton:true, constructor:function() {
  this.elements = {};
  this.handles = {};
  this.autoIdSeed = 0;
}, getId:function(el, autogen) {
  if (typeof el == 'string') {
    return el;
  }
  var id = el.id;
  if (!id && autogen !== false) {
    id = 'extdd-' + ++this.autoIdSeed;
    el.id = id;
  }
  return id;
}, register:function(el, data) {
  data = data || {};
  if (typeof el == 'string') {
    el = document.getElementById(el);
  }
  data.ddel = el;
  this.elements[this.getId(el)] = data;
  if (data.isHandle !== false) {
    this.handles[data.ddel.id] = data;
  }
  if (data.handles) {
    var hs = data.handles, i, len;
    for (i = 0, len = hs.length; i < len; i++) {
      this.handles[this.getId(hs[i])] = data;
    }
  }
}, unregister:function(el) {
  var id = this.getId(el, false), data = this.elements[id], hs, i, len;
  if (data) {
    delete this.elements[id];
    if (data.handles) {
      hs = data.handles;
      for (i = 0, len = hs.length; i < len; i++) {
        delete this.handles[this.getId(hs[i], false)];
      }
    }
  }
}, getHandle:function(id) {
  if (typeof id != 'string') {
    id = id.id;
  }
  return this.handles[id];
}, getHandleFromEvent:function(e) {
  var t = e.getTarget();
  return t ? this.handles[t.id] : null;
}, getTarget:function(id) {
  if (typeof id != 'string') {
    id = id.id;
  }
  return this.elements[id];
}, getTargetFromEvent:function(e) {
  var t = e.getTarget();
  return t ? this.elements[t.id] || this.handles[t.id] : null;
}});
Ext.define('Ext.dd.DropZone', {extend:Ext.dd.DropTarget, getTargetFromEvent:function(e) {
  return Ext.dd.Registry.getTargetFromEvent(e);
}, onNodeEnter:function(n, dd, e, data) {
}, onNodeOver:function(n, dd, e, data) {
  return this.dropAllowed;
}, onNodeOut:function(n, dd, e, data) {
}, onNodeDrop:function(n, dd, e, data) {
  return false;
}, onContainerOver:function(dd, e, data) {
  return this.dropNotAllowed;
}, onContainerDrop:function(dd, e, data) {
  return false;
}, notifyEnter:function(dd, e, data) {
  return this.dropNotAllowed;
}, notifyOver:function(dd, e, data) {
  var n = this.getTargetFromEvent(e);
  if (!n) {
    if (this.lastOverNode) {
      this.onNodeOut(this.lastOverNode, dd, e, data);
      this.lastOverNode = null;
    }
    return this.onContainerOver(dd, e, data);
  }
  if (this.lastOverNode != n) {
    if (this.lastOverNode) {
      this.onNodeOut(this.lastOverNode, dd, e, data);
    }
    this.onNodeEnter(n, dd, e, data);
    this.lastOverNode = n;
  }
  return this.onNodeOver(n, dd, e, data);
}, notifyOut:function(dd, e, data) {
  if (this.lastOverNode) {
    this.onNodeOut(this.lastOverNode, dd, e, data);
    this.lastOverNode = null;
  }
}, notifyDrop:function(dd, e, data) {
  var me = this, n = me.getTargetFromEvent(e), result = n ? me.onNodeDrop(n, dd, e, data) : me.onContainerDrop(dd, e, data);
  if (me.lastOverNode) {
    me.onNodeOut(me.lastOverNode, dd, e, data);
    me.lastOverNode = null;
  }
  return result;
}, triggerCacheRefresh:function() {
  Ext.dd.DDM.refreshCache(this.groups);
}});
Ext.define('Ext.dom.Layer', {extend:Ext.Element, alternateClassName:'Ext.Layer', statics:{shims:[]}, isLayer:true, localXYNames:{get:'getLocalXY', set:'setLocalXY'}, constructor:function(config, existingEl) {
  config = config || {};
  var me = this, dh = Ext.DomHelper, cp = config.parentEl, pel = cp ? Ext.getDom(cp) : document.body, hm = config.hideMode, cls = Ext.baseCSSPrefix + (config.fixed && !(Ext.isIE6 || Ext.isIEQuirks) ? 'fixed-layer' : 'layer');
  me.el = me;
  if (existingEl) {
    me.dom = Ext.getDom(existingEl);
  }
  if (!me.dom) {
    me.dom = dh.append(pel, config.dh || {tag:'div', cls:cls});
  } else {
    me.addCls(cls);
    if (!me.dom.parentNode) {
      pel.appendChild(me.dom);
    }
  }
  if (config.preventSync) {
    me.preventSync = true;
  }
  if (config.id) {
    me.id = me.dom.id = config.id;
  } else {
    me.id = Ext.id(me.dom);
  }
  Ext.Element.addToCache(me);
  if (config.cls) {
    me.addCls(config.cls);
  }
  me.constrain = config.constrain !== false;
  if (hm) {
    me.setVisibilityMode(Ext.Element[hm.toUpperCase()]);
    if (me.visibilityMode == Ext.Element.ASCLASS) {
      me.visibilityCls = config.visibilityCls;
    }
  } else {
    if (config.useDisplay) {
      me.setVisibilityMode(Ext.Element.DISPLAY);
    } else {
      me.setVisibilityMode(Ext.Element.VISIBILITY);
    }
  }
  if (config.shadow) {
    me.shadowOffset = config.shadowOffset || 4;
    me.shadow = new Ext.Shadow({offset:me.shadowOffset, mode:config.shadow, fixed:config.fixed});
    me.disableShadow();
  } else {
    me.shadowOffset = 0;
  }
  me.useShim = config.shim !== false && Ext.useShims;
  if (config.hidden === true) {
    me.hide();
  } else {
    me.show();
  }
}, getZIndex:function() {
  return parseInt((this.getShim() || this).getStyle('z-index'), 10);
}, getShim:function() {
  var me = this, shim, pn;
  if (!me.useShim) {
    return null;
  }
  if (!me.shim) {
    shim = me.self.shims.shift();
    if (!shim) {
      shim = me.createShim();
      shim.enableDisplayMode('block');
      shim.hide();
    }
    pn = me.dom.parentNode;
    if (shim.dom.parentNode != pn) {
      pn.insertBefore(shim.dom, me.dom);
    }
    me.shim = shim;
  }
  return me.shim;
}, hideShim:function() {
  var me = this;
  if (me.shim) {
    me.shim.setDisplayed(false);
    me.self.shims.push(me.shim);
    delete me.shim;
  }
}, disableShadow:function() {
  var me = this;
  if (me.shadow && !me.shadowDisabled) {
    me.shadowDisabled = true;
    me.shadow.hide();
    me.lastShadowOffset = me.shadowOffset;
    me.shadowOffset = 0;
  }
}, enableShadow:function(show) {
  var me = this;
  if (me.shadow && me.shadowDisabled) {
    me.shadowDisabled = false;
    me.shadowOffset = me.lastShadowOffset;
    delete me.lastShadowOffset;
    if (show) {
      me.sync(true);
    }
  }
}, sync:function(doShow) {
  var me = this, shadow = me.shadow, shadowPos, shimStyle, shadowSize, shim, xy, x, y, w, h, shimIndex;
  if (me.preventSync) {
    return;
  }
  if (!me.updating && me.isVisible() && (shadow || me.useShim)) {
    shim = me.getShim();
    xy = me[me.localXYNames.get]();
    x = xy[0];
    y = xy[1];
    w = me.dom.offsetWidth;
    h = me.dom.offsetHeight;
    if (shadow && !me.shadowDisabled) {
      if (doShow && !shadow.isVisible()) {
        shadow.show(me);
      } else {
        shadow.realign(x, y, w, h);
      }
      if (shim) {
        shimIndex = shim.getStyle('z-index');
        if (shimIndex > me.zindex) {
          me.shim.setStyle('z-index', me.zindex - 2);
        }
        shim.show();
        if (shadow.isVisible()) {
          shadowPos = shadow.el.getXY();
          shimStyle = shim.dom.style;
          shadowSize = shadow.el.getSize();
          if (Ext.supports.CSS3BoxShadow) {
            shadowSize.height += 6;
            shadowSize.width += 4;
            shadowPos[0] -= 2;
            shadowPos[1] -= 4;
          }
          shimStyle.left = shadowPos[0] + 'px';
          shimStyle.top = shadowPos[1] + 'px';
          shimStyle.width = shadowSize.width + 'px';
          shimStyle.height = shadowSize.height + 'px';
        } else {
          shim.setSize(w, h);
          shim[me.localXYNames.set](x, y);
        }
      }
    } else {
      if (shim) {
        shimIndex = shim.getStyle('z-index');
        if (shimIndex > me.zindex) {
          me.shim.setStyle('z-index', me.zindex - 2);
        }
        shim.show();
        shim.setSize(w, h);
        shim[me.localXYNames.set](x, y);
      }
    }
  }
  return me;
}, remove:function() {
  this.hideUnders();
  this.callParent();
}, beginUpdate:function() {
  this.updating = true;
}, endUpdate:function() {
  this.updating = false;
  this.sync(true);
}, hideUnders:function() {
  if (this.shadow) {
    this.shadow.hide();
  }
  this.hideShim();
}, constrainXY:function() {
  if (this.constrain) {
    var vw = Ext.Element.getViewWidth(), vh = Ext.Element.getViewHeight(), s = Ext.getDoc().getScroll(), xy = this.getXY(), x = xy[0], y = xy[1], so = this.shadowOffset, w = this.dom.offsetWidth + so, h = this.dom.offsetHeight + so, moved = false;
    if (x + w > vw + s.left) {
      x = vw - w - so;
      moved = true;
    }
    if (y + h > vh + s.top) {
      y = vh - h - so;
      moved = true;
    }
    if (x < s.left) {
      x = s.left;
      moved = true;
    }
    if (y < s.top) {
      y = s.top;
      moved = true;
    }
    if (moved) {
      Ext.Layer.superclass.setXY.call(this, [x, y]);
      this.sync();
    }
  }
  return this;
}, getConstrainOffset:function() {
  return this.shadowOffset;
}, setVisible:function(visible, animate, duration, callback, easing) {
  var me = this, cb;
  cb = function() {
    if (visible) {
      me.sync(true);
    }
    if (callback) {
      callback();
    }
  };
  if (!visible) {
    me.hideUnders(true);
  }
  me.callParent([visible, animate, duration, callback, easing]);
  if (!animate) {
    cb();
  }
  return me;
}, beforeFx:function() {
  this.beforeAction();
  return this.callParent(arguments);
}, afterFx:function() {
  this.callParent(arguments);
  this.sync(this.isVisible());
}, beforeAction:function() {
  if (!this.updating && this.shadow) {
    this.shadow.hide();
  }
}, setLeft:function(left) {
  this.callParent(arguments);
  return this.sync();
}, setTop:function(top) {
  this.callParent(arguments);
  return this.sync();
}, setLeftTop:function(left, top) {
  this.callParent(arguments);
  return this.sync();
}, setLocalX:function() {
  this.callParent(arguments);
  return this.sync();
}, setLocalXY:function() {
  this.callParent(arguments);
  return this.sync();
}, setLocalY:function() {
  this.callParent(arguments);
  return this.sync();
}, setXY:function(xy, animate, duration, callback, easing) {
  var me = this;
  callback = me.createCB(callback);
  me.fixDisplay();
  me.beforeAction();
  me.callParent([xy, animate, duration, callback, easing]);
  if (!animate) {
    callback();
  }
  return me;
}, createCB:function(callback) {
  var me = this, showShadow = me.shadow && me.shadow.isVisible();
  return function() {
    me.constrainXY();
    me.sync(showShadow);
    if (callback) {
      callback();
    }
  };
}, setX:function(x, animate, duration, callback, easing) {
  this.setXY([x, this.getY()], animate, duration, callback, easing);
  return this;
}, setY:function(y, animate, duration, callback, easing) {
  this.setXY([this.getX(), y], animate, duration, callback, easing);
  return this;
}, setSize:function(w, h, animate, duration, callback, easing) {
  var me = this;
  callback = me.createCB(callback);
  me.beforeAction();
  me.callParent([w, h, animate, duration, callback, easing]);
  if (!animate) {
    callback();
  }
  return me;
}, setWidth:function(w, animate, duration, callback, easing) {
  var me = this;
  callback = me.createCB(callback);
  me.beforeAction();
  me.callParent([w, animate, duration, callback, easing]);
  if (!animate) {
    callback();
  }
  return me;
}, setHeight:function(h, animate, duration, callback, easing) {
  var me = this;
  callback = me.createCB(callback);
  me.beforeAction();
  me.callParent([h, animate, duration, callback, easing]);
  if (!animate) {
    callback();
  }
  return me;
}, setBounds:function(x, y, width, height, animate, duration, callback, easing) {
  var me = this;
  callback = me.createCB(callback);
  me.beforeAction();
  if (!animate) {
    Ext.Layer.superclass.setXY.call(me, [x, y]);
    Ext.Layer.superclass.setSize.call(me, width, height);
    callback();
  } else {
    me.callParent([x, y, width, height, animate, duration, callback, easing]);
  }
  return me;
}, setZIndex:function(zindex) {
  var me = this;
  me.zindex = zindex;
  if (me.getShim()) {
    me.shim.setStyle('z-index', zindex++);
  }
  if (me.shadow) {
    me.shadow.setZIndex(zindex++);
  }
  return me.setStyle('z-index', zindex);
}, onOpacitySet:function(opacity) {
  var shadow = this.shadow;
  if (shadow) {
    shadow.setOpacity(opacity);
  }
}});
Ext.define('Ext.util.ComponentDragger', {extend:Ext.dd.DragTracker, autoStart:500, constructor:function(comp, config) {
  this.comp = comp;
  this.initialConstrainTo = config.constrainTo;
  this.callParent([config]);
}, onStart:function(e) {
  var me = this, comp = me.comp;
  me.startPosition = comp.getXY();
  if (comp.ghost && !comp.liveDrag) {
    me.proxy = comp.ghost();
    me.dragTarget = me.proxy.header.el;
  }
  if (me.constrain || me.constrainDelegate) {
    me.constrainTo = me.calculateConstrainRegion();
  }
  if (comp.beginDrag) {
    comp.beginDrag();
  }
}, calculateConstrainRegion:function() {
  var me = this, comp = me.comp, constrainTo = me.initialConstrainTo, constraintInsets = comp.constraintInsets, constrainEl, delegateRegion, elRegion, dragEl = me.proxy ? me.proxy.el : comp.el, shadowSize = !me.constrainDelegate && dragEl.shadow && comp.constrainShadow && !dragEl.shadowDisabled ? dragEl.shadow.getShadowSize() : 0;
  if (!(constrainTo instanceof Ext.util.Region)) {
    constrainEl = Ext.fly(constrainTo);
    constrainTo = constrainEl.getViewRegion();
    constrainTo.right = constrainTo.left + constrainEl.dom.clientWidth;
  } else {
    constrainTo = constrainTo.copy();
  }
  if (constraintInsets) {
    constraintInsets = Ext.isObject(constraintInsets) ? constraintInsets : Ext.Element.parseBox(constraintInsets);
    constrainTo.adjust(constraintInsets.top, constraintInsets.right, constraintInsets.bottom, constraintInsets.length);
  }
  if (shadowSize) {
    constrainTo.adjust(shadowSize[0], -shadowSize[1], -shadowSize[2], shadowSize[3]);
  }
  if (!me.constrainDelegate) {
    delegateRegion = Ext.fly(me.dragTarget).getRegion();
    elRegion = dragEl.getRegion();
    constrainTo.adjust(delegateRegion.top - elRegion.top, delegateRegion.right - elRegion.right, delegateRegion.bottom - elRegion.bottom, delegateRegion.left - elRegion.left);
  }
  return constrainTo;
}, onDrag:function(e) {
  var me = this, comp = me.proxy && !me.comp.liveDrag ? me.proxy : me.comp, offset = me.getOffset(me.constrain || me.constrainDelegate ? 'dragTarget' : null);
  comp.setPagePosition(me.startPosition[0] + offset[0], me.startPosition[1] + offset[1]);
}, onEnd:function(e) {
  var comp = this.comp;
  if (comp.isDestroyed || comp.destroying) {
    return;
  }
  if (this.proxy && !comp.liveDrag) {
    comp.unghost();
  }
  if (comp.endDrag) {
    comp.endDrag();
  }
}});
Ext.define('Ext.window.Window', {extend:Ext.panel.Panel, alternateClassName:'Ext.Window', alias:'widget.window', baseCls:Ext.baseCSSPrefix + 'window', resizable:true, draggable:true, constrain:false, constrainHeader:false, plain:false, minimizable:false, maximizable:false, minHeight:50, minWidth:50, expandOnShow:true, collapsible:false, closable:true, hidden:true, autoRender:true, hideMode:'offsets', floating:true, itemCls:Ext.baseCSSPrefix + 'window-item', initialAlphaNum:/^[a-z0-9]/, overlapHeader:true, 
ignoreHeaderBorderManagement:true, alwaysFramed:true, isRootCfg:{isRoot:true}, isWindow:true, initComponent:function() {
  var me = this;
  me.frame = false;
  me.callParent();
  me.addEvents('resize', 'maximize', 'minimize', 'restore');
  if (me.plain) {
    me.addClsWithUI('plain');
  }
  if (me.modal) {
    me.ariaRole = 'dialog';
  }
  me.addStateEvents(['maximize', 'restore', 'resize', 'dragend']);
}, getElConfig:function() {
  var me = this, elConfig;
  elConfig = me.callParent();
  elConfig.tabIndex = -1;
  return elConfig;
}, getState:function() {
  var me = this, state = me.callParent() || {}, maximized = !!me.maximized, ghostBox = me.ghostBox, pos;
  state.maximized = maximized;
  if (maximized) {
    pos = me.restorePos;
  } else {
    if (ghostBox) {
      pos = [ghostBox.x, ghostBox.y];
    } else {
      pos = me.getPosition();
    }
  }
  Ext.apply(state, {size:maximized ? me.restoreSize : me.getSize(), pos:pos});
  return state;
}, applyState:function(state) {
  var me = this;
  if (state) {
    me.maximized = state.maximized;
    if (me.maximized) {
      me.hasSavedRestore = true;
      me.restoreSize = state.size;
      me.restorePos = state.pos;
    } else {
      Ext.apply(me, {width:state.size.width, height:state.size.height, x:state.pos[0], y:state.pos[1]});
    }
  }
}, onRender:function(ct, position) {
  var me = this;
  me.callParent(arguments);
  me.focusEl = me.el;
  if (me.maximizable) {
    me.header.on({scope:me, dblclick:me.toggleMaximize});
  }
}, afterRender:function() {
  var me = this, header = me.header, keyMap;
  me.callParent();
  if (me.maximized) {
    me.maximized = false;
    me.maximize();
    if (header) {
      header.removeCls(header.indicateDragCls);
    }
  }
  if (me.closable) {
    keyMap = me.getKeyMap();
    keyMap.on(27, me.onEsc, me);
  } else {
    keyMap = me.keyMap;
  }
  if (keyMap && me.hidden) {
    keyMap.disable();
  }
}, initDraggable:function() {
  this.initSimpleDraggable();
}, initResizable:function() {
  this.callParent(arguments);
  if (this.maximized) {
    this.resizer.disable();
  }
}, onEsc:function(k, e) {
  if (!Ext.FocusManager || !Ext.FocusManager.enabled || Ext.FocusManager.focusedCmp === this) {
    e.stopEvent();
    this.close();
  }
}, beforeDestroy:function() {
  var me = this;
  if (me.rendered) {
    delete this.animateTarget;
    me.hide();
    Ext.destroy(me.keyMap);
  }
  me.callParent();
}, addTools:function() {
  var me = this;
  me.callParent();
  if (me.minimizable) {
    me.addTool({type:'minimize', handler:Ext.Function.bind(me.minimize, me, [])});
  }
  if (me.maximizable) {
    me.addTool({type:'maximize', handler:Ext.Function.bind(me.maximize, me, [])});
    me.addTool({type:'restore', handler:Ext.Function.bind(me.restore, me, []), hidden:true});
  }
}, getFocusEl:function() {
  return this.getDefaultFocus();
}, getDefaultFocus:function() {
  var me = this, result, defaultComp = me.defaultButton || me.defaultFocus, selector;
  if (defaultComp !== undefined) {
    if (Ext.isNumber(defaultComp)) {
      result = me.query('button')[defaultComp];
    } else {
      if (Ext.isString(defaultComp)) {
        selector = defaultComp;
        if (selector.match(me.initialAlphaNum)) {
          result = me.down('#' + selector);
        }
        if (!result) {
          result = me.down(selector);
        }
      } else {
        if (defaultComp.focus) {
          result = defaultComp;
        }
      }
    }
  }
  return result || me.el;
}, onFocus:function() {
  var me = this, focusDescendant;
  if (Ext.FocusManager && Ext.FocusManager.enabled || (focusDescendant = me.getDefaultFocus()) === me) {
    me.callParent(arguments);
  } else {
    focusDescendant.focus();
  }
}, onShow:function() {
  var me = this;
  me.callParent(arguments);
  if (me.expandOnShow) {
    me.expand(false);
  }
  me.syncMonitorWindowResize();
  if (me.keyMap) {
    me.keyMap.enable();
  }
}, doClose:function() {
  var me = this;
  if (me.hidden) {
    me.fireEvent('close', me);
    if (me.closeAction == 'destroy') {
      this.destroy();
    }
  } else {
    me.hide(me.animateTarget, me.doClose, me);
  }
}, afterHide:function() {
  var me = this;
  me.syncMonitorWindowResize();
  if (me.keyMap) {
    me.keyMap.disable();
  }
  me.callParent(arguments);
}, onWindowResize:function() {
  var me = this, sizeModel;
  if (me.maximized) {
    me.fitContainer();
  } else {
    sizeModel = me.getSizeModel();
    if (sizeModel.width.natural || sizeModel.height.natural) {
      me.updateLayout();
    }
    me.doConstrain();
  }
}, minimize:function() {
  this.fireEvent('minimize', this);
  return this;
}, resumeHeaderLayout:function(changed) {
  this.header.resumeLayouts(changed ? this.isRootCfg : null);
}, afterCollapse:function() {
  var me = this, header = me.header, tools = me.tools;
  if (header && me.maximizable) {
    header.suspendLayouts();
    tools.maximize.hide();
    tools.restore.hide();
    this.resumeHeaderLayout(true);
  }
  if (me.resizer) {
    me.resizer.disable();
  }
  me.callParent(arguments);
}, afterExpand:function() {
  var me = this, header = me.header, tools = me.tools, changed;
  if (header) {
    header.suspendLayouts();
    if (me.maximized) {
      tools.restore.show();
      changed = true;
    } else {
      if (me.maximizable) {
        tools.maximize.show();
        changed = true;
      }
    }
    this.resumeHeaderLayout(changed);
  }
  if (me.resizer) {
    me.resizer.enable();
  }
  me.callParent(arguments);
}, maximize:function(animate) {
  var me = this, header = me.header, tools = me.tools, changed;
  if (!me.maximized) {
    me.expand(false);
    if (!me.hasSavedRestore) {
      me.restoreSize = me.getSize();
      me.restorePos = me.getPosition(true);
    }
    if (header) {
      header.suspendLayouts();
      if (tools.maximize) {
        tools.maximize.hide();
        changed = true;
      }
      if (tools.restore) {
        tools.restore.show();
        changed = true;
      }
      if (me.collapseTool) {
        me.collapseTool.hide();
        changed = true;
      }
      me.resumeHeaderLayout(changed);
    }
    me.maximized = true;
    me.el.disableShadow();
    if (me.dd) {
      me.dd.disable();
      if (header) {
        header.removeCls(header.indicateDragCls);
      }
    }
    if (me.resizer) {
      me.resizer.disable();
    }
    me.el.addCls(Ext.baseCSSPrefix + 'window-maximized');
    me.container.addCls(Ext.baseCSSPrefix + 'window-maximized-ct');
    me.syncMonitorWindowResize();
    me.fitContainer(animate = animate || !!me.animateTarget ? {callback:function() {
      me.fireEvent('maximize', me);
    }} : null);
    if (!animate) {
      me.fireEvent('maximize', me);
    }
  }
  return me;
}, restore:function(animate) {
  var me = this, tools = me.tools, header = me.header, newBox = me.restoreSize, changed;
  if (me.maximized) {
    me.hasSavedRestore = null;
    me.removeCls(Ext.baseCSSPrefix + 'window-maximized');
    if (header) {
      header.suspendLayouts();
      if (tools.restore) {
        tools.restore.hide();
        changed = true;
      }
      if (tools.maximize) {
        tools.maximize.show();
        changed = true;
      }
      if (me.collapseTool) {
        me.collapseTool.show();
        changed = true;
      }
      me.resumeHeaderLayout(changed);
    }
    me.maximized = false;
    newBox.x = me.restorePos[0];
    newBox.y = me.restorePos[1];
    me.setBox(newBox, animate = animate || !!me.animateTarget ? {callback:function() {
      me.el.enableShadow(true);
      me.fireEvent('restore', me);
    }} : null);
    me.restorePos = me.restoreSize = null;
    if (me.dd) {
      me.dd.enable();
      if (header) {
        header.addCls(header.indicateDragCls);
      }
    }
    if (me.resizer) {
      me.resizer.enable();
    }
    me.container.removeCls(Ext.baseCSSPrefix + 'window-maximized-ct');
    me.syncMonitorWindowResize();
    if (!animate) {
      me.el.enableShadow(true);
      me.fireEvent('restore', me);
    }
  }
  return me;
}, syncMonitorWindowResize:function() {
  var me = this, currentlyMonitoring = me._monitoringResize, yes = me.monitorResize || me.constrain || me.constrainHeader || me.maximized, veto = me.hidden || me.destroying || me.isDestroyed;
  if (yes && !veto) {
    if (!currentlyMonitoring) {
      Ext.EventManager.onWindowResize(me.onWindowResize, me, {delay:1});
      me._monitoringResize = true;
    }
  } else {
    if (currentlyMonitoring) {
      Ext.EventManager.removeResizeListener(me.onWindowResize, me);
      me._monitoringResize = false;
    }
  }
}, toggleMaximize:function() {
  return this[this.maximized ? 'restore' : 'maximize']();
}});
Ext.define('Ext.form.Labelable', {autoEl:{tag:'table', cellpadding:0}, childEls:['labelCell', 'labelEl', 'bodyEl', 'sideErrorCell', 'errorEl', 'inputRow'], labelableRenderTpl:['\x3ctr role\x3d"presentation" id\x3d"{id}-inputRow" \x3ctpl if\x3d"inFormLayout"\x3eid\x3d"{id}"\x3c/tpl\x3e class\x3d"{inputRowCls}"\x3e', '\x3ctpl if\x3d"labelOnLeft"\x3e', '\x3ctd role\x3d"presentation" id\x3d"{id}-labelCell" style\x3d"{labelCellStyle}" {labelCellAttrs}\x3e', '{beforeLabelTpl}', '\x3clabel id\x3d"{id}-labelEl" {labelAttrTpl}\x3ctpl if\x3d"inputId"\x3e for\x3d"{inputId}"\x3c/tpl\x3e class\x3d"{labelCls}"', 
'\x3ctpl if\x3d"labelStyle"\x3e style\x3d"{labelStyle}"\x3c/tpl\x3e', ' unselectable\x3d"on"', '\x3e', '{beforeLabelTextTpl}', '\x3ctpl if\x3d"fieldLabel"\x3e{fieldLabel}{labelSeparator}\x3c/tpl\x3e', '{afterLabelTextTpl}', '\x3c/label\x3e', '{afterLabelTpl}', '\x3c/td\x3e', '\x3c/tpl\x3e', '\x3ctd role\x3d"presentation" class\x3d"{baseBodyCls} {fieldBodyCls} {extraFieldBodyCls}" id\x3d"{id}-bodyEl" colspan\x3d"{bodyColspan}" role\x3d"presentation"\x3e', '{beforeBodyEl}', '\x3ctpl if\x3d"labelAlign\x3d\x3d\'top\'"\x3e', 
'{beforeLabelTpl}', '\x3cdiv role\x3d"presentation" id\x3d"{id}-labelCell" style\x3d"{labelCellStyle}"\x3e', '\x3clabel id\x3d"{id}-labelEl" {labelAttrTpl}\x3ctpl if\x3d"inputId"\x3e for\x3d"{inputId}"\x3c/tpl\x3e class\x3d"{labelCls}"', '\x3ctpl if\x3d"labelStyle"\x3e style\x3d"{labelStyle}"\x3c/tpl\x3e', ' unselectable\x3d"on"', '\x3e', '{beforeLabelTextTpl}', '\x3ctpl if\x3d"fieldLabel"\x3e{fieldLabel}{labelSeparator}\x3c/tpl\x3e', '{afterLabelTextTpl}', '\x3c/label\x3e', '\x3c/div\x3e', '{afterLabelTpl}', 
'\x3c/tpl\x3e', '{beforeSubTpl}', '{[values.$comp.getSubTplMarkup(values)]}', '{afterSubTpl}', '\x3ctpl if\x3d"msgTarget\x3d\x3d\x3d\'side\'"\x3e', '{afterBodyEl}', '\x3c/td\x3e', '\x3ctd role\x3d"presentation" id\x3d"{id}-sideErrorCell" vAlign\x3d"{[values.labelAlign\x3d\x3d\x3d\'top\' \x26\x26 !values.hideLabel ? \'bottom\' : \'middle\']}" style\x3d"{[values.autoFitErrors ? \'display:none\' : \'\']}" width\x3d"{errorIconWidth}"\x3e', '\x3cdiv role\x3d"presentation" id\x3d"{id}-errorEl" class\x3d"{errorMsgCls}" style\x3d"display:none"\x3e\x3c/div\x3e', 
'\x3c/td\x3e', '\x3ctpl elseif\x3d"msgTarget\x3d\x3d\'under\'"\x3e', '\x3cdiv role\x3d"presentation" id\x3d"{id}-errorEl" class\x3d"{errorMsgClass}" colspan\x3d"2" style\x3d"display:none"\x3e\x3c/div\x3e', '{afterBodyEl}', '\x3c/td\x3e', '\x3c/tpl\x3e', '\x3c/tr\x3e', {disableFormats:true}], activeErrorsTpl:undefined, htmlActiveErrorsTpl:['\x3ctpl if\x3d"errors \x26\x26 errors.length"\x3e', '\x3cul class\x3d"{listCls}"\x3e\x3ctpl for\x3d"errors"\x3e\x3cli role\x3d"alert"\x3e{.}\x3c/li\x3e\x3c/tpl\x3e\x3c/ul\x3e', 
'\x3c/tpl\x3e'], plaintextActiveErrorsTpl:['\x3ctpl if\x3d"errors \x26\x26 errors.length"\x3e', '\x3ctpl for\x3d"errors"\x3e\x3ctpl if\x3d"xindex \x26gt; 1"\x3e\n\x3c/tpl\x3e{.}\x3c/tpl\x3e', '\x3c/tpl\x3e'], isFieldLabelable:true, formItemCls:Ext.baseCSSPrefix + 'form-item', labelCls:Ext.baseCSSPrefix + 'form-item-label', errorMsgCls:Ext.baseCSSPrefix + 'form-error-msg', baseBodyCls:Ext.baseCSSPrefix + 'form-item-body', inputRowCls:Ext.baseCSSPrefix + 'form-item-input-row', fieldBodyCls:'', clearCls:Ext.baseCSSPrefix + 
'clear', invalidCls:Ext.baseCSSPrefix + 'form-invalid', fieldLabel:undefined, labelAlign:'left', labelWidth:100, labelPad:5, labelSeparator:':', hideLabel:false, hideEmptyLabel:true, preventMark:false, autoFitErrors:true, msgTarget:'qtip', noWrap:true, labelableInsertions:['beforeBodyEl', 'afterBodyEl', 'beforeLabelTpl', 'afterLabelTpl', 'beforeSubTpl', 'afterSubTpl', 'beforeLabelTextTpl', 'afterLabelTextTpl', 'labelAttrTpl'], labelableRenderProps:['allowBlank', 'id', 'labelAlign', 'fieldBodyCls', 
'extraFieldBodyCls', 'baseBodyCls', 'clearCls', 'labelSeparator', 'msgTarget', 'inputRowCls'], initLabelable:function() {
  var me = this, padding = me.padding;
  if (padding) {
    me.padding = undefined;
    me.extraMargins = Ext.Element.parseBox(padding);
  }
  if (!me.activeErrorsTpl) {
    if (me.msgTarget == 'title') {
      me.activeErrorsTpl = me.plaintextActiveErrorsTpl;
    } else {
      me.activeErrorsTpl = me.htmlActiveErrorsTpl;
    }
  }
  me.addCls(Ext.plainTableCls);
  me.addCls(me.formItemCls);
  me.lastActiveError = '';
  me.addEvents('errorchange');
  me.enableBubble('errorchange');
}, trimLabelSeparator:function() {
  var me = this, separator = me.labelSeparator, label = me.fieldLabel || '', lastChar = label.substr(label.length - 1);
  return lastChar === separator ? label.slice(0, -1) : label;
}, getFieldLabel:function() {
  return this.trimLabelSeparator();
}, setFieldLabel:function(label) {
  label = label || '';
  var me = this, separator = me.labelSeparator, labelEl = me.labelEl;
  me.fieldLabel = label;
  if (me.rendered) {
    if (Ext.isEmpty(label) && me.hideEmptyLabel) {
      labelEl.parent().setDisplayed('none');
    } else {
      if (separator) {
        label = me.trimLabelSeparator() + separator;
      }
      labelEl.update(label);
      labelEl.parent().setDisplayed('');
    }
    me.updateLayout();
  }
}, getInsertionRenderData:function(data, names) {
  var i = names.length, name, value;
  while (i--) {
    name = names[i];
    value = this[name];
    if (value) {
      if (typeof value != 'string') {
        if (!value.isTemplate) {
          value = Ext.XTemplate.getTpl(this, name);
        }
        value = value.apply(data);
      }
    }
    data[name] = value || '';
  }
  return data;
}, getLabelableRenderData:function() {
  var me = this, data, tempEl, topLabel = me.labelAlign === 'top';
  if (!Ext.form.Labelable.errorIconWidth) {
    tempEl = Ext.getBody().createChild({style:'position:absolute', cls:Ext.baseCSSPrefix + 'form-invalid-icon'});
    Ext.form.Labelable.errorIconWidth = tempEl.getWidth() + tempEl.getMargin('l');
    tempEl.remove();
  }
  data = Ext.copyTo({inFormLayout:me.ownerLayout && me.ownerLayout.type === 'form', inputId:me.getInputId(), labelOnLeft:!topLabel, hideLabel:!me.hasVisibleLabel(), fieldLabel:me.getFieldLabel(), labelCellStyle:me.getLabelCellStyle(), labelCellAttrs:me.getLabelCellAttrs(), labelCls:me.getLabelCls(), labelStyle:me.getLabelStyle(), bodyColspan:me.getBodyColspan(), externalError:!me.autoFitErrors, errorMsgCls:me.getErrorMsgCls(), errorIconWidth:Ext.form.Labelable.errorIconWidth}, me, me.labelableRenderProps, 
  true);
  me.getInsertionRenderData(data, me.labelableInsertions);
  return data;
}, xhooks:{beforeRender:function() {
  var me = this;
  me.setFieldDefaults(me.getHierarchyState().fieldDefaults);
  if (me.ownerLayout) {
    me.addCls(Ext.baseCSSPrefix + me.ownerLayout.type + '-form-item');
  }
}, onRender:function() {
  var me = this, margins, side, style = {};
  if (me.extraMargins) {
    margins = me.el.getMargin();
    for (side in margins) {
      if (margins.hasOwnProperty(side)) {
        style['margin-' + side] = margins[side] + me.extraMargins[side] + 'px';
      }
    }
    me.el.setStyle(style);
  }
}}, hasVisibleLabel:function() {
  if (this.hideLabel) {
    return false;
  }
  return !(this.hideEmptyLabel && !this.getFieldLabel());
}, getLabelWidth:function() {
  var me = this;
  if (!me.hasVisibleLabel()) {
    return 0;
  }
  return me.labelWidth + me.labelPad;
}, getBodyColspan:function() {
  var me = this, result;
  if (me.msgTarget === 'side' && (!me.autoFitErrors || me.hasActiveError())) {
    result = 1;
  } else {
    result = 2;
  }
  if (me.labelAlign !== 'top' && !me.hasVisibleLabel()) {
    result++;
  }
  return result;
}, getLabelCls:function() {
  var labelCls = this.labelCls + ' ' + Ext.dom.Element.unselectableCls, labelClsExtra = this.labelClsExtra;
  return labelClsExtra ? labelCls + ' ' + labelClsExtra : labelCls;
}, getLabelCellStyle:function() {
  var me = this, hideLabelCell = me.hideLabel || !me.getFieldLabel() && me.hideEmptyLabel;
  return hideLabelCell ? 'display:none;' : '';
}, getErrorMsgCls:function() {
  var me = this, hideLabelCell = me.hideLabel || !me.fieldLabel && me.hideEmptyLabel;
  return me.errorMsgCls + (!hideLabelCell && me.labelAlign === 'top' ? ' ' + Ext.baseCSSPrefix + 'lbl-top-err-icon' : '');
}, getLabelCellAttrs:function() {
  var me = this, labelAlign = me.labelAlign, result = '';
  if (labelAlign !== 'top') {
    result = 'valign\x3d"top" halign\x3d"' + labelAlign + '" width\x3d"' + (me.labelWidth + me.labelPad) + '"';
  }
  return result + ' class\x3d"' + Ext.baseCSSPrefix + 'field-label-cell"';
}, getLabelStyle:function() {
  var me = this, labelPad = me.labelPad, labelStyle = '';
  if (me.labelAlign !== 'top') {
    if (me.labelWidth) {
      labelStyle = 'width:' + me.labelWidth + 'px;';
    }
    if (labelPad) {
      labelStyle += 'margin-right:' + labelPad + 'px;';
    }
  }
  return labelStyle + (me.labelStyle || '');
}, getSubTplMarkup:function() {
  return '';
}, getInputId:function() {
  return '';
}, getActiveError:function() {
  return this.activeError || '';
}, hasActiveError:function() {
  return !!this.getActiveError();
}, setActiveError:function(msg) {
  this.setActiveErrors(msg);
}, getActiveErrors:function() {
  return this.activeErrors || [];
}, setActiveErrors:function(errors) {
  errors = Ext.Array.from(errors);
  this.activeError = errors[0];
  this.activeErrors = errors;
  this.activeError = this.getTpl('activeErrorsTpl').apply({errors:errors, listCls:Ext.plainListCls});
  this.renderActiveError();
}, unsetActiveError:function() {
  delete this.activeError;
  delete this.activeErrors;
  this.renderActiveError();
}, renderActiveError:function() {
  var me = this, activeError = me.getActiveError(), hasError = !!activeError;
  if (activeError !== me.lastActiveError) {
    me.fireEvent('errorchange', me, activeError);
    me.lastActiveError = activeError;
  }
  if (me.rendered && !me.isDestroyed && !me.preventMark) {
    me.el[hasError ? 'addCls' : 'removeCls'](me.invalidCls);
    me.getActionEl().dom.setAttribute('aria-invalid', hasError);
    if (me.errorEl) {
      me.errorEl.dom.innerHTML = activeError;
    }
  }
}, setFieldDefaults:function(defaults) {
  var key;
  for (key in defaults) {
    if (!this.hasOwnProperty(key)) {
      this[key] = defaults[key];
    }
  }
}});
Ext.define('Ext.form.field.Field', {isFormField:true, disabled:false, submitValue:true, validateOnChange:true, suspendCheckChange:0, initField:function() {
  this.addEvents('change', 'validitychange', 'dirtychange');
  this.initValue();
  var badNames = ['tagName', 'nodeName', 'children', 'childNodes'], name = this.name;
  if (name && Ext.Array.indexOf(badNames, name) > -1) {
    Ext.log.warn(['It is recommended to not use "', name, '" as a field name, because it ', 'can cause naming collisions during form submission.'].join(''));
  }
}, initValue:function() {
  var me = this;
  me.value = me.transformOriginalValue(me.value);
  me.originalValue = me.lastValue = me.value;
  me.suspendCheckChange++;
  me.setValue(me.value);
  me.suspendCheckChange--;
}, transformOriginalValue:Ext.identityFn, getName:function() {
  return this.name;
}, getValue:function() {
  return this.value;
}, setValue:function(value) {
  var me = this;
  me.value = value;
  me.checkChange();
  return me;
}, isEqual:function(value1, value2) {
  return String(value1) === String(value2);
}, isEqualAsString:function(value1, value2) {
  return String(Ext.value(value1, '')) === String(Ext.value(value2, ''));
}, getSubmitData:function() {
  var me = this, data = null;
  if (!me.disabled && me.submitValue && !me.isFileUpload()) {
    data = {};
    data[me.getName()] = '' + me.getValue();
  }
  return data;
}, getModelData:function() {
  var me = this, data = null;
  if (!me.disabled && !me.isFileUpload()) {
    data = {};
    data[me.getName()] = me.getValue();
  }
  return data;
}, reset:function() {
  var me = this;
  me.beforeReset();
  me.setValue(me.originalValue);
  me.clearInvalid();
  delete me.wasValid;
}, beforeReset:Ext.emptyFn, resetOriginalValue:function() {
  this.originalValue = this.getValue();
  this.checkDirty();
}, checkChange:function() {
  if (!this.suspendCheckChange) {
    var me = this, newVal = me.getValue(), oldVal = me.lastValue;
    if (!me.isEqual(newVal, oldVal) && !me.isDestroyed) {
      me.lastValue = newVal;
      me.fireEvent('change', me, newVal, oldVal);
      me.onChange(newVal, oldVal);
    }
  }
}, onChange:function(newVal, oldVal) {
  if (this.validateOnChange) {
    this.validate();
  }
  this.checkDirty();
}, isDirty:function() {
  var me = this;
  return !me.disabled && !me.isEqual(me.getValue(), me.originalValue);
}, checkDirty:function() {
  var me = this, isDirty = me.isDirty();
  if (isDirty !== me.wasDirty) {
    me.fireEvent('dirtychange', me, isDirty);
    me.onDirtyChange(isDirty);
    me.wasDirty = isDirty;
  }
}, onDirtyChange:Ext.emptyFn, getErrors:function(value) {
  return [];
}, isValid:function() {
  var me = this;
  return me.disabled || Ext.isEmpty(me.getErrors());
}, validate:function() {
  var me = this, isValid = me.isValid();
  if (isValid !== me.wasValid) {
    me.wasValid = isValid;
    me.fireEvent('validitychange', me, isValid);
  }
  return isValid;
}, batchChanges:function(fn) {
  try {
    this.suspendCheckChange++;
    fn();
  } catch (e$30) {
    throw e$30;
  } finally {
    this.suspendCheckChange--;
  }
  this.checkChange();
}, isFileUpload:function() {
  return false;
}, extractFileInput:function() {
  return null;
}, markInvalid:Ext.emptyFn, clearInvalid:Ext.emptyFn});
Ext.define('Ext.layout.component.field.Field', {extend:Ext.layout.component.Auto, alias:'layout.field', type:'field', naturalSizingProp:'size', beginLayout:function(ownerContext) {
  var me = this, owner = me.owner;
  me.callParent(arguments);
  ownerContext.labelStrategy = me.getLabelStrategy();
  ownerContext.errorStrategy = me.getErrorStrategy();
  ownerContext.labelContext = ownerContext.getEl('labelEl');
  ownerContext.bodyCellContext = ownerContext.getEl('bodyEl');
  ownerContext.inputContext = ownerContext.getEl('inputEl');
  ownerContext.errorContext = ownerContext.getEl('errorEl');
  if (Ext.isIE7m && Ext.isStrict && ownerContext.inputContext) {
    me.ieInputWidthAdjustment = ownerContext.inputContext.getPaddingInfo().width + ownerContext.inputContext.getBorderInfo().width;
  }
  ownerContext.labelStrategy.prepare(ownerContext, owner);
  ownerContext.errorStrategy.prepare(ownerContext, owner);
}, beginLayoutCycle:function(ownerContext) {
  var me = this, owner = me.owner, widthModel = ownerContext.widthModel, ownerNaturalSize = owner[me.naturalSizingProp], width;
  me.callParent(arguments);
  if (widthModel.shrinkWrap) {
    me.beginLayoutShrinkWrap(ownerContext);
  } else {
    if (widthModel.natural) {
      if (typeof ownerNaturalSize == 'number' && !owner.inputWidth) {
        me.beginLayoutFixed(ownerContext, width = ownerNaturalSize * 6.5 + 20, 'px');
      } else {
        me.beginLayoutShrinkWrap(ownerContext);
      }
      ownerContext.setWidth(width, false);
    } else {
      me.beginLayoutFixed(ownerContext, '100', '%');
    }
  }
}, beginLayoutFixed:function(ownerContext, width, suffix) {
  var owner = ownerContext.target, inputEl = owner.inputEl, inputWidth = owner.inputWidth;
  owner.el.setStyle('table-layout', 'fixed');
  owner.bodyEl.setStyle('width', width + suffix);
  if (inputEl) {
    if (inputWidth) {
      inputEl.setStyle('width', inputWidth + 'px');
    } else {
      inputEl.setStyle('width', owner.stretchInputElFixed ? '100%' : '');
    }
  }
  ownerContext.isFixed = true;
}, beginLayoutShrinkWrap:function(ownerContext) {
  var owner = ownerContext.target, inputEl = owner.inputEl, inputWidth = owner.inputWidth;
  if (inputEl && inputEl.dom) {
    inputEl.dom.removeAttribute('size');
    if (inputWidth) {
      inputEl.setStyle('width', inputWidth + 'px');
    } else {
      inputEl.setStyle('width', '');
    }
  }
  owner.el.setStyle('table-layout', 'auto');
  owner.bodyEl.setStyle('width', '');
}, finishedLayout:function(ownerContext) {
  var owner = this.owner;
  this.callParent(arguments);
  ownerContext.labelStrategy.finishedLayout(ownerContext, owner);
  ownerContext.errorStrategy.finishedLayout(ownerContext, owner);
}, calculateOwnerHeightFromContentHeight:function(ownerContext, contentHeight) {
  return contentHeight;
}, measureContentHeight:function(ownerContext) {
  return ownerContext.el.getHeight();
}, measureContentWidth:function(ownerContext) {
  return ownerContext.el.getWidth();
}, measureLabelErrorHeight:function(ownerContext) {
  return ownerContext.labelStrategy.getHeight(ownerContext) + ownerContext.errorStrategy.getHeight(ownerContext);
}, onFocus:function() {
  this.getErrorStrategy().onFocus(this.owner);
}, getLabelStrategy:function() {
  var me = this, strategies = me.labelStrategies, labelAlign = me.owner.labelAlign;
  return strategies[labelAlign] || strategies.base;
}, getErrorStrategy:function() {
  var me = this, owner = me.owner, strategies = me.errorStrategies, msgTarget = owner.msgTarget;
  return !owner.preventMark && Ext.isString(msgTarget) ? strategies[msgTarget] || strategies.elementId : strategies.none;
}, labelStrategies:function() {
  var base = {prepare:function(ownerContext, owner) {
    var cls = owner.labelCls + '-' + owner.labelAlign, labelEl = owner.labelEl;
    if (labelEl) {
      labelEl.addCls(cls);
    }
  }, getHeight:function() {
    return 0;
  }, finishedLayout:Ext.emptyFn};
  return {base:base, top:Ext.applyIf({getHeight:function(ownerContext) {
    var labelContext = ownerContext.labelContext, props = labelContext.props, height = props.height;
    if (height === undefined) {
      props.height = height = labelContext.el.getHeight();
    }
    return height;
  }}, base), left:base, right:base};
}(), errorStrategies:function() {
  function showTip(owner) {
    var tip = Ext.layout.component.field.Field.tip, target;
    if (tip && tip.isVisible()) {
      target = tip.activeTarget;
      if (target && target.el === owner.getActionEl().dom) {
        tip.toFront(true);
      }
    }
  }
  var applyIf = Ext.applyIf, emptyFn = Ext.emptyFn, iconCls = Ext.baseCSSPrefix + 'form-invalid-icon', iconWidth, base = {prepare:function(ownerContext, owner) {
    var el = owner.errorEl;
    if (el) {
      el.setDisplayed(false);
    }
  }, getHeight:function() {
    return 0;
  }, onFocus:emptyFn, finishedLayout:emptyFn};
  return {none:base, side:applyIf({prepare:function(ownerContext, owner) {
    var errorEl = owner.errorEl, sideErrorCell = owner.sideErrorCell, displayError = owner.hasActiveError(), tempEl;
    if (!iconWidth) {
      iconWidth = (tempEl = Ext.getBody().createChild({style:'position:absolute', cls:iconCls})).getWidth();
      tempEl.remove();
    }
    errorEl.addCls(iconCls);
    errorEl.set({'data-errorqtip':owner.getActiveError() || ''});
    if (owner.autoFitErrors) {
      errorEl.setDisplayed(displayError);
    } else {
      errorEl.setVisible(displayError);
    }
    if (sideErrorCell && owner.autoFitErrors) {
      sideErrorCell.setDisplayed(displayError);
    }
    owner.bodyEl.dom.colSpan = owner.getBodyColspan();
    Ext.layout.component.field.Field.initTip();
  }, onFocus:showTip}, base), under:applyIf({prepare:function(ownerContext, owner) {
    var errorEl = owner.errorEl, cls = Ext.baseCSSPrefix + 'form-invalid-under';
    errorEl.addCls(cls);
    errorEl.setDisplayed(owner.hasActiveError());
  }, getHeight:function(ownerContext) {
    var height = 0, errorContext, props;
    if (ownerContext.target.hasActiveError()) {
      errorContext = ownerContext.errorContext;
      props = errorContext.props;
      height = props.height;
      if (height === undefined) {
        props.height = height = errorContext.el.getHeight();
      }
    }
    return height;
  }}, base), qtip:applyIf({prepare:function(ownerContext, owner) {
    Ext.layout.component.field.Field.initTip();
    owner.getActionEl().dom.setAttribute('data-errorqtip', owner.getActiveError() || '');
  }, onFocus:showTip}, base), title:applyIf({prepare:function(ownerContext, owner) {
    owner.getActionEl().dom.setAttribute('title', owner.getActiveError() || '');
  }}, base), elementId:applyIf({prepare:function(ownerContext, owner) {
    var targetEl = Ext.fly(owner.msgTarget);
    if (targetEl) {
      targetEl.dom.innerHTML = owner.getActiveError() || '';
      targetEl.setDisplayed(owner.hasActiveError());
    }
  }}, base)};
}(), statics:{initTip:function() {
  var tip = this.tip;
  if (!tip) {
    tip = this.tip = Ext.create('Ext.tip.QuickTip', {ui:'form-invalid'});
    tip.tagConfig = Ext.apply({}, {attribute:'errorqtip'}, tip.tagConfig);
  }
}, destroyTip:function() {
  var tip = this.tip;
  if (tip) {
    tip.destroy();
    delete this.tip;
  }
}}});
Ext.define('Ext.form.field.Base', {extend:Ext.Component, mixins:{labelable:Ext.form.Labelable, field:Ext.form.field.Field}, alias:'widget.field', alternateClassName:['Ext.form.Field', 'Ext.form.BaseField'], fieldSubTpl:['\x3cinput id\x3d"{id}" type\x3d"{type}" {inputAttrTpl}', ' size\x3d"1"', '\x3ctpl if\x3d"name"\x3e name\x3d"{name}"\x3c/tpl\x3e', '\x3ctpl if\x3d"value"\x3e value\x3d"{[Ext.util.Format.htmlEncode(values.value)]}"\x3c/tpl\x3e', '\x3ctpl if\x3d"placeholder"\x3e placeholder\x3d"{placeholder}"\x3c/tpl\x3e', 
'{%if (values.maxLength !\x3d\x3d undefined){%} maxlength\x3d"{maxLength}"{%}%}', '\x3ctpl if\x3d"readOnly"\x3e readonly\x3d"readonly"\x3c/tpl\x3e', '\x3ctpl if\x3d"disabled"\x3e disabled\x3d"disabled"\x3c/tpl\x3e', '\x3ctpl if\x3d"tabIdx"\x3e tabIndex\x3d"{tabIdx}"\x3c/tpl\x3e', '\x3ctpl if\x3d"fieldStyle"\x3e style\x3d"{fieldStyle}"\x3c/tpl\x3e', ' class\x3d"{fieldCls} {typeCls} {editableCls} {inputCls}" autocomplete\x3d"off"/\x3e', {disableFormats:true}], subTplInsertions:['inputAttrTpl'], inputType:'text', 
invalidText:'The value in this field is invalid', fieldCls:Ext.baseCSSPrefix + 'form-field', focusCls:'form-focus', dirtyCls:Ext.baseCSSPrefix + 'form-dirty', checkChangeEvents:Ext.isIE && (!document.documentMode || document.documentMode < 9) ? ['change', 'propertychange', 'keyup'] : ['change', 'input', 'textInput', 'keyup', 'dragdrop'], checkChangeBuffer:50, componentLayout:'field', readOnly:false, readOnlyCls:Ext.baseCSSPrefix + 'form-readonly', validateOnBlur:true, hasFocus:false, baseCls:Ext.baseCSSPrefix + 
'field', maskOnDisable:false, stretchInputElFixed:true, initComponent:function() {
  var me = this;
  me.callParent();
  me.subTplData = me.subTplData || {};
  me.addEvents('specialkey', 'writeablechange');
  me.initLabelable();
  me.initField();
  if (!me.name) {
    me.name = me.getInputId();
  }
  if (me.readOnly) {
    me.addCls(me.readOnlyCls);
  }
  me.addCls(Ext.baseCSSPrefix + 'form-type-' + me.inputType);
}, getInputId:function() {
  return this.inputId || (this.inputId = this.id + '-inputEl');
}, getSubTplData:function() {
  var me = this, type = me.inputType, inputId = me.getInputId(), data;
  data = Ext.apply({id:inputId, cmpId:me.id, name:me.name || inputId, disabled:me.disabled, readOnly:me.readOnly, value:me.getRawValue(), type:type, fieldCls:me.fieldCls, fieldStyle:me.getFieldStyle(), tabIdx:me.tabIndex, inputCls:me.inputCls, typeCls:Ext.baseCSSPrefix + 'form-' + (type === 'password' ? 'text' : type)}, me.subTplData);
  me.getInsertionRenderData(data, me.subTplInsertions);
  return data;
}, applyRenderSelectors:function() {
  var me = this;
  me.callParent();
  me.addChildEls('inputEl');
  me.inputEl = me.el.getById(me.getInputId());
}, getSubTplMarkup:function() {
  return this.getTpl('fieldSubTpl').apply(this.getSubTplData());
}, initRenderTpl:function() {
  var me = this;
  if (!me.hasOwnProperty('renderTpl')) {
    me.renderTpl = me.getTpl('labelableRenderTpl');
  }
  return me.callParent();
}, initRenderData:function() {
  return Ext.applyIf(this.callParent(), this.getLabelableRenderData());
}, setFieldStyle:function(style) {
  var me = this, inputEl = me.inputEl;
  if (inputEl) {
    inputEl.applyStyles(style);
  }
  me.fieldStyle = style;
}, getFieldStyle:function() {
  return Ext.isObject(this.fieldStyle) ? Ext.DomHelper.generateStyles(this.fieldStyle) : this.fieldStyle || '';
}, onRender:function() {
  this.callParent(arguments);
  this.renderActiveError();
}, getFocusEl:function() {
  return this.inputEl;
}, isFileUpload:function() {
  return this.inputType === 'file';
}, getSubmitData:function() {
  var me = this, data = null, val;
  if (!me.disabled && me.submitValue && !me.isFileUpload()) {
    val = me.getSubmitValue();
    if (val !== null) {
      data = {};
      data[me.getName()] = val;
    }
  }
  return data;
}, getSubmitValue:function() {
  return this.processRawValue(this.getRawValue());
}, getRawValue:function() {
  var me = this, v = me.inputEl ? me.inputEl.getValue() : Ext.value(me.rawValue, '');
  me.rawValue = v;
  return v;
}, setRawValue:function(value) {
  var me = this;
  value = Ext.value(me.transformRawValue(value), '');
  me.rawValue = value;
  if (me.inputEl) {
    me.inputEl.dom.value = value;
  }
  return value;
}, transformRawValue:Ext.identityFn, valueToRaw:function(value) {
  return '' + Ext.value(value, '');
}, rawToValue:Ext.identityFn, processRawValue:Ext.identityFn, getValue:function() {
  var me = this, val = me.rawToValue(me.processRawValue(me.getRawValue()));
  me.value = val;
  return val;
}, setValue:function(value) {
  var me = this;
  me.setRawValue(me.valueToRaw(value));
  return me.mixins.field.setValue.call(me, value);
}, onBoxReady:function() {
  var me = this;
  me.callParent();
  if (me.setReadOnlyOnBoxReady) {
    me.setReadOnly(me.readOnly);
  }
}, onDisable:function() {
  var me = this, inputEl = me.inputEl;
  me.callParent();
  if (inputEl) {
    inputEl.dom.disabled = true;
    if (me.hasActiveError()) {
      me.clearInvalid();
      me.needsValidateOnEnable = true;
    }
  }
}, onEnable:function() {
  var me = this, inputEl = me.inputEl;
  me.callParent();
  if (inputEl) {
    inputEl.dom.disabled = false;
    if (me.needsValidateOnEnable) {
      delete me.needsValidateOnEnable;
      me.forceValidation = true;
      me.isValid();
      delete me.forceValidation;
    }
  }
}, setReadOnly:function(readOnly) {
  var me = this, inputEl = me.inputEl;
  readOnly = !!readOnly;
  me[readOnly ? 'addCls' : 'removeCls'](me.readOnlyCls);
  me.readOnly = readOnly;
  if (inputEl) {
    inputEl.dom.readOnly = readOnly;
  } else {
    if (me.rendering) {
      me.setReadOnlyOnBoxReady = true;
    }
  }
  me.fireEvent('writeablechange', me, readOnly);
}, fireKey:function(e) {
  if (e.isSpecialKey()) {
    this.fireEvent('specialkey', this, new Ext.EventObjectImpl(e));
  }
}, initEvents:function() {
  var me = this, inputEl = me.inputEl, onChangeTask, onChangeEvent, events = me.checkChangeEvents, e, eLen = events.length, event;
  if (inputEl) {
    me.mon(inputEl, Ext.EventManager.getKeyEvent(), me.fireKey, me);
    onChangeTask = new Ext.util.DelayedTask(me.checkChange, me);
    me.onChangeEvent = onChangeEvent = function() {
      onChangeTask.delay(me.checkChangeBuffer);
    };
    for (e = 0; e < eLen; e++) {
      event = events[e];
      if (event === 'propertychange') {
        me.usesPropertychange = true;
      }
      me.mon(inputEl, event, onChangeEvent);
    }
  }
  me.callParent();
}, doComponentLayout:function() {
  var me = this, inputEl = me.inputEl, usesPropertychange = me.usesPropertychange, ename = 'propertychange', onChangeEvent = me.onChangeEvent;
  if (usesPropertychange) {
    me.mun(inputEl, ename, onChangeEvent);
  }
  me.callParent(arguments);
  if (usesPropertychange) {
    me.mon(inputEl, ename, onChangeEvent);
  }
}, onDirtyChange:function(isDirty) {
  this[isDirty ? 'addCls' : 'removeCls'](this.dirtyCls);
}, isValid:function() {
  var me = this, disabled = me.disabled, validate = me.forceValidation || !disabled;
  return validate ? me.validateValue(me.processRawValue(me.getRawValue())) : disabled;
}, validateValue:function(value) {
  var me = this, errors = me.getErrors(value), isValid = Ext.isEmpty(errors);
  if (!me.preventMark) {
    if (isValid) {
      me.clearInvalid();
    } else {
      me.markInvalid(errors);
    }
  }
  return isValid;
}, markInvalid:function(errors) {
  var me = this, oldMsg = me.getActiveError(), active;
  me.setActiveErrors(Ext.Array.from(errors));
  active = me.getActiveError();
  if (oldMsg !== active) {
    me.setError(active);
  }
}, clearInvalid:function() {
  var me = this, hadError = me.hasActiveError();
  delete me.needsValidateOnEnable;
  me.unsetActiveError();
  if (hadError) {
    me.setError('');
  }
}, setError:function(active) {
  var me = this, msgTarget = me.msgTarget, prop;
  if (me.rendered) {
    if (msgTarget == 'title' || msgTarget == 'qtip') {
      if (me.rendered) {
        prop = msgTarget == 'qtip' ? 'data-errorqtip' : 'title';
      }
      me.getActionEl().dom.setAttribute(prop, active || '');
    } else {
      me.updateLayout();
    }
  }
}, renderActiveError:function() {
  var me = this, hasError = me.hasActiveError();
  if (me.inputEl) {
    me.inputEl[hasError ? 'addCls' : 'removeCls'](me.invalidCls + '-field');
  }
  me.mixins.labelable.renderActiveError.call(me);
}, getActionEl:function() {
  return this.inputEl || this.el;
}});
Ext.define('Ext.form.field.VTypes', function() {
  var alpha = /^[a-zA-Z_]+$/, alphanum = /^[a-zA-Z0-9_]+$/, email = /^(")?(?:[^\."])(?:(?:[\.])?(?:[\w\-!#$%&'*+/=?^_`{|}~]))*\1@(\w[\-\w]*\.){1,5}([A-Za-z]){2,6}$/, url = /(((^https?)|(^ftp)):\/\/((([\-\w]+\.)+\w{2,3}(\/[%\-\w]+(\.\w{2,})?)*(([\w\-\.\?\\\/+@&#;`~=%!]*)(\.\w{2,})?)*)|(localhost|LOCALHOST))\/?)/i;
  return {singleton:true, alternateClassName:'Ext.form.VTypes', 'email':function(v) {
    return email.test(v);
  }, 'emailText':'This field should be an e-mail address in the format "user@example.com"', 'emailMask':/[\w.\-@'"!#$%&'*+/=?^_`{|}~]/i, 'url':function(v) {
    return url.test(v);
  }, 'urlText':'This field should be a URL in the format "http:/' + '/www.example.com"', 'alpha':function(v) {
    return alpha.test(v);
  }, 'alphaText':'This field should only contain letters and _', 'alphaMask':/[a-z_]/i, 'alphanum':function(v) {
    return alphanum.test(v);
  }, 'alphanumText':'This field should only contain letters, numbers and _', 'alphanumMask':/[a-z0-9_]/i};
}());
Ext.define('Ext.layout.component.field.Text', {extend:Ext.layout.component.field.Field, alias:'layout.textfield', type:'textfield', canGrowWidth:true, beginLayoutCycle:function(ownerContext) {
  this.callParent(arguments);
  if (ownerContext.heightModel.shrinkWrap) {
    ownerContext.inputContext.el.setStyle('height', '');
  }
}, measureContentWidth:function(ownerContext) {
  var me = this, owner = me.owner, width = me.callParent(arguments), inputContext = ownerContext.inputContext, inputEl, value, calcWidth, max, min;
  if (owner.grow && me.canGrowWidth && !ownerContext.state.growHandled) {
    inputEl = owner.inputEl;
    value = Ext.util.Format.htmlEncode(inputEl.dom.value || (owner.hasFocus ? '' : owner.emptyText) || '');
    value += owner.growAppend;
    calcWidth = inputEl.getTextWidth(value) + inputContext.getFrameInfo().width;
    max = owner.growMax;
    min = Math.min(max, width);
    max = Math.max(owner.growMin, max, min);
    calcWidth = Ext.Number.constrain(calcWidth, owner.growMin, max);
    inputContext.setWidth(calcWidth);
    ownerContext.state.growHandled = true;
    inputContext.domBlock(me, 'width');
    width = NaN;
  }
  return width;
}, publishInnerHeight:function(ownerContext, height) {
  ownerContext.inputContext.setHeight(height - this.measureLabelErrorHeight(ownerContext));
}, beginLayoutFixed:function(ownerContext, width, suffix) {
  var me = this, ieInputWidthAdjustment = me.ieInputWidthAdjustment;
  if (ieInputWidthAdjustment) {
    me.adjustIEInputPadding(ownerContext);
    if (suffix === 'px') {
      width -= ieInputWidthAdjustment;
    }
  }
  me.callParent(arguments);
}, adjustIEInputPadding:function(ownerContext) {
  this.owner.bodyEl.setStyle('padding-right', this.ieInputWidthAdjustment + 'px');
}});
Ext.define('Ext.form.field.Text', {extend:Ext.form.field.Base, alias:'widget.textfield', alternateClassName:['Ext.form.TextField', 'Ext.form.Text'], size:20, growMin:30, growMax:800, growAppend:'W', allowBlank:true, validateBlank:false, allowOnlyWhitespace:true, minLength:0, maxLength:Number.MAX_VALUE, minLengthText:'The minimum length for this field is {0}', maxLengthText:'The maximum length for this field is {0}', blankText:'This field is required', regexText:'', emptyCls:Ext.baseCSSPrefix + 'form-empty-field', 
requiredCls:Ext.baseCSSPrefix + 'form-required-field', componentLayout:'textfield', valueContainsPlaceholder:false, initComponent:function() {
  var me = this;
  if (me.allowOnlyWhitespace === false) {
    me.allowBlank = false;
  }
  me.callParent();
  me.addEvents('autosize', 'keydown', 'keyup', 'keypress');
  me.addStateEvents('change');
  me.setGrowSizePolicy();
}, setGrowSizePolicy:function() {
  if (this.grow) {
    this.shrinkWrap |= 1;
  }
}, initEvents:function() {
  var me = this, el = me.inputEl;
  me.callParent();
  if (me.selectOnFocus || me.emptyText) {
    me.mon(el, 'mousedown', me.onMouseDown, me);
  }
  if (me.maskRe || me.vtype && me.disableKeyFilter !== true && (me.maskRe = Ext.form.field.VTypes[me.vtype + 'Mask'])) {
    me.mon(el, 'keypress', me.filterKeys, me);
  }
  if (me.enableKeyEvents) {
    me.mon(el, {scope:me, keyup:me.onKeyUp, keydown:me.onKeyDown, keypress:me.onKeyPress});
  }
}, isEqual:function(value1, value2) {
  return this.isEqualAsString(value1, value2);
}, onChange:function(newVal, oldVal) {
  this.callParent(arguments);
  this.autoSize();
}, getSubTplData:function() {
  var me = this, value = me.getRawValue(), isEmpty = me.emptyText && value.length < 1, maxLength = me.maxLength, placeholder;
  if (me.enforceMaxLength) {
    if (maxLength === Number.MAX_VALUE) {
      maxLength = undefined;
    }
  } else {
    maxLength = undefined;
  }
  if (isEmpty) {
    if (Ext.supports.Placeholder) {
      placeholder = me.emptyText;
    } else {
      value = me.emptyText;
      me.valueContainsPlaceholder = true;
    }
  }
  return Ext.apply(me.callParent(), {maxLength:maxLength, readOnly:me.readOnly, placeholder:placeholder, value:value, fieldCls:me.fieldCls + (isEmpty && (placeholder || value) ? ' ' + me.emptyCls : '') + (me.allowBlank ? '' : ' ' + me.requiredCls)});
}, afterRender:function() {
  this.autoSize();
  this.callParent();
}, onMouseDown:function(e) {
  var me = this;
  if (!me.hasFocus) {
    me.mon(me.inputEl, 'mouseup', Ext.emptyFn, me, {single:true, preventDefault:true});
  }
}, processRawValue:function(value) {
  var me = this, stripRe = me.stripCharsRe, newValue;
  if (stripRe) {
    newValue = value.replace(stripRe, '');
    if (newValue !== value) {
      me.setRawValue(newValue);
      value = newValue;
    }
  }
  return value;
}, onDisable:function() {
  this.callParent();
  if (Ext.isIE) {
    this.inputEl.dom.unselectable = 'on';
  }
}, onEnable:function() {
  this.callParent();
  if (Ext.isIE) {
    this.inputEl.dom.unselectable = '';
  }
}, onKeyDown:function(e) {
  this.fireEvent('keydown', this, e);
}, onKeyUp:function(e) {
  this.fireEvent('keyup', this, e);
}, onKeyPress:function(e) {
  this.fireEvent('keypress', this, e);
}, reset:function() {
  this.callParent();
  this.applyEmptyText();
}, applyEmptyText:function() {
  var me = this, emptyText = me.emptyText, isEmpty;
  if (me.rendered && emptyText) {
    isEmpty = me.getRawValue().length < 1 && !me.hasFocus;
    if (Ext.supports.Placeholder) {
      me.inputEl.dom.placeholder = emptyText;
    } else {
      if (isEmpty) {
        me.setRawValue(emptyText);
        me.valueContainsPlaceholder = true;
      }
    }
    if (isEmpty) {
      me.inputEl.addCls(me.emptyCls);
    }
    me.autoSize();
  }
}, afterFirstLayout:function() {
  this.callParent();
  if (Ext.isIE && this.disabled) {
    var el = this.inputEl;
    if (el) {
      el.dom.unselectable = 'on';
    }
  }
}, beforeFocus:function() {
  var me = this, inputEl = me.inputEl, emptyText = me.emptyText, isEmpty;
  me.callParent(arguments);
  if (emptyText && !Ext.supports.Placeholder && (inputEl.dom.value === me.emptyText && me.valueContainsPlaceholder)) {
    me.setRawValue('');
    isEmpty = true;
    inputEl.removeCls(me.emptyCls);
    me.valueContainsPlaceholder = false;
  } else {
    if (Ext.supports.Placeholder) {
      me.inputEl.removeCls(me.emptyCls);
    }
  }
  if (me.selectOnFocus || isEmpty) {
    if (Ext.isWebKit) {
      if (!me.inputFocusTask) {
        me.inputFocusTask = new Ext.util.DelayedTask(me.focusInput, me);
      }
      me.inputFocusTask.delay(1);
    } else {
      inputEl.dom.select();
    }
  }
}, focusInput:function() {
  var input = this.inputEl;
  if (input) {
    input = input.dom;
    if (input) {
      input.select();
    }
  }
}, onFocus:function() {
  var me = this;
  me.callParent(arguments);
  if (me.emptyText) {
    me.autoSize();
  }
}, postBlur:function() {
  this.callParent(arguments);
  this.applyEmptyText();
}, filterKeys:function(e) {
  if (e.ctrlKey && !e.altKey) {
    return;
  }
  var key = e.getKey(), charCode = String.fromCharCode(e.getCharCode());
  if ((Ext.isGecko || Ext.isOpera) && (e.isNavKeyPress() || key === e.BACKSPACE || key === e.DELETE && e.button === -1)) {
    return;
  }
  if (!Ext.isGecko && !Ext.isOpera && e.isSpecialKey() && !charCode) {
    return;
  }
  if (!this.maskRe.test(charCode)) {
    e.stopEvent();
  }
}, getState:function() {
  return this.addPropertyToState(this.callParent(), 'value');
}, applyState:function(state) {
  this.callParent(arguments);
  if (state.hasOwnProperty('value')) {
    this.setValue(state.value);
  }
}, getRawValue:function() {
  var me = this, v = me.callParent();
  if (v === me.emptyText && me.valueContainsPlaceholder) {
    v = '';
  }
  return v;
}, setValue:function(value) {
  var me = this, inputEl = me.inputEl;
  if (inputEl && me.emptyText && !Ext.isEmpty(value)) {
    inputEl.removeCls(me.emptyCls);
    me.valueContainsPlaceholder = false;
  }
  me.callParent(arguments);
  me.applyEmptyText();
  return me;
}, getErrors:function(value) {
  var me = this, errors = me.callParent(arguments), validator = me.validator, vtype = me.vtype, vtypes = Ext.form.field.VTypes, regex = me.regex, format = Ext.String.format, msg, trimmed, isBlank;
  value = value || me.processRawValue(me.getRawValue());
  if (Ext.isFunction(validator)) {
    msg = validator.call(me, value);
    if (msg !== true) {
      errors.push(msg);
    }
  }
  trimmed = me.allowOnlyWhitespace ? value : Ext.String.trim(value);
  if (trimmed.length < 1 || value === me.emptyText && me.valueContainsPlaceholder) {
    if (!me.allowBlank) {
      errors.push(me.blankText);
    }
    if (!me.validateBlank) {
      return errors;
    }
    isBlank = true;
  }
  if (!isBlank && value.length < me.minLength) {
    errors.push(format(me.minLengthText, me.minLength));
  }
  if (value.length > me.maxLength) {
    errors.push(format(me.maxLengthText, me.maxLength));
  }
  if (vtype) {
    if (!vtypes[vtype](value, me)) {
      errors.push(me.vtypeText || vtypes[vtype + 'Text']);
    }
  }
  if (regex && !regex.test(value)) {
    errors.push(me.regexText || me.invalidText);
  }
  return errors;
}, selectText:function(start, end) {
  var me = this, v = me.getRawValue(), doFocus = true, el = me.inputEl.dom, undef, range;
  if (v.length > 0) {
    start = start === undef ? 0 : start;
    end = end === undef ? v.length : end;
    if (el.setSelectionRange) {
      el.setSelectionRange(start, end);
    } else {
      if (el.createTextRange) {
        range = el.createTextRange();
        range.moveStart('character', start);
        range.moveEnd('character', end - v.length);
        range.select();
      }
    }
    doFocus = Ext.isGecko || Ext.isOpera;
  }
  if (doFocus) {
    me.focus();
  }
}, autoSize:function() {
  var me = this;
  if (me.grow && me.rendered) {
    me.autoSizing = true;
    me.updateLayout();
  }
}, afterComponentLayout:function() {
  var me = this, width;
  me.callParent(arguments);
  if (me.autoSizing) {
    width = me.inputEl.getWidth();
    if (width !== me.lastInputWidth) {
      me.fireEvent('autosize', me, width);
      me.lastInputWidth = width;
      delete me.autoSizing;
    }
  }
}, onDestroy:function() {
  var me = this;
  me.callParent();
  if (me.inputFocusTask) {
    me.inputFocusTask.cancel();
    me.inputFocusTask = null;
  }
}});
Ext.define('Ext.layout.component.field.TextArea', {extend:Ext.layout.component.field.Text, alias:'layout.textareafield', type:'textareafield', canGrowWidth:false, naturalSizingProp:'cols', beginLayout:function(ownerContext) {
  this.callParent(arguments);
  ownerContext.target.inputEl.setStyle('height', '');
}, measureContentHeight:function(ownerContext) {
  var me = this, owner = me.owner, height = me.callParent(arguments), inputContext, inputEl, value, max, curWidth, calcHeight;
  if (owner.grow && !ownerContext.state.growHandled) {
    inputContext = ownerContext.inputContext;
    inputEl = owner.inputEl;
    curWidth = inputEl.getWidth(true);
    value = Ext.util.Format.htmlEncode(inputEl.dom.value) || '\x26#160;';
    value += owner.growAppend;
    value = value.replace(/\n/g, '\x3cbr/\x3e');
    calcHeight = Ext.util.TextMetrics.measure(inputEl, value, curWidth).height + inputContext.getBorderInfo().height + inputContext.getPaddingInfo().height;
    calcHeight = Ext.Number.constrain(calcHeight, owner.growMin, owner.growMax);
    inputContext.setHeight(calcHeight);
    ownerContext.state.growHandled = true;
    inputContext.domBlock(me, 'height');
    height = NaN;
  }
  return height;
}});
Ext.define('Ext.form.field.TextArea', {extend:Ext.form.field.Text, alias:['widget.textareafield', 'widget.textarea'], alternateClassName:'Ext.form.TextArea', fieldSubTpl:['\x3ctextarea id\x3d"{id}" {inputAttrTpl}', '\x3ctpl if\x3d"name"\x3e name\x3d"{name}"\x3c/tpl\x3e', '\x3ctpl if\x3d"rows"\x3e rows\x3d"{rows}" \x3c/tpl\x3e', '\x3ctpl if\x3d"cols"\x3e cols\x3d"{cols}" \x3c/tpl\x3e', '\x3ctpl if\x3d"placeholder"\x3e placeholder\x3d"{placeholder}"\x3c/tpl\x3e', '\x3ctpl if\x3d"size"\x3e size\x3d"{size}"\x3c/tpl\x3e', 
'\x3ctpl if\x3d"maxLength !\x3d\x3d undefined"\x3e maxlength\x3d"{maxLength}"\x3c/tpl\x3e', '\x3ctpl if\x3d"readOnly"\x3e readonly\x3d"readonly"\x3c/tpl\x3e', '\x3ctpl if\x3d"disabled"\x3e disabled\x3d"disabled"\x3c/tpl\x3e', '\x3ctpl if\x3d"tabIdx"\x3e tabIndex\x3d"{tabIdx}"\x3c/tpl\x3e', ' class\x3d"{fieldCls} {typeCls} {inputCls}" ', '\x3ctpl if\x3d"fieldStyle"\x3e style\x3d"{fieldStyle}"\x3c/tpl\x3e', ' autocomplete\x3d"off"\x3e\n', '\x3ctpl if\x3d"value"\x3e{[Ext.util.Format.htmlEncode(values.value)]}\x3c/tpl\x3e', 
'\x3c/textarea\x3e', {disableFormats:true}], growMin:60, growMax:1000, growAppend:'\n-', cols:20, rows:4, enterIsSpecial:false, preventScrollbars:false, componentLayout:'textareafield', setGrowSizePolicy:Ext.emptyFn, returnRe:/\r/g, inputCls:Ext.baseCSSPrefix + 'form-textarea', getSubTplData:function() {
  var me = this, fieldStyle = me.getFieldStyle(), ret = me.callParent();
  if (me.grow) {
    if (me.preventScrollbars) {
      ret.fieldStyle = (fieldStyle || '') + ';overflow:hidden;height:' + me.growMin + 'px';
    }
  }
  Ext.applyIf(ret, {cols:me.cols, rows:me.rows});
  return ret;
}, afterRender:function() {
  var me = this;
  me.callParent(arguments);
  me.needsMaxCheck = me.enforceMaxLength && me.maxLength !== Number.MAX_VALUE && !Ext.supports.TextAreaMaxLength;
  if (me.needsMaxCheck) {
    me.inputEl.on('paste', me.onPaste, me);
  }
}, transformRawValue:function(value) {
  return this.stripReturns(value);
}, transformOriginalValue:function(value) {
  return this.stripReturns(value);
}, getValue:function() {
  return this.stripReturns(this.callParent());
}, valueToRaw:function(value) {
  value = this.stripReturns(value);
  return this.callParent([value]);
}, stripReturns:function(value) {
  if (value && typeof value === 'string') {
    value = value.replace(this.returnRe, '');
  }
  return value;
}, onPaste:function(e) {
  var me = this;
  if (!me.pasteTask) {
    me.pasteTask = new Ext.util.DelayedTask(me.pasteCheck, me);
  }
  me.pasteTask.delay(1);
}, pasteCheck:function() {
  var me = this, value = me.getValue(), max = me.maxLength;
  if (value.length > max) {
    value = value.substr(0, max);
    me.setValue(value);
  }
}, fireKey:function(e) {
  var me = this, key = e.getKey(), value;
  if (e.isSpecialKey() && (me.enterIsSpecial || (key !== e.ENTER || e.hasModifier()))) {
    me.fireEvent('specialkey', me, e);
  }
  if (me.needsMaxCheck && key !== e.BACKSPACE && key !== e.DELETE && !e.isNavKeyPress() && !me.isCutCopyPasteSelectAll(e, key)) {
    value = me.getValue();
    if (value.length >= me.maxLength) {
      e.stopEvent();
    }
  }
}, isCutCopyPasteSelectAll:function(e, key) {
  if (e.ctrlKey) {
    return key === e.A || key === e.C || key === e.V || key === e.X;
  }
  return false;
}, autoSize:function() {
  var me = this, height;
  if (me.grow && me.rendered) {
    me.updateLayout();
    height = me.inputEl.getHeight();
    if (height !== me.lastInputHeight) {
      me.fireEvent('autosize', me, height);
      me.lastInputHeight = height;
    }
  }
}, initAria:function() {
  this.callParent(arguments);
  this.getActionEl().dom.setAttribute('aria-multiline', true);
}, beforeDestroy:function() {
  var task = this.pasteTask;
  if (task) {
    task.cancel();
    this.pasteTask = null;
  }
  this.callParent();
}});
Ext.define('Ext.form.field.Display', {extend:Ext.form.field.Base, alias:'widget.displayfield', alternateClassName:['Ext.form.DisplayField', 'Ext.form.Display'], fieldSubTpl:['\x3cdiv id\x3d"{id}" role\x3d"input" ', '\x3ctpl if\x3d"fieldStyle"\x3e style\x3d"{fieldStyle}"\x3c/tpl\x3e', ' class\x3d"{fieldCls}"\x3e{value}\x3c/div\x3e', {compiled:true, disableFormats:true}], readOnly:true, fieldCls:Ext.baseCSSPrefix + 'form-display-field', fieldBodyCls:Ext.baseCSSPrefix + 'form-display-field-body', htmlEncode:false, 
noWrap:false, validateOnChange:false, initEvents:Ext.emptyFn, submitValue:false, isDirty:function() {
  return false;
}, isValid:function() {
  return true;
}, validate:function() {
  return true;
}, getRawValue:function() {
  return this.rawValue;
}, setRawValue:function(value) {
  var me = this;
  value = Ext.value(value, '');
  me.rawValue = value;
  if (me.rendered) {
    me.inputEl.dom.innerHTML = me.getDisplayValue();
    me.updateLayout();
  }
  return value;
}, getDisplayValue:function() {
  var me = this, value = this.getRawValue(), display;
  if (me.renderer) {
    display = me.renderer.call(me.scope || me, value, me);
  } else {
    display = me.htmlEncode ? Ext.util.Format.htmlEncode(value) : value;
  }
  return display;
}, getSubTplData:function() {
  var ret = this.callParent(arguments);
  ret.value = this.getDisplayValue();
  return ret;
}});
Ext.define('Ext.layout.container.Anchor', {alias:'layout.anchor', extend:Ext.layout.container.Auto, alternateClassName:'Ext.layout.AnchorLayout', type:'anchor', defaultAnchor:'100%', parseAnchorRE:/^(r|right|b|bottom)$/i, manageOverflow:true, beginLayoutCycle:function(ownerContext) {
  var me = this, dimensions = 0, anchorSpec, childContext, childItems, i, length, target;
  me.callParent(arguments);
  childItems = ownerContext.childItems;
  length = childItems.length;
  for (i = 0; i < length; ++i) {
    childContext = childItems[i];
    anchorSpec = childContext.target.anchorSpec;
    if (anchorSpec) {
      if (childContext.widthModel.calculated && anchorSpec.right) {
        dimensions |= 1;
      }
      if (childContext.heightModel.calculated && anchorSpec.bottom) {
        dimensions |= 2;
      }
      if (dimensions == 3) {
        break;
      }
    }
  }
  ownerContext.anchorDimensions = dimensions;
  me.sanityCheck(ownerContext);
}, calculateItems:function(ownerContext, containerSize) {
  var me = this, childItems = ownerContext.childItems, length = childItems.length, gotHeight = containerSize.gotHeight, gotWidth = containerSize.gotWidth, ownerHeight = containerSize.height, ownerWidth = containerSize.width, knownDimensions = (gotWidth ? 1 : 0) | (gotHeight ? 2 : 0), anchorDimensions = ownerContext.anchorDimensions, anchorSpec, childContext, childMargins, height, i, width;
  if (!anchorDimensions) {
    return true;
  }
  for (i = 0; i < length; i++) {
    childContext = childItems[i];
    childMargins = childContext.getMarginInfo();
    anchorSpec = childContext.target.anchorSpec;
    if (gotWidth && childContext.widthModel.calculated) {
      width = anchorSpec.right(ownerWidth) - childMargins.width;
      width = me.adjustWidthAnchor(width, childContext);
      childContext.setWidth(width);
    }
    if (gotHeight && childContext.heightModel.calculated) {
      height = anchorSpec.bottom(ownerHeight) - childMargins.height;
      height = me.adjustHeightAnchor(height, childContext);
      childContext.setHeight(height);
    }
  }
  return (knownDimensions & anchorDimensions) === anchorDimensions;
}, sanityCheck:function(ownerContext) {
  var shrinkWrapWidth = ownerContext.widthModel.shrinkWrap, shrinkWrapHeight = ownerContext.heightModel.shrinkWrap, children = ownerContext.childItems, anchorSpec, comp, childContext, i, length;
  for (i = 0, length = children.length; i < length; ++i) {
    childContext = children[i];
    comp = childContext.target;
    anchorSpec = comp.anchorSpec;
    if (anchorSpec) {
      if (childContext.widthModel.calculated && anchorSpec.right) {
        if (shrinkWrapWidth) {
          Ext.log({level:'warn', msg:'Right anchor on ' + comp.id + ' in shrinkWrap width container'});
        }
      }
      if (childContext.heightModel.calculated && anchorSpec.bottom) {
        if (shrinkWrapHeight) {
          Ext.log({level:'warn', msg:'Bottom anchor on ' + comp.id + ' in shrinkWrap height container'});
        }
      }
    }
  }
}, anchorFactory:{offset:function(delta) {
  return function(v) {
    return v + delta;
  };
}, ratio:function(ratio) {
  return function(v) {
    return Math.floor(v * ratio);
  };
}, standard:function(diff) {
  return function(v) {
    return v - diff;
  };
}}, parseAnchor:function(a, start, cstart) {
  if (a && a != 'none') {
    var factory = this.anchorFactory, delta;
    if (this.parseAnchorRE.test(a)) {
      return factory.standard(cstart - start);
    }
    if (a.indexOf('%') != -1) {
      return factory.ratio(parseFloat(a.replace('%', '')) * 0.01);
    }
    delta = parseInt(a, 10);
    if (!isNaN(delta)) {
      return factory.offset(delta);
    }
  }
  return null;
}, adjustWidthAnchor:function(value, childContext) {
  return value;
}, adjustHeightAnchor:function(value, childContext) {
  return value;
}, configureItem:function(item) {
  var me = this, owner = me.owner, anchor = item.anchor, anchorsArray, anchorWidth, anchorHeight;
  me.callParent(arguments);
  if (!item.anchor && item.items && !Ext.isNumber(item.width) && !(Ext.isIE6 && Ext.isStrict)) {
    item.anchor = anchor = me.defaultAnchor;
  }
  if (owner.anchorSize) {
    if (typeof owner.anchorSize == 'number') {
      anchorWidth = owner.anchorSize;
    } else {
      anchorWidth = owner.anchorSize.width;
      anchorHeight = owner.anchorSize.height;
    }
  } else {
    anchorWidth = owner.initialConfig.width;
    anchorHeight = owner.initialConfig.height;
  }
  if (anchor) {
    anchorsArray = anchor.split(' ');
    item.anchorSpec = {right:me.parseAnchor(anchorsArray[0], item.initialConfig.width, anchorWidth), bottom:me.parseAnchor(anchorsArray[1], item.initialConfig.height, anchorHeight)};
  }
}, sizePolicy:{$:{readsWidth:1, readsHeight:1, setsWidth:0, setsHeight:0}, b:{readsWidth:1, readsHeight:0, setsWidth:0, setsHeight:1}, r:{$:{readsWidth:0, readsHeight:1, setsWidth:1, setsHeight:0}, b:{readsWidth:0, readsHeight:0, setsWidth:1, setsHeight:1}}}, getItemSizePolicy:function(item) {
  var anchorSpec = item.anchorSpec, key = '$', policy = this.sizePolicy, sizeModel;
  if (anchorSpec) {
    sizeModel = this.owner.getSizeModel();
    if (anchorSpec.right && !sizeModel.width.shrinkWrap) {
      policy = policy.r;
    }
    if (anchorSpec.bottom && !sizeModel.height.shrinkWrap) {
      key = 'b';
    }
  }
  return policy[key];
}});
Ext.define('Ext.window.MessageBox', {extend:Ext.window.Window, alias:'widget.messagebox', OK:1, YES:2, NO:4, CANCEL:8, OKCANCEL:9, YESNO:6, YESNOCANCEL:14, INFO:Ext.baseCSSPrefix + 'message-box-info', WARNING:Ext.baseCSSPrefix + 'message-box-warning', QUESTION:Ext.baseCSSPrefix + 'message-box-question', ERROR:Ext.baseCSSPrefix + 'message-box-error', hideMode:'offsets', closeAction:'hide', resizable:false, title:'\x26#160;', defaultMinWidth:250, defaultMaxWidth:600, defaultMinHeight:110, defaultMaxHeight:500, 
minWidth:null, maxWidth:null, minHeight:null, maxHeight:null, constrain:true, cls:[Ext.baseCSSPrefix + 'message-box', Ext.baseCSSPrefix + 'hide-offsets'], layout:{type:'vbox', align:'stretch'}, shrinkWrapDock:true, defaultTextHeight:75, minProgressWidth:250, minPromptWidth:250, buttonText:{ok:'OK', yes:'Yes', no:'No', cancel:'Cancel'}, buttonIds:['ok', 'yes', 'no', 'cancel'], titleText:{confirm:'Confirm', prompt:'Prompt', wait:'Loading...', alert:'Attention'}, iconHeight:35, iconWidth:50, makeButton:function(btnIdx) {
  var btnId = this.buttonIds[btnIdx];
  return new Ext.button.Button({handler:this.btnCallback, itemId:btnId, scope:this, text:this.buttonText[btnId], minWidth:75});
}, btnCallback:function(btn) {
  var me = this, value, field;
  if (me.cfg.prompt || me.cfg.multiline) {
    if (me.cfg.multiline) {
      field = me.textArea;
    } else {
      field = me.textField;
    }
    value = field.getValue();
    field.reset();
  }
  me.hide();
  me.userCallback(btn.itemId, value, me.cfg);
}, hide:function() {
  var me = this, cls = me.cfg.cls;
  me.dd.endDrag();
  me.progressBar.reset();
  if (cls) {
    me.removeCls(cls);
  }
  me.callParent(arguments);
}, constructor:function(cfg) {
  var me = this;
  me.callParent(arguments);
  me.minWidth = me.defaultMinWidth = me.minWidth || me.defaultMinWidth;
  me.maxWidth = me.defaultMaxWidth = me.maxWidth || me.defaultMaxWidth;
  me.minHeight = me.defaultMinHeight = me.minHeight || me.defaultMinHeight;
  me.maxHeight = me.defaultMaxHeight = me.maxHeight || me.defaultMaxHeight;
}, initComponent:function(cfg) {
  var me = this, baseId = me.id, i, button;
  me.title = '\x26#160;';
  me.topContainer = new Ext.container.Container({layout:'hbox', padding:10, style:{overflow:'hidden'}, items:[me.iconComponent = new Ext.Component({width:me.iconWidth, height:me.iconHeight}), me.promptContainer = new Ext.container.Container({flex:1, layout:'anchor', items:[me.msg = new Ext.form.field.Display({id:baseId + '-displayfield', cls:me.baseCls + '-text'}), me.textField = new Ext.form.field.Text({id:baseId + '-textfield', anchor:'100%', enableKeyEvents:true, listeners:{keydown:me.onPromptKey, 
  scope:me}}), me.textArea = new Ext.form.field.TextArea({id:baseId + '-textarea', anchor:'100%', height:75})]})]});
  me.progressBar = new Ext.ProgressBar({id:baseId + '-progressbar', margins:'0 10 10 10'});
  me.items = [me.topContainer, me.progressBar];
  me.msgButtons = [];
  for (i = 0; i < 4; i++) {
    button = me.makeButton(i);
    me.msgButtons[button.itemId] = button;
    me.msgButtons.push(button);
  }
  me.bottomTb = new Ext.toolbar.Toolbar({id:baseId + '-toolbar', ui:'footer', dock:'bottom', layout:{pack:'center'}, items:[me.msgButtons[0], me.msgButtons[1], me.msgButtons[2], me.msgButtons[3]]});
  me.dockedItems = [me.bottomTb];
  me.on('close', me.onClose, me);
  me.callParent();
}, onClose:function() {
  var btn = this.header.child('[type\x3dclose]');
  btn.itemId = 'cancel';
  this.btnCallback(btn);
  delete btn.itemId;
}, onPromptKey:function(textField, e) {
  var me = this;
  if (e.keyCode === e.RETURN || e.keyCode === 10) {
    if (me.msgButtons.ok.isVisible()) {
      me.msgButtons.ok.handler.call(me, me.msgButtons.ok);
    } else {
      if (me.msgButtons.yes.isVisible()) {
        me.msgButtons.yes.handler.call(me, me.msgButtons.yes);
      }
    }
  }
}, reconfigure:function(cfg) {
  var me = this, buttons = 0, hideToolbar = true, oldButtonText = me.buttonText, resizer = me.resizer, resizeTracker, width, height, i, textArea, textField, msg, progressBar, msgButtons;
  me.updateButtonText();
  cfg = cfg || {};
  me.cfg = cfg;
  if (cfg.width) {
    width = cfg.width;
  }
  if (cfg.height) {
    height = cfg.height;
  }
  me.minWidth = cfg.minWidth || me.defaultMinWidth;
  me.maxWidth = cfg.maxWidth || me.defaultMaxWidth;
  me.minHeight = cfg.minHeight || me.defaultMinHeight;
  me.maxHeight = cfg.maxHeight || me.defaultMaxHeight;
  if (resizer) {
    resizeTracker = resizer.resizeTracker;
    resizer.minWidth = resizeTracker.minWidth = me.minWidth;
    resizer.maxWidth = resizeTracker.maxWidth = me.maxWidth;
    resizer.minHeight = resizeTracker.minHeight = me.minHeight;
    resizer.maxHeight = resizeTracker.maxHeight = me.maxHeight;
  }
  delete me.defaultFocus;
  if (cfg.defaultFocus) {
    me.defaultFocus = cfg.defaultFocus;
  }
  me.animateTarget = cfg.animateTarget || undefined;
  me.modal = cfg.modal !== false;
  me.setTitle(cfg.title || '');
  me.setIconCls(cfg.iconCls || '');
  if (Ext.isObject(cfg.buttons)) {
    me.buttonText = cfg.buttons;
    buttons = 0;
  } else {
    me.buttonText = cfg.buttonText || me.buttonText;
    buttons = Ext.isNumber(cfg.buttons) ? cfg.buttons : 0;
  }
  buttons = buttons | me.updateButtonText();
  me.buttonText = oldButtonText;
  Ext.suspendLayouts();
  delete me.width;
  delete me.height;
  if (width || height) {
    if (width) {
      me.setWidth(width);
    }
    if (height) {
      me.setHeight(height);
    }
  }
  me.hidden = false;
  if (!me.rendered) {
    me.render(Ext.getBody());
  }
  me.closable = cfg.closable !== false && !cfg.wait;
  me.header.child('[type\x3dclose]').setVisible(me.closable);
  if (!cfg.title && !me.closable && !cfg.iconCls) {
    me.header.hide();
  } else {
    me.header.show();
  }
  me.liveDrag = !cfg.proxyDrag;
  me.userCallback = Ext.Function.bind(cfg.callback || cfg.fn || Ext.emptyFn, cfg.scope || Ext.global);
  me.setIcon(cfg.icon, cfg.iconWidth, cfg.iconHeight);
  msg = me.msg;
  if (cfg.msg) {
    msg.setValue(cfg.msg);
    msg.show();
  } else {
    msg.hide();
  }
  textArea = me.textArea;
  textField = me.textField;
  if (cfg.prompt || cfg.multiline) {
    me.multiline = cfg.multiline;
    if (cfg.multiline) {
      textArea.setValue(cfg.value);
      textArea.setHeight(cfg.defaultTextHeight || me.defaultTextHeight);
      textArea.show();
      textField.hide();
      me.defaultFocus = textArea;
    } else {
      textField.setValue(cfg.value);
      textArea.hide();
      textField.show();
      me.defaultFocus = textField;
    }
  } else {
    textArea.hide();
    textField.hide();
  }
  progressBar = me.progressBar;
  if (cfg.progress || cfg.wait) {
    progressBar.show();
    me.updateProgress(0, cfg.progressText);
    if (cfg.wait === true) {
      progressBar.wait(cfg.waitConfig);
    }
  } else {
    progressBar.hide();
  }
  msgButtons = me.msgButtons;
  for (i = 0; i < 4; i++) {
    if (buttons & Math.pow(2, i)) {
      if (!me.defaultFocus) {
        me.defaultFocus = msgButtons[i];
      }
      msgButtons[i].show();
      hideToolbar = false;
    } else {
      msgButtons[i].hide();
    }
  }
  if (hideToolbar) {
    me.bottomTb.hide();
  } else {
    me.bottomTb.show();
  }
  Ext.resumeLayouts(true);
}, updateButtonText:function() {
  var me = this, buttonText = me.buttonText, buttons = 0, btnId, btn;
  for (btnId in buttonText) {
    if (buttonText.hasOwnProperty(btnId)) {
      btn = me.msgButtons[btnId];
      if (btn) {
        if (me.cfg && me.cfg.buttonText) {
          buttons = buttons | Math.pow(2, Ext.Array.indexOf(me.buttonIds, btnId));
        }
        if (btn.text != buttonText[btnId]) {
          btn.setText(buttonText[btnId]);
        }
      }
    }
  }
  return buttons;
}, show:function(cfg) {
  var me = this, visibleFocusables;
  if (Ext.AbstractComponent.layoutSuspendCount) {
    Ext.on({resumelayouts:function() {
      me.show(cfg);
    }, single:true});
    return me;
  }
  me.reconfigure(cfg);
  if (cfg.cls) {
    me.addCls(cfg.cls);
  }
  visibleFocusables = me.query('textfield:not([hidden]),textarea:not([hidden]),button:not([hidden])');
  me.preventFocusOnActivate = !visibleFocusables.length;
  me.hidden = true;
  me.callParent();
  return me;
}, onShow:function() {
  this.callParent(arguments);
  this.center();
}, updateText:function(text) {
  this.msg.setValue(text);
}, setIcon:function(icon, width, height) {
  var me = this, iconCmp = me.iconComponent, cls = me.messageIconCls;
  if (cls) {
    iconCmp.removeCls(cls);
  }
  if (icon) {
    iconCmp.show();
    iconCmp.setSize(width || me.iconWidth, height || me.iconHeight);
    iconCmp.addCls(Ext.baseCSSPrefix + 'dlg-icon');
    iconCmp.addCls(me.messageIconCls = icon);
  } else {
    iconCmp.removeCls(Ext.baseCSSPrefix + 'dlg-icon');
    iconCmp.hide();
  }
  return me;
}, updateProgress:function(value, progressText, msg) {
  this.progressBar.updateProgress(value, progressText);
  if (msg) {
    this.updateText(msg);
  }
  return this;
}, onEsc:function() {
  if (this.closable !== false) {
    this.callParent(arguments);
  }
}, confirm:function(cfg, msg, fn, scope) {
  if (Ext.isString(cfg)) {
    cfg = {title:cfg, icon:this.QUESTION, msg:msg, buttons:this.YESNO, callback:fn, scope:scope};
  }
  return this.show(cfg);
}, prompt:function(cfg, msg, fn, scope, multiline, value) {
  if (Ext.isString(cfg)) {
    cfg = {prompt:true, title:cfg, minWidth:this.minPromptWidth, msg:msg, buttons:this.OKCANCEL, callback:fn, scope:scope, multiline:multiline, value:value};
  }
  return this.show(cfg);
}, wait:function(cfg, title, config) {
  if (Ext.isString(cfg)) {
    cfg = {title:title, msg:cfg, closable:false, wait:true, modal:true, minWidth:this.minProgressWidth, waitConfig:config};
  }
  return this.show(cfg);
}, alert:function(cfg, msg, fn, scope) {
  if (Ext.isString(cfg)) {
    cfg = {title:cfg, msg:msg, buttons:this.OK, fn:fn, scope:scope, minWidth:this.minWidth};
  }
  return this.show(cfg);
}, progress:function(cfg, msg, progressText) {
  if (Ext.isString(cfg)) {
    cfg = {title:cfg, msg:msg, progress:true, progressText:progressText};
  }
  return this.show(cfg);
}}, function() {
  Ext.MessageBox = Ext.Msg = new this;
});
Ext.define('Ext.form.Label', {extend:Ext.Component, alias:'widget.label', autoEl:'label', maskOnDisable:false, getElConfig:function() {
  var me = this;
  me.html = me.text ? Ext.util.Format.htmlEncode(me.text) : me.html || '';
  return Ext.apply(me.callParent(), {htmlFor:me.forId || ''});
}, setText:function(text, encode) {
  var me = this;
  encode = encode !== false;
  if (encode) {
    me.text = text;
    delete me.html;
  } else {
    me.html = text;
    delete me.text;
  }
  if (me.rendered) {
    me.el.dom.innerHTML = encode !== false ? Ext.util.Format.htmlEncode(text) : text;
    me.updateLayout();
  }
  return me;
}});
Ext.define('Ext.layout.component.field.Trigger', {alias:'layout.triggerfield', extend:Ext.layout.component.field.Field, type:'triggerfield', borderWidths:{}, beginLayout:function(ownerContext) {
  var me = this, owner = me.owner, flags;
  ownerContext.triggerWrap = ownerContext.getEl('triggerWrap');
  me.callParent(arguments);
  flags = owner.getTriggerStateFlags();
  if (flags != owner.lastTriggerStateFlags) {
    owner.lastTriggerStateFlags = flags;
    me.updateEditState();
  }
}, beginLayoutCycle:function(ownerContext) {
  this.callParent(arguments);
  if (ownerContext.widthModel.shrinkWrap && !this.owner.inputWidth) {
    ownerContext.inputContext.el.setStyle('width', '');
  }
}, beginLayoutFixed:function(ownerContext, width, suffix) {
  var me = this, owner = ownerContext.target, ieInputWidthAdjustment = me.ieInputWidthAdjustment || 0, inputWidth = '100%', triggerWrap = owner.triggerWrap;
  me.callParent(arguments);
  owner.inputCell.setStyle('width', '100%');
  if (ieInputWidthAdjustment) {
    me.adjustIEInputPadding(ownerContext);
    if (suffix === 'px') {
      if (owner.inputWidth) {
        inputWidth = owner.inputWidth - me.getExtraWidth(ownerContext);
      } else {
        inputWidth = width - ieInputWidthAdjustment - me.getExtraWidth(ownerContext);
      }
      inputWidth += 'px';
    }
  }
  owner.inputEl.setStyle('width', inputWidth);
  inputWidth = owner.inputWidth;
  if (inputWidth) {
    triggerWrap.setStyle('width', inputWidth + ieInputWidthAdjustment + 'px');
  } else {
    triggerWrap.setStyle('width', width + suffix);
  }
  triggerWrap.setStyle('table-layout', 'fixed');
}, adjustIEInputPadding:function(ownerContext) {
  this.owner.inputCell.setStyle('padding-right', this.ieInputWidthAdjustment + 'px');
}, getExtraWidth:function(ownerContext) {
  var me = this, owner = me.owner, borderWidths = me.borderWidths, ui = owner.ui + owner.triggerEl.getCount();
  if (!(ui in borderWidths)) {
    borderWidths[ui] = ownerContext.triggerWrap.getBorderInfo().width;
  }
  return borderWidths[ui] + owner.getTriggerWidth();
}, beginLayoutShrinkWrap:function(ownerContext) {
  var owner = ownerContext.target, emptyString = '', inputWidth = owner.inputWidth, triggerWrap = owner.triggerWrap;
  this.callParent(arguments);
  if (inputWidth) {
    triggerWrap.setStyle('width', inputWidth + 'px');
    inputWidth = inputWidth - this.getExtraWidth(ownerContext) + 'px';
    owner.inputEl.setStyle('width', inputWidth);
    owner.inputCell.setStyle('width', inputWidth);
  } else {
    owner.inputCell.setStyle('width', emptyString);
    owner.inputEl.setStyle('width', emptyString);
    triggerWrap.setStyle('width', emptyString);
    triggerWrap.setStyle('table-layout', 'auto');
  }
}, getTextWidth:function() {
  var me = this, owner = me.owner, inputEl = owner.inputEl, value;
  value = (inputEl.dom.value || (owner.hasFocus ? '' : owner.emptyText) || '') + owner.growAppend;
  return inputEl.getTextWidth(value);
}, publishOwnerWidth:function(ownerContext, width) {
  var owner = this.owner;
  this.callParent(arguments);
  if (!owner.grow && !owner.inputWidth) {
    width -= this.getExtraWidth(ownerContext);
    if (owner.labelAlign != 'top') {
      width -= owner.getLabelWidth();
    }
    ownerContext.inputContext.setWidth(width);
  }
}, publishInnerHeight:function(ownerContext, height) {
  ownerContext.inputContext.setHeight(height - this.measureLabelErrorHeight(ownerContext));
}, measureContentWidth:function(ownerContext) {
  var me = this, owner = me.owner, width = me.callParent(arguments), inputContext = ownerContext.inputContext, calcWidth, max, min;
  if (owner.grow && !ownerContext.state.growHandled) {
    calcWidth = me.getTextWidth() + ownerContext.inputContext.getFrameInfo().width;
    max = owner.growMax;
    min = Math.min(max, width);
    max = Math.max(owner.growMin, max, min);
    calcWidth = Ext.Number.constrain(calcWidth, owner.growMin, max);
    inputContext.setWidth(calcWidth);
    ownerContext.state.growHandled = true;
    inputContext.domBlock(me, 'width');
    width = NaN;
  } else {
    if (!owner.inputWidth) {
      width -= me.getExtraWidth(ownerContext);
    }
  }
  return width;
}, updateEditState:function() {
  var me = this, owner = me.owner, inputEl = owner.inputEl, noeditCls = Ext.baseCSSPrefix + 'trigger-noedit', displayed, readOnly;
  if (me.owner.readOnly) {
    inputEl.addCls(noeditCls);
    readOnly = true;
    displayed = false;
  } else {
    if (me.owner.editable) {
      inputEl.removeCls(noeditCls);
      readOnly = false;
    } else {
      inputEl.addCls(noeditCls);
      readOnly = true;
    }
    displayed = !me.owner.hideTrigger;
  }
  owner.triggerCell.setDisplayed(displayed);
  inputEl.dom.readOnly = readOnly;
}});
Ext.define('Ext.form.field.Trigger', {extend:Ext.form.field.Text, alias:['widget.triggerfield', 'widget.trigger'], alternateClassName:['Ext.form.TriggerField', 'Ext.form.TwinTriggerField', 'Ext.form.Trigger'], childEls:[{name:'triggerCell', select:'.' + Ext.baseCSSPrefix + 'trigger-cell'}, {name:'triggerEl', select:'.' + Ext.baseCSSPrefix + 'form-trigger'}, 'triggerWrap', 'inputCell'], triggerBaseCls:Ext.baseCSSPrefix + 'form-trigger', triggerWrapCls:Ext.baseCSSPrefix + 'form-trigger-wrap', triggerNoEditCls:Ext.baseCSSPrefix + 
'trigger-noedit', hideTrigger:false, editable:true, readOnly:false, repeatTriggerClick:false, autoSize:Ext.emptyFn, monitorTab:true, mimicing:false, triggerIndexRe:/trigger-index-(\d+)/, extraTriggerCls:'', componentLayout:'triggerfield', initComponent:function() {
  this.wrapFocusCls = this.triggerWrapCls + '-focus';
  this.callParent(arguments);
}, getSubTplMarkup:function(values) {
  var me = this, childElCls = values.childElCls, field = me.callParent(arguments);
  return '\x3ctable id\x3d"' + me.id + '-triggerWrap" class\x3d"' + Ext.baseCSSPrefix + 'form-trigger-wrap' + childElCls + '" cellpadding\x3d"0" cellspacing\x3d"0"\x3e\x3ctbody\x3e\x3ctr\x3e' + '\x3ctd id\x3d"' + me.id + '-inputCell" class\x3d"' + Ext.baseCSSPrefix + 'form-trigger-input-cell' + childElCls + '"\x3e' + field + '\x3c/td\x3e' + me.getTriggerMarkup() + '\x3c/tr\x3e\x3c/tbody\x3e\x3c/table\x3e';
}, getSubTplData:function() {
  var me = this, data = me.callParent(), readOnly = me.readOnly === true, editable = me.editable !== false;
  return Ext.apply(data, {editableCls:readOnly || !editable ? ' ' + me.triggerNoEditCls : '', readOnly:!editable || readOnly});
}, getLabelableRenderData:function() {
  var me = this, triggerWrapCls = me.triggerWrapCls, result = me.callParent(arguments);
  return Ext.applyIf(result, {triggerWrapCls:triggerWrapCls, triggerMarkup:me.getTriggerMarkup()});
}, getTriggerMarkup:function() {
  var me = this, i = 0, hideTrigger = me.readOnly || me.hideTrigger, triggerCls, triggerBaseCls = me.triggerBaseCls, triggerConfigs = [], unselectableCls = Ext.dom.Element.unselectableCls, style = 'width:' + me.triggerWidth + 'px;' + (hideTrigger ? 'display:none;' : ''), cls = me.extraTriggerCls + ' ' + Ext.baseCSSPrefix + 'trigger-cell ' + unselectableCls;
  if (!me.trigger1Cls) {
    me.trigger1Cls = me.triggerCls;
  }
  for (i = 0; (triggerCls = me['trigger' + (i + 1) + 'Cls']) || i < 1; i++) {
    triggerConfigs.push({tag:'td', valign:'top', cls:cls, style:style, cn:{cls:[Ext.baseCSSPrefix + 'trigger-index-' + i, triggerBaseCls, triggerCls].join(' '), role:'button'}});
  }
  triggerConfigs[0].cn.cls += ' ' + triggerBaseCls + '-first';
  return Ext.DomHelper.markup(triggerConfigs);
}, disableCheck:function() {
  return !this.disabled;
}, beforeRender:function() {
  var me = this, triggerBaseCls = me.triggerBaseCls, tempEl;
  if (!me.triggerWidth) {
    tempEl = Ext.getBody().createChild({style:'position: absolute;', cls:Ext.baseCSSPrefix + 'form-trigger'});
    Ext.form.field.Trigger.prototype.triggerWidth = tempEl.getWidth();
    tempEl.remove();
  }
  me.callParent();
  if (triggerBaseCls != Ext.baseCSSPrefix + 'form-trigger') {
    me.addChildEls({name:'triggerEl', select:'.' + triggerBaseCls});
  }
  me.lastTriggerStateFlags = me.getTriggerStateFlags();
}, onRender:function() {
  var me = this;
  me.callParent(arguments);
  me.doc = Ext.getDoc();
  me.initTrigger();
}, getTriggerWidth:function() {
  var me = this, totalTriggerWidth = 0;
  if (me.triggerWrap && !me.hideTrigger && !me.readOnly) {
    totalTriggerWidth = me.triggerEl.getCount() * me.triggerWidth;
  }
  return totalTriggerWidth;
}, setHideTrigger:function(hideTrigger) {
  if (hideTrigger != this.hideTrigger) {
    this.hideTrigger = hideTrigger;
    this.updateLayout();
  }
}, setEditable:function(editable) {
  if (editable != this.editable) {
    this.editable = editable;
    this.updateLayout();
  }
}, setReadOnly:function(readOnly) {
  var me = this, old = me.readOnly;
  me.callParent(arguments);
  if (readOnly != old) {
    me.updateLayout();
  }
}, initTrigger:function() {
  var me = this, triggerWrap = me.triggerWrap, triggerEl = me.triggerEl, disableCheck = me.disableCheck, els, eLen, el, e, idx;
  if (me.repeatTriggerClick) {
    me.triggerRepeater = new Ext.util.ClickRepeater(triggerWrap, {preventDefault:true, handler:me.onTriggerWrapClick, listeners:{mouseup:me.onTriggerWrapMouseup, scope:me}, scope:me});
  } else {
    me.mon(triggerWrap, {click:me.onTriggerWrapClick, mouseup:me.onTriggerWrapMouseup, scope:me});
  }
  triggerEl.setVisibilityMode(Ext.Element.DISPLAY);
  triggerEl.addClsOnOver(me.triggerBaseCls + '-over', disableCheck, me);
  els = triggerEl.elements;
  eLen = els.length;
  for (e = 0; e < eLen; e++) {
    el = els[e];
    idx = e + 1;
    el.addClsOnOver(me['trigger' + idx + 'Cls'] + '-over', disableCheck, me);
    el.addClsOnClick(me['trigger' + idx + 'Cls'] + '-click', disableCheck, me);
  }
  triggerEl.addClsOnClick(me.triggerBaseCls + '-click', disableCheck, me);
}, onDestroy:function() {
  var me = this;
  Ext.destroyMembers(me, 'triggerRepeater', 'triggerWrap', 'triggerEl');
  delete me.doc;
  me.callParent();
}, onFocus:function() {
  var me = this;
  me.callParent(arguments);
  if (!me.mimicing) {
    me.bodyEl.addCls(me.wrapFocusCls);
    me.mimicing = true;
    me.mon(me.doc, 'mousedown', me.mimicBlur, me, {delay:10});
    if (me.monitorTab) {
      me.on('specialkey', me.checkTab, me);
    }
  }
}, checkTab:function(me, e) {
  if (!this.ignoreMonitorTab && e.getKey() == e.TAB) {
    this.triggerBlur();
  }
}, getTriggerStateFlags:function() {
  var me = this, state = 0;
  if (me.readOnly) {
    state += 1;
  }
  if (me.editable) {
    state += 2;
  }
  if (me.hideTrigger) {
    state += 4;
  }
  return state;
}, onBlur:Ext.emptyFn, mimicBlur:function(e) {
  if (!this.isDestroyed && !this.bodyEl.contains(e.target) && this.validateBlur(e)) {
    this.triggerBlur(e);
  }
}, triggerBlur:function(e) {
  var me = this;
  me.mimicing = false;
  me.mun(me.doc, 'mousedown', me.mimicBlur, me);
  if (me.monitorTab && me.inputEl) {
    me.un('specialkey', me.checkTab, me);
  }
  Ext.form.field.Trigger.superclass.onBlur.call(me, e);
  if (me.bodyEl) {
    me.bodyEl.removeCls(me.wrapFocusCls);
  }
}, validateBlur:function(e) {
  return true;
}, onTriggerWrapClick:function() {
  var me = this, targetEl, match, triggerClickMethod, event;
  event = arguments[me.triggerRepeater ? 1 : 0];
  if (event && !me.readOnly && !me.disabled) {
    targetEl = event.getTarget('.' + me.triggerBaseCls, null);
    match = targetEl && targetEl.className.match(me.triggerIndexRe);
    if (match) {
      triggerClickMethod = me['onTrigger' + (parseInt(match[1], 10) + 1) + 'Click'] || me.onTriggerClick;
      if (triggerClickMethod) {
        triggerClickMethod.call(me, event);
      }
    }
  }
}, onTriggerWrapMouseup:Ext.emptyFn, onTriggerClick:Ext.emptyFn});
Ext.define('Ext.form.field.Picker', {extend:Ext.form.field.Trigger, alias:'widget.pickerfield', alternateClassName:'Ext.form.Picker', matchFieldWidth:true, pickerAlign:'tl-bl?', openCls:Ext.baseCSSPrefix + 'pickerfield-open', editable:true, initComponent:function() {
  this.callParent();
  this.addEvents('expand', 'collapse', 'select');
}, initEvents:function() {
  var me = this;
  me.callParent();
  me.keyNav = new Ext.util.KeyNav(me.inputEl, {down:me.onDownArrow, esc:{handler:me.onEsc, scope:me, defaultEventAction:false}, scope:me, forceKeyDown:true});
  if (!me.editable) {
    me.mon(me.inputEl, 'click', me.onTriggerClick, me);
  }
  if (Ext.isGecko) {
    me.inputEl.dom.setAttribute('autocomplete', 'off');
  }
}, onEsc:function(e) {
  if (Ext.isIE) {
    e.preventDefault();
  }
  if (this.isExpanded) {
    this.collapse();
    e.stopEvent();
  }
}, onDownArrow:function(e) {
  if (!this.isExpanded) {
    this.onTriggerClick();
  }
}, expand:function() {
  var me = this, bodyEl, picker, collapseIf;
  if (me.rendered && !me.isExpanded && !me.isDestroyed) {
    me.expanding = true;
    bodyEl = me.bodyEl;
    picker = me.getPicker();
    collapseIf = me.collapseIf;
    picker.show();
    me.isExpanded = true;
    me.alignPicker();
    bodyEl.addCls(me.openCls);
    me.mon(Ext.getDoc(), {mousewheel:collapseIf, mousedown:collapseIf, scope:me});
    Ext.EventManager.onWindowResize(me.alignPicker, me);
    me.fireEvent('expand', me);
    me.onExpand();
    delete me.expanding;
  }
}, onExpand:Ext.emptyFn, alignPicker:function() {
  var me = this, picker = me.getPicker();
  if (me.isExpanded) {
    if (me.matchFieldWidth) {
      picker.setWidth(me.bodyEl.getWidth());
    }
    if (picker.isFloating()) {
      me.doAlign();
    }
  }
}, doAlign:function() {
  var me = this, picker = me.picker, aboveSfx = '-above', isAbove;
  me.picker.alignTo(me.triggerWrap, me.pickerAlign, me.pickerOffset);
  isAbove = picker.el.getY() < me.inputEl.getY();
  me.bodyEl[isAbove ? 'addCls' : 'removeCls'](me.openCls + aboveSfx);
  picker[isAbove ? 'addCls' : 'removeCls'](picker.baseCls + aboveSfx);
}, collapse:function() {
  if (this.isExpanded && !this.isDestroyed) {
    var me = this, openCls = me.openCls, picker = me.picker, doc = Ext.getDoc(), collapseIf = me.collapseIf, aboveSfx = '-above';
    picker.hide();
    me.isExpanded = false;
    me.bodyEl.removeCls([openCls, openCls + aboveSfx]);
    picker.el.removeCls(picker.baseCls + aboveSfx);
    doc.un('mousewheel', collapseIf, me);
    doc.un('mousedown', collapseIf, me);
    Ext.EventManager.removeResizeListener(me.alignPicker, me);
    me.fireEvent('collapse', me);
    me.onCollapse();
  }
}, onCollapse:Ext.emptyFn, collapseIf:function(e) {
  var me = this;
  if (!me.isDestroyed && !e.within(me.bodyEl, false, true) && !e.within(me.picker.el, false, true) && !me.isEventWithinPickerLoadMask(e)) {
    me.collapse();
  }
}, getPicker:function() {
  var me = this;
  return me.picker || (me.picker = me.createPicker());
}, createPicker:Ext.emptyFn, onTriggerClick:function() {
  var me = this;
  if (!me.readOnly && !me.disabled) {
    if (me.isExpanded) {
      me.collapse();
    } else {
      me.expand();
    }
    me.inputEl.focus();
  }
}, triggerBlur:function() {
  var picker = this.picker;
  this.callParent(arguments);
  if (picker && picker.isVisible()) {
    picker.hide();
  }
}, mimicBlur:function(e) {
  var me = this, picker = me.picker;
  if (!picker || !e.within(picker.el, false, true) && !me.isEventWithinPickerLoadMask(e)) {
    me.callParent(arguments);
  }
}, onDestroy:function() {
  var me = this, picker = me.picker;
  Ext.EventManager.removeResizeListener(me.alignPicker, me);
  Ext.destroy(me.keyNav);
  if (picker) {
    delete picker.pickerField;
    picker.destroy();
  }
  me.callParent();
}, isEventWithinPickerLoadMask:function(e) {
  var loadMask = this.picker.loadMask;
  return loadMask ? e.within(loadMask.maskEl, false, true) || e.within(loadMask.el, false, true) : false;
}});
Ext.define('Ext.selection.Model', {extend:Ext.util.Observable, alternateClassName:'Ext.AbstractSelectionModel', mixins:{bindable:Ext.util.Bindable}, allowDeselect:undefined, toggleOnClick:true, selected:null, pruneRemoved:true, suspendChange:0, constructor:function(cfg) {
  var me = this;
  cfg = cfg || {};
  Ext.apply(me, cfg);
  me.addEvents('selectionchange', 'focuschange');
  me.modes = {SINGLE:true, SIMPLE:true, MULTI:true};
  me.setSelectionMode(cfg.mode || me.mode);
  me.selected = new Ext.util.MixedCollection(null, me.getSelectionId);
  me.callParent(arguments);
}, bindStore:function(store, initial) {
  var me = this;
  me.mixins.bindable.bindStore.apply(me, arguments);
  if (me.store && !initial) {
    me.refresh();
  }
}, getStoreListeners:function() {
  var me = this;
  return {add:me.onStoreAdd, clear:me.onStoreClear, bulkremove:me.onStoreRemove, update:me.onStoreUpdate, load:me.onStoreLoad, idchanged:me.onModelIdChanged, refresh:me.onStoreRefresh};
}, suspendChanges:function() {
  ++this.suspendChange;
}, resumeChanges:function() {
  if (this.suspendChange) {
    --this.suspendChange;
  }
}, selectAll:function(suppressEvent) {
  var me = this, selections = me.store.getRange(), i = 0, len = selections.length, start = me.getSelection().length;
  me.suspendChanges();
  for (; i < len; i++) {
    me.doSelect(selections[i], true, suppressEvent);
  }
  me.resumeChanges();
  if (!suppressEvent) {
    me.maybeFireSelectionChange(me.getSelection().length !== start);
  }
}, deselectAll:function(suppressEvent) {
  var me = this, selections = me.getSelection(), selIndexes = {}, store = me.store, start = selections.length, i, l, rec;
  for (i = 0, l = selections.length; i < l; i++) {
    rec = selections[i];
    selIndexes[rec.internalId] = store.indexOf(rec);
  }
  selections = Ext.Array.sort(selections, function(r1, r2) {
    var idx1 = selIndexes[r1.internalId], idx2 = selIndexes[r2.internalId];
    return idx1 < idx2 ? -1 : 1;
  });
  me.suspendChanges();
  me.doDeselect(selections, suppressEvent);
  me.resumeChanges();
  if (!suppressEvent) {
    me.maybeFireSelectionChange(me.getSelection().length !== start);
  }
}, selectWithEvent:function(record, e) {
  var me = this, isSelected = me.isSelected(record), shift = e.shiftKey, ctrl = e.ctrlKey, start = me.selectionStart, selected = me.getSelection(), len = selected.length, allowDeselect = me.allowDeselect, toDeselect, i, item;
  switch(me.selectionMode) {
    case 'MULTI':
      if (shift && start) {
        me.selectRange(start, record, ctrl);
      } else {
        if (ctrl && isSelected) {
          me.doDeselect(record, false);
        } else {
          if (ctrl) {
            me.doSelect(record, true, false);
          } else {
            if (isSelected && !shift && !ctrl && len > 1) {
              toDeselect = [];
              for (i = 0; i < len; ++i) {
                item = selected[i];
                if (item !== record) {
                  toDeselect.push(item);
                }
              }
              me.doDeselect(toDeselect);
            } else {
              if (!isSelected) {
                me.doSelect(record, false);
              }
            }
          }
        }
      }
      break;
    case 'SIMPLE':
      if (isSelected) {
        me.doDeselect(record);
      } else {
        me.doSelect(record, true);
      }
      break;
    case 'SINGLE':
      if (allowDeselect && !ctrl) {
        allowDeselect = me.toggleOnClick;
      }
      if (allowDeselect && isSelected) {
        me.doDeselect(record);
      } else {
        me.doSelect(record, false);
      }
      break;
  }
  if (!shift) {
    if (me.isSelected(record)) {
      me.selectionStart = record;
    } else {
      me.selectionStart = null;
    }
  }
}, afterKeyNavigate:function(e, record) {
  var me = this, recIdx, fromIdx, isSelected = me.isSelected(record), from = me.selectionStart && me.isSelected(me.lastFocused) ? me.selectionStart : me.selectionStart = me.lastFocused, key = e.getCharCode(), isSpace = key === e.SPACE, direction = key === e.UP || key === e.PAGE_UP ? 'up' : key === e.DOWN || key === e.DOWN ? 'down' : null;
  switch(me.selectionMode) {
    case 'MULTI':
      if (isSpace) {
        if (e.shiftKey) {
          me.selectRange(from, record, e.ctrlKey);
        } else {
          if (isSelected) {
            me.doDeselect(record, e.ctrlKey);
            me.setLastFocused(null);
            me.setLastFocused(record);
          } else {
            me.doSelect(record, e.ctrlKey);
          }
        }
      } else {
        if (e.shiftKey && from) {
          fromIdx = me.store.indexOf(from);
          recIdx = me.store.indexOf(record);
          if (direction === 'up' && fromIdx <= recIdx) {
            me.deselectRange(me.lastFocused, recIdx + 1);
          } else {
            if (direction === 'down' && fromIdx >= recIdx) {
              me.deselectRange(me.lastFocused, recIdx - 1);
            } else {
              if (from !== record) {
                me.selectRange(from, record, e.ctrlKey);
              }
            }
          }
          me.lastSelected = record;
          me.setLastFocused(record);
        } else {
          if (e.ctrlKey && isSelected) {
            me.setLastFocused(record);
          } else {
            if (e.ctrlKey) {
              me.setLastFocused(record);
            } else {
              me.doSelect(record, false);
            }
          }
        }
      }
      break;
    case 'SIMPLE':
      if (isSelected) {
        me.doDeselect(record);
      } else {
        me.doSelect(record, true);
      }
      break;
    case 'SINGLE':
      if (isSpace) {
        if (isSelected) {
          me.doDeselect(record);
          me.setLastFocused(record);
        } else {
          me.doSelect(record);
        }
      } else {
        if (e.ctrlKey) {
          me.setLastFocused(record);
        } else {
          if (me.allowDeselect && isSelected) {
            me.doDeselect(record);
          } else {
            me.doSelect(record, false);
          }
        }
      }
      break;
  }
  if (!e.shiftKey) {
    if (me.isSelected(record)) {
      me.selectionStart = record;
    }
  }
}, selectRange:function(startRow, endRow, keepExisting) {
  var me = this, store = me.store, selected = me.selected.items, result, i, len, toSelect, toDeselect, idx, rec;
  if (me.isLocked()) {
    return;
  }
  result = me.normalizeRowRange(startRow, endRow);
  startRow = result[0];
  endRow = result[1];
  toSelect = [];
  for (i = startRow; i <= endRow; i++) {
    if (!me.isSelected(store.getAt(i))) {
      toSelect.push(store.getAt(i));
    }
  }
  if (!keepExisting) {
    toDeselect = [];
    me.suspendChanges();
    for (i = 0, len = selected.length; i < len; ++i) {
      rec = selected[i];
      idx = store.indexOf(rec);
      if (idx < startRow || idx > endRow) {
        toDeselect.push(rec);
      }
    }
    for (i = 0, len = toDeselect.length; i < len; ++i) {
      me.doDeselect(toDeselect[i]);
    }
    me.resumeChanges();
  }
  me.doMultiSelect(toSelect, true);
}, deselectRange:function(startRow, endRow) {
  var me = this, store = me.store, result, i, toDeselect, record;
  if (me.isLocked()) {
    return;
  }
  result = me.normalizeRowRange(startRow, endRow);
  startRow = result[0];
  endRow = result[1];
  toDeselect = [];
  for (i = startRow; i <= endRow; i++) {
    record = store.getAt(i);
    if (me.isSelected(record)) {
      toDeselect.push(record);
    }
  }
  me.doDeselect(toDeselect);
}, normalizeRowRange:function(startRow, endRow) {
  var store = this.store, tmp;
  if (!Ext.isNumber(startRow)) {
    startRow = store.indexOf(startRow);
  }
  startRow = Math.max(0, startRow);
  if (!Ext.isNumber(endRow)) {
    endRow = store.indexOf(endRow);
  }
  endRow = Math.min(endRow, store.getCount() - 1);
  if (startRow > endRow) {
    tmp = endRow;
    endRow = startRow;
    startRow = tmp;
  }
  return [startRow, endRow];
}, onModelIdChanged:function(store, model, oldId, newId, oldInternalId) {
  this.selected.updateKey(oldInternalId, newId);
}, select:function(records, keepExisting, suppressEvent) {
  if (Ext.isDefined(records)) {
    this.doSelect(records, keepExisting, suppressEvent);
  }
}, deselect:function(records, suppressEvent) {
  this.doDeselect(records, suppressEvent);
}, doSelect:function(records, keepExisting, suppressEvent) {
  var me = this, record;
  if (me.locked || !me.store) {
    return;
  }
  if (typeof records === 'number') {
    record = me.store.getAt(records);
    if (!record) {
      return;
    }
    records = [record];
  }
  if (me.selectionMode == 'SINGLE' && records) {
    record = records.length ? records[0] : records;
    me.doSingleSelect(record, suppressEvent);
  } else {
    me.doMultiSelect(records, keepExisting, suppressEvent);
  }
}, doMultiSelect:function(records, keepExisting, suppressEvent) {
  var me = this, selected = me.selected, change = false, result, i, len, record, commit;
  if (me.locked) {
    return;
  }
  records = !Ext.isArray(records) ? [records] : records;
  len = records.length;
  if (!keepExisting && selected.getCount() > 0) {
    result = me.deselectDuringSelect(records, selected.getRange(), suppressEvent);
    if (result[0]) {
      me.maybeFireSelectionChange(result[1] > 0 && !suppressEvent);
      return;
    }
  }
  commit = function() {
    selected.add(record);
    change = true;
  };
  for (i = 0; i < len; i++) {
    record = records[i];
    if (me.isSelected(record)) {
      continue;
    }
    me.lastSelected = record;
    me.onSelectChange(record, true, suppressEvent, commit);
  }
  if (!me.preventFocus) {
    me.setLastFocused(record, suppressEvent);
  }
  me.maybeFireSelectionChange(change && !suppressEvent);
}, deselectDuringSelect:function(toSelect, selected, suppressEvent) {
  var me = this, len = selected.length, changed = 0, failed = false, item, i;
  me.suspendChanges();
  for (i = 0; i < len; ++i) {
    item = selected[i];
    if (!Ext.Array.contains(toSelect, item)) {
      if (me.doDeselect(item, suppressEvent)) {
        ++changed;
      } else {
        failed = true;
      }
    }
  }
  me.resumeChanges();
  return [failed, changed];
}, doDeselect:function(records, suppressEvent) {
  var me = this, selected = me.selected, i = 0, len, record, attempted = 0, accepted = 0, commit;
  if (me.locked || !me.store) {
    return false;
  }
  if (typeof records === 'number') {
    record = me.store.getAt(records);
    if (!record) {
      return false;
    }
    records = [record];
  } else {
    if (!Ext.isArray(records)) {
      records = [records];
    }
  }
  commit = function() {
    ++accepted;
    selected.remove(record);
  };
  len = records.length;
  me.suspendChanges();
  for (; i < len; i++) {
    record = records[i];
    if (me.isSelected(record)) {
      if (me.lastSelected === record) {
        me.lastSelected = selected.last();
        if (me.lastFocused === record) {
          me.setLastFocused(null);
        }
      }
      ++attempted;
      me.onSelectChange(record, false, suppressEvent, commit);
    }
  }
  me.resumeChanges();
  me.maybeFireSelectionChange(accepted > 0 && !suppressEvent);
  return accepted === attempted;
}, doSingleSelect:function(record, suppressEvent) {
  var me = this, changed = false, selected = me.selected, commit;
  if (me.locked) {
    return;
  }
  if (me.isSelected(record)) {
    return;
  }
  if (selected.getCount()) {
    me.suspendChanges();
    if (!me.doDeselect(me.lastSelected, suppressEvent)) {
      me.resumeChanges();
      return;
    }
    me.resumeChanges();
  }
  commit = function() {
    selected.add(record);
    me.lastSelected = record;
    changed = true;
  };
  me.onSelectChange(record, true, suppressEvent, commit);
  if (changed) {
    if (!suppressEvent && !me.preventFocus) {
      me.setLastFocused(record);
    }
    me.maybeFireSelectionChange(!suppressEvent);
  }
}, setLastFocused:function(record, supressFocus) {
  var me = this, recordBeforeLast = me.lastFocused;
  if (record !== recordBeforeLast) {
    me.lastFocused = record;
    me.onLastFocusChanged(recordBeforeLast, record, supressFocus);
  }
}, isFocused:function(record) {
  return record === this.getLastFocused();
}, maybeFireSelectionChange:function(fireEvent) {
  var me = this;
  if (fireEvent && !me.suspendChange) {
    me.fireEvent('selectionchange', me, me.getSelection());
  }
}, getLastSelected:function() {
  return this.lastSelected;
}, getLastFocused:function() {
  return this.lastFocused;
}, getSelection:function() {
  return this.selected.getRange();
}, getSelectionMode:function() {
  return this.selectionMode;
}, setSelectionMode:function(selMode) {
  selMode = selMode ? selMode.toUpperCase() : 'SINGLE';
  this.selectionMode = this.modes[selMode] ? selMode : 'SINGLE';
}, isLocked:function() {
  return this.locked;
}, setLocked:function(locked) {
  this.locked = !!locked;
}, isRangeSelected:function(startRow, endRow) {
  var me = this, store = me.store, i, result;
  result = me.normalizeRowRange(startRow, endRow);
  startRow = result[0];
  endRow = result[1];
  for (i = startRow; i <= endRow; i++) {
    if (!me.isSelected(store.getAt(i))) {
      return false;
    }
  }
  return true;
}, isSelected:function(record) {
  record = Ext.isNumber(record) ? this.store.getAt(record) : record;
  return this.selected.contains(record);
}, hasSelection:function() {
  return this.selected.getCount() > 0;
}, getSelectionId:function(record) {
  return record.internalId;
}, pruneIf:function() {
  var me = this, selected = me.selected, toRemove = [], len = selected.length, i, item;
  if (me.pruneRemoved) {
    for (i = 0; i < len; i++) {
      item = selected.getAt(i);
      if (!this.storeHasSelected(item)) {
        toRemove.push(item);
      }
    }
    if (toRemove.length) {
      for (i = 0, len = toRemove.length; i < len; i++) {
        selected.remove(toRemove[i]);
      }
      me.maybeFireSelectionChange(true);
    }
  }
}, storeHasSelected:function(record) {
  var store = this.store, records, len, id, i;
  if (record.hasId() && store.getById(record)) {
    return true;
  } else {
    records = store.data.items;
    len = records.length;
    id = record.internalId;
    for (i = 0; i < len; ++i) {
      if (id === records[i].internalId) {
        return true;
      }
    }
  }
  return false;
}, refresh:function() {
  var me = this, store = me.store, rec, toBeSelected = [], toBeReAdded = [], oldSelections = me.getSelection(), len = oldSelections.length, selection, change, i = 0, lastFocused = me.getLastFocused();
  if (!store) {
    return;
  }
  for (; i < len; i++) {
    selection = oldSelections[i];
    if (store.indexOf(selection) !== -1) {
      toBeSelected.push(selection);
    } else {
      if (!me.pruneRemoved) {
        rec = store.getById(selection.getId());
        if (rec) {
          toBeSelected.push(rec);
        } else {
          toBeReAdded.push(selection);
        }
      }
    }
    if (me.mode === 'SINGLE' && toBeReAdded.length) {
      break;
    }
  }
  if (me.selected.getCount() != toBeSelected.length + toBeReAdded.length) {
    change = true;
  }
  me.clearSelections();
  if (store.indexOf(lastFocused) !== -1) {
    me.setLastFocused(lastFocused, true);
  }
  if (toBeSelected.length) {
    me.doSelect(toBeSelected, false, true);
  }
  if (toBeReAdded.length) {
    me.selected.addAll(toBeReAdded);
    if (!me.lastSelected) {
      me.lastSelected = toBeReAdded[toBeReAdded.length - 1];
    }
  }
  me.maybeFireSelectionChange(change);
}, clearSelections:function() {
  this.selected.clear();
  this.lastSelected = null;
  this.setLastFocused(null);
}, onStoreAdd:Ext.emptyFn, onStoreClear:function() {
  if (this.selected.getCount() > 0) {
    this.clearSelections();
    this.maybeFireSelectionChange(true);
  }
}, onStoreRemove:function(store, records, indexes, isMove) {
  var me = this;
  if (me.selectionStart && Ext.Array.contains(records, me.selectionStart)) {
    me.selectionStart = null;
  }
  if (isMove || me.locked || !me.pruneRemoved) {
    return;
  }
  me.deselectDeletedRecords(records);
}, deselectDeletedRecords:function(records) {
  var me = this, selected = me.selected, i, length = records.length, removed = 0, record;
  for (i = 0; i < length; i++) {
    record = records[i];
    if (selected.remove(record)) {
      if (me.lastSelected == record) {
        me.lastSelected = null;
      }
      if (me.getLastFocused() == record) {
        me.setLastFocused(null);
      }
      ++removed;
    }
  }
  if (removed) {
    me.maybeFireSelectionChange(true);
  }
}, getCount:function() {
  return this.selected.getCount();
}, onUpdate:Ext.emptyFn, destroy:function() {
  this.clearListeners();
}, onStoreUpdate:Ext.emptyFn, onStoreRefresh:Ext.emptyFn, onStoreLoad:Ext.emptyFn, onSelectChange:function(record, isSelected, suppressEvent, commitFn) {
  var me = this, eventName = isSelected ? 'select' : 'deselect';
  if ((suppressEvent || me.fireEvent('before' + eventName, me, record)) !== false && commitFn() !== false) {
    if (!suppressEvent) {
      me.fireEvent(eventName, me, record);
    }
  }
}, onLastFocusChanged:function(oldFocused, newFocused) {
  this.fireEvent('focuschange', this, oldFocused, newFocused);
}, onEditorKey:Ext.emptyFn, beforeViewRender:function(view) {
  this.views = this.views || [];
  this.views.push(view);
  this.bindStore(view.getStore(), true);
}, bindComponent:Ext.emptyFn});
Ext.define('Ext.selection.DataViewModel', {extend:Ext.selection.Model, deselectOnContainerClick:true, enableKeyNav:true, constructor:function(cfg) {
  this.addEvents('beforedeselect', 'beforeselect', 'deselect', 'select');
  this.callParent(arguments);
}, bindComponent:function(view) {
  var me = this, eventListeners = {refresh:me.refresh, scope:me};
  me.view = view;
  me.bindStore(view.getStore());
  eventListeners[view.triggerEvent] = me.onItemClick;
  eventListeners[view.triggerCtEvent] = me.onContainerClick;
  view.on(eventListeners);
  if (me.enableKeyNav) {
    me.initKeyNav(view);
  }
}, onUpdate:function(record) {
  var view = this.view;
  if (view && this.isSelected(record)) {
    view.onItemSelect(record);
  }
}, onItemClick:function(view, record, item, index, e) {
  this.selectWithEvent(record, e);
}, onContainerClick:function() {
  if (this.deselectOnContainerClick) {
    this.deselectAll();
  }
}, initKeyNav:function(view) {
  var me = this;
  if (!view.rendered) {
    view.on({render:Ext.Function.bind(me.initKeyNav, me, [view]), single:true});
    return;
  }
  view.el.set({tabIndex:-1});
  me.keyNav = new Ext.util.KeyNav({target:view.el, ignoreInputFields:true, down:Ext.pass(me.onNavKey, [1], me), right:Ext.pass(me.onNavKey, [1], me), left:Ext.pass(me.onNavKey, [-1], me), up:Ext.pass(me.onNavKey, [-1], me), scope:me});
}, onNavKey:function(step) {
  step = step || 1;
  var me = this, view = me.view, selected = me.getSelection()[0], numRecords = me.view.store.getCount(), idx;
  if (selected) {
    idx = view.indexOf(view.getNode(selected)) + step;
  } else {
    idx = 0;
  }
  if (idx < 0) {
    idx = numRecords - 1;
  } else {
    if (idx >= numRecords) {
      idx = 0;
    }
  }
  me.select(idx);
}, onSelectChange:function(record, isSelected, suppressEvent, commitFn) {
  var me = this, view = me.view, eventName = isSelected ? 'select' : 'deselect';
  if ((suppressEvent || me.fireEvent('before' + eventName, me, record)) !== false && commitFn() !== false) {
    if (view) {
      if (isSelected) {
        view.onItemSelect(record);
      } else {
        view.onItemDeselect(record);
      }
    }
    if (!suppressEvent) {
      me.fireEvent(eventName, me, record);
    }
  }
}, onLastFocusChanged:function(oldFocus, newFocus, suppressFocus) {
  var view = this.view;
  if (view && !suppressFocus && newFocus) {
    view.focusNode(newFocus);
    this.fireEvent('focuschange', this, oldFocus, newFocus);
  }
}, destroy:function() {
  Ext.destroy(this.keyNav);
  this.callParent();
}});
Ext.define('Ext.view.AbstractView', {extend:Ext.Component, mixins:{bindable:Ext.util.Bindable}, inheritableStatics:{getRecord:function(node) {
  return this.getBoundView(node).getRecord(node);
}, getBoundView:function(node) {
  return Ext.getCmp(node.boundView);
}}, deferInitialRefresh:true, itemCls:Ext.baseCSSPrefix + 'dataview-item', loadingText:'Loading...', loadMask:true, loadingUseMsg:true, selectedItemCls:Ext.baseCSSPrefix + 'item-selected', emptyText:'', deferEmptyText:true, trackOver:false, blockRefresh:false, preserveScrollOnRefresh:false, last:false, triggerEvent:'itemclick', triggerCtEvent:'containerclick', addCmpEvents:function() {
}, initComponent:function() {
  var me = this, isDef = Ext.isDefined, itemTpl = me.itemTpl, memberFn = {};
  if (itemTpl) {
    if (Ext.isArray(itemTpl)) {
      itemTpl = itemTpl.join('');
    } else {
      if (Ext.isObject(itemTpl)) {
        memberFn = Ext.apply(memberFn, itemTpl.initialConfig);
        itemTpl = itemTpl.html;
      }
    }
    if (!me.itemSelector) {
      me.itemSelector = '.' + me.itemCls;
    }
    itemTpl = Ext.String.format('\x3ctpl for\x3d"."\x3e\x3cdiv class\x3d"{0}"\x3e{1}\x3c/div\x3e\x3c/tpl\x3e', me.itemCls, itemTpl);
    me.tpl = new Ext.XTemplate(itemTpl, memberFn);
  }
  if (!isDef(me.tpl) || !isDef(me.itemSelector)) {
    Ext.Error.raise({sourceClass:'Ext.view.View', tpl:me.tpl, itemSelector:me.itemSelector, msg:'DataView requires both tpl and itemSelector configurations to be defined.'});
  }
  me.callParent();
  me.tpl = me.getTpl('tpl');
  if (isDef(me.overCls) || isDef(me.overClass)) {
    if (Ext.isDefined(Ext.global.console)) {
      Ext.global.console.warn('Ext.view.View: Using the deprecated overCls or overClass configuration. Use overItemCls instead.');
    }
    me.overItemCls = me.overCls || me.overClass;
    delete me.overCls;
    delete me.overClass;
  }
  if (isDef(me.selectedCls) || isDef(me.selectedClass)) {
    if (Ext.isDefined(Ext.global.console)) {
      Ext.global.console.warn('Ext.view.View: Using the deprecated selectedCls or selectedClass configuration. Use selectedItemCls instead.');
    }
    me.selectedItemCls = me.selectedCls || me.selectedClass;
    delete me.selectedCls;
    delete me.selectedClass;
  }
  if (me.overItemCls) {
    me.trackOver = true;
  }
  me.addEvents('beforerefresh', 'refresh', 'viewready', 'itemupdate', 'itemadd', 'itemremove');
  me.addCmpEvents();
  me.store = Ext.data.StoreManager.lookup(me.store || 'ext-empty-store');
  if (!me.dataSource) {
    me.dataSource = me.store;
  }
  me.bindStore(me.dataSource, true, 'dataSource');
  if (!me.all) {
    me.all = new Ext.CompositeElementLite;
  }
  me.scrollState = {top:0, left:0};
  me.on({scroll:me.onViewScroll, element:'el', scope:me});
}, onRender:function() {
  var me = this, mask = me.loadMask, maskStore = me.getMaskStore(), cfg = {target:me, msg:me.loadingText, msgCls:me.loadingCls, useMsg:me.loadingUseMsg, store:maskStore};
  me.callParent(arguments);
  if (mask && !maskStore.proxy.isSynchronous) {
    if (Ext.isObject(mask)) {
      cfg = Ext.apply(cfg, mask);
    }
    me.loadMask = new Ext.LoadMask(cfg);
    me.loadMask.on({scope:me, beforeshow:me.onMaskBeforeShow, hide:me.onMaskHide});
  }
}, finishRender:function() {
  var me = this;
  me.callParent(arguments);
  if (!me.up('[collapsed],[hidden]')) {
    me.doFirstRefresh(me.dataSource);
  }
}, onBoxReady:function() {
  var me = this;
  me.callParent(arguments);
  if (!me.firstRefreshDone) {
    me.doFirstRefresh(me.dataSource);
  }
}, getMaskStore:function() {
  return this.store;
}, onMaskBeforeShow:function() {
  var me = this, loadingHeight = me.loadingHeight;
  if (loadingHeight && loadingHeight > me.getHeight()) {
    me.hasLoadingHeight = true;
    me.oldMinHeight = me.minHeight;
    me.minHeight = loadingHeight;
    me.updateLayout();
  }
}, onMaskHide:function() {
  var me = this;
  if (!me.destroying && me.hasLoadingHeight) {
    me.minHeight = me.oldMinHeight;
    me.updateLayout();
    delete me.hasLoadingHeight;
  }
}, beforeRender:function() {
  this.callParent(arguments);
  this.getSelectionModel().beforeViewRender(this);
}, afterRender:function() {
  this.callParent(arguments);
  this.getSelectionModel().bindComponent(this);
}, getSelectionModel:function() {
  var me = this, mode = 'SINGLE';
  if (me.simpleSelect) {
    mode = 'SIMPLE';
  } else {
    if (me.multiSelect) {
      mode = 'MULTI';
    }
  }
  if (!me.selModel || !me.selModel.events) {
    me.selModel = new Ext.selection.DataViewModel(Ext.apply({allowDeselect:me.allowDeselect, mode:mode}, me.selModel));
  }
  if (!me.selModel.hasRelaySetup) {
    me.relayEvents(me.selModel, ['selectionchange', 'beforeselect', 'beforedeselect', 'select', 'deselect', 'focuschange']);
    me.selModel.hasRelaySetup = true;
  }
  if (me.disableSelection) {
    me.selModel.locked = true;
  }
  return me.selModel;
}, refresh:function() {
  var me = this, targetEl, targetParent, oldDisplay, nextSibling, dom, records;
  if (!me.rendered || me.isDestroyed) {
    return;
  }
  if (!me.hasListeners.beforerefresh || me.fireEvent('beforerefresh', me) !== false) {
    targetEl = me.getTargetEl();
    records = me.getViewRange();
    dom = targetEl.dom;
    if (!me.preserveScrollOnRefresh) {
      targetParent = dom.parentNode;
      oldDisplay = dom.style.display;
      dom.style.display = 'none';
      nextSibling = dom.nextSibling;
      targetParent.removeChild(dom);
    }
    if (me.refreshCounter) {
      me.clearViewEl();
    } else {
      me.fixedNodes = targetEl.dom.childNodes.length;
      me.refreshCounter = 1;
    }
    me.tpl.append(targetEl, me.collectData(records, me.all.startIndex));
    if (records.length < 1) {
      if (!this.store.loading && (!me.deferEmptyText || me.hasFirstRefresh)) {
        Ext.core.DomHelper.insertHtml('beforeEnd', targetEl.dom, me.emptyText);
      }
      me.all.clear();
    } else {
      me.collectNodes(targetEl.dom);
      me.updateIndexes(0);
    }
    if (me.hasFirstRefresh) {
      if (me.refreshSelmodelOnRefresh !== false) {
        me.selModel.refresh();
      } else {
        me.selModel.pruneIf();
      }
    }
    me.hasFirstRefresh = true;
    if (!me.preserveScrollOnRefresh) {
      targetParent.insertBefore(dom, nextSibling);
      dom.style.display = oldDisplay;
    }
    this.refreshSize();
    me.fireEvent('refresh', me);
    if (!me.viewReady) {
      me.viewReady = true;
      me.fireEvent('viewready', me);
    }
  }
}, collectNodes:function(targetEl) {
  this.all.fill(Ext.query(this.getItemSelector(), Ext.getDom(targetEl)), this.all.startIndex);
}, getViewRange:function() {
  return this.dataSource.getRange();
}, refreshSize:function() {
  var sizeModel = this.getSizeModel();
  if (sizeModel.height.shrinkWrap || sizeModel.width.shrinkWrap) {
    this.updateLayout();
  }
}, clearViewEl:function() {
  var me = this, el = me.getTargetEl();
  if (me.fixedNodes) {
    while (el.dom.childNodes[me.fixedNodes]) {
      el.dom.removeChild(el.dom.childNodes[me.fixedNodes]);
    }
  } else {
    el.update('');
  }
  me.refreshCounter++;
}, onViewScroll:Ext.emptyFn, onIdChanged:Ext.emptyFn, saveScrollState:function() {
  if (this.rendered) {
    var dom = this.el.dom, state = this.scrollState;
    state.left = dom.scrollLeft;
    state.top = dom.scrollTop;
  }
}, restoreScrollState:function() {
  if (this.rendered) {
    var dom = this.el.dom, state = this.scrollState;
    dom.scrollLeft = state.left;
    dom.scrollTop = state.top;
  }
}, prepareData:function(data, index, record) {
  var associatedData, attr, hasCopied;
  if (record) {
    associatedData = record.getAssociatedData();
    for (attr in associatedData) {
      if (associatedData.hasOwnProperty(attr)) {
        if (!hasCopied) {
          data = Ext.Object.chain(data);
          hasCopied = true;
        }
        data[attr] = associatedData[attr];
      }
    }
  }
  return data;
}, collectData:function(records, startIndex) {
  var data = [], i = 0, len = records.length, record;
  for (; i < len; i++) {
    record = records[i];
    data[i] = this.prepareData(record.data, startIndex + i, record);
  }
  return data;
}, bufferRender:function(records, index) {
  var me = this, div = me.renderBuffer || (me.renderBuffer = document.createElement('div'));
  me.tpl.overwrite(div, me.collectData(records, index));
  return Ext.DomQuery.select(me.getItemSelector(), div);
}, getNodeContainer:function() {
  return this.getTargetEl();
}, onUpdate:function(ds, record) {
  var me = this, index, node;
  if (me.viewReady) {
    index = me.dataSource.indexOf(record);
    if (index > -1) {
      node = me.bufferRender([record], index)[0];
      if (me.getNode(record)) {
        me.all.replaceElement(index, node, true);
        me.updateIndexes(index, index);
        me.selModel.onUpdate(record);
        if (me.hasListeners.itemupdate) {
          me.fireEvent('itemupdate', record, index, node);
        }
        return node;
      }
    }
  }
}, onAdd:function(store, records, index) {
  var me = this, nodes;
  if (me.rendered) {
    if (me.all.getCount() === 0) {
      me.refresh();
      nodes = me.all.slice();
    } else {
      nodes = me.doAdd(records, index);
      if (me.refreshSelmodelOnRefresh !== false) {
        me.selModel.refresh();
      }
      me.updateIndexes(index);
      me.refreshSize();
    }
    if (me.hasListeners.itemadd) {
      me.fireEvent('itemadd', records, index, nodes);
    }
  }
}, doAdd:function(records, index) {
  var me = this, nodes = me.bufferRender(records, index, true), all = me.all, count = all.getCount(), i, l;
  if (count === 0) {
    for (i = 0, l = nodes.length; i < l; i++) {
      this.getNodeContainer().appendChild(nodes[i]);
    }
  } else {
    if (index < count) {
      if (index === 0) {
        all.item(index).insertSibling(nodes, 'before', true);
      } else {
        all.item(index - 1).insertSibling(nodes, 'after', true);
      }
    } else {
      all.last().insertSibling(nodes, 'after', true);
    }
  }
  all.insert(index, nodes);
  return nodes;
}, onRemove:function(ds, records, indexes) {
  var me = this, fireItemRemove = me.hasListeners.itemremove, i, record, index;
  if (me.all.getCount()) {
    if (me.dataSource.getCount() === 0) {
      if (fireItemRemove) {
        for (i = indexes.length - 1; i >= 0; --i) {
          me.fireEvent('itemremove', records[i], indexes[i]);
        }
      }
      me.refresh();
    } else {
      for (i = indexes.length - 1; i >= 0; --i) {
        record = records[i];
        index = indexes[i];
        me.doRemove(record, index);
        if (fireItemRemove) {
          me.fireEvent('itemremove', record, index);
        }
      }
      me.updateIndexes(indexes[0]);
    }
    this.refreshSize();
  }
}, doRemove:function(record, index) {
  this.all.removeElement(index, true);
}, refreshNode:function(index) {
  this.onUpdate(this.dataSource, this.dataSource.getAt(index));
}, updateIndexes:function(startIndex, endIndex) {
  var nodes = this.all.elements, records = this.getViewRange(), i;
  startIndex = startIndex || 0;
  endIndex = endIndex || (endIndex === 0 ? 0 : nodes.length - 1);
  for (i = startIndex; i <= endIndex; i++) {
    nodes[i].viewIndex = i;
    nodes[i].viewRecordId = records[i].internalId;
    if (!nodes[i].boundView) {
      nodes[i].boundView = this.id;
    }
  }
}, getStore:function() {
  return this.store;
}, bindStore:function(store, initial, propName) {
  var me = this;
  me.mixins.bindable.bindStore.apply(me, arguments);
  if (!initial) {
    me.getSelectionModel().bindStore(store);
  }
  if (me.componentLayoutCounter) {
    me.doFirstRefresh(store);
  }
}, doFirstRefresh:function(store) {
  var me = this;
  me.firstRefreshDone = true;
  if (store && !store.loading) {
    if (me.deferInitialRefresh) {
      me.applyFirstRefresh();
    } else {
      me.refresh();
    }
  }
}, applyFirstRefresh:function() {
  var me = this;
  if (me.isDestroyed) {
    return;
  }
  if (me.up('[isCollapsingOrExpanding]')) {
    Ext.Function.defer(me.applyFirstRefresh, 100, me);
  } else {
    Ext.Function.defer(function() {
      if (!me.isDestroyed) {
        me.refresh();
      }
    }, 1);
  }
}, onUnbindStore:function(store) {
  this.setMaskBind(null);
}, onBindStore:function(store, initial, propName) {
  this.setMaskBind(store);
  if (!initial && propName === 'store') {
    this.bindStore(store, false, 'dataSource');
  }
}, setMaskBind:function(store) {
  var mask = this.loadMask;
  if (mask && mask.bindStore) {
    mask.bindStore(store);
  }
}, getStoreListeners:function() {
  var me = this;
  return {idchanged:me.onIdChanged, refresh:me.onDataRefresh, add:me.onAdd, bulkremove:me.onRemove, update:me.onUpdate, clear:me.refresh};
}, onDataRefresh:function() {
  this.refreshView();
}, refreshView:function() {
  var me = this, blockedByAncestor = !me.firstRefreshDone && (!me.rendered || me.up('[collapsed],[isCollapsingOrExpanding],[hidden]'));
  if (blockedByAncestor) {
    me.deferInitialRefresh = false;
  } else {
    if (me.blockRefresh !== true) {
      me.firstRefreshDone = true;
      me.refresh();
    }
  }
}, findItemByChild:function(node) {
  return Ext.fly(node).findParent(this.getItemSelector(), this.getTargetEl());
}, findTargetByEvent:function(e) {
  return e.getTarget(this.getItemSelector(), this.getTargetEl());
}, getSelectedNodes:function() {
  var nodes = [], records = this.selModel.getSelection(), ln = records.length, i = 0;
  for (; i < ln; i++) {
    nodes.push(this.getNode(records[i]));
  }
  return nodes;
}, getRecords:function(nodes) {
  var records = [], i = 0, len = nodes.length, data = this.dataSource.data;
  for (; i < len; i++) {
    records[records.length] = data.getByKey(nodes[i].viewRecordId);
  }
  return records;
}, getRecord:function(node) {
  return this.dataSource.data.getByKey(Ext.getDom(node).viewRecordId);
}, isSelected:function(node) {
  var r = this.getRecord(node);
  return this.selModel.isSelected(r);
}, select:function(records, keepExisting, suppressEvent) {
  this.selModel.select(records, keepExisting, suppressEvent);
}, deselect:function(records, suppressEvent) {
  this.selModel.deselect(records, suppressEvent);
}, getNode:function(nodeInfo) {
  if (!nodeInfo && nodeInfo !== 0 || !this.rendered) {
    return null;
  }
  if (Ext.isString(nodeInfo)) {
    return document.getElementById(nodeInfo);
  }
  if (Ext.isNumber(nodeInfo)) {
    return this.all.elements[nodeInfo];
  }
  if (nodeInfo.isModel) {
    return this.getNodeByRecord(nodeInfo);
  }
  return nodeInfo;
}, getNodeByRecord:function(record) {
  var ns = this.all.elements, ln = ns.length, i = 0;
  for (; i < ln; i++) {
    if (ns[i].viewRecordId === record.internalId) {
      return ns[i];
    }
  }
  return null;
}, getNodes:function(start, end) {
  var all = this.all;
  if (end === undefined) {
    end = all.getCount();
  } else {
    end++;
  }
  return all.slice(start || 0, end);
}, indexOf:function(node) {
  node = this.getNode(node);
  if (!node && node !== 0) {
    return -1;
  }
  if (Ext.isNumber(node.viewIndex)) {
    return node.viewIndex;
  }
  return this.all.indexOf(node);
}, onDestroy:function() {
  var me = this;
  me.all.clear();
  me.callParent();
  me.bindStore(null);
  me.selModel.destroy();
}, onItemSelect:function(record) {
  var node = this.getNode(record);
  if (node) {
    Ext.fly(node).addCls(this.selectedItemCls);
  }
}, onItemDeselect:function(record) {
  var node = this.getNode(record);
  if (node) {
    Ext.fly(node).removeCls(this.selectedItemCls);
  }
}, getItemSelector:function() {
  return this.itemSelector;
}}, function() {
  Ext.deprecate('extjs', '4.0', function() {
    Ext.view.AbstractView.override({getSelectionCount:function() {
      if (Ext.global.console) {
        Ext.global.console.warn('DataView: getSelectionCount will be removed, please interact with the Ext.selection.DataViewModel');
      }
      return this.selModel.getSelection().length;
    }, getSelectedRecords:function() {
      if (Ext.global.console) {
        Ext.global.console.warn('DataView: getSelectedRecords will be removed, please interact with the Ext.selection.DataViewModel');
      }
      return this.selModel.getSelection();
    }, select:function(records, keepExisting, supressEvents) {
      if (Ext.global.console) {
        Ext.global.console.warn("DataView: select will be removed, please access select through a DataView's SelectionModel, ie: view.getSelectionModel().select()");
      }
      var sm = this.getSelectionModel();
      return sm.select.apply(sm, arguments);
    }, clearSelections:function() {
      if (Ext.global.console) {
        Ext.global.console.warn("DataView: clearSelections will be removed, please access deselectAll through DataView's SelectionModel, ie: view.getSelectionModel().deselectAll()");
      }
      var sm = this.getSelectionModel();
      return sm.deselectAll();
    }});
  });
});
Ext.define('Ext.view.View', {extend:Ext.view.AbstractView, alternateClassName:'Ext.DataView', alias:'widget.dataview', deferHighlight:Ext.isIE7m ? 100 : 0, mouseOverOutBuffer:20, inputTagRe:/^textarea$|^input$/i, inheritableStatics:{EventMap:{mousedown:'MouseDown', mouseup:'MouseUp', click:'Click', dblclick:'DblClick', contextmenu:'ContextMenu', mouseover:'MouseOver', mouseout:'MouseOut', mouseenter:'MouseEnter', mouseleave:'MouseLeave', keydown:'KeyDown', focus:'Focus'}}, initComponent:function() {
  var me = this;
  me.callParent();
  if (me.mouseOverOutBuffer) {
    me.handleMouseOverOrOut = Ext.Function.createBuffered(me.handleMouseOverOrOut, me.mouseOverOutBuffer, me);
    me.lastMouseOverOutEvent = new Ext.EventObjectImpl;
  } else {
    if (me.deferHighlight) {
      me.setHighlightedItem = Ext.Function.createBuffered(me.setHighlightedItem, me.deferHighlight, me);
    }
  }
}, addCmpEvents:function() {
  this.addEvents('beforeitemmousedown', 'beforeitemmouseup', 'beforeitemmouseenter', 'beforeitemmouseleave', 'beforeitemclick', 'beforeitemdblclick', 'beforeitemcontextmenu', 'beforeitemkeydown', 'itemmousedown', 'itemmouseup', 'itemmouseenter', 'itemmouseleave', 'itemclick', 'itemdblclick', 'itemcontextmenu', 'itemkeydown', 'beforecontainermousedown', 'beforecontainermouseup', 'beforecontainermouseover', 'beforecontainermouseout', 'beforecontainerclick', 'beforecontainerdblclick', 'beforecontainercontextmenu', 
  'beforecontainerkeydown', 'containermouseup', 'containermouseover', 'containermouseout', 'containerclick', 'containerdblclick', 'containercontextmenu', 'containerkeydown', 'selectionchange', 'beforeselect', 'beforedeselect', 'select', 'deselect', 'focuschange', 'highlightitem', 'unhighlightitem');
}, getFocusEl:function() {
  return this.getTargetEl();
}, afterRender:function() {
  var me = this, onMouseOverOut = me.mouseOverOutBuffer ? me.onMouseOverOut : me.handleMouseOverOrOut;
  me.callParent();
  me.mon(me.getTargetEl(), {scope:me, freezeEvent:true, click:me.handleEvent, mousedown:me.handleEvent, mouseup:me.handleEvent, dblclick:me.handleEvent, contextmenu:me.handleEvent, keydown:me.handleEvent, mouseover:onMouseOverOut, mouseout:onMouseOverOut});
}, onMouseOverOut:function(e) {
  var me = this;
  me.lastMouseOverOutEvent.setEvent(e.browserEvent, true);
  me.handleMouseOverOrOut(me.lastMouseOverOutEvent);
}, handleMouseOverOrOut:function(e) {
  var me = this, isMouseout = e.type === 'mouseout', method = isMouseout ? e.getRelatedTarget : e.getTarget, nowOverItem = method.call(e, me.itemSelector) || method.call(e, me.dataRowSelector);
  if (!me.mouseOverItem || nowOverItem !== me.mouseOverItem) {
    if (me.mouseOverItem) {
      e.item = me.mouseOverItem;
      e.newType = 'mouseleave';
      me.handleEvent(e);
    }
    me.mouseOverItem = nowOverItem;
    if (me.mouseOverItem) {
      e.item = me.mouseOverItem;
      e.newType = 'mouseenter';
      me.handleEvent(e);
    }
  }
}, handleEvent:function(e) {
  var me = this, key = e.type == 'keydown' && e.getKey();
  if (me.processUIEvent(e) !== false) {
    me.processSpecialEvent(e);
  }
  if (key === e.SPACE) {
    if (!me.inputTagRe.test(e.getTarget().tagName)) {
      e.stopEvent();
    }
  }
}, processItemEvent:Ext.emptyFn, processContainerEvent:Ext.emptyFn, processSpecialEvent:Ext.emptyFn, processUIEvent:function(e) {
  if (!Ext.getBody().isAncestor(e.target)) {
    return;
  }
  var me = this, item = e.getTarget(me.getItemSelector(), me.getTargetEl()), map = this.statics().EventMap, index, record, type = e.type, newType = e.type, sm;
  if (e.newType) {
    newType = e.newType;
    item = e.item;
  }
  if (!item && type == 'keydown') {
    sm = me.getSelectionModel();
    record = sm.lastFocused || sm.getLastSelected();
    if (record) {
      item = me.getNode(record, true);
    }
  }
  if (item) {
    if (!record) {
      record = me.getRecord(item);
    }
    index = me.indexInStore ? me.indexInStore(record) : me.indexOf(item);
    if (!record || me.processItemEvent(record, item, index, e) === false) {
      return false;
    }
    if (me['onBeforeItem' + map[newType]](record, item, index, e) === false || me.fireEvent('beforeitem' + newType, me, record, item, index, e) === false || me['onItem' + map[newType]](record, item, index, e) === false) {
      return false;
    }
    me.fireEvent('item' + newType, me, record, item, index, e);
  } else {
    if (me.processContainerEvent(e) === false || me['onBeforeContainer' + map[type]](e) === false || me.fireEvent('beforecontainer' + type, me, e) === false || me['onContainer' + map[type]](e) === false) {
      return false;
    }
    me.fireEvent('container' + type, me, e);
  }
  return true;
}, onItemMouseEnter:function(record, item, index, e) {
  if (this.trackOver) {
    this.highlightItem(item);
  }
}, onItemMouseLeave:function(record, item, index, e) {
  if (this.trackOver) {
    this.clearHighlight();
  }
}, onItemMouseDown:Ext.emptyFn, onItemMouseUp:Ext.emptyFn, onItemFocus:Ext.emptyFn, onItemClick:Ext.emptyFn, onItemDblClick:Ext.emptyFn, onItemContextMenu:Ext.emptyFn, onItemKeyDown:Ext.emptyFn, onBeforeItemMouseDown:Ext.emptyFn, onBeforeItemMouseUp:Ext.emptyFn, onBeforeItemFocus:Ext.emptyFn, onBeforeItemMouseEnter:Ext.emptyFn, onBeforeItemMouseLeave:Ext.emptyFn, onBeforeItemClick:Ext.emptyFn, onBeforeItemDblClick:Ext.emptyFn, onBeforeItemContextMenu:Ext.emptyFn, onBeforeItemKeyDown:Ext.emptyFn, 
onContainerMouseDown:Ext.emptyFn, onContainerMouseUp:Ext.emptyFn, onContainerMouseOver:Ext.emptyFn, onContainerMouseOut:Ext.emptyFn, onContainerClick:Ext.emptyFn, onContainerDblClick:Ext.emptyFn, onContainerContextMenu:Ext.emptyFn, onContainerKeyDown:Ext.emptyFn, onBeforeContainerMouseDown:Ext.emptyFn, onBeforeContainerMouseUp:Ext.emptyFn, onBeforeContainerMouseOver:Ext.emptyFn, onBeforeContainerMouseOut:Ext.emptyFn, onBeforeContainerClick:Ext.emptyFn, onBeforeContainerDblClick:Ext.emptyFn, onBeforeContainerContextMenu:Ext.emptyFn, 
onBeforeContainerKeyDown:Ext.emptyFn, setHighlightedItem:function(item) {
  var me = this, highlighted = me.highlightedItem, overItemCls = me.overItemCls, beforeOverItemCls = me.beforeOverItemCls, previous;
  if (highlighted != item) {
    if (highlighted) {
      Ext.fly(highlighted).removeCls(overItemCls);
      previous = highlighted.previousSibling;
      if (beforeOverItemCls && previous) {
        Ext.fly(previous).removeCls(beforeOverItemCls);
      }
      me.fireEvent('unhighlightitem', me, highlighted);
    }
    me.highlightedItem = item;
    if (item) {
      Ext.fly(item).addCls(me.overItemCls);
      previous = item.previousSibling;
      if (beforeOverItemCls && previous) {
        Ext.fly(previous).addCls(beforeOverItemCls);
      }
      me.fireEvent('highlightitem', me, item);
    }
  }
}, highlightItem:function(item) {
  this.setHighlightedItem(item);
}, clearHighlight:function() {
  this.setHighlightedItem(undefined);
}, onUpdate:function(store, record) {
  var me = this, node, newNode, highlighted;
  if (me.viewReady) {
    node = me.getNode(record);
    newNode = me.callParent(arguments);
    highlighted = me.highlightedItem;
    if (highlighted && highlighted === node) {
      delete me.highlightedItem;
      if (newNode) {
        me.highlightItem(newNode);
      }
    }
  }
}, refresh:function() {
  this.clearHighlight();
  this.callParent(arguments);
}, focusNode:function(rec) {
  var me = this, node = me.getNode(rec, true), el = me.el, adjustmentY = 0, adjustmentX = 0, elRegion = el.getRegion(), nodeRegion;
  elRegion.bottom = elRegion.top + el.dom.clientHeight;
  elRegion.right = elRegion.left + el.dom.clientWidth;
  if (node) {
    nodeRegion = Ext.fly(node).getRegion();
    if (nodeRegion.top < elRegion.top) {
      adjustmentY = nodeRegion.top - elRegion.top;
    } else {
      if (nodeRegion.bottom > elRegion.bottom) {
        adjustmentY = nodeRegion.bottom - elRegion.bottom;
      }
    }
    if (nodeRegion.left < elRegion.left) {
      adjustmentX = nodeRegion.left - elRegion.left;
    } else {
      if (nodeRegion.right > elRegion.right) {
        adjustmentX = nodeRegion.right - elRegion.right;
      }
    }
    if (adjustmentX || adjustmentY) {
      me.scrollBy(adjustmentX, adjustmentY, false);
    }
    el.focus();
  }
}});
Ext.define('Ext.layout.component.BoundList', {extend:Ext.layout.component.Auto, alias:'layout.boundlist', type:'component', beginLayout:function(ownerContext) {
  var me = this, owner = me.owner, toolbar = owner.pagingToolbar;
  me.callParent(arguments);
  if (owner.floating) {
    ownerContext.savedXY = owner.getXY();
    owner.setXY([0, -9999]);
  }
  if (toolbar) {
    ownerContext.toolbarContext = ownerContext.context.getCmp(toolbar);
  }
  ownerContext.listContext = ownerContext.getEl('listEl');
}, beginLayoutCycle:function(ownerContext) {
  var owner = this.owner;
  this.callParent(arguments);
  if (ownerContext.heightModel.auto) {
    owner.el.setHeight('auto');
    owner.listEl.setHeight('auto');
  }
}, getLayoutItems:function() {
  var toolbar = this.owner.pagingToolbar;
  return toolbar ? [toolbar] : [];
}, isValidParent:function() {
  return true;
}, finishedLayout:function(ownerContext) {
  var xy = ownerContext.savedXY;
  this.callParent(arguments);
  if (xy) {
    this.owner.setXY(xy);
  }
}, measureContentWidth:function(ownerContext) {
  return this.owner.listEl.getWidth();
}, measureContentHeight:function(ownerContext) {
  return this.owner.listEl.getHeight();
}, publishInnerHeight:function(ownerContext, height) {
  var toolbar = ownerContext.toolbarContext, toolbarHeight = 0;
  if (toolbar) {
    toolbarHeight = toolbar.getProp('height');
  }
  if (toolbarHeight === undefined) {
    this.done = false;
  } else {
    ownerContext.listContext.setHeight(height - ownerContext.getFrameInfo().height - toolbarHeight);
  }
}, calculateOwnerHeightFromContentHeight:function(ownerContext) {
  var height = this.callParent(arguments), toolbar = ownerContext.toolbarContext;
  if (toolbar) {
    height += toolbar.getProp('height');
  }
  return height;
}});
Ext.define('Ext.toolbar.TextItem', {extend:Ext.toolbar.Item, alias:'widget.tbtext', alternateClassName:'Ext.Toolbar.TextItem', text:'', renderTpl:'{text}', baseCls:Ext.baseCSSPrefix + 'toolbar-text', beforeRender:function() {
  var me = this;
  me.callParent();
  Ext.apply(me.renderData, {text:me.text});
}, setText:function(text) {
  var me = this;
  me.text = text;
  if (me.rendered) {
    me.el.update(text);
    me.updateLayout();
  }
}});
Ext.define('Ext.form.field.Spinner', {extend:Ext.form.field.Trigger, alias:'widget.spinnerfield', alternateClassName:'Ext.form.Spinner', trigger1Cls:Ext.baseCSSPrefix + 'form-spinner-up', trigger2Cls:Ext.baseCSSPrefix + 'form-spinner-down', spinUpEnabled:true, spinDownEnabled:true, keyNavEnabled:true, mouseWheelEnabled:true, repeatTriggerClick:true, onSpinUp:Ext.emptyFn, onSpinDown:Ext.emptyFn, triggerTpl:'\x3ctd style\x3d"{triggerStyle}" class\x3d"{triggerCls}"\x3e' + '\x3cdiv class\x3d"' + Ext.baseCSSPrefix + 
'trigger-index-0 ' + Ext.baseCSSPrefix + 'form-trigger ' + Ext.baseCSSPrefix + 'form-spinner-up {spinnerUpCls} {childElCls}" role\x3d"button"\x3e\x3c/div\x3e' + '\x3cdiv class\x3d"' + Ext.baseCSSPrefix + 'trigger-index-1 ' + Ext.baseCSSPrefix + 'form-trigger ' + Ext.baseCSSPrefix + 'form-spinner-down {spinnerDownCls} {childElCls}" role\x3d"button"\x3e\x3c/div\x3e' + '\x3c/td\x3e' + '\x3c/tr\x3e', initComponent:function() {
  this.callParent();
  this.addEvents('spin', 'spinup', 'spindown');
}, onRender:function() {
  var me = this, triggers;
  me.callParent(arguments);
  triggers = me.triggerEl;
  me.spinUpEl = triggers.item(0);
  me.spinDownEl = triggers.item(1);
  me.triggerCell = me.spinUpEl.parent();
  if (me.keyNavEnabled) {
    me.spinnerKeyNav = new Ext.util.KeyNav(me.inputEl, {scope:me, up:me.spinUp, down:me.spinDown});
  }
  if (me.mouseWheelEnabled) {
    me.mon(me.bodyEl, 'mousewheel', me.onMouseWheel, me);
  }
}, getSubTplMarkup:function(values) {
  var me = this, childElCls = values.childElCls, field = Ext.form.field.Base.prototype.getSubTplMarkup.apply(me, arguments);
  return '\x3ctable id\x3d"' + me.id + '-triggerWrap" class\x3d"' + Ext.baseCSSPrefix + 'form-trigger-wrap' + childElCls + '" cellpadding\x3d"0" cellspacing\x3d"0"\x3e' + '\x3ctbody\x3e' + '\x3ctr\x3e\x3ctd id\x3d"' + me.id + '-inputCell" class\x3d"' + Ext.baseCSSPrefix + 'form-trigger-input-cell' + childElCls + '"\x3e' + field + '\x3c/td\x3e' + me.getTriggerMarkup() + '\x3c/tbody\x3e\x3c/table\x3e';
}, getTriggerMarkup:function() {
  return this.getTpl('triggerTpl').apply(this.getTriggerData());
}, getTriggerData:function() {
  var me = this, hideTrigger = me.readOnly || me.hideTrigger;
  return {triggerCls:Ext.baseCSSPrefix + 'trigger-cell', triggerStyle:hideTrigger ? 'display:none' : '', spinnerUpCls:!me.spinUpEnabled ? me.trigger1Cls + '-disabled' : '', spinnerDownCls:!me.spinDownEnabled ? me.trigger2Cls + '-disabled' : ''};
}, getTriggerWidth:function() {
  var me = this, totalTriggerWidth = 0;
  if (me.triggerWrap && !me.hideTrigger && !me.readOnly) {
    totalTriggerWidth = me.triggerWidth;
  }
  return totalTriggerWidth;
}, onTrigger1Click:function() {
  this.spinUp();
}, onTrigger2Click:function() {
  this.spinDown();
}, onTriggerWrapMouseup:function() {
  this.inputEl.focus();
}, spinUp:function() {
  var me = this;
  if (me.spinUpEnabled && !me.disabled) {
    me.fireEvent('spin', me, 'up');
    me.fireEvent('spinup', me);
    me.onSpinUp();
  }
}, spinDown:function() {
  var me = this;
  if (me.spinDownEnabled && !me.disabled) {
    me.fireEvent('spin', me, 'down');
    me.fireEvent('spindown', me);
    me.onSpinDown();
  }
}, setSpinUpEnabled:function(enabled) {
  var me = this, wasEnabled = me.spinUpEnabled;
  me.spinUpEnabled = enabled;
  if (wasEnabled !== enabled && me.rendered) {
    me.spinUpEl[enabled ? 'removeCls' : 'addCls'](me.trigger1Cls + '-disabled');
  }
}, setSpinDownEnabled:function(enabled) {
  var me = this, wasEnabled = me.spinDownEnabled;
  me.spinDownEnabled = enabled;
  if (wasEnabled !== enabled && me.rendered) {
    me.spinDownEl[enabled ? 'removeCls' : 'addCls'](me.trigger2Cls + '-disabled');
  }
}, onMouseWheel:function(e) {
  var me = this, delta;
  if (me.hasFocus) {
    delta = e.getWheelDelta();
    if (delta > 0) {
      me.spinUp();
    } else {
      if (delta < 0) {
        me.spinDown();
      }
    }
    e.stopEvent();
  }
}, onDestroy:function() {
  Ext.destroyMembers(this, 'spinnerKeyNav', 'spinUpEl', 'spinDownEl');
  this.callParent();
}});
Ext.define('Ext.form.field.Number', {extend:Ext.form.field.Spinner, alias:'widget.numberfield', alternateClassName:['Ext.form.NumberField', 'Ext.form.Number'], allowExponential:true, allowDecimals:true, decimalSeparator:'.', submitLocaleSeparator:true, decimalPrecision:2, minValue:Number.NEGATIVE_INFINITY, maxValue:Number.MAX_VALUE, step:1, minText:'The minimum value for this field is {0}', maxText:'The maximum value for this field is {0}', nanText:'{0} is not a valid number', negativeText:'The value cannot be negative', 
baseChars:'0123456789', autoStripChars:false, initComponent:function() {
  var me = this;
  me.callParent();
  me.setMinValue(me.minValue);
  me.setMaxValue(me.maxValue);
}, getErrors:function(value) {
  var me = this, errors = me.callParent(arguments), format = Ext.String.format, num;
  value = Ext.isDefined(value) ? value : this.processRawValue(this.getRawValue());
  if (value.length < 1) {
    return errors;
  }
  value = String(value).replace(me.decimalSeparator, '.');
  if (isNaN(value)) {
    errors.push(format(me.nanText, value));
  }
  num = me.parseValue(value);
  if (me.minValue === 0 && num < 0) {
    errors.push(this.negativeText);
  } else {
    if (num < me.minValue) {
      errors.push(format(me.minText, me.minValue));
    }
  }
  if (num > me.maxValue) {
    errors.push(format(me.maxText, me.maxValue));
  }
  return errors;
}, rawToValue:function(rawValue) {
  var value = this.fixPrecision(this.parseValue(rawValue));
  if (value === null) {
    value = rawValue || null;
  }
  return value;
}, valueToRaw:function(value) {
  var me = this, decimalSeparator = me.decimalSeparator;
  value = me.parseValue(value);
  value = me.fixPrecision(value);
  value = Ext.isNumber(value) ? value : parseFloat(String(value).replace(decimalSeparator, '.'));
  value = isNaN(value) ? '' : String(value).replace('.', decimalSeparator);
  return value;
}, getSubmitValue:function() {
  var me = this, value = me.callParent();
  if (!me.submitLocaleSeparator) {
    value = value.replace(me.decimalSeparator, '.');
  }
  return value;
}, onChange:function() {
  this.toggleSpinners();
  this.callParent(arguments);
}, toggleSpinners:function() {
  var me = this, value = me.getValue(), valueIsNull = value === null, enabled;
  if (me.spinUpEnabled || me.spinUpDisabledByToggle) {
    enabled = valueIsNull || value < me.maxValue;
    me.setSpinUpEnabled(enabled, true);
  }
  if (me.spinDownEnabled || me.spinDownDisabledByToggle) {
    enabled = valueIsNull || value > me.minValue;
    me.setSpinDownEnabled(enabled, true);
  }
}, setMinValue:function(value) {
  var me = this, allowed;
  me.minValue = Ext.Number.from(value, Number.NEGATIVE_INFINITY);
  me.toggleSpinners();
  if (me.disableKeyFilter !== true) {
    allowed = me.baseChars + '';
    if (me.allowExponential) {
      allowed += me.decimalSeparator + 'e+-';
    } else {
      if (me.allowDecimals) {
        allowed += me.decimalSeparator;
      }
      if (me.minValue < 0) {
        allowed += '-';
      }
    }
    allowed = Ext.String.escapeRegex(allowed);
    me.maskRe = new RegExp('[' + allowed + ']');
    if (me.autoStripChars) {
      me.stripCharsRe = new RegExp('[^' + allowed + ']', 'gi');
    }
  }
}, setMaxValue:function(value) {
  this.maxValue = Ext.Number.from(value, Number.MAX_VALUE);
  this.toggleSpinners();
}, parseValue:function(value) {
  value = parseFloat(String(value).replace(this.decimalSeparator, '.'));
  return isNaN(value) ? null : value;
}, fixPrecision:function(value) {
  var me = this, nan = isNaN(value), precision = me.decimalPrecision;
  if (nan || !value) {
    return nan ? '' : value;
  } else {
    if (!me.allowDecimals || precision <= 0) {
      precision = 0;
    }
  }
  return parseFloat(Ext.Number.toFixed(parseFloat(value), precision));
}, beforeBlur:function() {
  var me = this, v = me.parseValue(me.getRawValue());
  if (!Ext.isEmpty(v)) {
    me.setValue(v);
  }
}, setSpinUpEnabled:function(enabled, internal) {
  this.callParent(arguments);
  if (!internal) {
    delete this.spinUpDisabledByToggle;
  } else {
    this.spinUpDisabledByToggle = !enabled;
  }
}, onSpinUp:function() {
  var me = this;
  if (!me.readOnly) {
    me.setSpinValue(Ext.Number.constrain(me.getValue() + me.step, me.minValue, me.maxValue));
  }
}, setSpinDownEnabled:function(enabled, internal) {
  this.callParent(arguments);
  if (!internal) {
    delete this.spinDownDisabledByToggle;
  } else {
    this.spinDownDisabledByToggle = !enabled;
  }
}, onSpinDown:function() {
  var me = this;
  if (!me.readOnly) {
    me.setSpinValue(Ext.Number.constrain(me.getValue() - me.step, me.minValue, me.maxValue));
  }
}, setSpinValue:function(value) {
  var me = this, len;
  if (me.enforceMaxLength) {
    if (me.fixPrecision(value).toString().length > me.maxLength) {
      return;
    }
  }
  me.setValue(value);
}});
Ext.define('Ext.toolbar.Paging', {extend:Ext.toolbar.Toolbar, alias:'widget.pagingtoolbar', alternateClassName:'Ext.PagingToolbar', mixins:{bindable:Ext.util.Bindable}, displayInfo:false, prependButtons:false, displayMsg:'Displaying {0} - {1} of {2}', emptyMsg:'No data to display', beforePageText:'Page', afterPageText:'of {0}', firstText:'First Page', prevText:'Previous Page', nextText:'Next Page', lastText:'Last Page', refreshText:'Refresh', inputItemWidth:30, getPagingItems:function() {
  var me = this;
  return [{itemId:'first', tooltip:me.firstText, overflowText:me.firstText, iconCls:Ext.baseCSSPrefix + 'tbar-page-first', disabled:true, handler:me.moveFirst, scope:me}, {itemId:'prev', tooltip:me.prevText, overflowText:me.prevText, iconCls:Ext.baseCSSPrefix + 'tbar-page-prev', disabled:true, handler:me.movePrevious, scope:me}, '-', me.beforePageText, {xtype:'numberfield', itemId:'inputItem', name:'inputItem', cls:Ext.baseCSSPrefix + 'tbar-page-number', allowDecimals:false, minValue:1, hideTrigger:true, 
  enableKeyEvents:true, keyNavEnabled:false, selectOnFocus:true, submitValue:false, isFormField:false, width:me.inputItemWidth, margins:'-1 2 3 2', listeners:{scope:me, keydown:me.onPagingKeyDown, blur:me.onPagingBlur}}, {xtype:'tbtext', itemId:'afterTextItem', text:Ext.String.format(me.afterPageText, 1)}, '-', {itemId:'next', tooltip:me.nextText, overflowText:me.nextText, iconCls:Ext.baseCSSPrefix + 'tbar-page-next', disabled:true, handler:me.moveNext, scope:me}, {itemId:'last', tooltip:me.lastText, 
  overflowText:me.lastText, iconCls:Ext.baseCSSPrefix + 'tbar-page-last', disabled:true, handler:me.moveLast, scope:me}, '-', {itemId:'refresh', tooltip:me.refreshText, overflowText:me.refreshText, iconCls:Ext.baseCSSPrefix + 'tbar-loading', handler:me.doRefresh, scope:me}];
}, initComponent:function() {
  var me = this, pagingItems = me.getPagingItems(), userItems = me.items || me.buttons || [];
  if (me.prependButtons) {
    me.items = userItems.concat(pagingItems);
  } else {
    me.items = pagingItems.concat(userItems);
  }
  delete me.buttons;
  if (me.displayInfo) {
    me.items.push('-\x3e');
    me.items.push({xtype:'tbtext', itemId:'displayItem'});
  }
  me.callParent();
  me.addEvents('change', 'beforechange');
  me.on('beforerender', me.onLoad, me, {single:true});
  me.bindStore(me.store || 'ext-empty-store', true);
}, updateInfo:function() {
  var me = this, displayItem = me.child('#displayItem'), store = me.store, pageData = me.getPageData(), count, msg;
  if (displayItem) {
    count = store.getCount();
    if (count === 0) {
      msg = me.emptyMsg;
    } else {
      msg = Ext.String.format(me.displayMsg, pageData.fromRecord, pageData.toRecord, pageData.total);
    }
    displayItem.setText(msg);
  }
}, onLoad:function() {
  var me = this, pageData, currPage, pageCount, afterText, count, isEmpty, item;
  count = me.store.getCount();
  isEmpty = count === 0;
  if (!isEmpty) {
    pageData = me.getPageData();
    currPage = pageData.currentPage;
    pageCount = pageData.pageCount;
    afterText = Ext.String.format(me.afterPageText, isNaN(pageCount) ? 1 : pageCount);
  } else {
    currPage = 0;
    pageCount = 0;
    afterText = Ext.String.format(me.afterPageText, 0);
  }
  Ext.suspendLayouts();
  item = me.child('#afterTextItem');
  if (item) {
    item.setText(afterText);
  }
  item = me.getInputItem();
  if (item) {
    item.setDisabled(isEmpty).setValue(currPage);
  }
  me.setChildDisabled('#first', currPage === 1 || isEmpty);
  me.setChildDisabled('#prev', currPage === 1 || isEmpty);
  me.setChildDisabled('#next', currPage === pageCount || isEmpty);
  me.setChildDisabled('#last', currPage === pageCount || isEmpty);
  me.setChildDisabled('#refresh', false);
  me.updateInfo();
  Ext.resumeLayouts(true);
  if (me.rendered) {
    me.fireEvent('change', me, pageData);
  }
}, setChildDisabled:function(selector, disabled) {
  var item = this.child(selector);
  if (item) {
    item.setDisabled(disabled);
  }
}, getPageData:function() {
  var store = this.store, totalCount = store.getTotalCount();
  return {total:totalCount, currentPage:store.currentPage, pageCount:Math.ceil(totalCount / store.pageSize), fromRecord:(store.currentPage - 1) * store.pageSize + 1, toRecord:Math.min(store.currentPage * store.pageSize, totalCount)};
}, onLoadError:function() {
  if (!this.rendered) {
    return;
  }
  this.setChildDisabled('#refresh', false);
}, getInputItem:function() {
  return this.child('#inputItem');
}, readPageFromInput:function(pageData) {
  var inputItem = this.getInputItem(), pageNum = false, v;
  if (inputItem) {
    v = inputItem.getValue();
    pageNum = parseInt(v, 10);
    if (!v || isNaN(pageNum)) {
      inputItem.setValue(pageData.currentPage);
      return false;
    }
  }
  return pageNum;
}, onPagingFocus:function() {
  var inputItem = this.getInputItem();
  if (inputItem) {
    inputItem.select();
  }
}, onPagingBlur:function(e) {
  var inputItem = this.getInputItem(), curPage;
  if (inputItem) {
    curPage = this.getPageData().currentPage;
    inputItem.setValue(curPage);
  }
}, onPagingKeyDown:function(field, e) {
  var me = this, k = e.getKey(), pageData = me.getPageData(), increment = e.shiftKey ? 10 : 1, pageNum;
  if (k == e.RETURN) {
    e.stopEvent();
    pageNum = me.readPageFromInput(pageData);
    if (pageNum !== false) {
      pageNum = Math.min(Math.max(1, pageNum), pageData.pageCount);
      if (me.fireEvent('beforechange', me, pageNum) !== false) {
        me.store.loadPage(pageNum);
      }
    }
  } else {
    if (k == e.HOME || k == e.END) {
      e.stopEvent();
      pageNum = k == e.HOME ? 1 : pageData.pageCount;
      field.setValue(pageNum);
    } else {
      if (k == e.UP || k == e.PAGE_UP || k == e.DOWN || k == e.PAGE_DOWN) {
        e.stopEvent();
        pageNum = me.readPageFromInput(pageData);
        if (pageNum) {
          if (k == e.DOWN || k == e.PAGE_DOWN) {
            increment *= -1;
          }
          pageNum += increment;
          if (pageNum >= 1 && pageNum <= pageData.pageCount) {
            field.setValue(pageNum);
          }
        }
      }
    }
  }
}, beforeLoad:function() {
  if (this.rendered) {
    this.setChildDisabled('#refresh', true);
  }
}, moveFirst:function() {
  if (this.fireEvent('beforechange', this, 1) !== false) {
    this.store.loadPage(1);
  }
}, movePrevious:function() {
  var me = this, prev = me.store.currentPage - 1;
  if (prev > 0) {
    if (me.fireEvent('beforechange', me, prev) !== false) {
      me.store.previousPage();
    }
  }
}, moveNext:function() {
  var me = this, total = me.getPageData().pageCount, next = me.store.currentPage + 1;
  if (next <= total) {
    if (me.fireEvent('beforechange', me, next) !== false) {
      me.store.nextPage();
    }
  }
}, moveLast:function() {
  var me = this, last = me.getPageData().pageCount;
  if (me.fireEvent('beforechange', me, last) !== false) {
    me.store.loadPage(last);
  }
}, doRefresh:function() {
  var me = this, current = me.store.currentPage;
  if (me.fireEvent('beforechange', me, current) !== false) {
    me.store.loadPage(current);
  }
}, getStoreListeners:function() {
  return {beforeload:this.beforeLoad, load:this.onLoad, exception:this.onLoadError};
}, unbind:function(store) {
  this.bindStore(null);
}, bind:function(store) {
  this.bindStore(store);
}, onDestroy:function() {
  this.unbind();
  this.callParent();
}});
Ext.define('Ext.view.BoundList', {extend:Ext.view.View, alias:'widget.boundlist', alternateClassName:'Ext.BoundList', mixins:{queryable:Ext.Queryable}, pageSize:0, baseCls:Ext.baseCSSPrefix + 'boundlist', itemCls:Ext.baseCSSPrefix + 'boundlist-item', listItemCls:'', shadow:false, trackOver:true, refreshed:0, deferInitialRefresh:false, componentLayout:'boundlist', childEls:['listEl'], renderTpl:['\x3cdiv id\x3d"{id}-listEl" class\x3d"{baseCls}-list-ct ', Ext.dom.Element.unselectableCls, '" style\x3d"overflow:auto"\x3e\x3c/div\x3e', 
'{%', 'var me\x3dvalues.$comp, pagingToolbar\x3dme.pagingToolbar;', 'if (pagingToolbar) {', 'pagingToolbar.ownerLayout \x3d me.componentLayout;', 'Ext.DomHelper.generateMarkup(pagingToolbar.getRenderTree(), out);', '}', '%}', {disableFormats:true}], initComponent:function() {
  var me = this, baseCls = me.baseCls, itemCls = me.itemCls;
  me.selectedItemCls = baseCls + '-selected';
  if (me.trackOver) {
    me.overItemCls = baseCls + '-item-over';
  }
  me.itemSelector = '.' + itemCls;
  if (me.floating) {
    me.addCls(baseCls + '-floating');
  }
  if (!me.tpl) {
    me.tpl = new Ext.XTemplate('\x3cul class\x3d"' + Ext.plainListCls + '"\x3e\x3ctpl for\x3d"."\x3e', '\x3cli role\x3d"option" unselectable\x3d"on" class\x3d"' + itemCls + '"\x3e' + me.getInnerTpl(me.displayField) + '\x3c/li\x3e', '\x3c/tpl\x3e\x3c/ul\x3e');
  } else {
    if (!me.tpl.isTemplate) {
      me.tpl = new Ext.XTemplate(me.tpl);
    }
  }
  if (me.pageSize) {
    me.pagingToolbar = me.createPagingToolbar();
  }
  me.callParent();
}, beforeRender:function() {
  var me = this;
  me.callParent(arguments);
  if (me.up('menu')) {
    me.addCls(Ext.baseCSSPrefix + 'menu');
  }
}, getRefOwner:function() {
  return this.pickerField || this.callParent();
}, getRefItems:function() {
  return this.pagingToolbar ? [this.pagingToolbar] : [];
}, createPagingToolbar:function() {
  return Ext.widget('pagingtoolbar', {id:this.id + '-paging-toolbar', pageSize:this.pageSize, store:this.dataSource, border:false, ownerCt:this, ownerLayout:this.getComponentLayout()});
}, finishRenderChildren:function() {
  var toolbar = this.pagingToolbar;
  this.callParent(arguments);
  if (toolbar) {
    toolbar.finishRender();
  }
}, refresh:function() {
  var me = this, tpl = me.tpl, toolbar = me.pagingToolbar, rendered = me.rendered;
  tpl.field = me.pickerField;
  tpl.store = me.store;
  me.callParent();
  tpl.field = tpl.store = null;
  if (rendered && toolbar && toolbar.rendered && !me.preserveScrollOnRefresh) {
    me.el.appendChild(toolbar.el);
  }
  if (rendered && Ext.isIE6 && Ext.isStrict) {
    me.listEl.repaint();
  }
}, bindStore:function(store, initial) {
  var toolbar = this.pagingToolbar;
  this.callParent(arguments);
  if (toolbar) {
    toolbar.bindStore(store, initial);
  }
}, getTargetEl:function() {
  return this.listEl || this.el;
}, getInnerTpl:function(displayField) {
  return '{' + displayField + '}';
}, onDestroy:function() {
  Ext.destroyMembers(this, 'pagingToolbar', 'listEl');
  this.callParent();
}});
Ext.define('Ext.view.BoundListKeyNav', {extend:Ext.util.KeyNav, constructor:function(el, config) {
  var me = this;
  me.boundList = config.boundList;
  me.callParent([el, Ext.apply({}, config, me.defaultHandlers)]);
}, defaultHandlers:{up:function() {
  var me = this, boundList = me.boundList, allItems = boundList.all, oldItem = boundList.highlightedItem, oldItemIdx = oldItem ? boundList.indexOf(oldItem) : -1, newItemIdx = oldItemIdx > 0 ? oldItemIdx - 1 : allItems.getCount() - 1;
  me.highlightAt(newItemIdx);
}, down:function() {
  var me = this, boundList = me.boundList, allItems = boundList.all, oldItem = boundList.highlightedItem, oldItemIdx = oldItem ? boundList.indexOf(oldItem) : -1, newItemIdx = oldItemIdx < allItems.getCount() - 1 ? oldItemIdx + 1 : 0;
  me.highlightAt(newItemIdx);
}, pageup:function() {
}, pagedown:function() {
}, home:function() {
  this.highlightAt(0);
}, end:function() {
  var me = this;
  me.highlightAt(me.boundList.all.getCount() - 1);
}, enter:function(e) {
  this.selectHighlighted(e);
}}, highlightAt:function(index) {
  var boundList = this.boundList, item = boundList.all.item(index);
  if (item) {
    item = item.dom;
    boundList.highlightItem(item);
    boundList.getTargetEl().scrollChildIntoView(item, false);
  }
}, selectHighlighted:function(e) {
  var me = this, boundList = me.boundList, highlighted = boundList.highlightedItem, selModel = boundList.getSelectionModel();
  if (highlighted) {
    selModel.selectWithEvent(boundList.getRecord(highlighted), e);
  }
}});
Ext.define('Ext.layout.component.field.ComboBox', {extend:Ext.layout.component.field.Trigger, alias:'layout.combobox', type:'combobox', startingWidth:null, getTextWidth:function() {
  var me = this, owner = me.owner, store = owner.store, field = owner.displayField, storeLn = store.data.length, value = '', i = 0, n = 0, ln, item, width;
  for (; i < storeLn; i++) {
    item = store.getAt(i).data[field];
    ln = item.length;
    if (ln > n) {
      n = ln;
      value = item;
    }
  }
  width = Math.max(me.callParent(arguments), owner.inputEl.getTextWidth(value + owner.growAppend));
  if (!me.startingWidth || owner.removingRecords) {
    me.startingWidth = width;
    if (width < owner.growMin) {
      owner.defaultListConfig.minWidth = owner.growMin;
    }
    owner.removingRecords = false;
  }
  return width < me.startingWidth ? me.startingWidth : width;
}});
Ext.define('Ext.form.field.ComboBox', {extend:Ext.form.field.Picker, alternateClassName:'Ext.form.ComboBox', alias:['widget.combobox', 'widget.combo'], mixins:{bindable:Ext.util.Bindable}, componentLayout:'combobox', triggerCls:Ext.baseCSSPrefix + 'form-arrow-trigger', hiddenName:'', hiddenDataCls:Ext.baseCSSPrefix + 'hide-display ' + Ext.baseCSSPrefix + 'form-data-hidden', fieldSubTpl:['\x3cdiv class\x3d"{hiddenDataCls}" role\x3d"presentation"\x3e\x3c/div\x3e', '\x3cinput id\x3d"{id}" type\x3d"{type}" {inputAttrTpl} class\x3d"{fieldCls} {typeCls} {editableCls}" autocomplete\x3d"off"', 
'\x3ctpl if\x3d"value"\x3e value\x3d"{[Ext.util.Format.htmlEncode(values.value)]}"\x3c/tpl\x3e', '\x3ctpl if\x3d"name"\x3e name\x3d"{name}"\x3c/tpl\x3e', '\x3ctpl if\x3d"placeholder"\x3e placeholder\x3d"{placeholder}"\x3c/tpl\x3e', '\x3ctpl if\x3d"size"\x3e size\x3d"{size}"\x3c/tpl\x3e', '\x3ctpl if\x3d"maxLength !\x3d\x3d undefined"\x3e maxlength\x3d"{maxLength}"\x3c/tpl\x3e', '\x3ctpl if\x3d"readOnly"\x3e readonly\x3d"readonly"\x3c/tpl\x3e', '\x3ctpl if\x3d"disabled"\x3e disabled\x3d"disabled"\x3c/tpl\x3e', 
'\x3ctpl if\x3d"tabIdx"\x3e tabIndex\x3d"{tabIdx}"\x3c/tpl\x3e', '\x3ctpl if\x3d"fieldStyle"\x3e style\x3d"{fieldStyle}"\x3c/tpl\x3e', '/\x3e', {compiled:true, disableFormats:true}], getSubTplData:function() {
  var me = this;
  Ext.applyIf(me.subTplData, {hiddenDataCls:me.hiddenDataCls});
  return me.callParent(arguments);
}, afterRender:function() {
  var me = this;
  me.callParent(arguments);
  me.setHiddenValue(me.value);
}, multiSelect:false, delimiter:', ', displayField:'text', triggerAction:'all', allQuery:'', queryParam:'query', queryMode:'remote', queryCaching:true, pageSize:0, anyMatch:false, caseSensitive:false, autoSelect:true, typeAhead:false, typeAheadDelay:250, selectOnTab:true, forceSelection:false, growToLongestValue:true, defaultListConfig:{loadingHeight:70, minWidth:70, maxHeight:300, shadow:'sides'}, ignoreSelection:0, removingRecords:null, resizeComboToGrow:function() {
  var me = this;
  return me.grow && me.growToLongestValue;
}, initComponent:function() {
  var me = this, isDefined = Ext.isDefined, store = me.store, transform = me.transform, transformSelect, isLocalMode;
  Ext.applyIf(me.renderSelectors, {hiddenDataEl:'.' + me.hiddenDataCls.split(' ').join('.')});
  if (me.typeAhead && me.multiSelect) {
    Ext.Error.raise('typeAhead and multiSelect are mutually exclusive options -- please remove one of them.');
  }
  if (me.typeAhead && !me.editable) {
    Ext.Error.raise('If typeAhead is enabled the combo must be editable: true -- please change one of those settings.');
  }
  if (me.selectOnFocus && !me.editable) {
    Ext.Error.raise('If selectOnFocus is enabled the combo must be editable: true -- please change one of those settings.');
  }
  this.addEvents('beforequery', 'select', 'beforeselect', 'beforedeselect');
  if (transform) {
    transformSelect = Ext.getDom(transform);
    if (transformSelect) {
      if (!me.store) {
        store = Ext.Array.map(Ext.Array.from(transformSelect.options), function(option) {
          return [option.value, option.text];
        });
      }
      if (!me.name) {
        me.name = transformSelect.name;
      }
      if (!('value' in me)) {
        me.value = transformSelect.value;
      }
    }
  }
  me.bindStore(store || 'ext-empty-store', true);
  store = me.store;
  if (store.autoCreated) {
    me.queryMode = 'local';
    me.valueField = me.displayField = 'field1';
    if (!store.expanded) {
      me.displayField = 'field2';
    }
  }
  if (!isDefined(me.valueField)) {
    me.valueField = me.displayField;
  }
  isLocalMode = me.queryMode === 'local';
  if (!isDefined(me.queryDelay)) {
    me.queryDelay = isLocalMode ? 10 : 500;
  }
  if (!isDefined(me.minChars)) {
    me.minChars = isLocalMode ? 0 : 4;
  }
  if (!me.displayTpl) {
    me.displayTpl = new Ext.XTemplate('\x3ctpl for\x3d"."\x3e' + '{[typeof values \x3d\x3d\x3d "string" ? values : values["' + me.displayField + '"]]}' + '\x3ctpl if\x3d"xindex \x3c xcount"\x3e' + me.delimiter + '\x3c/tpl\x3e' + '\x3c/tpl\x3e');
  } else {
    if (Ext.isString(me.displayTpl)) {
      me.displayTpl = new Ext.XTemplate(me.displayTpl);
    }
  }
  me.callParent();
  me.doQueryTask = new Ext.util.DelayedTask(me.doRawQuery, me);
  if (me.store.getCount() > 0) {
    me.setValue(me.value);
  }
  if (transformSelect) {
    me.render(transformSelect.parentNode, transformSelect);
    Ext.removeNode(transformSelect);
    delete me.renderTo;
  }
}, getStore:function() {
  return this.store;
}, beforeBlur:function() {
  this.doQueryTask.cancel();
  this.assertValue();
}, assertValue:function() {
  var me = this, value = me.getRawValue(), rec, currentValue;
  if (me.forceSelection) {
    if (me.multiSelect) {
      if (value !== me.getDisplayValue()) {
        me.setValue(me.lastSelection);
      }
    } else {
      rec = me.findRecordByDisplay(value);
      if (rec) {
        currentValue = me.value;
        if (!me.findRecordByValue(currentValue)) {
          me.select(rec, true);
        }
      } else {
        me.setValue(me.lastSelection);
      }
    }
  }
  me.collapse();
}, onTypeAhead:function() {
  var me = this, displayField = me.displayField, record = me.store.findRecord(displayField, me.getRawValue()), boundList = me.getPicker(), newValue, len, selStart;
  if (record) {
    newValue = record.get(displayField);
    len = newValue.length;
    selStart = me.getRawValue().length;
    boundList.highlightItem(boundList.getNode(record));
    if (selStart !== 0 && selStart !== len) {
      me.setRawValue(newValue);
      me.selectText(selStart, newValue.length);
    }
  }
}, resetToDefault:Ext.emptyFn, beforeReset:function() {
  this.callParent();
  if (this.queryFilter && !this.queryFilter.disabled) {
    this.queryFilter.disabled = true;
    this.store.filter();
  }
}, onUnbindStore:function(store) {
  var me = this, picker = me.picker;
  if (me.queryFilter) {
    me.store.removeFilter(me.queryFilter);
  }
  if (!store && picker) {
    picker.bindStore(null);
  }
}, onBindStore:function(store, initial) {
  var picker = this.picker;
  if (!initial) {
    this.resetToDefault();
  }
  if (picker) {
    picker.bindStore(store);
  }
}, getStoreListeners:function() {
  var me = this;
  return {beforeload:me.onBeforeLoad, clear:me.onClear, datachanged:me.onDataChanged, load:me.onLoad, exception:me.onException, remove:me.onRemove};
}, onBeforeLoad:function() {
  ++this.ignoreSelection;
}, onDataChanged:function() {
  var me = this;
  if (me.resizeComboToGrow()) {
    me.updateLayout();
  }
}, onClear:function() {
  var me = this;
  if (me.resizeComboToGrow()) {
    me.removingRecords = true;
    me.onDataChanged();
  }
}, onRemove:function() {
  var me = this;
  if (me.resizeComboToGrow()) {
    me.removingRecords = true;
  }
}, onException:function() {
  if (this.ignoreSelection > 0) {
    --this.ignoreSelection;
  }
  this.collapse();
}, onLoad:function(store, records, success) {
  var me = this;
  if (me.ignoreSelection > 0) {
    --me.ignoreSelection;
  }
  if (success && !store.lastOptions.rawQuery) {
    if (me.value == null) {
      if (me.store.getCount()) {
        me.doAutoSelect();
      } else {
        me.setValue(me.value);
      }
    } else {
      me.setValue(me.value);
    }
  }
}, doRawQuery:function() {
  this.doQuery(this.getRawValue(), false, true);
}, doQuery:function(queryString, forceAll, rawQuery) {
  var me = this, queryPlan = me.beforeQuery({query:queryString || '', rawQuery:rawQuery, forceAll:forceAll, combo:me, cancel:false});
  if (queryPlan === false || queryPlan.cancel) {
    return false;
  }
  if (me.queryCaching && queryPlan.query === me.lastQuery) {
    me.expand();
  } else {
    me.lastQuery = queryPlan.query;
    if (me.queryMode === 'local') {
      me.doLocalQuery(queryPlan);
    } else {
      me.doRemoteQuery(queryPlan);
    }
  }
  return true;
}, beforeQuery:function(queryPlan) {
  var me = this;
  if (me.fireEvent('beforequery', queryPlan) === false) {
    queryPlan.cancel = true;
  } else {
    if (!queryPlan.cancel) {
      if (queryPlan.query.length < me.minChars && !queryPlan.forceAll) {
        queryPlan.cancel = true;
      }
    }
  }
  return queryPlan;
}, doLocalQuery:function(queryPlan) {
  var me = this, queryString = queryPlan.query;
  if (!me.queryFilter) {
    me.queryFilter = new Ext.util.Filter({id:me.id + '-query-filter', anyMatch:me.anyMatch, caseSensitive:me.caseSensitive, root:'data', property:me.displayField});
    me.store.addFilter(me.queryFilter, false);
  }
  if (queryString || !queryPlan.forceAll) {
    me.queryFilter.disabled = false;
    me.queryFilter.setValue(me.enableRegEx ? new RegExp(queryString) : queryString);
  } else {
    me.queryFilter.disabled = true;
  }
  me.store.filter();
  if (me.store.getCount()) {
    me.expand();
  } else {
    me.collapse();
  }
  me.afterQuery(queryPlan);
}, doRemoteQuery:function(queryPlan) {
  var me = this, loadCallback = function() {
    me.afterQuery(queryPlan);
  };
  me.expand();
  if (me.pageSize) {
    me.loadPage(1, {rawQuery:queryPlan.rawQuery, callback:loadCallback});
  } else {
    me.store.load({params:me.getParams(queryPlan.query), rawQuery:queryPlan.rawQuery, callback:loadCallback});
  }
}, afterQuery:function(queryPlan) {
  var me = this;
  if (me.store.getCount()) {
    if (me.typeAhead) {
      me.doTypeAhead();
    }
    if (me.getRawValue() !== me.getDisplayValue()) {
      me.ignoreSelection++;
      me.picker.getSelectionModel().deselectAll();
      me.ignoreSelection--;
    }
    if (queryPlan.rawQuery) {
      me.syncSelection();
      if (me.picker && !me.picker.getSelectionModel().hasSelection()) {
        me.doAutoSelect();
      }
    } else {
      me.doAutoSelect();
    }
  }
}, loadPage:function(pageNum, options) {
  this.store.loadPage(pageNum, Ext.apply({params:this.getParams(this.lastQuery)}, options));
}, onPageChange:function(toolbar, newPage) {
  this.loadPage(newPage);
  return false;
}, getParams:function(queryString) {
  var params = {}, param = this.queryParam;
  if (param) {
    params[param] = queryString;
  }
  return params;
}, doAutoSelect:function() {
  var me = this, picker = me.picker, lastSelected, itemNode;
  if (picker && me.autoSelect && me.store.getCount() > 0) {
    lastSelected = picker.getSelectionModel().lastSelected;
    itemNode = picker.getNode(lastSelected || 0);
    if (itemNode) {
      picker.highlightItem(itemNode);
      picker.listEl.scrollChildIntoView(itemNode, false);
    }
  }
}, doTypeAhead:function() {
  if (!this.typeAheadTask) {
    this.typeAheadTask = new Ext.util.DelayedTask(this.onTypeAhead, this);
  }
  if (this.lastKey != Ext.EventObject.BACKSPACE && this.lastKey != Ext.EventObject.DELETE) {
    this.typeAheadTask.delay(this.typeAheadDelay);
  }
}, onTriggerClick:function() {
  var me = this;
  if (!me.readOnly && !me.disabled) {
    if (me.isExpanded) {
      me.collapse();
    } else {
      me.onFocus({});
      if (me.triggerAction === 'all') {
        me.doQuery(me.allQuery, true);
      } else {
        if (me.triggerAction === 'last') {
          me.doQuery(me.lastQuery, true);
        } else {
          me.doQuery(me.getRawValue(), false, true);
        }
      }
    }
    me.inputEl.focus();
  }
}, onPaste:function() {
  var me = this;
  if (!me.readOnly && !me.disabled && me.editable) {
    me.doQueryTask.delay(me.queryDelay);
  }
}, onKeyUp:function(e, t) {
  var me = this, key = e.getKey();
  if (!me.readOnly && !me.disabled && me.editable) {
    me.lastKey = key;
    if (!e.isSpecialKey() || key == e.BACKSPACE || key == e.DELETE) {
      me.doQueryTask.delay(me.queryDelay);
    }
  }
  if (me.enableKeyEvents) {
    me.callParent(arguments);
  }
}, initEvents:function() {
  var me = this;
  me.callParent();
  if (!me.enableKeyEvents) {
    me.mon(me.inputEl, 'keyup', me.onKeyUp, me);
  }
  me.mon(me.inputEl, 'paste', me.onPaste, me);
}, onDestroy:function() {
  Ext.destroy(this.listKeyNav);
  this.bindStore(null);
  this.callParent();
}, onAdded:function() {
  var me = this;
  me.callParent(arguments);
  if (me.picker) {
    me.picker.ownerCt = me.up('[floating]');
    me.picker.registerWithOwnerCt();
  }
}, createPicker:function() {
  var me = this, picker, pickerCfg = Ext.apply({xtype:'boundlist', pickerField:me, selModel:{mode:me.multiSelect ? 'SIMPLE' : 'SINGLE'}, floating:true, hidden:true, store:me.store, displayField:me.displayField, focusOnToFront:false, pageSize:me.pageSize, tpl:me.tpl}, me.listConfig, me.defaultListConfig);
  picker = me.picker = Ext.widget(pickerCfg);
  if (me.pageSize) {
    picker.pagingToolbar.on('beforechange', me.onPageChange, me);
  }
  me.mon(picker, {itemclick:me.onItemClick, refresh:me.onListRefresh, scope:me});
  me.mon(picker.getSelectionModel(), {beforeselect:me.onBeforeSelect, beforedeselect:me.onBeforeDeselect, selectionchange:me.onListSelectionChange, scope:me});
  return picker;
}, alignPicker:function() {
  var me = this, picker = me.getPicker(), heightAbove = me.getPosition()[1] - Ext.getBody().getScroll().top, heightBelow = Ext.Element.getViewHeight() - heightAbove - me.getHeight(), space = Math.max(heightAbove, heightBelow);
  if (picker.height) {
    delete picker.height;
    picker.updateLayout();
  }
  if (picker.getHeight() > space - 5) {
    picker.setHeight(space - 5);
  }
  me.callParent();
}, onListRefresh:function() {
  if (!this.expanding) {
    this.alignPicker();
  }
  this.syncSelection();
}, onItemClick:function(picker, record) {
  var me = this, selection = me.picker.getSelectionModel().getSelection(), valueField = me.valueField;
  if (!me.multiSelect && selection.length) {
    if (record.get(valueField) === selection[0].get(valueField)) {
      me.displayTplData = [record.data];
      me.setRawValue(me.getDisplayValue());
      me.collapse();
    }
  }
}, onBeforeSelect:function(list, record) {
  return this.fireEvent('beforeselect', this, record, record.index);
}, onBeforeDeselect:function(list, record) {
  return this.fireEvent('beforedeselect', this, record, record.index);
}, onListSelectionChange:function(list, selectedRecords) {
  var me = this, isMulti = me.multiSelect, hasRecords = selectedRecords.length > 0;
  if (!me.ignoreSelection && me.isExpanded) {
    if (!isMulti) {
      Ext.defer(me.collapse, 1, me);
    }
    if (isMulti || hasRecords) {
      me.setValue(selectedRecords, false);
    }
    if (hasRecords) {
      me.fireEvent('select', me, selectedRecords);
    }
    me.inputEl.focus();
  }
}, onExpand:function() {
  var me = this, keyNav = me.listKeyNav, selectOnTab = me.selectOnTab, picker = me.getPicker();
  if (keyNav) {
    keyNav.enable();
  } else {
    keyNav = me.listKeyNav = new Ext.view.BoundListKeyNav(this.inputEl, {boundList:picker, forceKeyDown:true, tab:function(e) {
      if (selectOnTab) {
        this.selectHighlighted(e);
        me.triggerBlur();
      }
      return true;
    }, enter:function(e) {
      var selModel = picker.getSelectionModel(), count = selModel.getCount();
      this.selectHighlighted(e);
      if (!me.multiSelect && count === selModel.getCount()) {
        me.collapse();
      }
    }});
  }
  if (selectOnTab) {
    me.ignoreMonitorTab = true;
  }
  Ext.defer(keyNav.enable, 1, keyNav);
  me.inputEl.focus();
}, onCollapse:function() {
  var me = this, keyNav = me.listKeyNav;
  if (keyNav) {
    keyNav.disable();
    me.ignoreMonitorTab = false;
  }
}, select:function(r, assert) {
  var me = this, picker = me.picker, doSelect = true, fireSelect;
  if (r && r.isModel && assert === true && picker) {
    fireSelect = !picker.getSelectionModel().isSelected(r);
  }
  me.setValue(r, true);
  if (fireSelect) {
    me.fireEvent('select', me, r);
  }
}, findRecord:function(field, value) {
  var ds = this.store, idx = ds.findExact(field, value);
  return idx !== -1 ? ds.getAt(idx) : false;
}, findRecordByValue:function(value) {
  return this.findRecord(this.valueField, value);
}, findRecordByDisplay:function(value) {
  return this.findRecord(this.displayField, value);
}, setValue:function(value, doSelect) {
  var me = this, valueNotFoundText = me.valueNotFoundText, inputEl = me.inputEl, i, len, record, dataObj, matchedRecords = [], displayTplData = [], processedValue = [];
  if (me.store.loading) {
    me.value = value;
    me.setHiddenValue(me.value);
    return me;
  }
  value = Ext.Array.from(value);
  for (i = 0, len = value.length; i < len; i++) {
    record = value[i];
    if (!record || !record.isModel) {
      record = me.findRecordByValue(record);
    }
    if (record) {
      matchedRecords.push(record);
      displayTplData.push(record.data);
      processedValue.push(record.get(me.valueField));
    } else {
      if (!me.forceSelection) {
        processedValue.push(value[i]);
        dataObj = {};
        dataObj[me.displayField] = value[i];
        displayTplData.push(dataObj);
      } else {
        if (Ext.isDefined(valueNotFoundText)) {
          displayTplData.push(valueNotFoundText);
        }
      }
    }
  }
  me.setHiddenValue(processedValue);
  me.value = me.multiSelect ? processedValue : processedValue[0];
  if (!Ext.isDefined(me.value)) {
    me.value = null;
  }
  me.displayTplData = displayTplData;
  me.lastSelection = me.valueModels = matchedRecords;
  if (inputEl && me.emptyText && !Ext.isEmpty(value)) {
    inputEl.removeCls(me.emptyCls);
  }
  me.setRawValue(me.getDisplayValue());
  me.checkChange();
  if (doSelect !== false) {
    me.syncSelection();
  }
  me.applyEmptyText();
  return me;
}, setHiddenValue:function(values) {
  var me = this, name = me.hiddenName, i, dom, childNodes, input, valueCount, childrenCount;
  if (!me.hiddenDataEl || !name) {
    return;
  }
  values = Ext.Array.from(values);
  dom = me.hiddenDataEl.dom;
  childNodes = dom.childNodes;
  input = childNodes[0];
  valueCount = values.length;
  childrenCount = childNodes.length;
  if (!input && valueCount > 0) {
    me.hiddenDataEl.update(Ext.DomHelper.markup({tag:'input', type:'hidden', name:name}));
    childrenCount = 1;
    input = dom.firstChild;
  }
  while (childrenCount > valueCount) {
    dom.removeChild(childNodes[0]);
    --childrenCount;
  }
  while (childrenCount < valueCount) {
    dom.appendChild(input.cloneNode(true));
    ++childrenCount;
  }
  for (i = 0; i < valueCount; i++) {
    childNodes[i].value = values[i];
  }
}, getDisplayValue:function() {
  return this.displayTpl.apply(this.displayTplData);
}, getValue:function() {
  var me = this, picker = me.picker, rawValue = me.getRawValue(), value = me.value;
  if (me.getDisplayValue() !== rawValue) {
    value = rawValue;
    me.value = me.displayTplData = me.valueModels = null;
    if (picker) {
      me.ignoreSelection++;
      picker.getSelectionModel().deselectAll();
      me.ignoreSelection--;
    }
  }
  return value;
}, getSubmitValue:function() {
  var value = this.getValue();
  if (Ext.isEmpty(value)) {
    value = '';
  }
  return value;
}, isEqual:function(v1, v2) {
  var fromArray = Ext.Array.from, i, len;
  v1 = fromArray(v1);
  v2 = fromArray(v2);
  len = v1.length;
  if (len !== v2.length) {
    return false;
  }
  for (i = 0; i < len; i++) {
    if (v2[i] !== v1[i]) {
      return false;
    }
  }
  return true;
}, clearValue:function() {
  this.setValue([]);
}, syncSelection:function() {
  var me = this, picker = me.picker, selection, selModel, values = me.valueModels || [], vLen = values.length, v, value;
  if (picker) {
    selection = [];
    for (v = 0; v < vLen; v++) {
      value = values[v];
      if (value && value.isModel && me.store.indexOf(value) >= 0) {
        selection.push(value);
      }
    }
    me.ignoreSelection++;
    selModel = picker.getSelectionModel();
    selModel.deselectAll();
    if (selection.length) {
      selModel.select(selection, undefined, true);
    }
    me.ignoreSelection--;
  }
}, onEditorTab:function(e) {
  var keyNav = this.listKeyNav;
  if (this.selectOnTab && keyNav) {
    keyNav.selectHighlighted(e);
  }
}});
Ext.define('Ext.picker.Month', {extend:Ext.Component, alias:'widget.monthpicker', alternateClassName:'Ext.MonthPicker', childEls:['bodyEl', 'prevEl', 'nextEl', 'buttonsEl', 'monthEl', 'yearEl'], renderTpl:['\x3cdiv id\x3d"{id}-bodyEl" class\x3d"{baseCls}-body"\x3e', '\x3cdiv id\x3d"{id}-monthEl" class\x3d"{baseCls}-months"\x3e', '\x3ctpl for\x3d"months"\x3e', '\x3cdiv class\x3d"{parent.baseCls}-item {parent.baseCls}-month"\x3e', '\x3ca style\x3d"{parent.monthStyle}" hidefocus\x3d"on" class\x3d"{parent.baseCls}-item-inner" href\x3d"#"\x3e{.}\x3c/a\x3e', 
'\x3c/div\x3e', '\x3c/tpl\x3e', '\x3c/div\x3e', '\x3cdiv id\x3d"{id}-yearEl" class\x3d"{baseCls}-years"\x3e', '\x3cdiv class\x3d"{baseCls}-yearnav"\x3e', '\x3cdiv class\x3d"{baseCls}-yearnav-button-ct"\x3e', '\x3ca id\x3d"{id}-prevEl" class\x3d"{baseCls}-yearnav-button {baseCls}-yearnav-prev" href\x3d"#" hidefocus\x3d"on" \x3e\x3c/a\x3e', '\x3c/div\x3e', '\x3cdiv class\x3d"{baseCls}-yearnav-button-ct"\x3e', '\x3ca id\x3d"{id}-nextEl" class\x3d"{baseCls}-yearnav-button {baseCls}-yearnav-next" href\x3d"#" hidefocus\x3d"on" \x3e\x3c/a\x3e', 
'\x3c/div\x3e', '\x3c/div\x3e', '\x3ctpl for\x3d"years"\x3e', '\x3cdiv class\x3d"{parent.baseCls}-item {parent.baseCls}-year"\x3e', '\x3ca hidefocus\x3d"on" class\x3d"{parent.baseCls}-item-inner" href\x3d"#"\x3e{.}\x3c/a\x3e', '\x3c/div\x3e', '\x3c/tpl\x3e', '\x3c/div\x3e', '\x3cdiv class\x3d"' + Ext.baseCSSPrefix + 'clear"\x3e\x3c/div\x3e', '\x3c/div\x3e', '\x3ctpl if\x3d"showButtons"\x3e', '\x3cdiv id\x3d"{id}-buttonsEl" class\x3d"{baseCls}-buttons"\x3e{%', 'var me\x3dvalues.$comp, okBtn\x3dme.okBtn, cancelBtn\x3dme.cancelBtn;', 
'okBtn.ownerLayout \x3d cancelBtn.ownerLayout \x3d me.componentLayout;', 'okBtn.ownerCt \x3d cancelBtn.ownerCt \x3d me;', 'Ext.DomHelper.generateMarkup(okBtn.getRenderTree(), out);', 'Ext.DomHelper.generateMarkup(cancelBtn.getRenderTree(), out);', '%}\x3c/div\x3e', '\x3c/tpl\x3e'], okText:'OK', cancelText:'Cancel', baseCls:Ext.baseCSSPrefix + 'monthpicker', showButtons:true, measureWidth:35, measureMaxHeight:20, smallCls:Ext.baseCSSPrefix + 'monthpicker-small', totalYears:10, yearOffset:5, monthOffset:6, 
initComponent:function() {
  var me = this;
  me.selectedCls = me.baseCls + '-selected';
  me.addEvents('cancelclick', 'monthclick', 'monthdblclick', 'okclick', 'select', 'yearclick', 'yeardblclick');
  if (me.small) {
    me.addCls(me.smallCls);
  }
  me.setValue(me.value);
  me.activeYear = me.getYear((new Date).getFullYear() - 4, -4);
  if (me.showButtons) {
    me.okBtn = new Ext.button.Button({text:me.okText, handler:me.onOkClick, scope:me});
    me.cancelBtn = new Ext.button.Button({text:me.cancelText, handler:me.onCancelClick, scope:me});
  }
  this.callParent();
}, beforeRender:function() {
  var me = this, i = 0, months = [], shortName = Ext.Date.getShortMonthName, monthLen = me.monthOffset, margin = me.monthMargin, style = '';
  me.callParent();
  for (; i < monthLen; ++i) {
    months.push(shortName(i), shortName(i + monthLen));
  }
  if (Ext.isDefined(margin)) {
    style = 'margin: 0 ' + margin + 'px;';
  }
  Ext.apply(me.renderData, {months:months, years:me.getYears(), showButtons:me.showButtons, monthStyle:style});
}, afterRender:function() {
  var me = this, body = me.bodyEl, buttonsEl = me.buttonsEl;
  me.callParent();
  me.mon(body, 'click', me.onBodyClick, me);
  me.mon(body, 'dblclick', me.onBodyClick, me);
  me.years = body.select('.' + me.baseCls + '-year a');
  me.months = body.select('.' + me.baseCls + '-month a');
  me.backRepeater = new Ext.util.ClickRepeater(me.prevEl, {handler:Ext.Function.bind(me.adjustYear, me, [-me.totalYears])});
  me.prevEl.addClsOnOver(me.baseCls + '-yearnav-prev-over');
  me.nextRepeater = new Ext.util.ClickRepeater(me.nextEl, {handler:Ext.Function.bind(me.adjustYear, me, [me.totalYears])});
  me.nextEl.addClsOnOver(me.baseCls + '-yearnav-next-over');
  me.updateBody();
  if (!Ext.isDefined(me.monthMargin)) {
    Ext.picker.Month.prototype.monthMargin = me.calculateMonthMargin();
  }
}, calculateMonthMargin:function() {
  var me = this, monthEl = me.monthEl, months = me.months, first = months.first(), itemMargin = first.getMargin('l');
  while (itemMargin && me.getLargest() > me.measureMaxHeight) {
    --itemMargin;
    months.setStyle('margin', '0 ' + itemMargin + 'px');
  }
  return itemMargin;
}, getLargest:function(months) {
  var largest = 0;
  this.months.each(function(item) {
    var h = item.getHeight();
    if (h > largest) {
      largest = h;
    }
  });
  return largest;
}, setValue:function(value) {
  var me = this, active = me.activeYear, offset = me.monthOffset, year, index;
  if (!value) {
    me.value = [null, null];
  } else {
    if (Ext.isDate(value)) {
      me.value = [value.getMonth(), value.getFullYear()];
    } else {
      me.value = [value[0], value[1]];
    }
  }
  if (me.rendered) {
    year = me.value[1];
    if (year !== null) {
      if (year < active || year > active + me.yearOffset) {
        me.activeYear = year - me.yearOffset + 1;
      }
    }
    me.updateBody();
  }
  return me;
}, getValue:function() {
  return this.value;
}, hasSelection:function() {
  var value = this.value;
  return value[0] !== null && value[1] !== null;
}, getYears:function() {
  var me = this, offset = me.yearOffset, start = me.activeYear, end = start + offset, i = start, years = [];
  for (; i < end; ++i) {
    years.push(i, i + offset);
  }
  return years;
}, updateBody:function() {
  var me = this, years = me.years, months = me.months, yearNumbers = me.getYears(), cls = me.selectedCls, value = me.getYear(null), month = me.value[0], monthOffset = me.monthOffset, year, yearItems, y, yLen, el;
  if (me.rendered) {
    years.removeCls(cls);
    months.removeCls(cls);
    yearItems = years.elements;
    yLen = yearItems.length;
    for (y = 0; y < yLen; y++) {
      el = Ext.fly(yearItems[y]);
      year = yearNumbers[y];
      el.dom.innerHTML = year;
      if (year == value) {
        el.addCls(cls);
      }
    }
    if (month !== null) {
      if (month < monthOffset) {
        month = month * 2;
      } else {
        month = (month - monthOffset) * 2 + 1;
      }
      months.item(month).addCls(cls);
    }
  }
}, getYear:function(defaultValue, offset) {
  var year = this.value[1];
  offset = offset || 0;
  return year === null ? defaultValue : year + offset;
}, onBodyClick:function(e, t) {
  var me = this, isDouble = e.type == 'dblclick';
  if (e.getTarget('.' + me.baseCls + '-month')) {
    e.stopEvent();
    me.onMonthClick(t, isDouble);
  } else {
    if (e.getTarget('.' + me.baseCls + '-year')) {
      e.stopEvent();
      me.onYearClick(t, isDouble);
    }
  }
}, adjustYear:function(offset) {
  if (typeof offset != 'number') {
    offset = this.totalYears;
  }
  this.activeYear += offset;
  this.updateBody();
}, onOkClick:function() {
  this.fireEvent('okclick', this, this.value);
}, onCancelClick:function() {
  this.fireEvent('cancelclick', this);
}, onMonthClick:function(target, isDouble) {
  var me = this;
  me.value[0] = me.resolveOffset(me.months.indexOf(target), me.monthOffset);
  me.updateBody();
  me.fireEvent('month' + (isDouble ? 'dbl' : '') + 'click', me, me.value);
  me.fireEvent('select', me, me.value);
}, onYearClick:function(target, isDouble) {
  var me = this;
  me.value[1] = me.activeYear + me.resolveOffset(me.years.indexOf(target), me.yearOffset);
  me.updateBody();
  me.fireEvent('year' + (isDouble ? 'dbl' : '') + 'click', me, me.value);
  me.fireEvent('select', me, me.value);
}, resolveOffset:function(index, offset) {
  if (index % 2 === 0) {
    return index / 2;
  } else {
    return offset + Math.floor(index / 2);
  }
}, beforeDestroy:function() {
  var me = this;
  me.years = me.months = null;
  Ext.destroyMembers(me, 'backRepeater', 'nextRepeater', 'okBtn', 'cancelBtn');
  me.callParent();
}, finishRenderChildren:function() {
  var me = this;
  this.callParent(arguments);
  if (this.showButtons) {
    me.okBtn.finishRender();
    me.cancelBtn.finishRender();
  }
}, onDestroy:function() {
  Ext.destroyMembers(this, 'okBtn', 'cancelBtn');
  this.callParent();
}});
Ext.define('Ext.picker.Date', {extend:Ext.Component, alias:'widget.datepicker', alternateClassName:'Ext.DatePicker', childEls:['innerEl', 'eventEl', 'prevEl', 'nextEl', 'middleBtnEl', 'footerEl'], border:true, renderTpl:['\x3cdiv id\x3d"{id}-innerEl" role\x3d"grid"\x3e', '\x3cdiv role\x3d"presentation" class\x3d"{baseCls}-header"\x3e', '\x3ca id\x3d"{id}-prevEl" class\x3d"{baseCls}-prev {baseCls}-arrow" href\x3d"#" role\x3d"button" title\x3d"{prevText}" hidefocus\x3d"on" \x3e\x3c/a\x3e', '\x3cdiv class\x3d"{baseCls}-month" id\x3d"{id}-middleBtnEl"\x3e{%this.renderMonthBtn(values, out)%}\x3c/div\x3e', 
'\x3ca id\x3d"{id}-nextEl" class\x3d"{baseCls}-next {baseCls}-arrow" href\x3d"#" role\x3d"button" title\x3d"{nextText}" hidefocus\x3d"on" \x3e\x3c/a\x3e', '\x3c/div\x3e', '\x3ctable id\x3d"{id}-eventEl" class\x3d"{baseCls}-inner" cellspacing\x3d"0" role\x3d"grid"\x3e', '\x3cthead role\x3d"presentation"\x3e\x3ctr role\x3d"row"\x3e', '\x3ctpl for\x3d"dayNames"\x3e', '\x3cth role\x3d"columnheader" class\x3d"{parent.baseCls}-column-header" title\x3d"{.}"\x3e', '\x3cdiv class\x3d"{parent.baseCls}-column-header-inner"\x3e{.:this.firstInitial}\x3c/div\x3e', 
'\x3c/th\x3e', '\x3c/tpl\x3e', '\x3c/tr\x3e\x3c/thead\x3e', '\x3ctbody role\x3d"presentation"\x3e\x3ctr role\x3d"row"\x3e', '\x3ctpl for\x3d"days"\x3e', '{#:this.isEndOfWeek}', '\x3ctd role\x3d"gridcell" id\x3d"{[Ext.id()]}"\x3e', '\x3ca role\x3d"presentation" hidefocus\x3d"on" class\x3d"{parent.baseCls}-date" href\x3d"#"\x3e\x3c/a\x3e', '\x3c/td\x3e', '\x3c/tpl\x3e', '\x3c/tr\x3e\x3c/tbody\x3e', '\x3c/table\x3e', '\x3ctpl if\x3d"showToday"\x3e', '\x3cdiv id\x3d"{id}-footerEl" role\x3d"presentation" class\x3d"{baseCls}-footer"\x3e{%this.renderTodayBtn(values, out)%}\x3c/div\x3e', 
'\x3c/tpl\x3e', '\x3c/div\x3e', {firstInitial:function(value) {
  return Ext.picker.Date.prototype.getDayInitial(value);
}, isEndOfWeek:function(value) {
  value--;
  var end = value % 7 === 0 && value !== 0;
  return end ? '\x3c/tr\x3e\x3ctr role\x3d"row"\x3e' : '';
}, renderTodayBtn:function(values, out) {
  Ext.DomHelper.generateMarkup(values.$comp.todayBtn.getRenderTree(), out);
}, renderMonthBtn:function(values, out) {
  Ext.DomHelper.generateMarkup(values.$comp.monthBtn.getRenderTree(), out);
}}], todayText:'Today', ariaTitle:'Date Picker: {0}', ariaTitleDateFormat:'F d, Y', todayTip:'{0} (Spacebar)', minText:'This date is before the minimum date', maxText:'This date is after the maximum date', disabledDaysText:'Disabled', disabledDatesText:'Disabled', nextText:'Next Month (Control+Right)', prevText:'Previous Month (Control+Left)', monthYearText:'Choose a month (Control+Up/Down to move years)', monthYearFormat:'F Y', startDay:0, showToday:true, disableAnim:false, baseCls:Ext.baseCSSPrefix + 
'datepicker', longDayFormat:'F d, Y', focusOnShow:false, focusOnSelect:true, initHour:12, numDays:42, initComponent:function() {
  var me = this, clearTime = Ext.Date.clearTime;
  me.selectedCls = me.baseCls + '-selected';
  me.disabledCellCls = me.baseCls + '-disabled';
  me.prevCls = me.baseCls + '-prevday';
  me.activeCls = me.baseCls + '-active';
  me.cellCls = me.baseCls + '-cell';
  me.nextCls = me.baseCls + '-prevday';
  me.todayCls = me.baseCls + '-today';
  if (!me.format) {
    me.format = Ext.Date.defaultFormat;
  }
  if (!me.dayNames) {
    me.dayNames = Ext.Date.dayNames;
  }
  me.dayNames = me.dayNames.slice(me.startDay).concat(me.dayNames.slice(0, me.startDay));
  me.callParent();
  me.value = me.value ? clearTime(me.value, true) : clearTime(new Date);
  me.addEvents('select');
  me.initDisabledDays();
}, beforeRender:function() {
  var me = this, days = new Array(me.numDays), today = Ext.Date.format(new Date, me.format);
  if (me.up('menu')) {
    me.addCls(Ext.baseCSSPrefix + 'menu');
  }
  me.monthBtn = new Ext.button.Split({ownerCt:me, ownerLayout:me.getComponentLayout(), text:'', tooltip:me.monthYearText, listeners:{click:me.showMonthPicker, arrowclick:me.showMonthPicker, scope:me}});
  if (me.showToday) {
    me.todayBtn = new Ext.button.Button({ownerCt:me, ownerLayout:me.getComponentLayout(), text:Ext.String.format(me.todayText, today), tooltip:Ext.String.format(me.todayTip, today), tooltipType:'title', handler:me.selectToday, scope:me});
  }
  me.callParent();
  Ext.applyIf(me, {renderData:{}});
  Ext.apply(me.renderData, {dayNames:me.dayNames, showToday:me.showToday, prevText:me.prevText, nextText:me.nextText, days:days});
  me.protoEl.unselectable();
}, finishRenderChildren:function() {
  var me = this;
  me.callParent();
  me.monthBtn.finishRender();
  if (me.showToday) {
    me.todayBtn.finishRender();
  }
}, onRender:function(container, position) {
  var me = this;
  me.callParent(arguments);
  me.cells = me.eventEl.select('tbody td');
  me.textNodes = me.eventEl.query('tbody td a');
  me.mon(me.eventEl, {scope:me, mousewheel:me.handleMouseWheel, click:{fn:me.handleDateClick, delegate:'a.' + me.baseCls + '-date'}});
}, initEvents:function() {
  var me = this, eDate = Ext.Date, day = eDate.DAY;
  me.callParent();
  me.prevRepeater = new Ext.util.ClickRepeater(me.prevEl, {handler:me.showPrevMonth, scope:me, preventDefault:true, stopDefault:true});
  me.nextRepeater = new Ext.util.ClickRepeater(me.nextEl, {handler:me.showNextMonth, scope:me, preventDefault:true, stopDefault:true});
  me.keyNav = new Ext.util.KeyNav(me.eventEl, Ext.apply({scope:me, left:function(e) {
    if (e.ctrlKey) {
      me.showPrevMonth();
    } else {
      me.update(eDate.add(me.activeDate, day, -1));
    }
  }, right:function(e) {
    if (e.ctrlKey) {
      me.showNextMonth();
    } else {
      me.update(eDate.add(me.activeDate, day, 1));
    }
  }, up:function(e) {
    if (e.ctrlKey) {
      me.showNextYear();
    } else {
      me.update(eDate.add(me.activeDate, day, -7));
    }
  }, down:function(e) {
    if (e.ctrlKey) {
      me.showPrevYear();
    } else {
      me.update(eDate.add(me.activeDate, day, 7));
    }
  }, pageUp:function(e) {
    if (e.altKey) {
      me.showPrevYear();
    } else {
      me.showPrevMonth();
    }
  }, pageDown:function(e) {
    if (e.altKey) {
      me.showNextYear();
    } else {
      me.showNextMonth();
    }
  }, tab:function(e) {
    me.doCancelFieldFocus = true;
    me.handleTabClick(e);
    delete me.doCancelFieldFocus;
    return true;
  }, enter:function(e) {
    e.stopPropagation();
    return true;
  }, home:function(e) {
    me.update(eDate.getFirstDateOfMonth(me.activeDate));
  }, end:function(e) {
    me.update(eDate.getLastDateOfMonth(me.activeDate));
  }}, me.keyNavConfig));
  if (me.showToday) {
    me.todayKeyListener = me.eventEl.addKeyListener(Ext.EventObject.SPACE, me.selectToday, me);
  }
  me.update(me.value);
}, handleTabClick:function(e) {
  var me = this, t = me.getSelectedDate(me.activeDate), handler = me.handler;
  if (!me.disabled && t.dateValue && !Ext.fly(t.parentNode).hasCls(me.disabledCellCls)) {
    me.doCancelFocus = me.focusOnSelect === false;
    me.setValue(new Date(t.dateValue));
    delete me.doCancelFocus;
    me.fireEvent('select', me, me.value);
    if (handler) {
      handler.call(me.scope || me, me, me.value);
    }
    me.onSelect();
  }
}, getSelectedDate:function(date) {
  var me = this, t = date.getTime(), cells = me.cells, cls = me.selectedCls, cellItems = cells.elements, c, cLen = cellItems.length, cell;
  cells.removeCls(cls);
  for (c = 0; c < cLen; c++) {
    cell = Ext.fly(cellItems[c]);
    if (cell.dom.firstChild.dateValue == t) {
      return cell.dom.firstChild;
    }
  }
  return null;
}, initDisabledDays:function() {
  var me = this, dd = me.disabledDates, re = '(?:', len, d, dLen, dI;
  if (!me.disabledDatesRE && dd) {
    len = dd.length - 1;
    dLen = dd.length;
    for (d = 0; d < dLen; d++) {
      dI = dd[d];
      re += Ext.isDate(dI) ? '^' + Ext.String.escapeRegex(Ext.Date.dateFormat(dI, me.format)) + '$' : dI;
      if (d != len) {
        re += '|';
      }
    }
    me.disabledDatesRE = new RegExp(re + ')');
  }
}, setDisabledDates:function(dd) {
  var me = this;
  if (Ext.isArray(dd)) {
    me.disabledDates = dd;
    me.disabledDatesRE = null;
  } else {
    me.disabledDatesRE = dd;
  }
  me.initDisabledDays();
  me.update(me.value, true);
  return me;
}, setDisabledDays:function(dd) {
  this.disabledDays = dd;
  return this.update(this.value, true);
}, setMinDate:function(dt) {
  this.minDate = dt;
  return this.update(this.value, true);
}, setMaxDate:function(dt) {
  this.maxDate = dt;
  return this.update(this.value, true);
}, setValue:function(value) {
  this.value = Ext.Date.clearTime(value, true);
  return this.update(this.value);
}, getValue:function() {
  return this.value;
}, getDayInitial:function(value) {
  return value.substr(0, 1);
}, focus:function() {
  this.update(this.activeDate);
}, onEnable:function() {
  this.callParent();
  this.setDisabledStatus(false);
  this.update(this.activeDate);
}, onDisable:function() {
  this.callParent();
  this.setDisabledStatus(true);
}, setDisabledStatus:function(disabled) {
  var me = this;
  me.keyNav.setDisabled(disabled);
  me.prevRepeater.setDisabled(disabled);
  me.nextRepeater.setDisabled(disabled);
  if (me.showToday) {
    me.todayKeyListener.setDisabled(disabled);
    me.todayBtn.setDisabled(disabled);
  }
}, getActive:function() {
  return this.activeDate || this.value;
}, runAnimation:function(isHide) {
  var picker = this.monthPicker, options = {duration:200, callback:function() {
    if (isHide) {
      picker.hide();
    } else {
      picker.show();
    }
  }};
  if (isHide) {
    picker.el.slideOut('t', options);
  } else {
    picker.el.slideIn('t', options);
  }
}, hideMonthPicker:function(animate) {
  var me = this, picker = me.monthPicker;
  if (picker) {
    if (me.shouldAnimate(animate)) {
      me.runAnimation(true);
    } else {
      picker.hide();
    }
  }
  return me;
}, showMonthPicker:function(animate) {
  var me = this, picker;
  if (me.rendered && !me.disabled) {
    picker = me.createMonthPicker();
    picker.setValue(me.getActive());
    picker.setSize(me.getSize());
    picker.setPosition(-1, -1);
    if (me.shouldAnimate(animate)) {
      me.runAnimation(false);
    } else {
      picker.show();
    }
  }
  return me;
}, shouldAnimate:function(animate) {
  return Ext.isDefined(animate) ? animate : !this.disableAnim;
}, createMonthPicker:function() {
  var me = this, picker = me.monthPicker;
  if (!picker) {
    me.monthPicker = picker = new Ext.picker.Month({renderTo:me.el, floating:true, shadow:false, small:me.showToday === false, listeners:{scope:me, cancelclick:me.onCancelClick, okclick:me.onOkClick, yeardblclick:me.onOkClick, monthdblclick:me.onOkClick}});
    if (!me.disableAnim) {
      picker.el.setStyle('display', 'none');
    }
    me.on('beforehide', Ext.Function.bind(me.hideMonthPicker, me, [false]));
  }
  return picker;
}, onOkClick:function(picker, value) {
  var me = this, month = value[0], year = value[1], date = new Date(year, month, me.getActive().getDate());
  if (date.getMonth() !== month) {
    date = Ext.Date.getLastDateOfMonth(new Date(year, month, 1));
  }
  me.setValue(date);
  me.hideMonthPicker();
}, onCancelClick:function() {
  this.selectedUpdate(this.activeDate);
  this.hideMonthPicker();
}, showPrevMonth:function(e) {
  return this.setValue(Ext.Date.add(this.activeDate, Ext.Date.MONTH, -1));
}, showNextMonth:function(e) {
  return this.setValue(Ext.Date.add(this.activeDate, Ext.Date.MONTH, 1));
}, showPrevYear:function() {
  return this.setValue(Ext.Date.add(this.activeDate, Ext.Date.YEAR, -1));
}, showNextYear:function() {
  return this.setValue(Ext.Date.add(this.activeDate, Ext.Date.YEAR, 1));
}, handleMouseWheel:function(e) {
  e.stopEvent();
  if (!this.disabled) {
    var delta = e.getWheelDelta();
    if (delta > 0) {
      this.showPrevMonth();
    } else {
      if (delta < 0) {
        this.showNextMonth();
      }
    }
  }
}, handleDateClick:function(e, t) {
  var me = this, handler = me.handler;
  e.stopEvent();
  if (!me.disabled && t.dateValue && !Ext.fly(t.parentNode).hasCls(me.disabledCellCls)) {
    me.doCancelFocus = me.focusOnSelect === false;
    me.setValue(new Date(t.dateValue));
    delete me.doCancelFocus;
    me.fireEvent('select', me, me.value);
    if (handler) {
      handler.call(me.scope || me, me, me.value);
    }
    me.onSelect();
  }
}, onSelect:function() {
  if (this.hideOnSelect) {
    this.hide();
  }
}, selectToday:function() {
  var me = this, btn = me.todayBtn, handler = me.handler;
  if (btn && !btn.disabled) {
    me.setValue(Ext.Date.clearTime(new Date));
    me.fireEvent('select', me, me.value);
    if (handler) {
      handler.call(me.scope || me, me, me.value);
    }
    me.onSelect();
  }
  return me;
}, selectedUpdate:function(date) {
  var me = this, t = date.getTime(), cells = me.cells, cls = me.selectedCls, cellItems = cells.elements, c, cLen = cellItems.length, cell;
  cells.removeCls(cls);
  for (c = 0; c < cLen; c++) {
    cell = Ext.fly(cellItems[c]);
    if (cell.dom.firstChild.dateValue == t) {
      me.fireEvent('highlightitem', me, cell);
      cell.addCls(cls);
      if (me.isVisible() && !me.doCancelFocus) {
        Ext.fly(cell.dom.firstChild).focus(50);
      }
      break;
    }
  }
}, fullUpdate:function(date) {
  var me = this, cells = me.cells.elements, textNodes = me.textNodes, disabledCls = me.disabledCellCls, eDate = Ext.Date, i = 0, extraDays = 0, visible = me.isVisible(), newDate = +eDate.clearTime(date, true), today = +eDate.clearTime(new Date), min = me.minDate ? eDate.clearTime(me.minDate, true) : Number.NEGATIVE_INFINITY, max = me.maxDate ? eDate.clearTime(me.maxDate, true) : Number.POSITIVE_INFINITY, ddMatch = me.disabledDatesRE, ddText = me.disabledDatesText, ddays = me.disabledDays ? me.disabledDays.join('') : 
  false, ddaysText = me.disabledDaysText, format = me.format, days = eDate.getDaysInMonth(date), firstOfMonth = eDate.getFirstDateOfMonth(date), startingPos = firstOfMonth.getDay() - me.startDay, previousMonth = eDate.add(date, eDate.MONTH, -1), longDayFormat = me.longDayFormat, prevStart, current, disableToday, tempDate, setCellClass, html, cls, formatValue, value;
  if (startingPos < 0) {
    startingPos += 7;
  }
  days += startingPos;
  prevStart = eDate.getDaysInMonth(previousMonth) - startingPos;
  current = new Date(previousMonth.getFullYear(), previousMonth.getMonth(), prevStart, me.initHour);
  if (me.showToday) {
    tempDate = eDate.clearTime(new Date);
    disableToday = tempDate < min || tempDate > max || ddMatch && format && ddMatch.test(eDate.dateFormat(tempDate, format)) || ddays && ddays.indexOf(tempDate.getDay()) != -1;
    if (!me.disabled) {
      me.todayBtn.setDisabled(disableToday);
      me.todayKeyListener.setDisabled(disableToday);
    }
  }
  setCellClass = function(cell, cls) {
    value = +eDate.clearTime(current, true);
    cell.title = eDate.format(current, longDayFormat);
    cell.firstChild.dateValue = value;
    if (value == today) {
      cls += ' ' + me.todayCls;
      cell.title = me.todayText;
      me.todayElSpan = Ext.DomHelper.append(cell.firstChild, {tag:'span', cls:Ext.baseCSSPrefix + 'hide-clip', html:me.todayText}, true);
    }
    if (value == newDate) {
      cls += ' ' + me.selectedCls;
      me.fireEvent('highlightitem', me, cell);
      if (visible && me.floating) {
        Ext.fly(cell.firstChild).focus(50);
      }
    }
    if (value < min) {
      cls += ' ' + disabledCls;
      cell.title = me.minText;
    } else {
      if (value > max) {
        cls += ' ' + disabledCls;
        cell.title = me.maxText;
      } else {
        if (ddays && ddays.indexOf(current.getDay()) !== -1) {
          cell.title = ddaysText;
          cls += ' ' + disabledCls;
        } else {
          if (ddMatch && format) {
            formatValue = eDate.dateFormat(current, format);
            if (ddMatch.test(formatValue)) {
              cell.title = ddText.replace('%0', formatValue);
              cls += ' ' + disabledCls;
            }
          }
        }
      }
    }
    cell.className = cls + ' ' + me.cellCls;
  };
  for (; i < me.numDays; ++i) {
    if (i < startingPos) {
      html = ++prevStart;
      cls = me.prevCls;
    } else {
      if (i >= days) {
        html = ++extraDays;
        cls = me.nextCls;
      } else {
        html = i - startingPos + 1;
        cls = me.activeCls;
      }
    }
    textNodes[i].innerHTML = html;
    current.setDate(current.getDate() + 1);
    setCellClass(cells[i], cls);
  }
  me.monthBtn.setText(Ext.Date.format(date, me.monthYearFormat));
}, update:function(date, forceRefresh) {
  var me = this, active = me.activeDate;
  if (me.rendered) {
    me.activeDate = date;
    if (!forceRefresh && active && me.el && active.getMonth() == date.getMonth() && active.getFullYear() == date.getFullYear()) {
      me.selectedUpdate(date, active);
    } else {
      me.fullUpdate(date, active);
    }
  }
  return me;
}, beforeDestroy:function() {
  var me = this;
  if (me.rendered) {
    Ext.destroy(me.todayKeyListener, me.keyNav, me.monthPicker, me.monthBtn, me.nextRepeater, me.prevRepeater, me.todayBtn);
    delete me.textNodes;
    delete me.cells.elements;
  }
  me.callParent();
}, onShow:function() {
  this.callParent(arguments);
  if (this.focusOnShow) {
    this.focus();
  }
}});
Ext.define('Ext.form.field.Date', {extend:Ext.form.field.Picker, alias:'widget.datefield', alternateClassName:['Ext.form.DateField', 'Ext.form.Date'], format:'m/d/Y', altFormats:'m/d/Y|n/j/Y|n/j/y|m/j/y|n/d/y|m/j/Y|n/d/Y|m-d-y|m-d-Y|m/d|m-d|md|mdy|mdY|d|Y-m-d|n-j|n/j', disabledDaysText:'Disabled', disabledDatesText:'Disabled', minText:'The date in this field must be equal to or after {0}', maxText:'The date in this field must be equal to or before {0}', invalidText:'{0} is not a valid date - it must be in the format {1}', 
triggerCls:Ext.baseCSSPrefix + 'form-date-trigger', showToday:true, useStrict:undefined, initTime:'12', initTimeFormat:'H', matchFieldWidth:false, startDay:0, initComponent:function() {
  var me = this, isString = Ext.isString, min, max;
  min = me.minValue;
  max = me.maxValue;
  if (isString(min)) {
    me.minValue = me.parseDate(min);
  }
  if (isString(max)) {
    me.maxValue = me.parseDate(max);
  }
  me.disabledDatesRE = null;
  me.initDisabledDays();
  me.callParent();
}, initValue:function() {
  var me = this, value = me.value;
  if (Ext.isString(value)) {
    me.value = me.rawToValue(value);
  }
  me.callParent();
}, initDisabledDays:function() {
  if (this.disabledDates) {
    var dd = this.disabledDates, len = dd.length - 1, re = '(?:', d, dLen = dd.length, date;
    for (d = 0; d < dLen; d++) {
      date = dd[d];
      re += Ext.isDate(date) ? '^' + Ext.String.escapeRegex(date.dateFormat(this.format)) + '$' : date;
      if (d !== len) {
        re += '|';
      }
    }
    this.disabledDatesRE = new RegExp(re + ')');
  }
}, setDisabledDates:function(dd) {
  var me = this, picker = me.picker;
  me.disabledDates = dd;
  me.initDisabledDays();
  if (picker) {
    picker.setDisabledDates(me.disabledDatesRE);
  }
}, setDisabledDays:function(dd) {
  var picker = this.picker;
  this.disabledDays = dd;
  if (picker) {
    picker.setDisabledDays(dd);
  }
}, setMinValue:function(dt) {
  var me = this, picker = me.picker, minValue = Ext.isString(dt) ? me.parseDate(dt) : dt;
  me.minValue = minValue;
  if (picker) {
    picker.minText = Ext.String.format(me.minText, me.formatDate(me.minValue));
    picker.setMinDate(minValue);
  }
}, setMaxValue:function(dt) {
  var me = this, picker = me.picker, maxValue = Ext.isString(dt) ? me.parseDate(dt) : dt;
  me.maxValue = maxValue;
  if (picker) {
    picker.maxText = Ext.String.format(me.maxText, me.formatDate(me.maxValue));
    picker.setMaxDate(maxValue);
  }
}, getErrors:function(value) {
  var me = this, format = Ext.String.format, clearTime = Ext.Date.clearTime, errors = me.callParent(arguments), disabledDays = me.disabledDays, disabledDatesRE = me.disabledDatesRE, minValue = me.minValue, maxValue = me.maxValue, len = disabledDays ? disabledDays.length : 0, i = 0, svalue, fvalue, day, time;
  value = me.formatDate(value || me.processRawValue(me.getRawValue()));
  if (value === null || value.length < 1) {
    return errors;
  }
  svalue = value;
  value = me.parseDate(value);
  if (!value) {
    errors.push(format(me.invalidText, svalue, Ext.Date.unescapeFormat(me.format)));
    return errors;
  }
  time = value.getTime();
  if (minValue && time < clearTime(minValue).getTime()) {
    errors.push(format(me.minText, me.formatDate(minValue)));
  }
  if (maxValue && time > clearTime(maxValue).getTime()) {
    errors.push(format(me.maxText, me.formatDate(maxValue)));
  }
  if (disabledDays) {
    day = value.getDay();
    for (; i < len; i++) {
      if (day === disabledDays[i]) {
        errors.push(me.disabledDaysText);
        break;
      }
    }
  }
  fvalue = me.formatDate(value);
  if (disabledDatesRE && disabledDatesRE.test(fvalue)) {
    errors.push(format(me.disabledDatesText, fvalue));
  }
  return errors;
}, rawToValue:function(rawValue) {
  return this.parseDate(rawValue) || rawValue || null;
}, valueToRaw:function(value) {
  return this.formatDate(this.parseDate(value));
}, safeParse:function(value, format) {
  var me = this, utilDate = Ext.Date, result = null, strict = me.useStrict, parsedDate;
  if (utilDate.formatContainsHourInfo(format)) {
    result = utilDate.parse(value, format, strict);
  } else {
    parsedDate = utilDate.parse(value + ' ' + me.initTime, format + ' ' + me.initTimeFormat, strict);
    if (parsedDate) {
      result = utilDate.clearTime(parsedDate);
    }
  }
  return result;
}, getSubmitValue:function() {
  var format = this.submitFormat || this.format, value = this.getValue();
  return value ? Ext.Date.format(value, format) : '';
}, parseDate:function(value) {
  if (!value || Ext.isDate(value)) {
    return value;
  }
  var me = this, val = me.safeParse(value, me.format), altFormats = me.altFormats, altFormatsArray = me.altFormatsArray, i = 0, len;
  if (!val && altFormats) {
    altFormatsArray = altFormatsArray || altFormats.split('|');
    len = altFormatsArray.length;
    for (; i < len && !val; ++i) {
      val = me.safeParse(value, altFormatsArray[i]);
    }
  }
  return val;
}, formatDate:function(date) {
  return Ext.isDate(date) ? Ext.Date.dateFormat(date, this.format) : date;
}, createPicker:function() {
  var me = this, format = Ext.String.format;
  return new Ext.picker.Date({pickerField:me, ownerCt:me.ownerCt, renderTo:document.body, floating:true, hidden:true, focusOnShow:true, minDate:me.minValue, maxDate:me.maxValue, disabledDatesRE:me.disabledDatesRE, disabledDatesText:me.disabledDatesText, disabledDays:me.disabledDays, disabledDaysText:me.disabledDaysText, format:me.format, showToday:me.showToday, startDay:me.startDay, minText:format(me.minText, me.formatDate(me.minValue)), maxText:format(me.maxText, me.formatDate(me.maxValue)), listeners:{scope:me, 
  select:me.onSelect}, keyNavConfig:{esc:function() {
    me.collapse();
  }}});
}, onDownArrow:function(e) {
  this.callParent(arguments);
  if (this.isExpanded) {
    this.getPicker().focus();
  }
}, onSelect:function(m, d) {
  var me = this;
  me.setValue(d);
  me.fireEvent('select', me, d);
  me.collapse();
}, onExpand:function() {
  var value = this.getValue();
  this.picker.setValue(Ext.isDate(value) ? value : new Date);
}, onCollapse:function() {
  this.focus(false, 60);
}, beforeBlur:function() {
  var me = this, v = me.parseDate(me.getRawValue()), focusTask = me.focusTask;
  if (focusTask) {
    focusTask.cancel();
  }
  if (v) {
    me.setValue(v);
  }
}});
Ext.define('Ext.grid.CellContext', {isCellContext:true, constructor:function(view) {
  this.view = view;
}, setPosition:function(row, col) {
  var me = this;
  if (arguments.length === 1) {
    if (row.view) {
      me.view = row.view;
    }
    col = row.column;
    row = row.row;
  }
  me.setRow(row);
  me.setColumn(col);
  return me;
}, setRow:function(row) {
  var me = this;
  if (row !== undefined) {
    if (typeof row === 'number') {
      me.row = Math.max(Math.min(row, me.view.dataSource.getCount() - 1), 0);
      me.record = me.view.dataSource.getAt(row);
    } else {
      if (row.isModel) {
        me.record = row;
        me.row = me.view.indexOf(row);
      } else {
        if (row.tagName) {
          me.record = me.view.getRecord(row);
          me.row = me.view.indexOf(me.record);
        }
      }
    }
  }
}, setColumn:function(col) {
  var me = this, columnManager = me.view.ownerCt.columnManager;
  if (col !== undefined) {
    if (typeof col === 'number') {
      me.column = col;
      me.columnHeader = columnManager.getHeaderAtIndex(col);
    } else {
      if (col.isHeader) {
        me.columnHeader = col;
        me.column = columnManager.getHeaderIndex(col);
      }
    }
  }
}});
Ext.define('Ext.grid.ColumnComponentLayout', {extend:Ext.layout.component.Auto, alias:'layout.columncomponent', type:'columncomponent', setWidthInDom:true, beginLayout:function(ownerContext) {
  var me = this;
  me.callParent(arguments);
  ownerContext.titleContext = ownerContext.getEl('titleEl');
  ownerContext.triggerContext = ownerContext.getEl('triggerEl');
}, beginLayoutCycle:function(ownerContext) {
  var me = this, owner = me.owner;
  me.callParent(arguments);
  if (ownerContext.widthModel.shrinkWrap) {
    owner.el.setWidth('');
  }
  var borderRightWidth = owner.isLast && owner.isSubHeader ? '0' : '';
  if (borderRightWidth !== me.lastBorderRightWidth) {
    owner.el.dom.style.borderRightWidth = me.lasBorderRightWidth = borderRightWidth;
  }
  owner.titleEl.setStyle({paddingTop:'', paddingBottom:''});
}, publishInnerHeight:function(ownerContext, outerHeight) {
  if (!outerHeight) {
    return;
  }
  var me = this, owner = me.owner, innerHeight = outerHeight - ownerContext.getBorderInfo().height, availableHeight = innerHeight, textHeight, titleHeight, pt, pb;
  if (!owner.noWrap && !ownerContext.hasDomProp('width')) {
    me.done = false;
    return;
  }
  if (ownerContext.hasRawContent) {
    titleHeight = availableHeight;
    textHeight = owner.textEl.getHeight();
    if (textHeight) {
      availableHeight -= textHeight;
      if (availableHeight > 0) {
        pt = Math.floor(availableHeight / 2);
        pb = availableHeight - pt;
        ownerContext.titleContext.setProp('padding-top', pt);
        ownerContext.titleContext.setProp('padding-bottom', pb);
      }
    }
  } else {
    titleHeight = owner.titleEl.getHeight();
    ownerContext.setProp('innerHeight', innerHeight - titleHeight, false);
  }
  if ((Ext.isIE6 || Ext.isIEQuirks) && ownerContext.triggerContext) {
    ownerContext.triggerContext.setHeight(titleHeight);
  }
}, measureContentHeight:function(ownerContext) {
  return ownerContext.el.dom.offsetHeight;
}, publishOwnerHeight:function(ownerContext, contentHeight) {
  this.callParent(arguments);
  if ((Ext.isIE6 || Ext.isIEQuirks) && ownerContext.triggerContext) {
    ownerContext.triggerContext.setHeight(contentHeight);
  }
}, publishInnerWidth:function(ownerContext, outerWidth) {
  if (!ownerContext.hasRawContent) {
    ownerContext.setProp('innerWidth', outerWidth - ownerContext.getBorderInfo().width, false);
  }
}, calculateOwnerHeightFromContentHeight:function(ownerContext, contentHeight) {
  var result = this.callParent(arguments);
  if (!ownerContext.hasRawContent) {
    if (this.owner.noWrap || ownerContext.hasDomProp('width')) {
      return contentHeight + this.owner.titleEl.getHeight() + ownerContext.getBorderInfo().height;
    }
    return null;
  }
  return result;
}, calculateOwnerWidthFromContentWidth:function(ownerContext, contentWidth) {
  var owner = this.owner, inner = Math.max(contentWidth, owner.textEl.getWidth() + ownerContext.titleContext.getPaddingInfo().width), padWidth = ownerContext.getPaddingInfo().width, triggerOffset = this.getTriggerOffset(owner, ownerContext);
  return inner + padWidth + triggerOffset;
}, getTriggerOffset:function(owner, ownerContext) {
  var width = 0;
  if (ownerContext.widthModel.shrinkWrap && !owner.menuDisabled) {
    if (owner.query('\x3e:not([hidden])').length === 0) {
      width = owner.self.triggerElWidth;
    }
  }
  return width;
}});
Ext.define('Ext.grid.ColumnLayout', {extend:Ext.layout.container.HBox, alias:'layout.gridcolumn', type:'gridcolumn', reserveOffset:false, firstHeaderCls:Ext.baseCSSPrefix + 'column-header-first', lastHeaderCls:Ext.baseCSSPrefix + 'column-header-last', initLayout:function() {
  if (!this.scrollbarWidth) {
    this.self.prototype.scrollbarWidth = Ext.getScrollbarSize().width;
  }
  this.grid = this.owner.up('[scrollerOwner]');
  this.callParent();
}, beginLayout:function(ownerContext) {
  var me = this, owner = me.owner, grid = me.grid, view = grid.view, items = me.getVisibleItems(), len = items.length, firstCls = me.firstHeaderCls, lastCls = me.lastHeaderCls, i, item;
  if (grid.lockable) {
    if (owner.up('tablepanel') === view.normalGrid) {
      view = view.normalGrid.getView();
    } else {
      view = null;
    }
  }
  for (i = 0; i < len; i++) {
    item = items[i];
    item.isLast = false;
    item.removeCls([firstCls, lastCls]);
    if (i === 0) {
      item.addCls(firstCls);
    }
    if (i === len - 1) {
      item.addCls(lastCls);
      item.isLast = true;
    }
  }
  me.callParent(arguments);
  if (!owner.isColumn && Ext.getScrollbarSize().width && !grid.collapsed && view && view.rendered && (ownerContext.viewTable = view.body.dom)) {
    ownerContext.viewContext = ownerContext.context.getCmp(view);
  }
}, roundFlex:function(width) {
  return Math.floor(width);
}, calculate:function(ownerContext) {
  this.callParent(arguments);
  if (ownerContext.state.parallelDone && (!this.owner.forceFit || ownerContext.flexedItems.length)) {
    ownerContext.setProp('columnWidthsDone', true);
  }
  if (ownerContext.viewContext) {
    ownerContext.state.tableHeight = ownerContext.viewTable.offsetHeight;
  }
}, completeLayout:function(ownerContext) {
  var me = this, owner = me.owner, state = ownerContext.state;
  me.callParent(arguments);
  if (!ownerContext.flexedItems.length && !state.flexesCalculated && owner.forceFit && me.convertWidthsToFlexes(ownerContext)) {
    me.cacheFlexes(ownerContext);
    ownerContext.invalidate({state:{flexesCalculated:true}});
  } else {
    ownerContext.setProp('columnWidthsDone', true);
  }
}, convertWidthsToFlexes:function(ownerContext) {
  var me = this, totalWidth = 0, calculated = me.sizeModels.calculated, childItems, len, i, childContext, item;
  childItems = ownerContext.childItems;
  len = childItems.length;
  for (i = 0; i < len; i++) {
    childContext = childItems[i];
    item = childContext.target;
    totalWidth += childContext.props.width;
    if (!(item.fixed || item.resizable === false)) {
      item.flex = ownerContext.childItems[i].flex = childContext.props.width;
      item.width = null;
      childContext.widthModel = calculated;
    }
  }
  return totalWidth !== ownerContext.props.width;
}, getContainerSize:function(ownerContext) {
  var me = this, result, viewContext = ownerContext.viewContext, viewHeight;
  if (me.owner.isColumn) {
    result = me.getColumnContainerSize(ownerContext);
  } else {
    result = me.callParent(arguments);
    if (viewContext && !viewContext.heightModel.shrinkWrap && viewContext.target.componentLayout.ownerContext) {
      viewHeight = viewContext.getProp('height');
      if (isNaN(viewHeight)) {
        me.done = false;
      } else {
        if (ownerContext.state.tableHeight > viewHeight) {
          result.width -= Ext.getScrollbarSize().width;
          ownerContext.state.parallelDone = false;
          viewContext.invalidate();
        }
      }
    }
  }
  return result;
}, getColumnContainerSize:function(ownerContext) {
  var padding = ownerContext.paddingContext.getPaddingInfo(), got = 0, needed = 0, gotWidth, gotHeight, width, height;
  if (!ownerContext.widthModel.shrinkWrap) {
    ++needed;
    width = ownerContext.getProp('innerWidth');
    gotWidth = typeof width == 'number';
    if (gotWidth) {
      ++got;
      width -= padding.width;
      if (width < 0) {
        width = 0;
      }
    }
  }
  if (!ownerContext.heightModel.shrinkWrap) {
    ++needed;
    height = ownerContext.getProp('innerHeight');
    gotHeight = typeof height == 'number';
    if (gotHeight) {
      ++got;
      height -= padding.height;
      if (height < 0) {
        height = 0;
      }
    }
  }
  return {width:width, height:height, needed:needed, got:got, gotAll:got == needed, gotWidth:gotWidth, gotHeight:gotHeight};
}, publishInnerCtSize:function(ownerContext) {
  var me = this, size = ownerContext.state.boxPlan.targetSize, cw = ownerContext.peek('contentWidth'), view;
  me.owner.tooNarrow = ownerContext.state.boxPlan.tooNarrow;
  if (cw != null && !me.owner.isColumn) {
    size.width = cw;
    view = me.owner.ownerCt.view;
    if (view.scrollFlags.y) {
      size.width += Ext.getScrollbarSize().width;
    }
  }
  return me.callParent(arguments);
}});
Ext.define('Ext.grid.ColumnManager', {alternateClassName:['Ext.grid.ColumnModel'], columns:null, constructor:function(headerCt, secondHeaderCt) {
  if (!headerCt.isRootHeader) {
    Ext.Error.raise('ColumnManager must be passed an instantiated HeaderContainer');
  }
  this.headerCt = headerCt;
  if (secondHeaderCt) {
    if (!headerCt.isRootHeader) {
      Ext.Error.raise('ColumnManager must be passed an instantiated HeaderContainer');
    }
    this.secondHeaderCt = secondHeaderCt;
  }
}, getColumns:function() {
  if (!this.columns) {
    this.cacheColumns();
  }
  return this.columns;
}, getHeaderIndex:function(header) {
  if (header.isGroupHeader) {
    header = header.down(':not([isGroupHeader])');
  }
  return Ext.Array.indexOf(this.getColumns(), header);
}, getHeaderAtIndex:function(index) {
  var columns = this.getColumns();
  return columns.length ? columns[index] : null;
}, getHeaderById:function(id) {
  var columns = this.getColumns(), len = columns.length, i, header;
  for (i = 0; i < len; ++i) {
    header = columns[i];
    if (header.getItemId() === id) {
      return header;
    }
  }
  return null;
}, getVisibleHeaderClosestToIndex:function(index) {
  var result = this.getHeaderAtIndex(index);
  if (result && result.hidden) {
    result = result.next(':not([hidden])') || result.prev(':not([hidden])');
  }
  return result;
}, cacheColumns:function() {
  this.columns = this.headerCt.getVisibleGridColumns();
  if (this.secondHeaderCt) {
    Ext.Array.push(this.columns, this.secondHeaderCt.getVisibleGridColumns());
  }
}, invalidate:function() {
  this.columns = null;
  if (this.rootColumns) {
    this.rootColumns.invalidate();
  }
}}, function() {
  this.createAlias('indexOf', 'getHeaderIndex');
});
Ext.define('Ext.panel.Table', {extend:Ext.panel.Panel, alias:'widget.tablepanel', extraBaseCls:Ext.baseCSSPrefix + 'grid', extraBodyCls:Ext.baseCSSPrefix + 'grid-body', layout:'fit', hasView:false, viewType:null, selType:'rowmodel', scroll:true, deferRowRender:true, sortableColumns:true, enableLocking:false, scrollerOwner:true, enableColumnMove:true, sealedColumns:false, enableColumnResize:true, rowLines:true, colLinesCls:Ext.baseCSSPrefix + 'grid-with-col-lines', rowLinesCls:Ext.baseCSSPrefix + 
'grid-with-row-lines', noRowLinesCls:Ext.baseCSSPrefix + 'grid-no-row-lines', hiddenHeaderCtCls:Ext.baseCSSPrefix + 'grid-header-ct-hidden', hiddenHeaderCls:Ext.baseCSSPrefix + 'grid-header-hidden', resizeMarkerCls:Ext.baseCSSPrefix + 'grid-resize-marker', emptyCls:Ext.baseCSSPrefix + 'grid-empty', initComponent:function() {
  if (!this.viewType) {
    Ext.Error.raise('You must specify a viewType config.');
  }
  if (this.headers) {
    Ext.Error.raise('The headers config is not supported. Please specify columns instead.');
  }
  var me = this, headerCtCfg = me.columns || me.colModel, view, i, len, store = me.store = Ext.data.StoreManager.lookup(me.store || 'ext-empty-store'), columns;
  if (me.columnLines) {
    me.addCls(me.colLinesCls);
  }
  me.addCls(me.rowLines ? me.rowLinesCls : me.noRowLinesCls);
  if (!headerCtCfg) {
    Ext.Error.raise('A column configuration must be specified');
  }
  if (headerCtCfg instanceof Ext.grid.header.Container) {
    headerCtCfg.isRootHeader = true;
    me.headerCt = headerCtCfg;
  } else {
    if (me.enableLocking || me.hasLockedColumns(headerCtCfg)) {
      me.self.mixin('lockable', Ext.grid.locking.Lockable);
      me.injectLockable();
    } else {
      if (Ext.isArray(headerCtCfg)) {
        headerCtCfg = {items:headerCtCfg};
      }
      Ext.apply(headerCtCfg, {grid:me, forceFit:me.forceFit, sortable:me.sortableColumns, enableColumnMove:me.enableColumnMove, enableColumnResize:me.enableColumnResize, sealed:me.sealedColumns, isRootHeader:true});
      if (Ext.isDefined(me.enableColumnHide)) {
        headerCtCfg.enableColumnHide = me.enableColumnHide;
      }
      if (!me.headerCt) {
        me.headerCt = new Ext.grid.header.Container(headerCtCfg);
      }
    }
  }
  me.columns = me.headerCt.getGridColumns();
  me.scrollTask = new Ext.util.DelayedTask(me.syncHorizontalScroll, me);
  me.addEvents('reconfigure', 'viewready');
  me.bodyCls = me.bodyCls || '';
  me.bodyCls += ' ' + me.extraBodyCls;
  me.cls = me.cls || '';
  me.cls += ' ' + me.extraBaseCls;
  delete me.autoScroll;
  if (!me.hasView) {
    columns = me.headerCt.getGridColumns();
    if (store.buffered && !store.remoteSort) {
      for (i = 0, len = columns.length; i < len; i++) {
        columns[i].sortable = false;
      }
    }
    if (me.hideHeaders) {
      me.headerCt.height = 0;
      me.headerCt.hiddenHeaders = true;
      me.headerCt.addCls(me.hiddenHeaderCtCls);
      me.addCls(me.hiddenHeaderCls);
      if (Ext.isIEQuirks) {
        me.headerCt.style = {display:'none'};
      }
    }
    me.relayHeaderCtEvents(me.headerCt);
    me.features = me.features || [];
    if (!Ext.isArray(me.features)) {
      me.features = [me.features];
    }
    me.dockedItems = [].concat(me.dockedItems || []);
    me.dockedItems.unshift(me.headerCt);
    me.viewConfig = me.viewConfig || {};
    view = me.getView();
    me.items = [view];
    me.hasView = true;
    if (!me.hideHeaders) {
      view.on({scroll:{fn:me.onHorizontalScroll, element:'el', scope:me}});
    }
    me.bindStore(store, true);
    me.mon(view, {viewready:me.onViewReady, refresh:me.onRestoreHorzScroll, scope:me});
  }
  me.relayEvents(me.view, ['beforeitemmousedown', 'beforeitemmouseup', 'beforeitemmouseenter', 'beforeitemmouseleave', 'beforeitemclick', 'beforeitemdblclick', 'beforeitemcontextmenu', 'itemmousedown', 'itemmouseup', 'itemmouseenter', 'itemmouseleave', 'itemclick', 'itemdblclick', 'itemcontextmenu', 'beforecellclick', 'cellclick', 'beforecelldblclick', 'celldblclick', 'beforecellcontextmenu', 'cellcontextmenu', 'beforecellmousedown', 'cellmousedown', 'beforecellmouseup', 'cellmouseup', 'beforecellkeydown', 
  'cellkeydown', 'beforecontainermousedown', 'beforecontainermouseup', 'beforecontainermouseover', 'beforecontainermouseout', 'beforecontainerclick', 'beforecontainerdblclick', 'beforecontainercontextmenu', 'containermouseup', 'containermouseover', 'containermouseout', 'containerclick', 'containerdblclick', 'containercontextmenu', 'selectionchange', 'beforeselect', 'select', 'beforedeselect', 'deselect']);
  me.callParent(arguments);
  me.addStateEvents(['columnresize', 'columnmove', 'columnhide', 'columnshow', 'sortchange', 'filterchange']);
  if (!me.lockable && me.headerCt) {
    me.headerCt.on('afterlayout', me.onRestoreHorzScroll, me);
  }
}, hasLockedColumns:function(columns) {
  var i, len, column;
  if (Ext.isObject(columns)) {
    columns = columns.items;
  }
  for (i = 0, len = columns.length; i < len; i++) {
    column = columns[i];
    if (!column.processed && column.locked) {
      return true;
    }
  }
}, relayHeaderCtEvents:function(headerCt) {
  this.relayEvents(headerCt, ['columnresize', 'columnmove', 'columnhide', 'columnshow', 'columnschanged', 'sortchange', 'headerclick', 'headercontextmenu', 'headertriggerclick']);
}, getState:function() {
  var me = this, state = me.callParent(), storeState = me.store.getState();
  state = me.addPropertyToState(state, 'columns', me.headerCt.getColumnsState());
  if (storeState) {
    state.storeState = storeState;
  }
  return state;
}, applyState:function(state) {
  var me = this, sorter = state.sort, storeState = state.storeState, store = me.store, columns = state.columns;
  delete state.columns;
  me.callParent(arguments);
  if (columns) {
    me.headerCt.applyColumnsState(columns);
  }
  if (sorter) {
    if (store.remoteSort) {
      store.sort({property:sorter.property, direction:sorter.direction, root:sorter.root}, null, false);
    } else {
      store.sort(sorter.property, sorter.direction);
    }
  } else {
    if (storeState) {
      store.applyState(storeState);
    }
  }
}, getStore:function() {
  return this.store;
}, getView:function() {
  var me = this, sm;
  if (!me.view) {
    sm = me.getSelectionModel();
    Ext.widget(Ext.apply({grid:me, deferInitialRefresh:me.deferRowRender !== false, trackOver:me.trackMouseOver !== false, scroll:me.scroll, xtype:me.viewType, store:me.store, headerCt:me.headerCt, columnLines:me.columnLines, rowLines:me.rowLines, selModel:sm, features:me.features, panel:me, emptyText:me.emptyText || ''}, me.viewConfig));
    if (me.view.emptyText) {
      me.view.emptyText = '\x3cdiv class\x3d"' + me.emptyCls + '"\x3e' + me.view.emptyText + '\x3c/div\x3e';
    }
    me.view.getComponentLayout().headerCt = me.headerCt;
    me.mon(me.view, {uievent:me.processEvent, scope:me});
    sm.view = me.view;
    me.headerCt.view = me.view;
  }
  return me.view;
}, setAutoScroll:Ext.emptyFn, processEvent:function(type, view, cell, recordIndex, cellIndex, e, record, row) {
  var me = this, header;
  if (cellIndex !== -1) {
    header = me.columnManager.getColumns()[cellIndex];
    return header.processEvent.apply(header, arguments);
  }
}, determineScrollbars:function() {
  Ext.log.warn('Obsolete');
}, invalidateScroller:function() {
  Ext.log.warn('Obsolete');
}, scrollByDeltaY:function(yDelta, animate) {
  this.getView().scrollBy(0, yDelta, animate);
}, scrollByDeltaX:function(xDelta, animate) {
  this.getView().scrollBy(xDelta, 0, animate);
}, afterCollapse:function() {
  var me = this;
  me.saveScrollPos();
  me.saveScrollPos();
  me.callParent(arguments);
}, afterExpand:function() {
  var me = this;
  me.callParent(arguments);
  me.restoreScrollPos();
  me.restoreScrollPos();
}, saveScrollPos:Ext.emptyFn, restoreScrollPos:Ext.emptyFn, onHeaderResize:function() {
  this.delayScroll();
}, onHeaderMove:function(headerCt, header, colsToMove, fromIdx, toIdx) {
  var me = this;
  if (me.optimizedColumnMove === false) {
    me.view.refresh();
  } else {
    me.view.moveColumn(fromIdx, toIdx, colsToMove);
  }
  me.delayScroll();
}, onHeaderHide:function(headerCt, header) {
  this.view.refresh();
  this.delayScroll();
}, onHeaderShow:function(headerCt, header) {
  this.view.refresh();
  this.delayScroll();
}, delayScroll:function() {
  var target = this.getScrollTarget().el;
  if (target) {
    this.scrollTask.delay(10, null, null, [target.dom.scrollLeft]);
  }
}, onViewReady:function() {
  this.fireEvent('viewready', this);
}, onRestoreHorzScroll:function() {
  var left = this.scrollLeftPos;
  if (left) {
    this.syncHorizontalScroll(left, true);
  }
}, getScrollerOwner:function() {
  var rootCmp = this;
  if (!this.scrollerOwner) {
    rootCmp = this.up('[scrollerOwner]');
  }
  return rootCmp;
}, getLhsMarker:function() {
  var me = this;
  return me.lhsMarker || (me.lhsMarker = Ext.DomHelper.append(me.el, {cls:me.resizeMarkerCls}, true));
}, getRhsMarker:function() {
  var me = this;
  return me.rhsMarker || (me.rhsMarker = Ext.DomHelper.append(me.el, {cls:me.resizeMarkerCls}, true));
}, getSelectionModel:function() {
  var me = this, selModel = me.selModel, applyMode, mode, type;
  if (!selModel) {
    selModel = {};
    applyMode = true;
  }
  if (!selModel.events) {
    type = selModel.selType || me.selType;
    applyMode = !selModel.mode;
    selModel = me.selModel = Ext.create('selection.' + type, selModel);
  }
  if (me.simpleSelect) {
    mode = 'SIMPLE';
  } else {
    if (me.multiSelect) {
      mode = 'MULTI';
    }
  }
  Ext.applyIf(selModel, {allowDeselect:me.allowDeselect});
  if (mode && applyMode) {
    selModel.setSelectionMode(mode);
  }
  if (!selModel.hasRelaySetup) {
    me.relayEvents(selModel, ['selectionchange', 'beforeselect', 'beforedeselect', 'select', 'deselect']);
    selModel.hasRelaySetup = true;
  }
  if (me.disableSelection) {
    selModel.locked = true;
  }
  return selModel;
}, getScrollTarget:function() {
  var owner = this.getScrollerOwner(), items = owner.query('tableview');
  return items[1] || items[0];
}, onHorizontalScroll:function(event, target) {
  this.syncHorizontalScroll(target.scrollLeft);
}, syncHorizontalScroll:function(left, setBody) {
  var me = this, scrollTarget;
  setBody = setBody === true;
  if (me.rendered && (setBody || left !== me.scrollLeftPos)) {
    if (setBody) {
      scrollTarget = me.getScrollTarget();
      scrollTarget.el.dom.scrollLeft = left;
    }
    me.headerCt.el.dom.scrollLeft = left;
    me.scrollLeftPos = left;
  }
}, onStoreLoad:Ext.emptyFn, getEditorParent:function() {
  return this.body;
}, bindStore:function(store, initial) {
  var me = this, view = me.getView(), bufferedStore = store && store.buffered, bufferedRenderer;
  me.store = store;
  bufferedRenderer = me.findPlugin('bufferedrenderer');
  if (bufferedRenderer) {
    me.verticalScroller = bufferedRenderer;
    if (bufferedRenderer.store) {
      bufferedRenderer.bindStore(store);
    }
  } else {
    if (bufferedStore) {
      me.verticalScroller = bufferedRenderer = me.addPlugin(Ext.apply({ptype:'bufferedrenderer'}, me.initialConfig.verticalScroller));
    }
  }
  if (view.store !== store) {
    if (initial) {
      view.bindStore(store, false, 'dataSource');
    } else {
      view.bindStore(store, false);
    }
  }
  me.mon(store, {load:me.onStoreLoad, scope:me});
  me.storeRelayers = me.relayEvents(store, ['filterchange']);
  if (bufferedRenderer) {
    me.invalidateScrollerOnRefresh = false;
  }
  if (me.invalidateScrollerOnRefresh !== undefined) {
    view.preserveScrollOnRefresh = !me.invalidateScrollerOnRefresh;
  }
}, unbindStore:function() {
  var me = this, store = me.store;
  if (store) {
    me.store = null;
    me.mun(store, {load:me.onStoreLoad, scope:me});
    Ext.destroy(me.storeRelayers);
  }
}, reconfigure:function(store, columns) {
  var me = this, view = me.getView(), originalDeferinitialRefresh, oldStore = me.store, headerCt = me.headerCt, oldColumns = headerCt ? headerCt.items.getRange() : me.columns;
  if (columns) {
    columns = Ext.Array.slice(columns);
  }
  me.fireEvent('beforereconfigure', me, store, columns, oldStore, oldColumns);
  if (me.lockable) {
    me.reconfigureLockable(store, columns);
  } else {
    Ext.suspendLayouts();
    if (columns) {
      delete me.scrollLeftPos;
      headerCt.removeAll();
      headerCt.add(columns);
    }
    if (store && (store = Ext.StoreManager.lookup(store)) !== oldStore) {
      if (me.store) {
        me.unbindStore();
      }
      originalDeferinitialRefresh = view.deferInitialRefresh;
      view.deferInitialRefresh = false;
      me.bindStore(store);
      view.deferInitialRefresh = originalDeferinitialRefresh;
    } else {
      me.getView().refresh();
    }
    headerCt.setSortState();
    Ext.resumeLayouts(true);
  }
  me.fireEvent('reconfigure', me, store, columns, oldStore, oldColumns);
}, beforeDestroy:function() {
  var task = this.scrollTask;
  if (task) {
    task.cancel();
    this.scrollTask = null;
  }
  this.callParent();
}, onDestroy:function() {
  if (this.lockable) {
    this.destroyLockable();
  }
  this.callParent();
}});
Ext.define('Ext.util.CSS', function() {
  var CSS, rules = null, doc = document, camelRe = /(-[a-z])/gi, camelFn = function(m, a) {
    return a.charAt(1).toUpperCase();
  };
  return {singleton:true, rules:rules, initialized:false, constructor:function() {
    CSS = this;
  }, createStyleSheet:function(cssText, id) {
    var ss, head = doc.getElementsByTagName('head')[0], styleEl = doc.createElement('style');
    styleEl.setAttribute('type', 'text/css');
    if (id) {
      styleEl.setAttribute('id', id);
    }
    if (Ext.isIE) {
      head.appendChild(styleEl);
      ss = styleEl.styleSheet;
      ss.cssText = cssText;
    } else {
      try {
        styleEl.appendChild(doc.createTextNode(cssText));
      } catch (e$31) {
        styleEl.cssText = cssText;
      }
      head.appendChild(styleEl);
      ss = styleEl.styleSheet ? styleEl.styleSheet : styleEl.sheet || doc.styleSheets[doc.styleSheets.length - 1];
    }
    CSS.cacheStyleSheet(ss);
    return ss;
  }, removeStyleSheet:function(id) {
    var existing = doc.getElementById(id);
    if (existing) {
      existing.parentNode.removeChild(existing);
    }
  }, swapStyleSheet:function(id, url) {
    var ss;
    CSS.removeStyleSheet(id);
    ss = doc.createElement('link');
    ss.setAttribute('rel', 'stylesheet');
    ss.setAttribute('type', 'text/css');
    ss.setAttribute('id', id);
    ss.setAttribute('href', url);
    doc.getElementsByTagName('head')[0].appendChild(ss);
  }, refreshCache:function() {
    return CSS.getRules(true);
  }, cacheStyleSheet:function(ss) {
    if (!rules) {
      rules = CSS.rules = {};
    }
    try {
      var ssRules = ss.cssRules || ss.rules, i = ssRules.length - 1, imports = ss.imports, len = imports ? imports.length : 0, rule, j;
      for (j = 0; j < len; ++j) {
        CSS.cacheStyleSheet(imports[j]);
      }
      for (; i >= 0; --i) {
        rule = ssRules[i];
        if (rule.styleSheet) {
          CSS.cacheStyleSheet(rule.styleSheet);
        }
        CSS.cacheRule(rule, ss);
      }
    } catch (e$32) {
    }
  }, cacheRule:function(cssRule, styleSheet) {
    if (cssRule.styleSheet) {
      return CSS.cacheStyleSheet(cssRule.styleSheet);
    }
    var selectorText = cssRule.selectorText, selectorCount, j;
    if (selectorText) {
      selectorText = selectorText.split(',');
      selectorCount = selectorText.length;
      for (j = 0; j < selectorCount; j++) {
        rules[Ext.String.trim(selectorText[j]).toLowerCase()] = {parentStyleSheet:styleSheet, cssRule:cssRule};
      }
    }
  }, getRules:function(refreshCache) {
    var result = {}, selector;
    if (rules === null || refreshCache) {
      CSS.refreshCache();
    }
    for (selector in rules) {
      result[selector] = rules[selector].cssRule;
    }
    return result;
  }, refreshCache:function() {
    var ds = doc.styleSheets, i = 0, len = ds.length;
    rules = CSS.rules = {};
    for (; i < len; i++) {
      try {
        if (!ds[i].disabled) {
          CSS.cacheStyleSheet(ds[i]);
        }
      } catch (e$33) {
      }
    }
  }, getRule:function(selector, refreshCache, rawCache) {
    var i, result;
    if (!rules || refreshCache) {
      CSS.refreshCache();
    }
    if (!Ext.isArray(selector)) {
      result = rules[selector.toLowerCase()];
      if (result && !rawCache) {
        result = result.cssRule;
      }
      return result || null;
    }
    for (i = 0; i < selector.length; i++) {
      if (rules[selector[i]]) {
        return rawCache ? rules[selector[i].toLowerCase()] : rules[selector[i].toLowerCase()].cssRule;
      }
    }
    return null;
  }, createRule:function(styleSheet, selector, cssText) {
    var result, ruleSet = styleSheet.cssRules || styleSheet.rules, index = ruleSet.length;
    if (styleSheet.insertRule) {
      styleSheet.insertRule(selector + '{' + cssText + '}', index);
    } else {
      styleSheet.addRule(selector, cssText || ' ');
    }
    CSS.cacheRule(result = ruleSet[index], styleSheet);
    return result;
  }, updateRule:function(selector, property, value) {
    var rule, i, styles;
    if (!Ext.isArray(selector)) {
      rule = CSS.getRule(selector);
      if (rule) {
        if (arguments.length == 2) {
          styles = Ext.Element.parseStyles(property);
          for (property in styles) {
            rule.style[property.replace(camelRe, camelFn)] = styles[property];
          }
        } else {
          rule.style[property.replace(camelRe, camelFn)] = value;
        }
        return true;
      }
    } else {
      for (i = 0; i < selector.length; i++) {
        if (CSS.updateRule(selector[i], property, value)) {
          return true;
        }
      }
    }
    return false;
  }, deleteRule:function(selector) {
    var rule = CSS.getRule(selector, false, true), styleSheet, index;
    if (rule) {
      styleSheet = rule.parentStyleSheet;
      index = Ext.Array.indexOf(styleSheet.cssRules || styleSheet.rules, rule.cssRule);
      if (styleSheet.deleteRule) {
        styleSheet.deleteRule(index);
      } else {
        styleSheet.removeRule(index);
      }
      delete rules[selector];
    }
  }};
});
Ext.define('Ext.view.TableLayout', {extend:Ext.layout.component.Auto, alias:['layout.tableview'], type:'tableview', beginLayout:function(ownerContext) {
  var me = this, otherSide = me.owner.lockingPartner, owner = me.owner;
  me.callParent(arguments);
  if (otherSide) {
    me.lockedGrid = me.owner.up('[lockable]');
    me.lockedGrid.needsRowHeightSync = true;
    if (!ownerContext.lockingPartner) {
      ownerContext.lockingPartner = ownerContext.context.getItem(otherSide, otherSide.el);
      if (ownerContext.lockingPartner && !ownerContext.lockingPartner.lockingPartner) {
        ownerContext.lockingPartner.lockingPartner = ownerContext;
      }
    }
  }
  ownerContext.headerContext = ownerContext.context.getCmp(me.headerCt);
  if (me.owner.body.dom) {
    ownerContext.bodyContext = ownerContext.getEl(me.owner.body);
  }
  if (Ext.isWebKit) {
    owner.el.select(owner.getBodySelector()).setStyle('table-layout', 'auto');
  }
}, calculate:function(ownerContext) {
  var me = this, lockingPartner = me.lockingPartner, owner = me.owner, contentHeight = 0, emptyEl;
  if (ownerContext.headerContext.hasProp('columnWidthsDone')) {
    if (!me.setColumnWidths(ownerContext)) {
      me.done = false;
      return;
    }
    ownerContext.state.columnWidthsSynced = true;
    if (ownerContext.bodyContext) {
      emptyEl = me.owner.el.down('.' + owner.ownerCt.emptyCls, true);
      if (!emptyEl) {
        contentHeight = ownerContext.bodyContext.el.dom.offsetHeight;
        ownerContext.bodyContext.setHeight(contentHeight, false);
      } else {
        contentHeight = emptyEl.offsetHeight;
      }
      ownerContext.setProp('contentHeight', contentHeight);
    }
    if (lockingPartner && !lockingPartner.state.columnWidthsSynced) {
      me.done = false;
    } else {
      me.callParent(arguments);
    }
  } else {
    me.done = false;
  }
}, measureContentHeight:function(ownerContext) {
  var lockingPartner = ownerContext.lockingPartner;
  if (!ownerContext.bodyContext || ownerContext.state.columnWidthsSynced && (!lockingPartner || lockingPartner.state.columnWidthsSynced)) {
    return this.callParent(arguments);
  }
}, setColumnWidths:function(ownerContext) {
  var me = this, owner = me.owner, context = ownerContext.context, columns = me.headerCt.getVisibleGridColumns(), column, i = 0, len = columns.length, tableWidth = 0, columnLineWidth = 0, childContext, colWidth, isContentBox = !Ext.isBorderBox;
  if (context) {
    context.currentLayout = me;
  }
  for (i = 0; i < len; i++) {
    column = columns[i];
    childContext = context.getCmp(column);
    colWidth = childContext.props.width;
    if (isNaN(colWidth)) {
      childContext.getProp('width');
      return false;
    }
    tableWidth += colWidth;
    if (isContentBox && owner.columnLines) {
      if (!columnLineWidth) {
        columnLineWidth = context.getCmp(column).borderInfo.width || 1;
      }
      colWidth -= columnLineWidth;
    }
    owner.body.select(owner.getColumnSizerSelector(column)).setWidth(colWidth);
  }
  owner.el.select(owner.getBodySelector()).setWidth(tableWidth);
  return true;
}, finishedLayout:function() {
  var me = this, owner = me.owner;
  me.callParent(arguments);
  if (Ext.isWebKit) {
    owner.el.select(owner.getBodySelector()).setStyle('table-layout', '');
  }
  if (owner.refreshCounter && me.lockedGrid && me.lockedGrid.syncRowHeight && me.lockedGrid.needsRowHeightSync) {
    me.lockedGrid.syncRowHeights();
    me.lockedGrid.needsRowHeightSync = false;
  }
}});
Ext.define('Ext.view.NodeCache', {constructor:function(view) {
  this.view = view;
  this.clear();
  this.el = new Ext.dom.AbstractElement.Fly;
}, clear:function(removeDom) {
  var me = this, elements = this.elements, i, el;
  if (removeDom) {
    for (i in elements) {
      el = elements[i];
      el.parentNode.removeChild(el);
    }
  }
  me.elements = {};
  me.count = me.startIndex = 0;
  me.endIndex = -1;
}, fill:function(newElements, startIndex) {
  var me = this, elements = me.elements = {}, i, len = newElements.length;
  if (!startIndex) {
    startIndex = 0;
  }
  for (i = 0; i < len; i++) {
    elements[startIndex + i] = newElements[i];
  }
  me.startIndex = startIndex;
  me.endIndex = startIndex + len - 1;
  me.count = len;
  return this;
}, insert:function(insertPoint, nodes) {
  var me = this, elements = me.elements, i, nodeCount = nodes.length;
  if (me.count) {
    if (insertPoint > me.endIndex + 1 || insertPoint + nodes.length - 1 < me.startIndex) {
      Ext.Error.raise('Discontiguous range would result from inserting ' + nodes.length + ' nodes at ' + insertPoint);
    }
    if (insertPoint < me.count) {
      for (i = me.endIndex + nodeCount; i >= insertPoint + nodeCount; i--) {
        elements[i] = elements[i - nodeCount];
        elements[i].setAttribute('data-recordIndex', i);
      }
    }
    me.endIndex = me.endIndex + nodeCount;
  } else {
    me.startIndex = insertPoint;
    me.endIndex = insertPoint + nodeCount - 1;
  }
  for (i = 0; i < nodeCount; i++, insertPoint++) {
    elements[insertPoint] = nodes[i];
    elements[insertPoint].setAttribute('data-recordIndex', insertPoint);
  }
  me.count += nodeCount;
}, item:function(index, asDom) {
  var el = this.elements[index], result = null;
  if (el) {
    result = asDom ? this.elements[index] : this.el.attach(this.elements[index]);
  }
  return result;
}, first:function(asDom) {
  return this.item(this.startIndex, asDom);
}, last:function(asDom) {
  return this.item(this.endIndex, asDom);
}, getCount:function() {
  return this.count;
}, slice:function(start, end) {
  var elements = this.elements, result = [], i;
  if (arguments.length < 2) {
    end = this.endIndex;
  } else {
    end = Math.min(this.endIndex, end - 1);
  }
  for (i = start || this.startIndex; i <= end; i++) {
    result.push(elements[i]);
  }
  return result;
}, replaceElement:function(el, replacement, domReplace) {
  var elements = this.elements, index = typeof el === 'number' ? el : this.indexOf(el);
  if (index > -1) {
    replacement = Ext.getDom(replacement);
    if (domReplace) {
      el = elements[index];
      el.parentNode.insertBefore(replacement, el);
      Ext.removeNode(el);
      replacement.setAttribute('data-recordIndex', index);
    }
    this.elements[index] = replacement;
  }
  return this;
}, indexOf:function(el) {
  var elements = this.elements, index;
  el = Ext.getDom(el);
  for (index = this.startIndex; index <= this.endIndex; index++) {
    if (elements[index] === el) {
      return index;
    }
  }
  return -1;
}, removeRange:function(start, end, removeDom) {
  var me = this, elements = me.elements, el, i, removeCount, fromPos;
  if (end === undefined) {
    end = me.count;
  } else {
    end = Math.min(me.endIndex + 1, end + 1);
  }
  if (!start) {
    start = 0;
  }
  removeCount = end - start;
  for (i = start, fromPos = end; i < me.endIndex; i++, fromPos++) {
    if (removeDom && i < end) {
      Ext.removeNode(elements[i]);
    }
    if (fromPos <= me.endIndex) {
      el = elements[i] = elements[fromPos];
      el.setAttribute('data-recordIndex', i);
    } else {
      delete elements[i];
    }
  }
  me.count -= removeCount;
  me.endIndex -= removeCount;
}, removeElement:function(keys, removeDom) {
  var me = this, inKeys, key, elements = me.elements, el, deleteCount, keyIndex = 0, index, fromIndex;
  if (Ext.isArray(keys)) {
    inKeys = keys;
    keys = [];
    deleteCount = inKeys.length;
    for (keyIndex = 0; keyIndex < deleteCount; keyIndex++) {
      key = inKeys[keyIndex];
      if (typeof key !== 'number') {
        key = me.indexOf(key);
      }
      if (key >= me.startIndex && key <= me.endIndex) {
        keys[keys.length] = key;
      }
    }
    Ext.Array.sort(keys);
    deleteCount = keys.length;
  } else {
    if (keys < me.startIndex || keys > me.endIndex) {
      return;
    }
    deleteCount = 1;
    keys = [keys];
  }
  for (index = fromIndex = keys[0], keyIndex = 0; index <= me.endIndex; index++, fromIndex++) {
    if (keyIndex < deleteCount && index === keys[keyIndex]) {
      fromIndex++;
      keyIndex++;
      if (removeDom) {
        Ext.removeNode(elements[index]);
      }
    }
    if (fromIndex <= me.endIndex && fromIndex >= me.startIndex) {
      el = elements[index] = elements[fromIndex];
      el.setAttribute('data-recordIndex', index);
    } else {
      delete elements[index];
    }
  }
  me.endIndex -= deleteCount;
  me.count -= deleteCount;
}, scroll:function(newRecords, direction, removeCount) {
  var me = this, elements = me.elements, recCount = newRecords.length, i, el, removeEnd, newNodes, nodeContainer = me.view.getNodeContainer(), frag = document.createDocumentFragment();
  if (direction == -1) {
    for (i = me.endIndex - removeCount + 1; i <= me.endIndex; i++) {
      el = elements[i];
      delete elements[i];
      el.parentNode.removeChild(el);
    }
    me.endIndex -= removeCount;
    newNodes = me.view.bufferRender(newRecords, me.startIndex -= recCount);
    for (i = 0; i < recCount; i++) {
      elements[me.startIndex + i] = newNodes[i];
      frag.appendChild(newNodes[i]);
    }
    nodeContainer.insertBefore(frag, nodeContainer.firstChild);
  } else {
    removeEnd = me.startIndex + removeCount;
    for (i = me.startIndex; i < removeEnd; i++) {
      el = elements[i];
      delete elements[i];
      el.parentNode.removeChild(el);
    }
    me.startIndex = i;
    newNodes = me.view.bufferRender(newRecords, me.endIndex + 1);
    for (i = 0; i < recCount; i++) {
      elements[me.endIndex += 1] = newNodes[i];
      frag.appendChild(newNodes[i]);
    }
    nodeContainer.appendChild(frag);
  }
  me.count = me.endIndex - me.startIndex + 1;
}});
Ext.define('Ext.view.Table', {extend:Ext.view.View, alias:'widget.tableview', componentLayout:'tableview', baseCls:Ext.baseCSSPrefix + 'grid-view', firstCls:Ext.baseCSSPrefix + 'grid-cell-first', lastCls:Ext.baseCSSPrefix + 'grid-cell-last', headerRowSelector:'tr.' + Ext.baseCSSPrefix + 'grid-header-row', selectedItemCls:Ext.baseCSSPrefix + 'grid-row-selected', beforeSelectedItemCls:Ext.baseCSSPrefix + 'grid-row-before-selected', selectedCellCls:Ext.baseCSSPrefix + 'grid-cell-selected', focusedItemCls:Ext.baseCSSPrefix + 
'grid-row-focused', beforeFocusedItemCls:Ext.baseCSSPrefix + 'grid-row-before-focused', tableFocusedFirstCls:Ext.baseCSSPrefix + 'grid-table-focused-first', tableSelectedFirstCls:Ext.baseCSSPrefix + 'grid-table-selected-first', tableOverFirstCls:Ext.baseCSSPrefix + 'grid-table-over-first', overItemCls:Ext.baseCSSPrefix + 'grid-row-over', beforeOverItemCls:Ext.baseCSSPrefix + 'grid-row-before-over', altRowCls:Ext.baseCSSPrefix + 'grid-row-alt', dirtyCls:Ext.baseCSSPrefix + 'grid-dirty-cell', rowClsRe:new RegExp('(?:^|\\s*)' + 
Ext.baseCSSPrefix + 'grid-row-(first|last|alt)(?:\\s+|$)', 'g'), cellRe:new RegExp(Ext.baseCSSPrefix + 'grid-cell-([^\\s]+) ', ''), positionBody:true, trackOver:true, getRowClass:null, stripeRows:true, markDirty:true, tpl:'{%values.view.tableTpl.applyOut(values, out)%}', tableTpl:['{%', 'var view\x3dvalues.view,tableCls\x3d["' + Ext.baseCSSPrefix + '" + view.id + "-table ' + Ext.baseCSSPrefix + 'grid-table"];', 'if (view.columnLines) tableCls[tableCls.length]\x3dview.ownerCt.colLinesCls;', 'if (view.rowLines) tableCls[tableCls.length]\x3dview.ownerCt.rowLinesCls;', 
'%}', '\x3ctable role\x3d"presentation" id\x3d"{view.id}-table" class\x3d"{[tableCls.join(" ")]}" border\x3d"0" cellspacing\x3d"0" cellpadding\x3d"0" style\x3d"{tableStyle}" tabIndex\x3d"-1"\x3e', '{[view.renderColumnSizer(out)]}', '{[view.renderTHead(values, out)]}', '{[view.renderTFoot(values, out)]}', '\x3ctbody id\x3d"{view.id}-body"\x3e', '{%', 'view.renderRows(values.rows, values.viewStartIndex, out);', '%}', '\x3c/tbody\x3e', '\x3c/table\x3e', {priority:0}], rowTpl:['{%', 'var dataRowCls \x3d values.recordIndex \x3d\x3d\x3d -1 ? "" : " ' + 
Ext.baseCSSPrefix + 'grid-data-row";', '%}', '\x3ctr role\x3d"row" {[values.rowId ? ("id\x3d\\"" + values.rowId + "\\"") : ""]} ', 'data-boundView\x3d"{view.id}" ', 'data-recordId\x3d"{record.internalId}" ', 'data-recordIndex\x3d"{recordIndex}" ', 'class\x3d"{[values.itemClasses.join(" ")]} {[values.rowClasses.join(" ")]}{[dataRowCls]}" ', '{rowAttr:attributes} tabIndex\x3d"-1"\x3e', '\x3ctpl for\x3d"columns"\x3e' + '{%', 'parent.view.renderCell(values, parent.record, parent.recordIndex, xindex - 1, out, parent)', 
'%}', '\x3c/tpl\x3e', '\x3c/tr\x3e', {priority:0}], cellTpl:['\x3ctd role\x3d"gridcell" class\x3d"{tdCls}" {tdAttr} id\x3d"{[Ext.id()]}"\x3e', '\x3cdiv {unselectableAttr} class\x3d"' + Ext.baseCSSPrefix + 'grid-cell-inner {innerCls}"', 'style\x3d"text-align:{align};\x3ctpl if\x3d"style"\x3e{style}\x3c/tpl\x3e"\x3e{value}\x3c/div\x3e', '\x3c/td\x3e', {priority:0}], refreshSelmodelOnRefresh:false, tableValues:{}, rowValues:{itemClasses:[], rowClasses:[]}, cellValues:{classes:[Ext.baseCSSPrefix + 'grid-cell ' + 
Ext.baseCSSPrefix + 'grid-td']}, renderBuffer:document.createElement('div'), constructor:function(config) {
  if (config.grid.isTree) {
    config.baseCls = Ext.baseCSSPrefix + 'tree-view';
  }
  this.callParent([config]);
}, initComponent:function() {
  var me = this, scroll = me.scroll;
  this.addEvents('beforecellclick', 'cellclick', 'beforecelldblclick', 'celldblclick', 'beforecellcontextmenu', 'cellcontextmenu', 'beforecellmousedown', 'cellmousedown', 'beforecellmouseup', 'cellmouseup', 'beforecellkeydown', 'cellkeydown');
  me.body = new Ext.dom.Element.Fly;
  me.body.id = me.id + 'gridBody';
  me.autoScroll = undefined;
  if (!me.trackOver) {
    me.overItemCls = null;
    me.beforeOverItemCls = null;
  }
  if (scroll === true || scroll === 'both') {
    me.autoScroll = true;
  } else {
    if (scroll === 'horizontal') {
      me.overflowX = 'auto';
    } else {
      if (scroll === 'vertical') {
        me.overflowY = 'auto';
      }
    }
  }
  me.selModel.view = me;
  me.headerCt.view = me;
  me.grid.view = me;
  me.initFeatures(me.grid);
  delete me.grid;
  me.tpl = me.getTpl('tpl');
  me.itemSelector = me.getItemSelector();
  me.all = new Ext.view.NodeCache(me);
  me.callParent();
}, moveColumn:function(fromIdx, toIdx, colsToMove) {
  var me = this, fragment = colsToMove > 1 ? document.createDocumentFragment() : undefined, destinationCellIdx = toIdx, colCount = me.getGridColumns().length, lastIndex = colCount - 1, doFirstLastClasses = (me.firstCls || me.lastCls) && (toIdx === 0 || toIdx == colCount || fromIdx === 0 || fromIdx == lastIndex), i, j, rows, len, tr, cells, tables;
  if (me.rendered && toIdx !== fromIdx) {
    rows = me.el.query(me.getDataRowSelector());
    if (toIdx > fromIdx && fragment) {
      destinationCellIdx -= colsToMove;
    }
    for (i = 0, len = rows.length; i < len; i++) {
      tr = rows[i];
      cells = tr.childNodes;
      if (doFirstLastClasses) {
        if (cells.length === 1) {
          Ext.fly(cells[0]).addCls(me.firstCls);
          Ext.fly(cells[0]).addCls(me.lastCls);
          continue;
        }
        if (fromIdx === 0) {
          Ext.fly(cells[0]).removeCls(me.firstCls);
          Ext.fly(cells[1]).addCls(me.firstCls);
        } else {
          if (fromIdx === lastIndex) {
            Ext.fly(cells[lastIndex]).removeCls(me.lastCls);
            Ext.fly(cells[lastIndex - 1]).addCls(me.lastCls);
          }
        }
        if (toIdx === 0) {
          Ext.fly(cells[0]).removeCls(me.firstCls);
          Ext.fly(cells[fromIdx]).addCls(me.firstCls);
        } else {
          if (toIdx === colCount) {
            Ext.fly(cells[lastIndex]).removeCls(me.lastCls);
            Ext.fly(cells[fromIdx]).addCls(me.lastCls);
          }
        }
      }
      if (fragment) {
        for (j = 0; j < colsToMove; j++) {
          fragment.appendChild(cells[fromIdx]);
        }
        tr.insertBefore(fragment, cells[destinationCellIdx] || null);
      } else {
        tr.insertBefore(cells[fromIdx], cells[destinationCellIdx] || null);
      }
    }
    tables = me.el.query(me.getBodySelector());
    for (i = 0, len = tables.length; i < len; i++) {
      tr = tables[i];
      if (fragment) {
        for (j = 0; j < colsToMove; j++) {
          fragment.appendChild(tr.childNodes[fromIdx]);
        }
        tr.insertBefore(fragment, tr.childNodes[destinationCellIdx] || null);
      } else {
        tr.insertBefore(tr.childNodes[fromIdx], tr.childNodes[destinationCellIdx] || null);
      }
    }
  }
}, scrollToTop:Ext.emptyFn, addElListener:function(eventName, fn, scope) {
  this.mon(this, eventName, fn, scope, {element:'el'});
}, getGridColumns:function() {
  return this.ownerCt.columnManager.getColumns();
}, getHeaderAtIndex:function(index) {
  return this.ownerCt.columnManager.getHeaderAtIndex(index);
}, getCell:function(record, column) {
  var row = this.getNode(record, true);
  return Ext.fly(row).down(column.getCellSelector());
}, getFeature:function(id) {
  var features = this.featuresMC;
  if (features) {
    return features.get(id);
  }
}, findFeature:function(ftype) {
  if (this.features) {
    return Ext.Array.findBy(this.features, function(feature) {
      if (feature.ftype === ftype) {
        return true;
      }
    });
  }
}, initFeatures:function(grid) {
  var me = this, i, features, feature, len;
  me.tableTpl = Ext.XTemplate.getTpl(this, 'tableTpl');
  me.rowTpl = Ext.XTemplate.getTpl(this, 'rowTpl');
  me.cellTpl = Ext.XTemplate.getTpl(this, 'cellTpl');
  me.featuresMC = new Ext.util.MixedCollection;
  features = me.features = me.constructFeatures();
  len = features ? features.length : 0;
  for (i = 0; i < len; i++) {
    feature = features[i];
    feature.view = me;
    feature.grid = grid;
    me.featuresMC.add(feature);
    feature.init(grid);
  }
}, renderTHead:function(values, out) {
  var headers = values.view.headerFns, len, i;
  if (headers) {
    for (i = 0, len = headers.length; i < len; ++i) {
      headers[i].call(this, values, out);
    }
  }
}, addHeaderFn:function() {
  var headers = this.headerFns;
  if (!headers) {
    headers = this.headerFns = [];
  }
  headers.push(fn);
}, renderTFoot:function(values, out) {
  var footers = values.view.footerFns, len, i;
  if (footers) {
    for (i = 0, len = footers.length; i < len; ++i) {
      footers[i].call(this, values, out);
    }
  }
}, addFooterFn:function(fn) {
  var footers = this.footerFns;
  if (!footers) {
    footers = this.footerFns = [];
  }
  footers.push(fn);
}, addTableTpl:function(newTpl) {
  return this.addTpl('tableTpl', newTpl);
}, addRowTpl:function(newTpl) {
  return this.addTpl('rowTpl', newTpl);
}, addCellTpl:function(newTpl) {
  return this.addTpl('cellTpl', newTpl);
}, addTpl:function(which, newTpl) {
  var me = this, tpl, prevTpl;
  newTpl = Ext.Object.chain(newTpl);
  if (!newTpl.isTemplate) {
    newTpl.applyOut = me.tplApplyOut;
  }
  for (tpl = me[which]; newTpl.priority < tpl.priority; tpl = tpl.nextTpl) {
    prevTpl = tpl;
  }
  if (prevTpl) {
    prevTpl.nextTpl = newTpl;
  } else {
    me[which] = newTpl;
  }
  newTpl.nextTpl = tpl;
  return newTpl;
}, tplApplyOut:function(values, out) {
  if (this.before) {
    if (this.before(values, out) === false) {
      return;
    }
  }
  this.nextTpl.applyOut(values, out);
  if (this.after) {
    this.after(values, out);
  }
}, constructFeatures:function() {
  var me = this, features = me.features, feature, result, i = 0, len;
  if (features) {
    result = [];
    len = features.length;
    for (; i < len; i++) {
      feature = features[i];
      if (!feature.isFeature) {
        feature = Ext.create('feature.' + feature.ftype, feature);
      }
      result[i] = feature;
    }
  }
  return result;
}, beforeRender:function() {
  var me = this;
  me.callParent();
  if (!me.enableTextSelection) {
    me.protoEl.unselectable();
  }
}, onViewScroll:function(e, t) {
  this.callParent(arguments);
  this.fireEvent('bodyscroll', e, t);
}, createRowElement:function(record, index) {
  var me = this, div = me.renderBuffer;
  me.tpl.overwrite(div, me.collectData([record], index));
  return Ext.fly(div).down(me.getNodeContainerSelector(), true).firstChild;
}, bufferRender:function(records, index) {
  var me = this, div = me.renderBuffer;
  me.tpl.overwrite(div, me.collectData(records, index));
  return Ext.Array.toArray(Ext.fly(div).down(me.getNodeContainerSelector(), true).childNodes);
}, collectData:function(records, startIndex) {
  this.rowValues.view = this;
  return {view:this, rows:records, viewStartIndex:startIndex, tableStyle:this.bufferedRenderer ? 'position:absolute;top:' + this.bufferedRenderer.bodyTop : ''};
}, collectNodes:function(targetEl) {
  this.all.fill(this.getNodeContainer().childNodes, this.all.startIndex);
}, refreshSize:function() {
  var me = this, grid, bodySelector = me.getBodySelector();
  if (bodySelector) {
    me.body.attach(me.el.child(bodySelector, true));
  }
  if (!me.hasLoadingHeight) {
    grid = me.up('tablepanel');
    Ext.suspendLayouts();
    me.callParent();
    grid.updateLayout();
    Ext.resumeLayouts(true);
  }
}, statics:{getBoundView:function(node) {
  return Ext.getCmp(node.getAttribute('data-boundView'));
}}, getRecord:function(node) {
  node = this.getNode(node);
  if (node) {
    var recordIndex = node.getAttribute('data-recordIndex');
    if (recordIndex) {
      recordIndex = parseInt(recordIndex, 10);
      if (recordIndex > -1) {
        return this.store.data.getAt(recordIndex);
      }
    }
    return this.dataSource.data.get(node.getAttribute('data-recordId'));
  }
}, indexOf:function(node) {
  node = this.getNode(node, false);
  if (!node && node !== 0) {
    return -1;
  }
  return this.all.indexOf(node);
}, indexInStore:function(node) {
  node = this.getNode(node, true);
  if (!node && node !== 0) {
    return -1;
  }
  var recordIndex = node.getAttribute('data-recordIndex');
  if (recordIndex) {
    return parseInt(recordIndex, 10);
  }
  return this.dataSource.indexOf(this.getRecord(node));
}, renderRows:function(rows, viewStartIndex, out) {
  var rowValues = this.rowValues, rowCount = rows.length, i;
  rowValues.view = this;
  rowValues.columns = this.ownerCt.columnManager.getColumns();
  for (i = 0; i < rowCount; i++, viewStartIndex++) {
    rowValues.itemClasses.length = rowValues.rowClasses.length = 0;
    this.renderRow(rows[i], viewStartIndex, out);
  }
  rowValues.view = rowValues.columns = rowValues.record = null;
}, renderColumnSizer:function(out) {
  var columns = this.getGridColumns(), len = columns.length, i, column, width;
  for (i = 0; i < len; i++) {
    column = columns[i];
    width = column.hidden ? 0 : column.lastBox ? column.lastBox.width : Ext.grid.header.Container.prototype.defaultWidth;
    out.push('\x3ccolgroup\x3e\x3ccol class\x3d"', Ext.baseCSSPrefix, 'grid-cell-', columns[i].getItemId(), '" style\x3d"width:' + width + 'px"\x3e\x3c/colgroup\x3e');
  }
}, renderRow:function(record, rowIdx, out) {
  var me = this, isMetadataRecord = rowIdx === -1, selModel = me.selModel, rowValues = me.rowValues, itemClasses = rowValues.itemClasses, rowClasses = rowValues.rowClasses, cls, rowTpl = me.rowTpl;
  rowValues.record = record;
  rowValues.recordId = record.internalId;
  rowValues.recordIndex = rowIdx;
  rowValues.rowId = me.getRowId(record);
  rowValues.itemCls = rowValues.rowCls = '';
  if (!rowValues.columns) {
    rowValues.columns = me.ownerCt.columnManager.getColumns();
  }
  itemClasses.length = rowClasses.length = 0;
  if (!isMetadataRecord) {
    itemClasses[0] = Ext.baseCSSPrefix + 'grid-row';
    if (selModel && selModel.isRowSelected) {
      if (selModel.isRowSelected(rowIdx + 1)) {
        itemClasses.push(me.beforeSelectedItemCls);
      }
      if (selModel.isRowSelected(record)) {
        itemClasses.push(me.selectedItemCls);
      }
    }
    if (me.stripeRows && rowIdx % 2 !== 0) {
      rowClasses.push(me.altRowCls);
    }
    if (me.getRowClass) {
      cls = me.getRowClass(record, rowIdx, null, me.dataSource);
      if (cls) {
        rowClasses.push(cls);
      }
    }
  }
  if (out) {
    rowTpl.applyOut(rowValues, out);
  } else {
    return rowTpl.apply(rowValues);
  }
}, renderCell:function(column, record, recordIndex, columnIndex, out) {
  var me = this, selModel = me.selModel, cellValues = me.cellValues, classes = cellValues.classes, fieldValue = record.data[column.dataIndex], cellTpl = me.cellTpl, value, clsInsertPoint;
  cellValues.record = record;
  cellValues.column = column;
  cellValues.recordIndex = recordIndex;
  cellValues.columnIndex = columnIndex;
  cellValues.cellIndex = columnIndex;
  cellValues.align = column.align;
  cellValues.tdCls = column.tdCls;
  cellValues.innerCls = column.innerCls;
  cellValues.style = cellValues.tdAttr = '';
  cellValues.unselectableAttr = me.enableTextSelection ? '' : 'unselectable\x3d"on"';
  if (column.renderer && column.renderer.call) {
    value = column.renderer.call(column.scope || me.ownerCt, fieldValue, cellValues, record, recordIndex, columnIndex, me.dataSource, me);
    if (cellValues.css) {
      record.cssWarning = true;
      cellValues.tdCls += ' ' + cellValues.css;
      delete cellValues.css;
    }
  } else {
    value = fieldValue;
  }
  cellValues.value = value == null || value === '' ? '\x26#160;' : value;
  classes[1] = Ext.baseCSSPrefix + 'grid-cell-' + column.getItemId();
  clsInsertPoint = 2;
  if (column.tdCls) {
    classes[clsInsertPoint++] = column.tdCls;
  }
  if (me.markDirty && record.isModified(column.dataIndex)) {
    classes[clsInsertPoint++] = me.dirtyCls;
  }
  if (column.isFirstVisible) {
    classes[clsInsertPoint++] = me.firstCls;
  }
  if (column.isLastVisible) {
    classes[clsInsertPoint++] = me.lastCls;
  }
  if (!me.enableTextSelection) {
    classes[clsInsertPoint++] = Ext.baseCSSPrefix + 'unselectable';
  }
  classes[clsInsertPoint++] = cellValues.tdCls;
  if (selModel && selModel.isCellSelected && selModel.isCellSelected(me, recordIndex, columnIndex)) {
    classes[clsInsertPoint++] = me.selectedCellCls;
  }
  classes.length = clsInsertPoint;
  cellValues.tdCls = classes.join(' ');
  cellTpl.applyOut(cellValues, out);
  cellValues.column = null;
}, getNode:function(nodeInfo, dataRow) {
  var fly, result = this.callParent(arguments);
  if (result && result.tagName) {
    if (dataRow) {
      if (!(fly = Ext.fly(result)).is(this.dataRowSelector)) {
        return fly.down(this.dataRowSelector, true);
      }
    } else {
      if (dataRow === false) {
        if (!(fly = Ext.fly(result)).is(this.itemSelector)) {
          return fly.up(this.itemSelector, null, true);
        }
      }
    }
  }
  return result;
}, getRowId:function(record) {
  return this.id + '-record-' + record.internalId;
}, constructRowId:function(internalId) {
  return this.id + '-record-' + internalId;
}, getNodeById:function(id, dataRow) {
  id = this.constructRowId(id);
  return this.retrieveNode(id, dataRow);
}, getNodeByRecord:function(record, dataRow) {
  var id = this.getRowId(record);
  return this.retrieveNode(id, dataRow);
}, retrieveNode:function(id, dataRow) {
  var result = this.el.getById(id, true), itemSelector = this.itemSelector, fly;
  if (dataRow === false && result) {
    if (!(fly = Ext.fly(result)).is(itemSelector)) {
      return fly.up(itemSelector, null, true);
    }
  }
  return result;
}, updateIndexes:Ext.emptyFn, bodySelector:'table', nodeContainerSelector:'tbody', itemSelector:'tr.' + Ext.baseCSSPrefix + 'grid-row', dataRowSelector:'tr.' + Ext.baseCSSPrefix + 'grid-data-row', cellSelector:'td.' + Ext.baseCSSPrefix + 'grid-cell', sizerSelector:'col.' + Ext.baseCSSPrefix + 'grid-cell', innerSelector:'div.' + Ext.baseCSSPrefix + 'grid-cell-inner', getNodeContainer:function() {
  return this.el.down(this.nodeContainerSelector, true);
}, getBodySelector:function() {
  return this.bodySelector + '.' + Ext.baseCSSPrefix + this.id + '-table';
}, getNodeContainerSelector:function() {
  return this.nodeContainerSelector;
}, getColumnSizerSelector:function(header) {
  return this.sizerSelector + '-' + header.getItemId();
}, getItemSelector:function() {
  return this.itemSelector;
}, getDataRowSelector:function() {
  return this.dataRowSelector;
}, getCellSelector:function(header) {
  var result = this.cellSelector;
  if (header) {
    result += '-' + header.getItemId();
  }
  return result;
}, getCellInnerSelector:function(header) {
  return this.getCellSelector(header) + ' ' + this.innerSelector;
}, addRowCls:function(rowInfo, cls) {
  var row = this.getNode(rowInfo, false);
  if (row) {
    Ext.fly(row).addCls(cls);
  }
}, removeRowCls:function(rowInfo, cls) {
  var row = this.getNode(rowInfo, false);
  if (row) {
    Ext.fly(row).removeCls(cls);
  }
}, setHighlightedItem:function(item) {
  var me = this, highlighted = me.highlightedItem;
  if (highlighted && me.el.isAncestor(highlighted) && me.isRowStyleFirst(highlighted)) {
    me.getRowStyleTableEl(highlighted).removeCls(me.tableOverFirstCls);
  }
  if (item && me.isRowStyleFirst(item)) {
    me.getRowStyleTableEl(item).addCls(me.tableOverFirstCls);
  }
  me.callParent(arguments);
}, onRowSelect:function(rowIdx) {
  var me = this;
  me.addRowCls(rowIdx, me.selectedItemCls);
  if (me.isRowStyleFirst(rowIdx)) {
    me.getRowStyleTableEl(rowIdx).addCls(me.tableSelectedFirstCls);
  } else {
    me.addRowCls(rowIdx - 1, me.beforeSelectedItemCls);
  }
}, onRowDeselect:function(rowIdx) {
  var me = this;
  me.removeRowCls(rowIdx, [me.selectedItemCls, me.focusedItemCls]);
  if (me.isRowStyleFirst(rowIdx)) {
    me.getRowStyleTableEl(rowIdx).removeCls([me.tableFocusedFirstCls, me.tableSelectedFirstCls]);
  } else {
    me.removeRowCls(rowIdx - 1, [me.beforeFocusedItemCls, me.beforeSelectedItemCls]);
  }
}, onCellSelect:function(position) {
  var cell = this.getCellByPosition(position);
  if (cell) {
    cell.addCls(this.selectedCellCls);
    this.scrollCellIntoView(cell);
  }
}, onCellDeselect:function(position) {
  var cell = this.getCellByPosition(position, true);
  if (cell) {
    Ext.fly(cell).removeCls(this.selectedCellCls);
  }
}, getCellByPosition:function(position, returnDom) {
  if (position) {
    var row = this.getNode(position.row, true), header = this.ownerCt.columnManager.getHeaderAtIndex(position.column);
    if (header && row) {
      return Ext.fly(row).down(this.getCellSelector(header), returnDom);
    }
  }
  return false;
}, getFocusEl:function() {
  var me = this, result;
  if (me.refreshCounter) {
    result = me.focusedRow;
    if (!(result && me.el.contains(result))) {
      if (me.all.getCount() && (result = me.getNode(me.all.item(0).dom, true))) {
        me.focusRow(result);
      } else {
        result = me.body;
      }
    }
  } else {
    return me.el;
  }
  return Ext.get(result);
}, onRowFocus:function(rowIdx, highlight, supressFocus) {
  var me = this;
  if (highlight) {
    me.addRowCls(rowIdx, me.focusedItemCls);
    if (me.isRowStyleFirst(rowIdx)) {
      me.getRowStyleTableEl(rowIdx).addCls(me.tableFocusedFirstCls);
    } else {
      me.addRowCls(rowIdx - 1, me.beforeFocusedItemCls);
    }
    if (!supressFocus) {
      me.focusRow(rowIdx);
    }
  } else {
    me.removeRowCls(rowIdx, me.focusedItemCls);
    if (me.isRowStyleFirst(rowIdx)) {
      me.getRowStyleTableEl(rowIdx).removeCls(me.tableFocusedFirstCls);
    } else {
      me.removeRowCls(rowIdx - 1, me.beforeFocusedItemCls);
    }
  }
  if ((Ext.isIE6 || Ext.isIE7) && !me.ownerCt.rowLines) {
    me.repaintRow(rowIdx);
  }
}, focus:function(selectText, delay) {
  var me = this, saveScroll = Ext.isIE && !delay, scrollPos;
  if (saveScroll) {
    scrollPos = me.el.dom.scrollLeft;
  }
  this.callParent(arguments);
  if (saveScroll) {
    me.el.dom.scrollLeft = scrollPos;
  }
}, focusRow:function(row, delay) {
  var me = this, rowIdx, gridCollapsed = me.ownerCt && me.ownerCt.collapsed, record;
  if (me.isVisible(true) && !gridCollapsed && (row = me.getNode(row, true))) {
    me.scrollRowIntoView(row);
    record = me.getRecord(row);
    rowIdx = me.indexInStore(row);
    me.selModel.setLastFocused(record);
    me.focusedRow = row;
    me.focus(false, delay, function() {
      me.fireEvent('rowfocus', record, row, rowIdx);
    });
  }
}, scrollRowIntoView:function(row) {
  row = this.getNode(row, true);
  if (row) {
    Ext.fly(row).scrollIntoView(this.el, false);
  }
}, focusCell:function(position) {
  var me = this, cell = me.getCellByPosition(position), record = me.getRecord(position.row);
  me.focusRow(record);
  if (cell) {
    me.scrollCellIntoView(cell);
    me.fireEvent('cellfocus', record, cell, position);
  }
}, scrollCellIntoView:function(cell) {
  if (cell.row != null && cell.column != null) {
    cell = this.getCellByPosition(cell);
  }
  if (cell) {
    Ext.fly(cell).scrollIntoView(this.el, true);
  }
}, scrollByDelta:function(delta, dir) {
  dir = dir || 'scrollTop';
  var elDom = this.el.dom;
  elDom[dir] = elDom[dir] += delta;
}, isDataRow:function(row) {
  return Ext.fly(row).hasCls(Ext.baseCSSPrefix + 'grid-data-row');
}, syncRowHeights:function(firstRow, secondRow) {
  firstRow = Ext.get(firstRow);
  secondRow = Ext.get(secondRow);
  firstRow.dom.style.height = secondRow.dom.style.height = '';
  var me = this, rowTpl = me.rowTpl, firstRowHeight = firstRow.dom.offsetHeight, secondRowHeight = secondRow.dom.offsetHeight;
  if (firstRowHeight !== secondRowHeight) {
    while (rowTpl) {
      if (rowTpl.syncRowHeights) {
        if (rowTpl.syncRowHeights(firstRow, secondRow) === false) {
          break;
        }
      }
      rowTpl = rowTpl.nextTpl;
    }
    firstRowHeight = firstRow.dom.offsetHeight;
    secondRowHeight = secondRow.dom.offsetHeight;
    if (firstRowHeight !== secondRowHeight) {
      firstRow = firstRow.down('[data-recordId]') || firstRow;
      secondRow = secondRow.down('[data-recordId]') || secondRow;
      if (firstRow && secondRow) {
        firstRow.dom.style.height = secondRow.dom.style.height = '';
        firstRowHeight = firstRow.dom.offsetHeight;
        secondRowHeight = secondRow.dom.offsetHeight;
        if (firstRowHeight > secondRowHeight) {
          firstRow.setHeight(firstRowHeight);
          secondRow.setHeight(firstRowHeight);
        } else {
          if (secondRowHeight > firstRowHeight) {
            firstRow.setHeight(secondRowHeight);
            secondRow.setHeight(secondRowHeight);
          }
        }
      }
    }
  }
}, onIdChanged:function(store, rec, oldId, newId, oldInternalId) {
  var me = this, rowDom;
  if (me.viewReady) {
    rowDom = me.getNodeById(oldInternalId);
    if (rowDom) {
      rowDom.setAttribute('data-recordId', rec.internalId);
      rowDom.id = me.getRowId(rec);
    }
  }
}, onUpdate:function(store, record, operation, changedFieldNames) {
  var me = this, rowTpl = me.rowTpl, index, oldRow, oldRowDom, newRowDom, newAttrs, attLen, attName, attrIndex, overItemCls, beforeOverItemCls, focusedItemCls, beforeFocusedItemCls, selectedItemCls, beforeSelectedItemCls, columns;
  if (me.viewReady) {
    oldRowDom = me.getNodeByRecord(record, false);
    if (oldRowDom) {
      overItemCls = me.overItemCls;
      beforeOverItemCls = me.overItemCls;
      focusedItemCls = me.focusedItemCls;
      beforeFocusedItemCls = me.beforeFocusedItemCls;
      selectedItemCls = me.selectedItemCls;
      beforeSelectedItemCls = me.beforeSelectedItemCls;
      index = me.indexInStore(record);
      oldRow = Ext.fly(oldRowDom, '_internal');
      newRowDom = me.createRowElement(record, index);
      if (oldRow.hasCls(overItemCls)) {
        Ext.fly(newRowDom).addCls(overItemCls);
      }
      if (oldRow.hasCls(beforeOverItemCls)) {
        Ext.fly(newRowDom).addCls(beforeOverItemCls);
      }
      if (oldRow.hasCls(focusedItemCls)) {
        Ext.fly(newRowDom).addCls(focusedItemCls);
      }
      if (oldRow.hasCls(beforeFocusedItemCls)) {
        Ext.fly(newRowDom).addCls(beforeFocusedItemCls);
      }
      if (oldRow.hasCls(selectedItemCls)) {
        Ext.fly(newRowDom).addCls(selectedItemCls);
      }
      if (oldRow.hasCls(beforeSelectedItemCls)) {
        Ext.fly(newRowDom).addCls(beforeSelectedItemCls);
      }
      columns = me.ownerCt.columnManager.getColumns();
      if (Ext.isIE9m && oldRowDom.mergeAttributes) {
        oldRowDom.mergeAttributes(newRowDom, true);
      } else {
        newAttrs = newRowDom.attributes;
        attLen = newAttrs.length;
        for (attrIndex = 0; attrIndex < attLen; attrIndex++) {
          attName = newAttrs[attrIndex].name;
          if (attName !== 'id') {
            oldRowDom.setAttribute(attName, newAttrs[attrIndex].value);
          }
        }
      }
      if (columns.length) {
        me.updateColumns(record, me.getNode(oldRowDom, true), me.getNode(newRowDom, true), columns, changedFieldNames);
      }
      while (rowTpl) {
        if (rowTpl.syncContent) {
          if (rowTpl.syncContent(oldRowDom, newRowDom) === false) {
            break;
          }
        }
        rowTpl = rowTpl.nextTpl;
      }
      me.fireEvent('itemupdate', record, index, oldRowDom);
      me.refreshSize();
    }
  }
}, updateColumns:function(record, oldRowDom, newRowDom, columns, changedFieldNames) {
  var me = this, newAttrs, attLen, attName, attrIndex, colCount = columns.length, colIndex, column, oldCell, newCell, row, editingPlugin = me.editingPlugin || me.lockingPartner && me.ownerCt.ownerLockable.view.editingPlugin, isEditing = editingPlugin && editingPlugin.editing, cellSelector = me.getCellSelector();
  if (oldRowDom.mergeAttributes) {
    oldRowDom.mergeAttributes(newRowDom, true);
  } else {
    newAttrs = newRowDom.attributes;
    attLen = newAttrs.length;
    for (attrIndex = 0; attrIndex < attLen; attrIndex++) {
      attName = newAttrs[attrIndex].name;
      if (attName !== 'id') {
        oldRowDom.setAttribute(attName, newAttrs[attrIndex].value);
      }
    }
  }
  for (colIndex = 0; colIndex < colCount; colIndex++) {
    column = columns[colIndex];
    if (me.shouldUpdateCell(record, column, changedFieldNames)) {
      cellSelector = me.getCellSelector(column);
      oldCell = Ext.DomQuery.selectNode(cellSelector, oldRowDom);
      newCell = Ext.DomQuery.selectNode(cellSelector, newRowDom);
      if (isEditing) {
        Ext.fly(oldCell).syncContent(newCell);
      } else {
        row = oldCell.parentNode;
        row.insertBefore(newCell, oldCell);
        row.removeChild(oldCell);
      }
    }
  }
}, shouldUpdateCell:function(record, column, changedFieldNames) {
  if (column.hasCustomRenderer || !changedFieldNames) {
    return true;
  }
  if (changedFieldNames) {
    var len = changedFieldNames.length, i, field;
    for (i = 0; i < len; ++i) {
      field = changedFieldNames[i];
      if (field === column.dataIndex || field === record.idProperty) {
        return true;
      }
    }
  }
  return false;
}, refresh:function() {
  var me = this, hasFocus = me.el && me.el.isAncestor(Ext.Element.getActiveElement());
  me.callParent(arguments);
  me.headerCt.setSortState();
  if (me.el && !me.all.getCount() && me.headerCt && me.headerCt.tooNarrow) {
    me.el.createChild({style:'position:absolute;height:1px;width:1px;left:' + (me.headerCt.getFullWidth() - 1) + 'px'});
  }
  if (hasFocus) {
    me.selModel.onLastFocusChanged(null, me.selModel.lastFocused);
  }
}, processItemEvent:function(record, row, rowIndex, e) {
  if (this.indexInStore(row) !== -1) {
    var me = this, cell = e.getTarget(me.getCellSelector(), row), cellIndex, map = me.statics().EventMap, selModel = me.getSelectionModel(), type = e.type, features = me.features, len = features.length, i, result, feature, header;
    if (type == 'keydown' && !cell && selModel.getCurrentPosition) {
      cell = me.getCellByPosition(selModel.getCurrentPosition(), true);
    }
    if (cell) {
      if (!cell.parentNode) {
        return false;
      }
      header = me.getHeaderByCell(cell);
      cellIndex = Ext.Array.indexOf(me.getGridColumns(), header);
    } else {
      cellIndex = -1;
    }
    result = me.fireEvent('uievent', type, me, cell, rowIndex, cellIndex, e, record, row);
    if (result === false || me.callParent(arguments) === false) {
      me.selModel.onVetoUIEvent(type, me, cell, rowIndex, cellIndex, e, record, row);
      return false;
    }
    for (i = 0; i < len; ++i) {
      feature = features[i];
      if (feature.wrapsItem) {
        if (feature.vetoEvent(record, row, rowIndex, e) === false) {
          me.processSpecialEvent(e);
          return false;
        }
      }
    }
    if (type == 'mouseover' || type == 'mouseout') {
      return true;
    }
    if (!cell) {
      return true;
    }
    return !(me['onBeforeCell' + map[type]](cell, cellIndex, record, row, rowIndex, e) === false || me.fireEvent('beforecell' + type, me, cell, cellIndex, record, row, rowIndex, e) === false || me['onCell' + map[type]](cell, cellIndex, record, row, rowIndex, e) === false || me.fireEvent('cell' + type, me, cell, cellIndex, record, row, rowIndex, e) === false);
  } else {
    this.processSpecialEvent(e);
    return false;
  }
}, processSpecialEvent:function(e) {
  var me = this, features = me.features, ln = features.length, type = e.type, i, feature, prefix, featureTarget, beforeArgs, args, panel = me.ownerCt;
  me.callParent(arguments);
  if (type == 'mouseover' || type == 'mouseout') {
    return;
  }
  for (i = 0; i < ln; i++) {
    feature = features[i];
    if (feature.hasFeatureEvent) {
      featureTarget = e.getTarget(feature.eventSelector, me.getTargetEl());
      if (featureTarget) {
        prefix = feature.eventPrefix;
        beforeArgs = feature.getFireEventArgs('before' + prefix + type, me, featureTarget, e);
        args = feature.getFireEventArgs(prefix + type, me, featureTarget, e);
        if (me.fireEvent.apply(me, beforeArgs) === false || panel.fireEvent.apply(panel, beforeArgs) === false || me.fireEvent.apply(me, args) === false || panel.fireEvent.apply(panel, args) === false) {
          return false;
        }
      }
    }
  }
  return true;
}, onCellMouseDown:Ext.emptyFn, onCellMouseUp:Ext.emptyFn, onCellClick:Ext.emptyFn, onCellDblClick:Ext.emptyFn, onCellContextMenu:Ext.emptyFn, onCellKeyDown:Ext.emptyFn, onBeforeCellMouseDown:Ext.emptyFn, onBeforeCellMouseUp:Ext.emptyFn, onBeforeCellClick:Ext.emptyFn, onBeforeCellDblClick:Ext.emptyFn, onBeforeCellContextMenu:Ext.emptyFn, onBeforeCellKeyDown:Ext.emptyFn, expandToFit:function(header) {
  this.autoSizeColumn(header);
}, autoSizeColumn:function(header) {
  if (Ext.isNumber(header)) {
    header = this.getGridColumns[header];
  }
  if (header) {
    if (header.isGroupHeader) {
      header.autoSize();
      return;
    }
    delete header.flex;
    header.setWidth(this.getMaxContentWidth(header));
  }
}, getMaxContentWidth:function(header) {
  var me = this, cells = me.el.query(header.getCellInnerSelector()), originalWidth = header.getWidth(), i = 0, ln = cells.length, hasPaddingBug = Ext.supports.ScrollWidthInlinePaddingBug, columnSizer = me.body.select(me.getColumnSizerSelector(header)), max = Math.max, paddingAdjust, maxWidth;
  if (hasPaddingBug && ln > 0) {
    paddingAdjust = me.getCellPaddingAfter(cells[0]);
  }
  columnSizer.setWidth(1);
  maxWidth = header.textEl.dom.offsetWidth + header.titleEl.getPadding('lr');
  for (; i < ln; i++) {
    maxWidth = max(maxWidth, cells[i].scrollWidth);
  }
  if (hasPaddingBug) {
    maxWidth += paddingAdjust;
  }
  maxWidth = max(maxWidth, 40);
  columnSizer.setWidth(originalWidth);
  return maxWidth;
}, getPositionByEvent:function(e) {
  var me = this, cellNode = e.getTarget(me.cellSelector), rowNode = e.getTarget(me.itemSelector), record = me.getRecord(rowNode), header = me.getHeaderByCell(cellNode);
  return me.getPosition(record, header);
}, getHeaderByCell:function(cell) {
  if (cell) {
    var match = cell.className.match(this.cellRe);
    if (match && match[1]) {
      return this.ownerCt.columnManager.getHeaderById(match[1]);
    }
  }
  return false;
}, walkCells:function(pos, direction, e, preventWrap, verifierFn, scope) {
  if (!pos) {
    return false;
  }
  var me = this, row = pos.row, column = pos.column, rowCount = me.dataSource.getCount(), lastCol = me.ownerCt.columnManager.getColumns().length - 1, newRow = row, newColumn = column, activeHeader = me.ownerCt.columnManager.getHeaderAtIndex(column);
  if (!activeHeader || activeHeader.hidden || !rowCount) {
    return false;
  }
  e = e || {};
  direction = direction.toLowerCase();
  switch(direction) {
    case 'right':
      if (column === lastCol) {
        if (preventWrap || row === rowCount - 1) {
          return false;
        }
        if (!e.ctrlKey) {
          newRow = me.walkRows(row, 1);
          if (newRow !== row) {
            newColumn = 0;
          }
        }
      } else {
        if (!e.ctrlKey) {
          newColumn = column + 1;
        } else {
          newColumn = lastCol;
        }
      }
      break;
    case 'left':
      if (column === 0) {
        if (preventWrap || row === 0) {
          return false;
        }
        if (!e.ctrlKey) {
          newRow = me.walkRows(row, -1);
          if (newRow !== row) {
            newColumn = lastCol;
          }
        }
      } else {
        if (!e.ctrlKey) {
          newColumn = column - 1;
        } else {
          newColumn = 0;
        }
      }
      break;
    case 'up':
      if (row === 0) {
        return false;
      } else {
        if (!e.ctrlKey) {
          newRow = me.walkRows(row, -1);
        } else {
          newRow = me.walkRows(-1, 1);
        }
      }
      break;
    case 'down':
      if (row === rowCount - 1) {
        return false;
      } else {
        if (!e.ctrlKey) {
          newRow = me.walkRows(row, 1);
        } else {
          newRow = me.walkRows(rowCount, -1);
        }
      }
      break;
  }
  if (verifierFn && verifierFn.call(scope || me, {row:newRow, column:newColumn}) !== true) {
    return false;
  } else {
    return (new Ext.grid.CellContext(me)).setPosition(newRow, newColumn);
  }
}, walkRows:function(startRow, distance) {
  var me = this, moved = 0, lastValid = startRow, node, last = (me.dataSource.buffered ? me.dataSource.getTotalCount() : me.dataSource.getCount()) - 1, limit = distance < 0 ? 0 : last, increment = limit ? 1 : -1, result = startRow;
  do {
    if (limit ? result >= limit : result <= 0) {
      return lastValid || limit;
    }
    result += increment;
    if ((node = Ext.fly(me.getNode(result, true))) && node.isVisible(true)) {
      moved += increment;
      lastValid = result;
    }
  } while (moved !== distance);
  return result;
}, walkRecs:function(startRec, distance) {
  var me = this, moved = 0, lastValid = startRec, node, last = (me.store.buffered ? me.store.getTotalCount() : me.store.getCount()) - 1, limit = distance < 0 ? 0 : last, increment = limit ? 1 : -1, testIndex = me.store.indexOf(startRec), rec;
  do {
    if (limit ? testIndex >= limit : testIndex <= 0) {
      return lastValid;
    }
    testIndex += increment;
    rec = me.store.getAt(testIndex);
    if ((node = Ext.fly(me.getNodeByRecord(rec, true))) && node.isVisible(true)) {
      moved += increment;
      lastValid = rec;
    }
  } while (moved !== distance);
  return lastValid;
}, getFirstVisibleRowIndex:function() {
  var me = this, count = me.dataSource.buffered ? me.dataSource.getTotalCount() : me.dataSource.getCount(), result = me.indexOf(me.all.first()) - 1;
  do {
    result += 1;
    if (result === count) {
      return;
    }
  } while (!Ext.fly(me.getNode(result, true)).isVisible(true));
  return result;
}, getLastVisibleRowIndex:function() {
  var me = this, result = me.indexOf(me.all.last());
  do {
    result -= 1;
    if (result === -1) {
      return;
    }
  } while (!Ext.fly(me.getNode(result, true)).isVisible(true));
  return result;
}, getHeaderCt:function() {
  return this.headerCt;
}, getPosition:function(record, header) {
  return (new Ext.grid.CellContext(this)).setPosition(record, header);
}, beforeDestroy:function() {
  var me = this;
  if (me.rendered) {
    me.el.removeAllListeners();
  }
  me.callParent(arguments);
}, onDestroy:function() {
  var me = this, features = me.featuresMC, len, i;
  if (features) {
    for (i = 0, len = features.getCount(); i < len; ++i) {
      features.getAt(i).destroy();
    }
  }
  me.featuresMC = null;
  this.callParent(arguments);
}, onAdd:function(ds, records, index) {
  this.callParent(arguments);
  this.doStripeRows(index);
}, onRemove:function(ds, records, indexes) {
  this.callParent(arguments);
  this.doStripeRows(indexes[0]);
}, doStripeRows:function(startRow, endRow) {
  var me = this, rows, rowsLn, i, row;
  if (me.rendered && me.stripeRows) {
    rows = me.getNodes(startRow, endRow);
    for (i = 0, rowsLn = rows.length; i < rowsLn; i++) {
      row = rows[i];
      row.className = row.className.replace(me.rowClsRe, ' ');
      startRow++;
      if (startRow % 2 === 0) {
        row.className += ' ' + me.altRowCls;
      }
    }
  }
}, repaintRow:function(rowIdx) {
  var node = this.getNode(rowIdx), tds = node.childNodes, i = tds.length;
  while (i--) {
    tds[i].className = tds[i].className;
  }
}, getRowStyleTableEl:function(item) {
  var me = this;
  if (!item.tagName) {
    item = this.getNode(item);
  }
  return (me.isGrouping ? Ext.fly(item) : this.el).down('table.x-grid-table');
}, isRowStyleFirst:function(item) {
  var me = this, index;
  if (item === -1) {
    return false;
  }
  if (!item.tagName) {
    index = item;
    item = this.getNode(item);
  } else {
    index = me.indexOf(item);
  }
  return !index || me.isGrouping && Ext.fly(item).hasCls(Ext.baseCSSPrefix + 'grid-group-row');
}, getCellPaddingAfter:function(cell) {
  return Ext.fly(cell).getPadding('r');
}});
Ext.define('Ext.grid.plugin.BufferedRendererTableView', {override:'Ext.view.Table', onAdd:function(store, records, index) {
  var me = this, bufferedRenderer = me.bufferedRenderer, rows = me.all;
  if (me.rendered && bufferedRenderer && rows.getCount() + records.length > bufferedRenderer.viewSize) {
    if (index < rows.startIndex + bufferedRenderer.viewSize && index + records.length > rows.startIndex) {
      me.refreshView();
    } else {
      bufferedRenderer.stretchView(me, bufferedRenderer.getScrollHeight());
    }
  } else {
    me.callParent([store, records, index]);
  }
}, onRemove:function(store, records, indices) {
  var me = this, bufferedRenderer = me.bufferedRenderer;
  me.callParent([store, records, indices]);
  if (me.rendered && bufferedRenderer) {
    if (me.dataSource.getCount() > bufferedRenderer.viewSize) {
      me.refreshView();
    } else {
      bufferedRenderer.stretchView(me, bufferedRenderer.getScrollHeight());
    }
  }
}, onDataRefresh:function() {
  var me = this;
  if (me.bufferedRenderer) {
    me.all.clear();
    me.bufferedRenderer.onStoreClear();
  }
  me.callParent();
}});
Ext.define('Ext.grid.View', {extend:Ext.view.Table, alias:'widget.gridview', stripeRows:true, autoScroll:true});
Ext.define('Ext.grid.Panel', {extend:Ext.panel.Table, alias:['widget.gridpanel', 'widget.grid'], alternateClassName:['Ext.list.ListView', 'Ext.ListView', 'Ext.grid.GridPanel'], viewType:'gridview', lockable:false, rowLines:true});
Ext.define('Ext.grid.plugin.HeaderResizer', {extend:Ext.AbstractPlugin, alias:'plugin.gridheaderresizer', disabled:false, config:{dynamic:false}, colHeaderCls:Ext.baseCSSPrefix + 'column-header', minColWidth:40, maxColWidth:1000, wResizeCursor:'col-resize', eResizeCursor:'col-resize', init:function(headerCt) {
  this.headerCt = headerCt;
  headerCt.on('render', this.afterHeaderRender, this, {single:true});
}, destroy:function() {
  if (this.tracker) {
    this.tracker.destroy();
  }
}, afterHeaderRender:function() {
  var headerCt = this.headerCt, el = headerCt.el;
  headerCt.mon(el, 'mousemove', this.onHeaderCtMouseMove, this);
  this.tracker = new Ext.dd.DragTracker({disabled:this.disabled, onBeforeStart:Ext.Function.bind(this.onBeforeStart, this), onStart:Ext.Function.bind(this.onStart, this), onDrag:Ext.Function.bind(this.onDrag, this), onEnd:Ext.Function.bind(this.onEnd, this), tolerance:3, autoStart:300, el:el});
}, onHeaderCtMouseMove:function(e, t) {
  var me = this, prevSiblings, headerEl, overHeader, resizeHeader, resizeHeaderOwnerGrid, ownerGrid;
  if (me.headerCt.dragging) {
    if (me.activeHd) {
      me.activeHd.el.dom.style.cursor = '';
      delete me.activeHd;
    }
  } else {
    headerEl = e.getTarget('.' + me.colHeaderCls, 3, true);
    if (headerEl) {
      overHeader = Ext.getCmp(headerEl.id);
      if (overHeader.isOnLeftEdge(e)) {
        resizeHeader = overHeader.previousNode('gridcolumn:not([hidden]):not([isGroupHeader])');
        if (resizeHeader) {
          ownerGrid = me.headerCt.up('tablepanel');
          resizeHeaderOwnerGrid = resizeHeader.up('tablepanel');
          if (!(resizeHeaderOwnerGrid === ownerGrid || ownerGrid.ownerCt.isXType('tablepanel') && ownerGrid.ownerCt.view.lockedGrid === resizeHeaderOwnerGrid)) {
            resizeHeader = null;
          }
        }
      } else {
        if (overHeader.isOnRightEdge(e)) {
          resizeHeader = overHeader;
        } else {
          resizeHeader = null;
        }
      }
      if (resizeHeader) {
        if (resizeHeader.isGroupHeader) {
          prevSiblings = resizeHeader.getGridColumns();
          resizeHeader = prevSiblings[prevSiblings.length - 1];
        }
        if (resizeHeader && !(resizeHeader.fixed || resizeHeader.resizable === false || me.disabled)) {
          me.activeHd = resizeHeader;
          overHeader.el.dom.style.cursor = me.eResizeCursor;
          if (overHeader.triggerEl) {
            overHeader.triggerEl.dom.style.cursor = me.eResizeCursor;
          }
        }
      } else {
        overHeader.el.dom.style.cursor = '';
        if (overHeader.triggerEl) {
          overHeader.triggerEl.dom.style.cursor = '';
        }
        me.activeHd = null;
      }
    }
  }
}, onBeforeStart:function(e) {
  this.dragHd = this.activeHd;
  if (!!this.dragHd && !this.headerCt.dragging) {
    this.tracker.constrainTo = this.getConstrainRegion();
    return true;
  } else {
    this.headerCt.dragging = false;
    return false;
  }
}, getConstrainRegion:function() {
  var me = this, dragHdEl = me.dragHd.el, rightAdjust = 0, nextHd, lockedGrid;
  if (me.headerCt.forceFit) {
    nextHd = me.dragHd.nextNode('gridcolumn:not([hidden]):not([isGroupHeader])');
    if (nextHd) {
      if (!me.headerInSameGrid(nextHd)) {
        nextHd = null;
      }
      rightAdjust = nextHd.getWidth() - me.minColWidth;
    }
  } else {
    if ((lockedGrid = me.dragHd.up('tablepanel')).isLocked) {
      rightAdjust = me.dragHd.up('[scrollerOwner]').getWidth() - lockedGrid.getWidth() - 30;
    } else {
      rightAdjust = me.maxColWidth - dragHdEl.getWidth();
    }
  }
  return me.adjustConstrainRegion(dragHdEl.getRegion(), 0, rightAdjust, 0, me.minColWidth);
}, onStart:function(e) {
  var me = this, dragHd = me.dragHd, width = dragHd.el.getWidth(), headerCt = dragHd.getOwnerHeaderCt(), x, y, gridSection, markerOwner, lhsMarker, rhsMarker, markerHeight;
  me.headerCt.dragging = true;
  me.origWidth = width;
  if (!me.dynamic) {
    gridSection = markerOwner = headerCt.up('tablepanel');
    if (gridSection.ownerLockable) {
      markerOwner = gridSection.ownerLockable;
    }
    x = me.getLeftMarkerX(markerOwner);
    lhsMarker = markerOwner.getLhsMarker();
    rhsMarker = markerOwner.getRhsMarker();
    markerHeight = gridSection.body.getHeight() + headerCt.getHeight();
    y = headerCt.getOffsetsTo(markerOwner)[1];
    lhsMarker.setLocalY(y);
    rhsMarker.setLocalY(y);
    lhsMarker.setHeight(markerHeight);
    rhsMarker.setHeight(markerHeight);
    me.setMarkerX(lhsMarker, x);
    me.setMarkerX(rhsMarker, x + width);
  }
}, onDrag:function(e) {
  var me = this, markerOwner;
  if (me.dynamic) {
    me.doResize();
  } else {
    markerOwner = this.headerCt.up('tablepanel');
    if (markerOwner.ownerLockable) {
      markerOwner = markerOwner.ownerLockable;
    }
    this.setMarkerX(this.getMovingMarker(markerOwner), this.calculateDragX(markerOwner));
  }
}, getMovingMarker:function(markerOwner) {
  return markerOwner.getRhsMarker();
}, onEnd:function(e) {
  this.headerCt.dragging = false;
  if (this.dragHd) {
    if (!this.dynamic) {
      var markerOwner = this.headerCt.up('tablepanel');
      if (markerOwner.ownerLockable) {
        markerOwner = markerOwner.ownerLockable;
      }
      this.setMarkerX(markerOwner.getLhsMarker(), -9999);
      this.setMarkerX(markerOwner.getRhsMarker(), -9999);
    }
    this.doResize();
  }
}, doResize:function() {
  var me = this, dragHd = me.dragHd, nextHd, offset;
  if (dragHd) {
    offset = me.tracker.getOffset('point');
    if (dragHd.flex) {
      delete dragHd.flex;
    }
    Ext.suspendLayouts();
    me.adjustColumnWidth(offset[0]);
    if (me.headerCt.forceFit) {
      nextHd = dragHd.nextNode('gridcolumn:not([hidden]):not([isGroupHeader])');
      if (nextHd && !me.headerInSameGrid(nextHd)) {
        nextHd = null;
      }
      if (nextHd) {
        delete nextHd.flex;
        nextHd.setWidth(nextHd.getWidth() - offset[0]);
      }
    }
    Ext.resumeLayouts(true);
  }
}, headerInSameGrid:function(header) {
  var grid = this.dragHd.up('tablepanel');
  return !!header.up(grid);
}, disable:function() {
  this.disabled = true;
  if (this.tracker) {
    this.tracker.disable();
  }
}, enable:function() {
  this.disabled = false;
  if (this.tracker) {
    this.tracker.enable();
  }
}, calculateDragX:function(markerOwner) {
  return this.tracker.getXY('point')[0] - markerOwner.getX() - markerOwner.el.getBorderWidth('l');
}, getLeftMarkerX:function(markerOwner) {
  return this.dragHd.getX() - markerOwner.getX() - markerOwner.el.getBorderWidth('l') - 1;
}, setMarkerX:function(marker, x) {
  marker.setLocalX(x);
}, adjustConstrainRegion:function(region, t, r, b, l) {
  return region.adjust(t, r, b, l);
}, adjustColumnWidth:function(offsetX) {
  this.dragHd.setWidth(this.origWidth + offsetX);
}});
Ext.define('Ext.grid.header.DragZone', {extend:Ext.dd.DragZone, colHeaderSelector:'.' + Ext.baseCSSPrefix + 'column-header', colInnerSelector:'.' + Ext.baseCSSPrefix + 'column-header-inner', maxProxyWidth:120, constructor:function(headerCt) {
  this.headerCt = headerCt;
  this.ddGroup = this.getDDGroup();
  this.callParent([headerCt.el]);
  this.proxy.el.addCls(Ext.baseCSSPrefix + 'grid-col-dd');
}, getDDGroup:function() {
  return 'header-dd-zone-' + this.headerCt.up('[scrollerOwner]').id;
}, getDragData:function(e) {
  if (e.getTarget(this.colInnerSelector)) {
    var header = e.getTarget(this.colHeaderSelector), headerCmp, ddel;
    if (header) {
      headerCmp = Ext.getCmp(header.id);
      if (!this.headerCt.dragging && headerCmp.draggable && !(headerCmp.isOnLeftEdge(e) || headerCmp.isOnRightEdge(e))) {
        ddel = document.createElement('div');
        ddel.innerHTML = Ext.getCmp(header.id).text;
        return {ddel:ddel, header:headerCmp};
      }
    }
  }
  return false;
}, onBeforeDrag:function() {
  return !(this.headerCt.dragging || this.disabled);
}, onInitDrag:function() {
  this.headerCt.dragging = true;
  this.callParent(arguments);
}, onDragDrop:function() {
  this.headerCt.dragging = false;
  this.callParent(arguments);
}, afterRepair:function() {
  this.callParent();
  this.headerCt.dragging = false;
}, getRepairXY:function() {
  return this.dragData.header.el.getXY();
}, disable:function() {
  this.disabled = true;
}, enable:function() {
  this.disabled = false;
}});
Ext.define('Ext.grid.header.DropZone', {extend:Ext.dd.DropZone, colHeaderCls:Ext.baseCSSPrefix + 'column-header', proxyOffsets:[-4, -9], constructor:function(headerCt) {
  this.headerCt = headerCt;
  this.ddGroup = this.getDDGroup();
  this.callParent([headerCt.el]);
}, getDDGroup:function() {
  return 'header-dd-zone-' + this.headerCt.up('[scrollerOwner]').id;
}, getTargetFromEvent:function(e) {
  return e.getTarget('.' + this.colHeaderCls);
}, getTopIndicator:function() {
  if (!this.topIndicator) {
    this.self.prototype.topIndicator = Ext.DomHelper.append(Ext.getBody(), {cls:'col-move-top', html:'\x26#160;'}, true);
    this.self.prototype.indicatorXOffset = Math.floor((this.topIndicator.dom.offsetWidth + 1) / 2);
  }
  return this.topIndicator;
}, getBottomIndicator:function() {
  if (!this.bottomIndicator) {
    this.self.prototype.bottomIndicator = Ext.DomHelper.append(Ext.getBody(), {cls:'col-move-bottom', html:'\x26#160;'}, true);
  }
  return this.bottomIndicator;
}, getLocation:function(e, t) {
  var x = e.getXY()[0], region = Ext.fly(t).getRegion(), pos;
  if (region.right - x <= (region.right - region.left) / 2) {
    pos = 'after';
  } else {
    pos = 'before';
  }
  return {pos:pos, header:Ext.getCmp(t.id), node:t};
}, positionIndicator:function(data, node, e) {
  var me = this, dragHeader = data.header, dropLocation = me.getLocation(e, node), targetHeader = dropLocation.header, pos = dropLocation.pos, nextHd, prevHd, topIndicator, bottomIndicator, topAnchor, bottomAnchor, topXY, bottomXY, headerCtEl, minX, maxX, allDropZones, ln, i, dropZone;
  if (targetHeader === me.lastTargetHeader && pos === me.lastDropPos) {
    return;
  }
  nextHd = dragHeader.nextSibling('gridcolumn:not([hidden])');
  prevHd = dragHeader.previousSibling('gridcolumn:not([hidden])');
  me.lastTargetHeader = targetHeader;
  me.lastDropPos = pos;
  if (!targetHeader.draggable && pos === 'before' && targetHeader.getIndex() === 0) {
    return false;
  }
  data.dropLocation = dropLocation;
  if (dragHeader !== targetHeader && (pos === 'before' && nextHd !== targetHeader || pos === 'after' && prevHd !== targetHeader) && !targetHeader.isDescendantOf(dragHeader)) {
    allDropZones = Ext.dd.DragDropManager.getRelated(me);
    ln = allDropZones.length;
    i = 0;
    for (; i < ln; i++) {
      dropZone = allDropZones[i];
      if (dropZone !== me && dropZone.invalidateDrop) {
        dropZone.invalidateDrop();
      }
    }
    me.valid = true;
    topIndicator = me.getTopIndicator();
    bottomIndicator = me.getBottomIndicator();
    if (pos === 'before') {
      topAnchor = 'bc-tl';
      bottomAnchor = 'tc-bl';
    } else {
      topAnchor = 'bc-tr';
      bottomAnchor = 'tc-br';
    }
    topXY = topIndicator.getAlignToXY(targetHeader.el, topAnchor);
    bottomXY = bottomIndicator.getAlignToXY(targetHeader.el, bottomAnchor);
    headerCtEl = me.headerCt.el;
    minX = headerCtEl.getX() - me.indicatorXOffset;
    maxX = headerCtEl.getX() + headerCtEl.getWidth();
    topXY[0] = Ext.Number.constrain(topXY[0], minX, maxX);
    bottomXY[0] = Ext.Number.constrain(bottomXY[0], minX, maxX);
    topIndicator.setXY(topXY);
    bottomIndicator.setXY(bottomXY);
    topIndicator.show();
    bottomIndicator.show();
  } else {
    me.invalidateDrop();
  }
}, invalidateDrop:function() {
  this.valid = false;
  this.hideIndicators();
}, onNodeOver:function(node, dragZone, e, data) {
  var me = this, from = data.header, doPosition, to, fromPanel, toPanel;
  if (data.header.el.dom === node) {
    doPosition = false;
  } else {
    data.isLock = data.isUnlock = false;
    to = me.getLocation(e, node).header;
    doPosition = from.ownerCt === to.ownerCt;
    if (!doPosition && (!from.ownerCt.sealed && !to.ownerCt.sealed)) {
      doPosition = true;
      fromPanel = from.up('tablepanel');
      toPanel = to.up('tablepanel');
      data.isLock = toPanel.isLocked && !fromPanel.isLocked;
      data.isUnlock = !toPanel.isLocked && fromPanel.isLocked;
      if (data.isUnlock && from.lockable === false || data.isLock && !from.isLockable()) {
        doPosition = false;
      }
    }
  }
  if (doPosition) {
    me.positionIndicator(data, node, e);
  } else {
    me.valid = false;
  }
  return me.valid ? me.dropAllowed : me.dropNotAllowed;
}, hideIndicators:function() {
  var me = this;
  me.getTopIndicator().hide();
  me.getBottomIndicator().hide();
  me.lastTargetHeader = me.lastDropPos = null;
}, onNodeOut:function() {
  this.hideIndicators();
}, onNodeDrop:function(node, dragZone, e, data) {
  if (this.valid) {
    var dragHeader = data.header, dropLocation = data.dropLocation, targetHeader = dropLocation.header, fromCt = dragHeader.ownerCt, localFromIdx = fromCt.items.indexOf(dragHeader), toCt = targetHeader.ownerCt, localToIdx = toCt.items.indexOf(targetHeader), headerCt = this.headerCt, columnManager = headerCt.columnManager, fromIdx = columnManager.getHeaderIndex(dragHeader), toIdx = columnManager.getHeaderIndex(targetHeader), colsToMove = dragHeader.isGroupHeader ? dragHeader.query(':not([isGroupHeader])').length : 
    1, sameCt = fromCt === toCt, scrollerOwner, savedWidth;
    if (dropLocation.pos === 'after') {
      localToIdx++;
      toIdx += targetHeader.isGroupHeader ? targetHeader.query(':not([isGroupHeader])').length : 1;
    }
    if (data.isLock) {
      scrollerOwner = fromCt.up('[scrollerOwner]');
      scrollerOwner.lock(dragHeader, localToIdx);
      data.isLock = false;
      this.onNodeDrop(node, dragZone, e, data);
    } else {
      if (data.isUnlock) {
        scrollerOwner = fromCt.up('[scrollerOwner]');
        scrollerOwner.unlock(dragHeader, localToIdx);
        data.isUnlock = false;
        this.onNodeDrop(node, dragZone, e, data);
      } else {
        this.invalidateDrop();
        savedWidth = dragHeader.getWidth();
        if (sameCt) {
          if (localToIdx === localFromIdx) {
            headerCt.onHeaderMoved(dragHeader, colsToMove, fromIdx, toIdx);
            return;
          }
          if (localToIdx > localFromIdx) {
            localToIdx -= 1;
          }
        }
        Ext.suspendLayouts();
        if (sameCt) {
          toCt.move(localFromIdx, localToIdx);
        } else {
          fromCt.remove(dragHeader, false);
          toCt.insert(localToIdx, dragHeader);
        }
        if (toCt.isGroupHeader) {
          if (!sameCt) {
            dragHeader.savedFlex = dragHeader.flex;
            delete dragHeader.flex;
            dragHeader.width = savedWidth;
          }
        } else {
          if (dragHeader.savedFlex) {
            dragHeader.flex = dragHeader.savedFlex;
            delete dragHeader.width;
          }
        }
        headerCt.purgeCache();
        Ext.resumeLayouts(true);
        headerCt.onHeaderMoved(dragHeader, colsToMove, fromIdx, toIdx);
      }
    }
  }
}});
Ext.define('Ext.grid.plugin.HeaderReorderer', {extend:Ext.AbstractPlugin, alias:'plugin.gridheaderreorderer', init:function(headerCt) {
  this.headerCt = headerCt;
  headerCt.on({render:this.onHeaderCtRender, single:true, scope:this});
}, destroy:function() {
  Ext.destroy(this.dragZone, this.dropZone);
}, onHeaderCtRender:function() {
  var me = this;
  me.dragZone = new Ext.grid.header.DragZone(me.headerCt);
  me.dropZone = new Ext.grid.header.DropZone(me.headerCt);
  if (me.disabled) {
    me.dragZone.disable();
  }
}, enable:function() {
  this.disabled = false;
  if (this.dragZone) {
    this.dragZone.enable();
  }
}, disable:function() {
  this.disabled = true;
  if (this.dragZone) {
    this.dragZone.disable();
  }
}});
Ext.define('Ext.grid.header.Container', {extend:Ext.container.Container, border:true, alias:'widget.headercontainer', baseCls:Ext.baseCSSPrefix + 'grid-header-ct', dock:'top', weight:100, defaultType:'gridcolumn', detachOnRemove:false, defaultWidth:100, sortAscText:'Sort Ascending', sortDescText:'Sort Descending', sortClearText:'Clear Sort', columnsText:'Columns', headerOpenCls:Ext.baseCSSPrefix + 'column-header-open', menuSortAscCls:Ext.baseCSSPrefix + 'hmenu-sort-asc', menuSortDescCls:Ext.baseCSSPrefix + 
'hmenu-sort-desc', menuColsIcon:Ext.baseCSSPrefix + 'cols-icon', triStateSort:false, ddLock:false, dragging:false, sortable:true, enableColumnHide:true, initComponent:function() {
  var me = this;
  me.headerCounter = 0;
  me.plugins = me.plugins || [];
  if (!me.isColumn) {
    if (me.enableColumnResize) {
      me.resizer = new Ext.grid.plugin.HeaderResizer;
      me.plugins.push(me.resizer);
    }
    if (me.enableColumnMove) {
      me.reorderer = new Ext.grid.plugin.HeaderReorderer;
      me.plugins.push(me.reorderer);
    }
  }
  if (me.isColumn && (!me.items || me.items.length === 0)) {
    me.isContainer = false;
    me.layout = {type:'container', calculate:Ext.emptyFn};
  } else {
    me.layout = Ext.apply({type:'gridcolumn', align:'stretch'}, me.initialConfig.layout);
    if (me.isRootHeader) {
      me.grid.columnManager = me.columnManager = new Ext.grid.ColumnManager(me);
    }
  }
  me.defaults = me.defaults || {};
  Ext.applyIf(me.defaults, {triStateSort:me.triStateSort, sortable:me.sortable});
  me.menuTask = new Ext.util.DelayedTask(me.updateMenuDisabledState, me);
  me.callParent();
  me.addEvents('columnresize', 'headerclick', 'headercontextmenu', 'headertriggerclick', 'columnmove', 'columnhide', 'columnshow', 'columnschanged', 'sortchange', 'menucreate');
}, isLayoutRoot:function() {
  if (this.hiddenHeaders) {
    return false;
  }
  return this.callParent();
}, getOwnerHeaderCt:function() {
  var me = this;
  return me.isRootHeader ? me : me.up('[isRootHeader]');
}, onDestroy:function() {
  var me = this;
  if (me.menu) {
    me.menu.un('hide', me.onMenuHide, me);
  }
  me.menuTask.cancel();
  Ext.destroy(me.resizer, me.reorderer);
  me.callParent();
}, applyColumnsState:function(columns) {
  if (!columns || !columns.length) {
    return;
  }
  var me = this, items = me.items.items, count = items.length, i = 0, length = columns.length, c, col, columnState, index;
  for (c = 0; c < length; c++) {
    columnState = columns[c];
    for (index = count; index--;) {
      col = items[index];
      if (col.getStateId && col.getStateId() == columnState.id) {
        if (i !== index) {
          me.moveHeader(index, i);
        }
        if (col.applyColumnState) {
          col.applyColumnState(columnState);
        }
        ++i;
        break;
      }
    }
  }
}, getColumnsState:function() {
  var me = this, columns = [], state;
  me.items.each(function(col) {
    state = col.getColumnState && col.getColumnState();
    if (state) {
      columns.push(state);
    }
  });
  return columns;
}, onAdd:function(c) {
  var me = this;
  if (!c.headerId) {
    c.headerId = c.initialConfig.id || Ext.id(null, 'header-');
  }
  if (!c.getStateId()) {
    c.stateId = c.initialConfig.id || 'h' + ++me.headerCounter;
  }
  if (Ext.global.console && Ext.global.console.warn) {
    if (!me._usedIDs) {
      me._usedIDs = {};
    }
    if (me._usedIDs[c.headerId]) {
      Ext.global.console.warn(this.$className, 'attempted to reuse an existing id', c.headerId);
    }
    me._usedIDs[c.headerId] = true;
  }
  me.callParent(arguments);
  me.onColumnsChanged();
}, onMove:function() {
  this.callParent(arguments);
  this.onColumnsChanged();
}, onShow:function() {
  this.callParent(arguments);
  this.onColumnsChanged();
}, onColumnsChanged:function() {
  var headerCt = this;
  while (headerCt) {
    headerCt.purgeCache();
    if (headerCt.isRootHeader) {
      break;
    }
    headerCt = headerCt.ownerCt;
  }
  if (headerCt && headerCt.rendered) {
    headerCt.fireEvent('columnschanged', headerCt);
  }
}, onRemove:function(c) {
  var me = this, ownerCt = me.ownerCt;
  me.callParent(arguments);
  if (!me._usedIDs) {
    me._usedIDs = {};
  }
  delete me._usedIDs[c.headerId];
  if (!me.destroying) {
    me.onColumnsChanged();
    if (me.isGroupHeader && !me.items.getCount() && ownerCt) {
      me.detachComponent(c);
      Ext.suspendLayouts();
      ownerCt.remove(me);
      Ext.resumeLayouts(true);
    }
  }
}, applyDefaults:function(config) {
  var ret;
  if (config && !config.isComponent && config.xtype == 'rownumberer') {
    ret = config;
  } else {
    ret = this.callParent(arguments);
    if (!config.isGroupHeader && !('width' in ret) && !ret.flex) {
      ret.width = this.defaultWidth;
    }
  }
  return ret;
}, setSortState:function() {
  var store = this.up('[store]').store, first = store.getFirstSorter(), hd;
  if (first) {
    hd = this.down('gridcolumn[dataIndex\x3d' + first.property + ']');
    if (hd) {
      hd.setSortState(first.direction, false, true);
    }
  } else {
    this.clearOtherSortStates(null);
  }
}, getHeaderMenu:function() {
  var menu = this.getMenu(), item;
  if (menu) {
    item = menu.child('#columnItem');
    if (item) {
      return item.menu;
    }
  }
  return null;
}, onHeaderVisibilityChange:function(header, visible) {
  var me = this, menu = me.getHeaderMenu(), item;
  me.purgeCache();
  if (menu) {
    item = me.getMenuItemForHeader(menu, header);
    if (item) {
      item.setChecked(visible, true);
    }
    if (menu.isVisible()) {
      me.menuTask.delay(50);
    }
  }
}, updateMenuDisabledState:function(menu) {
  var me = this, columns = me.query(':not([hidden])'), i, len = columns.length, item, checkItem, method;
  if (!menu) {
    menu = me.getMenu();
  }
  for (i = 0; i < len; ++i) {
    item = columns[i];
    checkItem = me.getMenuItemForHeader(menu, item);
    if (checkItem) {
      method = item.isHideable() ? 'enable' : 'disable';
      if (checkItem.menu) {
        method += 'CheckChange';
      }
      checkItem[method]();
    }
  }
}, getMenuItemForHeader:function(menu, header) {
  return header ? menu.down('menucheckitem[headerId\x3d' + header.id + ']') : null;
}, onHeaderShow:function(header) {
  var me = this, gridSection = me.ownerCt;
  if (me.forceFit) {
    delete me.flex;
  }
  me.onHeaderVisibilityChange(header, true);
  if (!header.isGroupHeader) {
    if (gridSection) {
      gridSection.onHeaderShow(me, header);
    }
  }
  me.fireEvent('columnshow', me, header);
  me.fireEvent('columnschanged', this);
}, onHeaderHide:function(header) {
  var me = this, gridSection = me.ownerCt;
  me.onHeaderVisibilityChange(header, false);
  if (!header.isGroupHeader) {
    if (gridSection) {
      gridSection.onHeaderHide(me, header);
    }
  }
  me.fireEvent('columnhide', me, header);
  me.fireEvent('columnschanged', this);
}, tempLock:function() {
  this.ddLock = true;
  Ext.Function.defer(function() {
    this.ddLock = false;
  }, 200, this);
}, onHeaderResize:function(header, w, suppressFocus) {
  var me = this, view = me.view, gridSection = me.ownerCt;
  if (view && view.body.dom) {
    me.tempLock();
    if (gridSection) {
      gridSection.onHeaderResize(me, header, w);
    }
  }
  me.fireEvent('columnresize', this, header, w);
}, onHeaderClick:function(header, e, t) {
  header.fireEvent('headerclick', this, header, e, t);
  this.fireEvent('headerclick', this, header, e, t);
}, onHeaderContextMenu:function(header, e, t) {
  header.fireEvent('headercontextmenu', this, header, e, t);
  this.fireEvent('headercontextmenu', this, header, e, t);
}, onHeaderTriggerClick:function(header, e, t) {
  var me = this;
  if (header.fireEvent('headertriggerclick', me, header, e, t) !== false && me.fireEvent('headertriggerclick', me, header, e, t) !== false) {
    me.showMenuBy(t, header);
  }
}, showMenuBy:function(t, header) {
  var menu = this.getMenu(), ascItem = menu.down('#ascItem'), descItem = menu.down('#descItem'), sortableMth;
  menu.activeHeader = menu.ownerButton = header;
  header.setMenuActive(true);
  sortableMth = header.sortable ? 'enable' : 'disable';
  if (ascItem) {
    ascItem[sortableMth]();
  }
  if (descItem) {
    descItem[sortableMth]();
  }
  menu.showBy(t);
}, onMenuHide:function(menu) {
  menu.activeHeader.setMenuActive(false);
}, moveHeader:function(fromIdx, toIdx) {
  this.tempLock();
  this.onHeaderMoved(this.move(fromIdx, toIdx), 1, fromIdx, toIdx);
}, purgeCache:function() {
  var me = this, menu = me.menu;
  me.gridDataColumns = me.hideableColumns = null;
  if (me.columnManager) {
    me.columnManager.invalidate();
  }
  if (menu && menu.hidden) {
    menu.hide();
    menu.destroy();
    me.menu = null;
  }
}, onHeaderMoved:function(header, colsToMove, fromIdx, toIdx) {
  var me = this, gridSection = me.ownerCt;
  if (gridSection && gridSection.onHeaderMove) {
    gridSection.onHeaderMove(me, header, colsToMove, fromIdx, toIdx);
  }
  me.fireEvent('columnmove', me, header, fromIdx, toIdx);
}, getMenu:function() {
  var me = this;
  if (!me.menu) {
    me.menu = new Ext.menu.Menu({hideOnParentHide:false, items:me.getMenuItems(), listeners:{hide:me.onMenuHide, scope:me}});
    me.fireEvent('menucreate', me, me.menu);
  }
  me.updateMenuDisabledState(me.menu);
  return me.menu;
}, getMenuItems:function() {
  var me = this, menuItems = [], hideableColumns = me.enableColumnHide ? me.getColumnMenu(me) : null;
  if (me.sortable) {
    menuItems = [{itemId:'ascItem', text:me.sortAscText, cls:me.menuSortAscCls, handler:me.onSortAscClick, scope:me}, {itemId:'descItem', text:me.sortDescText, cls:me.menuSortDescCls, handler:me.onSortDescClick, scope:me}];
  }
  if (hideableColumns && hideableColumns.length) {
    if (me.sortable) {
      menuItems.push('-');
    }
    menuItems.push({itemId:'columnItem', text:me.columnsText, cls:me.menuColsIcon, menu:hideableColumns, hideOnClick:false});
  }
  return menuItems;
}, onSortAscClick:function() {
  var menu = this.getMenu(), activeHeader = menu.activeHeader;
  activeHeader.setSortState('ASC');
}, onSortDescClick:function() {
  var menu = this.getMenu(), activeHeader = menu.activeHeader;
  activeHeader.setSortState('DESC');
}, getColumnMenu:function(headerContainer) {
  var menuItems = [], i = 0, item, items = headerContainer.query('\x3egridcolumn[hideable]'), itemsLn = items.length, menuItem;
  for (; i < itemsLn; i++) {
    item = items[i];
    menuItem = new Ext.menu.CheckItem({text:item.menuText || item.text, checked:!item.hidden, hideOnClick:false, headerId:item.id, menu:item.isGroupHeader ? this.getColumnMenu(item) : undefined, checkHandler:this.onColumnCheckChange, scope:this});
    menuItems.push(menuItem);
    item.on({destroy:Ext.Function.bind(menuItem.destroy, menuItem)});
  }
  return menuItems;
}, onColumnCheckChange:function(checkItem, checked) {
  var header = Ext.getCmp(checkItem.headerId);
  header[checked ? 'show' : 'hide']();
}, getColumnCount:function() {
  return this.getGridColumns().length;
}, getFullWidth:function() {
  var fullWidth = 0, headers = this.getVisibleGridColumns(), headersLn = headers.length, i = 0, header;
  for (; i < headersLn; i++) {
    header = headers[i];
    if (header.getDesiredWidth) {
      fullWidth += header.getDesiredWidth() || 0;
    } else {
      fullWidth += header.getWidth();
    }
  }
  return fullWidth;
}, clearOtherSortStates:function(activeHeader) {
  var headers = this.getGridColumns(), headersLn = headers.length, i = 0;
  for (; i < headersLn; i++) {
    if (headers[i] !== activeHeader) {
      headers[i].setSortState(null, true);
    }
  }
}, getVisibleGridColumns:function() {
  var allColumns = this.getGridColumns(), result = [], len = allColumns.length, i;
  for (i = 0; i < len; i++) {
    if (!allColumns[i].hidden) {
      result[result.length] = allColumns[i];
    }
  }
  return result;
}, getGridColumns:function(inResult, hiddenAncestor) {
  if (!inResult && this.gridDataColumns) {
    return this.gridDataColumns;
  }
  var me = this, result = inResult || [], items, i, len, item, lastVisibleColumn;
  hiddenAncestor = hiddenAncestor || me.hidden;
  if (me.items) {
    items = me.items.items;
    for (i = 0, len = items.length; i < len; i++) {
      item = items[i];
      if (item.isGroupHeader) {
        item.getGridColumns(result, hiddenAncestor);
      } else {
        item.hiddenAncestor = hiddenAncestor;
        result.push(item);
      }
    }
  }
  if (!inResult) {
    me.gridDataColumns = result;
  }
  if (!inResult && len) {
    for (i = 0, len = result.length; i < len; i++) {
      item = result[i];
      item.isFirstVisible = item.isLastVisible = false;
      if (!(item.hidden || item.hiddenAncestor)) {
        if (!lastVisibleColumn) {
          item.isFirstVisible = true;
        }
        lastVisibleColumn = item;
      }
    }
    if (lastVisibleColumn) {
      lastVisibleColumn.isLastVisible = true;
    }
  }
  return result;
}, getHideableColumns:function() {
  var me = this, result = me.hideableColumns;
  if (!result) {
    result = me.hideableColumns = me.query('[hideable]');
  }
  return result;
}, getHeaderIndex:function(header) {
  return this.columnManager.getHeaderIndex(header);
}, getHeaderAtIndex:function(index) {
  return this.columnManager.getHeaderAtIndex(index);
}, getVisibleHeaderClosestToIndex:function(index) {
  return this.columnManager.getVisibleHeaderClosestToIndex(index);
}, autoSizeColumn:function(header) {
  var view = this.view;
  if (view) {
    view.autoSizeColumn(header);
  }
}});
Ext.define('Ext.grid.column.Column', {extend:Ext.grid.header.Container, alias:'widget.gridcolumn', alternateClassName:'Ext.grid.Column', baseCls:Ext.baseCSSPrefix + 'column-header', hoverCls:Ext.baseCSSPrefix + 'column-header-over', handleWidth:4, sortState:null, possibleSortStates:['ASC', 'DESC'], childEls:['titleEl', 'triggerEl', 'textEl'], noWrap:true, renderTpl:'\x3cdiv id\x3d"{id}-titleEl" {tipMarkup}class\x3d"' + Ext.baseCSSPrefix + 'column-header-inner"\x3e' + '\x3cspan id\x3d"{id}-textEl" class\x3d"' + 
Ext.baseCSSPrefix + 'column-header-text' + '{childElCls}"\x3e' + '{text}' + '\x3c/span\x3e' + '\x3ctpl if\x3d"!menuDisabled"\x3e' + '\x3cdiv id\x3d"{id}-triggerEl" class\x3d"' + Ext.baseCSSPrefix + 'column-header-trigger' + '{childElCls}"\x3e\x3c/div\x3e' + '\x3c/tpl\x3e' + '\x3c/div\x3e' + '{%this.renderContainer(out,values)%}', dataIndex:null, text:'\x26#160;', menuText:null, emptyCellText:'\x26#160;', sortable:true, resizable:true, hideable:true, menuDisabled:false, renderer:false, editRenderer:false, 
align:'left', draggable:true, tooltipType:'qtip', initDraggable:Ext.emptyFn, tdCls:'', isHeader:true, isColumn:true, ascSortCls:Ext.baseCSSPrefix + 'column-header-sort-ASC', descSortCls:Ext.baseCSSPrefix + 'column-header-sort-DESC', componentLayout:'columncomponent', groupSubHeaderCls:Ext.baseCSSPrefix + 'group-sub-header', groupHeaderCls:Ext.baseCSSPrefix + 'group-header', clickTargetName:'titleEl', detachOnRemove:true, initResizable:Ext.emptyFn, initComponent:function() {
  var me = this, renderer, listeners;
  if (me.header != null) {
    me.text = me.header;
    me.header = null;
  }
  if (!me.triStateSort) {
    me.possibleSortStates.length = 2;
  }
  if (me.columns != null) {
    me.isGroupHeader = true;
    if (me.dataIndex) {
      Ext.Error.raise('Ext.grid.column.Column: Group header may not accept a dataIndex');
    }
    if (me.width && me.width !== Ext.grid.header.Container.prototype.defaultWidth || me.flex) {
      Ext.Error.raise('Ext.grid.column.Column: Group header does not support setting explicit widths or flexs. The group header width is calculated by the sum of its children.');
    }
    me.items = me.columns;
    me.columns = me.flex = me.width = null;
    me.cls = (me.cls || '') + ' ' + me.groupHeaderCls;
    me.sortable = me.resizable = false;
    me.align = 'center';
  } else {
    if (me.flex) {
      me.minWidth = me.minWidth || Ext.grid.plugin.HeaderResizer.prototype.minColWidth;
    }
  }
  me.addCls(Ext.baseCSSPrefix + 'column-header-align-' + me.align);
  renderer = me.renderer;
  if (renderer) {
    if (typeof renderer == 'string') {
      me.renderer = Ext.util.Format[renderer];
    }
    me.hasCustomRenderer = true;
  } else {
    if (me.defaultRenderer) {
      me.scope = me;
      me.renderer = me.defaultRenderer;
    }
  }
  me.callParent(arguments);
  listeners = {element:me.clickTargetName, click:me.onTitleElClick, contextmenu:me.onTitleElContextMenu, mouseenter:me.onTitleMouseOver, mouseleave:me.onTitleMouseOut, scope:me};
  if (me.resizable) {
    listeners.dblclick = me.onTitleElDblClick;
  }
  me.on(listeners);
}, onAdd:function(child) {
  if (child.isColumn) {
    child.isSubHeader = true;
    child.addCls(this.groupSubHeaderCls);
  }
  if (this.hidden) {
    child.hide();
  }
  this.callParent(arguments);
}, onRemove:function(child) {
  if (child.isSubHeader) {
    child.isSubHeader = false;
    child.removeCls(this.groupSubHeaderCls);
  }
  this.callParent(arguments);
}, initRenderData:function() {
  var me = this, tipMarkup = '', tip = me.tooltip, attr = me.tooltipType == 'qtip' ? 'data-qtip' : 'title';
  if (!Ext.isEmpty(tip)) {
    tipMarkup = attr + '\x3d"' + tip + '" ';
  }
  return Ext.applyIf(me.callParent(arguments), {text:me.text, menuDisabled:me.menuDisabled, tipMarkup:tipMarkup});
}, applyColumnState:function(state) {
  var me = this;
  me.applyColumnsState(state.columns);
  if (state.hidden != null) {
    me.hidden = state.hidden;
  }
  if (state.locked != null) {
    me.locked = state.locked;
  }
  if (state.sortable != null) {
    me.sortable = state.sortable;
  }
  if (state.width != null) {
    me.flex = null;
    me.width = state.width;
  } else {
    if (state.flex != null) {
      me.width = null;
      me.flex = state.flex;
    }
  }
}, getColumnState:function() {
  var me = this, items = me.items.items, iLen = items ? items.length : 0, i, columns = [], state = {id:me.getStateId()};
  me.savePropsToState(['hidden', 'sortable', 'locked', 'flex', 'width'], state);
  if (me.isGroupHeader) {
    for (i = 0; i < iLen; i++) {
      columns.push(items[i].getColumnState());
    }
    if (columns.length) {
      state.columns = columns;
    }
  } else {
    if (me.isSubHeader && me.ownerCt.hidden) {
      delete me.hidden;
    }
  }
  if ('width' in state) {
    delete state.flex;
  }
  return state;
}, getStateId:function() {
  return this.stateId || this.headerId;
}, setText:function(text) {
  this.text = text;
  if (this.rendered) {
    this.textEl.update(text);
  }
}, getIndex:function() {
  return this.isGroupColumn ? false : this.getOwnerHeaderCt().getHeaderIndex(this);
}, getVisibleIndex:function() {
  return this.isGroupColumn ? false : Ext.Array.indexOf(this.getOwnerHeaderCt().getVisibleGridColumns(), this);
}, beforeRender:function() {
  var me = this, grid = me.up('tablepanel');
  me.callParent();
  if (grid && (!me.sortable || grid.sortableColumns === false) && !me.groupable && !me.lockable && (grid.enableColumnHide === false || !me.getOwnerHeaderCt().getHideableColumns().length)) {
    me.menuDisabled = true;
  }
  me.protoEl.unselectable();
}, afterRender:function() {
  var me = this, triggerEl = me.triggerEl, triggerWidth;
  me.callParent(arguments);
  if (!Ext.isIE8 || !Ext.isStrict) {
    me.mon(me.getFocusEl(), {focus:me.onTitleMouseOver, blur:me.onTitleMouseOut, scope:me});
  }
  if (triggerEl && me.self.triggerElWidth === undefined) {
    triggerEl.setStyle('display', 'block');
    me.self.triggerElWidth = triggerEl.getWidth();
    triggerEl.setStyle('display', '');
  }
  me.keyNav = new Ext.util.KeyNav(me.el, {enter:me.onEnterKey, down:me.onDownKey, scope:me});
}, afterComponentLayout:function(width, height, oldWidth, oldHeight) {
  var me = this, ownerHeaderCt = me.getOwnerHeaderCt();
  me.callParent(arguments);
  if (ownerHeaderCt && (oldWidth != null || me.flex) && width !== oldWidth) {
    ownerHeaderCt.onHeaderResize(me, width, true);
  }
}, onDestroy:function() {
  var me = this;
  Ext.destroy(me.textEl, me.keyNav, me.field);
  me.keyNav = null;
  me.callParent(arguments);
}, onTitleMouseOver:function() {
  this.titleEl.addCls(this.hoverCls);
}, onTitleMouseOut:function() {
  this.titleEl.removeCls(this.hoverCls);
}, onDownKey:function(e) {
  if (this.triggerEl) {
    this.onTitleElClick(e, this.triggerEl.dom || this.el.dom);
  }
}, onEnterKey:function(e) {
  this.onTitleElClick(e, this.el.dom);
}, onTitleElDblClick:function(e, t) {
  var me = this, prev, leafColumns;
  if (me.isOnLeftEdge(e)) {
    prev = me.previousNode('gridcolumn:not([hidden]):not([isGroupHeader])');
    if (prev && prev.getOwnerHeaderCt() === me.getOwnerHeaderCt()) {
      prev.autoSize();
    }
  } else {
    if (me.isOnRightEdge(e)) {
      if (me.isGroupHeader && e.getPoint().isContainedBy(me.layout.innerCt)) {
        leafColumns = me.query('gridcolumn:not([hidden]):not([isGroupHeader])');
        this.getOwnerHeaderCt().autoSizeColumn(leafColumns[leafColumns.length - 1]);
        return;
      }
      me.autoSize();
    }
  }
}, autoSize:function() {
  var me = this, leafColumns, numLeaves, i, headerCt;
  if (me.isGroupHeader) {
    leafColumns = me.query('gridcolumn:not([hidden]):not([isGroupHeader])');
    numLeaves = leafColumns.length;
    headerCt = this.getOwnerHeaderCt();
    Ext.suspendLayouts();
    for (i = 0; i < numLeaves; i++) {
      headerCt.autoSizeColumn(leafColumns[i]);
    }
    Ext.resumeLayouts(true);
    return;
  }
  this.getOwnerHeaderCt().autoSizeColumn(this);
}, onTitleElClick:function(e, t) {
  var me = this, ownerHeaderCt = me.getOwnerHeaderCt();
  if (ownerHeaderCt && !ownerHeaderCt.ddLock) {
    if (me.triggerEl && (e.target === me.triggerEl.dom || t === me.triggerEl.dom || e.within(me.triggerEl))) {
      ownerHeaderCt.onHeaderTriggerClick(me, e, t);
    } else {
      if (e.getKey() || !me.isOnLeftEdge(e) && !me.isOnRightEdge(e)) {
        me.toggleSortState();
        ownerHeaderCt.onHeaderClick(me, e, t);
      }
    }
  }
}, onTitleElContextMenu:function(e, t) {
  var me = this, ownerHeaderCt = me.getOwnerHeaderCt();
  if (ownerHeaderCt && !ownerHeaderCt.ddLock) {
    ownerHeaderCt.onHeaderContextMenu(me, e, t);
  }
}, processEvent:function(type, view, cell, recordIndex, cellIndex, e) {
  return this.fireEvent.apply(this, arguments);
}, toggleSortState:function() {
  var me = this, idx, nextIdx;
  if (me.sortable) {
    idx = Ext.Array.indexOf(me.possibleSortStates, me.sortState);
    nextIdx = (idx + 1) % me.possibleSortStates.length;
    me.setSortState(me.possibleSortStates[nextIdx]);
  }
}, doSort:function(state) {
  var tablePanel = this.up('tablepanel'), store = tablePanel.store;
  if (tablePanel.ownerLockable && store.isNodeStore) {
    store = tablePanel.ownerLockable.lockedGrid.store;
  }
  store.sort({property:this.getSortParam(), direction:state});
}, getSortParam:function() {
  return this.dataIndex;
}, setSortState:function(state, skipClear, initial) {
  var me = this, ascCls = me.ascSortCls, descCls = me.descSortCls, ownerHeaderCt = me.getOwnerHeaderCt(), oldSortState = me.sortState;
  state = state || null;
  if (!me.sorting && oldSortState !== state && me.getSortParam() != null) {
    if (state && !initial) {
      me.sorting = true;
      me.doSort(state);
      me.sorting = false;
    }
    switch(state) {
      case 'DESC':
        me.addCls(descCls);
        me.removeCls(ascCls);
        break;
      case 'ASC':
        me.addCls(ascCls);
        me.removeCls(descCls);
        break;
      default:
        me.removeCls([ascCls, descCls]);
    }
    if (ownerHeaderCt && !me.triStateSort && !skipClear) {
      ownerHeaderCt.clearOtherSortStates(me);
    }
    me.sortState = state;
    if (me.triStateSort || state != null) {
      ownerHeaderCt.fireEvent('sortchange', ownerHeaderCt, me, state);
    }
  }
}, isHideable:function() {
  var result = {hideCandidate:this, result:this.hideable};
  if (result.result) {
    this.ownerCt.bubble(this.hasOtherMenuEnabledChildren, null, [result]);
  }
  return result.result;
}, hasOtherMenuEnabledChildren:function(result) {
  var visibleChildren, count;
  if (!this.isXType('headercontainer')) {
    result.result = false;
    return false;
  }
  visibleChildren = this.query('\x3e:not([hidden]):not([menuDisabled])');
  count = visibleChildren.length;
  if (Ext.Array.contains(visibleChildren, result.hideCandidate)) {
    count--;
  }
  if (count) {
    return false;
  }
  result.hideCandidate = this;
}, isLockable:function() {
  var result = {result:this.lockable !== false};
  if (result.result) {
    this.ownerCt.bubble(this.hasMultipleVisibleChildren, null, [result]);
  }
  return result.result;
}, isLocked:function() {
  return this.locked || !!this.up('[isColumn][locked]', '[isRootHeader]');
}, hasMultipleVisibleChildren:function(result) {
  if (!this.isXType('headercontainer')) {
    result.result = false;
    return false;
  }
  if (this.query('\x3e:not([hidden])').length > 1) {
    return false;
  }
}, hide:function(fromOwner) {
  var me = this, ownerHeaderCt = me.getOwnerHeaderCt(), owner = me.ownerCt, ownerIsGroup, item, items, len, i;
  if (!me.isVisible()) {
    return me;
  }
  if (!ownerHeaderCt) {
    me.callParent();
    return me;
  }
  if (ownerHeaderCt.forceFit) {
    me.visibleSiblingCount = ownerHeaderCt.getVisibleGridColumns().length - 1;
    if (me.flex) {
      me.savedWidth = me.getWidth();
      me.flex = null;
    }
  }
  ownerIsGroup = owner.isGroupHeader;
  if (ownerIsGroup && !fromOwner) {
    items = owner.query('\x3e:not([hidden])');
    if (items.length === 1 && items[0] == me) {
      me.ownerCt.hide();
      return;
    }
  }
  Ext.suspendLayouts();
  if (me.isGroupHeader) {
    items = me.items.items;
    for (i = 0, len = items.length; i < len; i++) {
      item = items[i];
      if (!item.hidden) {
        item.hide(true);
      }
    }
  }
  me.callParent();
  ownerHeaderCt.onHeaderHide(me);
  Ext.resumeLayouts(true);
  return me;
}, show:function(fromOwner, fromChild) {
  var me = this, ownerHeaderCt = me.getOwnerHeaderCt(), ownerCt = me.ownerCt, items, len, i, item, myWidth, availFlex, totalFlex, oldLen, defaultWidth = Ext.grid.header.Container.prototype.defaultWidth;
  if (me.isVisible()) {
    return me;
  }
  if (!me.rendered) {
    me.hidden = false;
    return;
  }
  availFlex = ownerHeaderCt.el.getViewSize().width - (ownerHeaderCt.view.el.dom.scrollHeight > ownerHeaderCt.view.el.dom.clientHeight ? Ext.getScrollbarSize().width : 0);
  if (ownerHeaderCt.forceFit) {
    items = Ext.ComponentQuery.query(':not([flex])', ownerHeaderCt.getVisibleGridColumns());
    if (items.length) {
      me.width = me.savedWidth || me.width || defaultWidth;
    } else {
      items = ownerHeaderCt.getVisibleGridColumns();
      len = items.length;
      oldLen = me.visibleSiblingCount;
      myWidth = me.savedWidth || me.width || defaultWidth;
      myWidth = Math.min(myWidth * (oldLen / len), defaultWidth, Math.max(availFlex - len * defaultWidth, defaultWidth));
      me.width = null;
      me.flex = myWidth;
      availFlex -= myWidth;
      totalFlex = 0;
      for (i = 0; i < len; i++) {
        item = items[i];
        item.flex = item.width || item.getWidth();
        totalFlex += item.flex;
        item.width = null;
      }
      for (i = 0; i < len; i++) {
        item = items[i];
        item.flex = item.flex / totalFlex * availFlex;
      }
    }
  }
  Ext.suspendLayouts();
  if (me.isSubHeader && ownerCt.hidden) {
    ownerCt.show(false, true);
  }
  me.callParent(arguments);
  if (me.isGroupHeader && fromChild !== true && !me.query(':not([hidden])').length) {
    items = me.items.items;
    for (i = 0, len = items.length; i < len; i++) {
      item = items[i];
      if (item.hidden) {
        item.show(true);
      }
    }
  }
  Ext.resumeLayouts(true);
  ownerCt = me.getOwnerHeaderCt();
  if (ownerCt) {
    ownerCt.onHeaderShow(me);
  }
}, getDesiredWidth:function() {
  var me = this;
  if (me.rendered && me.componentLayout && me.componentLayout.lastComponentSize) {
    return me.componentLayout.lastComponentSize.width;
  } else {
    if (me.flex) {
      return me.width;
    } else {
      return me.width;
    }
  }
}, getCellSelector:function() {
  return '.' + Ext.baseCSSPrefix + 'grid-cell-' + this.getItemId();
}, getCellInnerSelector:function() {
  return this.getCellSelector() + ' .' + Ext.baseCSSPrefix + 'grid-cell-inner';
}, isOnLeftEdge:function(e) {
  return e.getXY()[0] - this.getX() <= this.handleWidth;
}, isOnRightEdge:function(e) {
  return this.getX() + this.getWidth() - e.getXY()[0] <= this.handleWidth;
}, setMenuActive:function(isMenuOpen) {
  this.titleEl[isMenuOpen ? 'addCls' : 'removeCls'](this.headerOpenCls);
}});
Ext.define('Ext.grid.locking.HeaderContainer', {extend:Ext.grid.header.Container, constructor:function(lockable) {
  var me = this, events, event, eventNames = [], lockedGrid = lockable.lockedGrid, normalGrid = lockable.normalGrid;
  me.lockable = lockable;
  me.callParent();
  lockedGrid.columnManager.rootColumns = normalGrid.columnManager.rootColumns = lockable.columnManager = me.columnManager = new Ext.grid.ColumnManager(lockedGrid.headerCt, normalGrid.headerCt);
  events = lockedGrid.headerCt.events;
  for (event in events) {
    if (events.hasOwnProperty(event)) {
      eventNames.push(event);
    }
  }
  me.relayEvents(lockedGrid.headerCt, eventNames);
  me.relayEvents(normalGrid.headerCt, eventNames);
}, getRefItems:function() {
  return this.lockable.lockedGrid.headerCt.getRefItems().concat(this.lockable.normalGrid.headerCt.getRefItems());
}, getGridColumns:function() {
  return this.lockable.lockedGrid.headerCt.getGridColumns().concat(this.lockable.normalGrid.headerCt.getGridColumns());
}, getColumnsState:function() {
  var me = this, locked = me.lockable.lockedGrid.headerCt.getColumnsState(), normal = me.lockable.normalGrid.headerCt.getColumnsState();
  return locked.concat(normal);
}, applyColumnsState:function(columns) {
  var me = this, lockedGrid = me.lockable.lockedGrid, lockedHeaderCt = lockedGrid.headerCt, normalHeaderCt = me.lockable.normalGrid.headerCt, lockedCols = Ext.Array.toValueMap(lockedHeaderCt.items.items, 'headerId'), normalCols = Ext.Array.toValueMap(normalHeaderCt.items.items, 'headerId'), locked = [], normal = [], lockedWidth = 1, length = columns.length, i, existing, lockedDefault, col;
  for (i = 0; i < length; i++) {
    col = columns[i];
    lockedDefault = lockedCols[col.id];
    existing = lockedDefault || normalCols[col.id];
    if (existing) {
      if (existing.applyColumnState) {
        existing.applyColumnState(col);
      }
      if (existing.locked === undefined) {
        existing.locked = !!lockedDefault;
      }
      if (existing.locked) {
        locked.push(existing);
        if (!existing.hidden && typeof existing.width == 'number') {
          lockedWidth += existing.width;
        }
      } else {
        normal.push(existing);
      }
    }
  }
  if (locked.length + normal.length == lockedHeaderCt.items.getCount() + normalHeaderCt.items.getCount()) {
    lockedHeaderCt.removeAll(false);
    normalHeaderCt.removeAll(false);
    lockedHeaderCt.add(locked);
    normalHeaderCt.add(normal);
    lockedGrid.setWidth(lockedWidth);
  }
}});
Ext.define('Ext.grid.locking.View', {alternateClassName:'Ext.grid.LockingView', mixins:{observable:Ext.util.Observable}, isLockingView:true, eventRelayRe:/^(beforeitem|beforecontainer|item|container|cell|refresh)/, constructor:function(config) {
  var me = this, eventNames = [], eventRe = me.eventRelayRe, locked = config.locked.getView(), normal = config.normal.getView(), events, event;
  Ext.apply(me, {lockedView:locked, normalView:normal, lockedGrid:config.locked, normalGrid:config.normal, panel:config.panel});
  me.mixins.observable.constructor.call(me, config);
  events = locked.events;
  for (event in events) {
    if (events.hasOwnProperty(event) && eventRe.test(event)) {
      eventNames.push(event);
    }
  }
  me.relayEvents(locked, eventNames);
  me.relayEvents(normal, eventNames);
  normal.on({scope:me, itemmouseleave:me.onItemMouseLeave, itemmouseenter:me.onItemMouseEnter});
  locked.on({scope:me, itemmouseleave:me.onItemMouseLeave, itemmouseenter:me.onItemMouseEnter});
  me.panel.on({render:me.onPanelRender, scope:me});
}, onPanelRender:function() {
  var me = this, mask = me.loadMask, cfg = {target:me.panel, msg:me.loadingText, msgCls:me.loadingCls, useMsg:me.loadingUseMsg, store:me.panel.store};
  me.el = me.panel.body;
  me.fireEvent('render', me);
  if (mask) {
    if (Ext.isObject(mask)) {
      cfg = Ext.apply(cfg, mask);
    }
    me.loadMask = new Ext.LoadMask(cfg);
  }
}, getGridColumns:function() {
  var cols = this.lockedGrid.headerCt.getVisibleGridColumns();
  return cols.concat(this.normalGrid.headerCt.getVisibleGridColumns());
}, getEl:function(column) {
  return this.getViewForColumn(column).getEl();
}, getViewForColumn:function(column) {
  var view = this.lockedView, inLocked;
  view.headerCt.cascade(function(col) {
    if (col === column) {
      inLocked = true;
      return false;
    }
  });
  return inLocked ? view : this.normalView;
}, onItemMouseEnter:function(view, record) {
  var me = this, locked = me.lockedView, other = me.normalView, item;
  if (view.trackOver) {
    if (view !== locked) {
      other = locked;
    }
    item = other.getNode(record, false);
    other.highlightItem(item);
  }
}, onItemMouseLeave:function(view, record) {
  var me = this, locked = me.lockedView, other = me.normalView;
  if (view.trackOver) {
    if (view !== locked) {
      other = locked;
    }
    other.clearHighlight();
  }
}, relayFn:function(name, args) {
  args = args || [];
  var view = this.lockedView;
  view[name].apply(view, args);
  view = this.normalView;
  view[name].apply(view, args);
}, getSelectionModel:function() {
  return this.panel.getSelectionModel();
}, getStore:function() {
  return this.panel.store;
}, getNode:function(nodeInfo, dataRow) {
  return this.normalView.getNode(nodeInfo, dataRow);
}, getCell:function(record, column) {
  var view = this.getViewForColumn(column), row = view.getNode(record, true);
  return Ext.fly(row).down(column.getCellSelector());
}, indexOf:function(record) {
  var result = this.lockedView.indexOf(record);
  if (!result) {
    result = this.normalView.indexOf(record);
  }
  return result;
}, focus:function() {
  var p = this.getSelectionModel().getCurrentPosition(), v = p ? p.view : this.normalView;
  v.focus();
}, focusRow:function(row) {
  this.normalView.focusRow(row);
}, focusCell:function(position) {
  position.view.focusCell(position);
}, isVisible:function(deep) {
  return this.panel.isVisible(deep);
}, getRecord:function(node) {
  var result = this.lockedView.getRecord(node);
  if (!result) {
    result = this.normalView.getRecord(node);
  }
  return result;
}, scrollBy:function() {
  var normal = this.normalView;
  normal.scrollBy.apply(normal, arguments);
}, addElListener:function(eventName, fn, scope) {
  this.relayFn('addElListener', arguments);
}, refreshNode:function() {
  this.relayFn('refreshNode', arguments);
}, refresh:function() {
  this.relayFn('refresh', arguments);
}, bindStore:function() {
  this.relayFn('bindStore', arguments);
}, addRowCls:function() {
  this.relayFn('addRowCls', arguments);
}, removeRowCls:function() {
  this.relayFn('removeRowCls', arguments);
}, destroy:function() {
  var me = this, mask = me.loadMask;
  me.clearListeners();
  if (mask && mask.bindStore) {
    mask.bindStore(null);
  }
}});
Ext.define('Ext.grid.locking.Lockable', {alternateClassName:'Ext.grid.Lockable', syncRowHeight:true, headerCounter:0, scrollDelta:40, lockedGridCls:Ext.baseCSSPrefix + 'grid-inner-locked', unlockText:'Unlock', lockText:'Lock', bothCfgCopy:['invalidateScrollerOnRefresh', 'hideHeaders', 'enableColumnHide', 'enableColumnMove', 'enableColumnResize', 'sortableColumns', 'columnLines', 'rowLines'], normalCfgCopy:['verticalScroller', 'verticalScrollDock', 'verticalScrollerType', 'scroll'], lockedCfgCopy:[], 
determineXTypeToCreate:function(lockedSide) {
  var me = this, typeToCreate, xtypes, xtypesLn, xtype, superxtype;
  if (me.subGridXType) {
    typeToCreate = me.subGridXType;
  } else {
    if (!lockedSide) {
      return 'gridpanel';
    }
    xtypes = this.getXTypes().split('/');
    xtypesLn = xtypes.length;
    xtype = xtypes[xtypesLn - 1];
    superxtype = xtypes[xtypesLn - 2];
    if (superxtype !== 'tablepanel') {
      typeToCreate = superxtype;
    } else {
      typeToCreate = xtype;
    }
  }
  return typeToCreate;
}, injectLockable:function() {
  this.lockable = true;
  this.hasView = true;
  var me = this, scrollbarHeight = Ext.getScrollbarSize().height, store = me.store = Ext.StoreManager.lookup(me.store), selModel = me.getSelectionModel(), allFeatures, allPlugins, lockedGrid, normalGrid, i, columns, lockedHeaderCt, normalHeaderCt, lockedView, normalView, listeners, bufferedRenderer = me.findPlugin('bufferedrenderer');
  allFeatures = me.constructLockableFeatures();
  if (me.features) {
    me.features = null;
  }
  allPlugins = me.constructLockablePlugins();
  me.plugins = allPlugins.topPlugins;
  lockedGrid = Ext.apply({id:me.id + '-locked', isLocked:true, ownerLockable:me, xtype:me.determineXTypeToCreate(true), store:store, scrollerOwner:false, animate:false, scroll:scrollbarHeight ? false : 'vertical', selModel:selModel, border:false, cls:me.lockedGridCls, isLayoutRoot:function() {
    return false;
  }, features:allFeatures.lockedFeatures, plugins:allPlugins.lockedPlugins}, me.lockedGridConfig);
  normalGrid = Ext.apply({id:me.id + '-normal', isLocked:false, ownerLockable:me, xtype:me.determineXTypeToCreate(), store:store, scrollerOwner:false, selModel:selModel, border:false, isLayoutRoot:function() {
    return false;
  }, features:allFeatures.normalFeatures, plugins:allPlugins.normalPlugins}, me.normalGridConfig);
  me.addCls(Ext.baseCSSPrefix + 'grid-locked');
  Ext.copyTo(normalGrid, me, me.bothCfgCopy, true);
  Ext.copyTo(lockedGrid, me, me.bothCfgCopy, true);
  Ext.copyTo(normalGrid, me, me.normalCfgCopy, true);
  Ext.copyTo(lockedGrid, me, me.lockedCfgCopy, true);
  for (i = 0; i < me.normalCfgCopy.length; i++) {
    delete me[me.normalCfgCopy[i]];
  }
  for (i = 0; i < me.lockedCfgCopy.length; i++) {
    delete me[me.lockedCfgCopy[i]];
  }
  me.addEvents('processcolumns', 'lockcolumn', 'unlockcolumn');
  me.addStateEvents(['lockcolumn', 'unlockcolumn']);
  columns = me.processColumns(me.columns);
  lockedGrid.width = columns.lockedWidth + Ext.num(selModel.headerWidth, 0) + (columns.locked.items.length ? 1 : 0);
  lockedGrid.columns = columns.locked;
  normalGrid.columns = columns.normal;
  normalGrid.flex = 1;
  lockedGrid.viewConfig = me.lockedViewConfig || {};
  lockedGrid.viewConfig.loadingUseMsg = false;
  lockedGrid.viewConfig.loadMask = false;
  if (scrollbarHeight) {
    lockedGrid.viewConfig.style = 'border-bottom:' + scrollbarHeight + 'px solid #f6f6f6;' + (lockedGrid.viewConfig.style || '');
  }
  normalGrid.viewConfig = me.normalViewConfig || {};
  normalGrid.viewConfig.loadMask = false;
  if (me.viewConfig && me.viewConfig.id) {
    Ext.log.warn('id specified on Lockable viewConfig, it will be shared between both views: "' + me.viewConfig.id + '"');
  }
  Ext.applyIf(lockedGrid.viewConfig, me.viewConfig);
  Ext.applyIf(normalGrid.viewConfig, me.viewConfig);
  me.lockedGrid = Ext.ComponentManager.create(lockedGrid);
  if (me.isTree) {
    me.lockedGrid.getView().animate = false;
    normalGrid.store = me.lockedGrid.view.store;
    normalGrid.deferRowRender = false;
    normalGrid.viewConfig.stripeRows = me.lockedGrid.view.stripeRows;
    normalGrid.rowLines = me.lockedGrid.rowLines;
  }
  lockedView = me.lockedGrid.getView();
  normalGrid.viewConfig.lockingPartner = lockedView;
  me.normalGrid = Ext.ComponentManager.create(normalGrid);
  lockedView.lockingPartner = normalView = me.normalGrid.getView();
  me.view = new Ext.grid.locking.View({loadingText:normalView.loadingText, loadingCls:normalView.loadingCls, loadingUseMsg:normalView.loadingUseMsg, loadMask:me.loadMask !== false, locked:me.lockedGrid, normal:me.normalGrid, panel:me});
  listeners = bufferedRenderer ? {} : {scroll:{fn:me.onLockedViewScroll, element:'el', scope:me}};
  if (scrollbarHeight) {
    me.lockedGrid.on({afterlayout:me.afterLockedViewLayout, scope:me});
    lockedView.getOverflowStyle();
    if (lockedView.scrollFlags.y) {
      me.lockedGrid.headerCt.forceFit = true;
    } else {
      listeners.mousewheel = {fn:me.onLockedViewMouseWheel, element:'el', scope:me};
    }
  }
  lockedView.on(listeners);
  listeners = bufferedRenderer ? {} : {scroll:{fn:me.onNormalViewScroll, element:'el', scope:me}, scope:me};
  normalView.on(listeners);
  lockedHeaderCt = me.lockedGrid.headerCt;
  normalHeaderCt = me.normalGrid.headerCt;
  me.headerCt = me.view.headerCt = new Ext.grid.locking.HeaderContainer(me);
  lockedHeaderCt.lockedCt = true;
  lockedHeaderCt.lockableInjected = true;
  normalHeaderCt.lockableInjected = true;
  lockedHeaderCt.on({add:{buffer:1, scope:me, fn:me.onLockedHeaderAdd}, columnshow:me.onLockedHeaderShow, columnhide:me.onLockedHeaderHide, sortchange:me.onLockedHeaderSortChange, columnresize:me.onLockedHeaderResize, scope:me});
  normalHeaderCt.on({sortchange:me.onNormalHeaderSortChange, scope:me});
  me.modifyHeaderCt();
  me.items = [me.lockedGrid, me.normalGrid];
  me.relayHeaderCtEvents(lockedHeaderCt);
  me.relayHeaderCtEvents(normalHeaderCt);
  me.storeRelayers = me.relayEvents(store, ['filterchange']);
  me.layout = {type:'hbox', align:'stretch'};
}, getLockingViewConfig:function() {
  return {xclass:'Ext.grid.locking.View', locked:this.lockedGrid, normal:this.normalGrid, panel:this};
}, processColumns:function(columns) {
  var i, len, column, cp = this.dummyHdrCtr || (this.self.prototype.dummyHdrCtr = new Ext.grid.header.Container), lockedHeaders = [], normalHeaders = [], lockedHeaderCt = {itemId:'lockedHeaderCt', stretchMaxPartner:'^^\x3e\x3e#normalHeaderCt', items:lockedHeaders}, normalHeaderCt = {itemId:'normalHeaderCt', stretchMaxPartner:'^^\x3e\x3e#lockedHeaderCt', items:normalHeaders}, result = {lockedWidth:0, locked:lockedHeaderCt, normal:normalHeaderCt};
  if (Ext.isObject(columns)) {
    Ext.applyIf(lockedHeaderCt, columns);
    Ext.applyIf(normalHeaderCt, columns);
    Ext.apply(cp, columns);
    columns = columns.items;
  }
  for (i = 0, len = columns.length; i < len; ++i) {
    column = columns[i];
    if (!column.isComponent) {
      column = cp.lookupComponent(cp.applyDefaults(column));
    }
    column.processed = true;
    if (column.locked || column.autoLock) {
      if (!column.hidden) {
        result.lockedWidth += this.getColumnWidth(column) || cp.defaultWidth;
      }
      lockedHeaders.push(column);
    } else {
      normalHeaders.push(column);
    }
    if (!column.headerId) {
      column.headerId = (column.initialConfig || column).id || 'h' + ++this.headerCounter;
    }
  }
  this.fireEvent('processcolumns', this, lockedHeaders, normalHeaders);
  return result;
}, getColumnWidth:function(column) {
  var result = column.width || 0, subcols, len, i;
  if (column.flex) {
    Ext.Error.raise('Columns which are locked do NOT support a flex width. You must set a width on the ' + column.text + 'column.');
  }
  if (!result && column.isGroupHeader) {
    subcols = column.items.items;
    len = subcols.length;
    for (i = 0; i < len; i++) {
      result += this.getColumnWidth(subcols[i]);
    }
  }
  return result;
}, afterLockedViewLayout:function() {
  var me = this, lockedView = me.lockedGrid.getView(), lockedViewEl = lockedView.el.dom, spacerHeight = me.normalGrid.headerCt.tooNarrow ? Ext.getScrollbarSize().height : 0;
  if (lockedView.scrollFlags.x && lockedViewEl.scrollWidth > lockedViewEl.clientWidth) {
    spacerHeight = 0;
  }
  lockedView.el.dom.style.borderBottomWidth = spacerHeight + 'px';
  if (!Ext.isBorderBox) {
    lockedView.el.setHeight(lockedView.lastBox.height);
  }
}, onLockedViewMouseWheel:function(e) {
  var me = this, scrollDelta = -me.scrollDelta, deltaY = scrollDelta * e.getWheelDeltas().y, vertScrollerEl = me.lockedGrid.getView().el.dom, verticalCanScrollDown, verticalCanScrollUp;
  if (!me.ignoreMousewheel) {
    if (vertScrollerEl) {
      verticalCanScrollDown = vertScrollerEl.scrollTop !== vertScrollerEl.scrollHeight - vertScrollerEl.clientHeight;
      verticalCanScrollUp = vertScrollerEl.scrollTop !== 0;
    }
    if (deltaY < 0 && verticalCanScrollUp || deltaY > 0 && verticalCanScrollDown) {
      e.stopEvent();
      vertScrollerEl.scrollTop += deltaY;
      me.normalGrid.getView().el.dom.scrollTop = vertScrollerEl.scrollTop;
      me.onNormalViewScroll();
    }
  }
}, onLockedViewScroll:function() {
  var me = this, lockedView = me.lockedGrid.getView(), normalView = me.normalGrid.getView(), normalDom = normalView.el.dom, lockedDom = lockedView.el.dom, normalTable, lockedTable;
  if (normalDom.scrollTop !== lockedDom.scrollTop) {
    normalDom.scrollTop = lockedDom.scrollTop;
    if (me.store.buffered) {
      lockedTable = lockedView.el.child('table', true);
      normalTable = normalView.el.child('table', true);
      normalTable.style.position = 'absolute';
      normalTable.style.top = lockedTable.style.top;
    }
  }
}, onNormalViewScroll:function() {
  var me = this, lockedView = me.lockedGrid.getView(), normalView = me.normalGrid.getView(), normalDom = normalView.el.dom, lockedDom = lockedView.el.dom, normalTable, lockedTable;
  if (normalDom.scrollTop !== lockedDom.scrollTop) {
    lockedDom.scrollTop = normalDom.scrollTop;
    if (me.store.buffered) {
      lockedTable = lockedView.el.child('table', true);
      normalTable = normalView.el.child('table', true);
      lockedTable.style.position = 'absolute';
      lockedTable.style.top = normalTable.style.top;
    }
  }
}, syncRowHeights:function() {
  var me = this, i, lockedView = me.lockedGrid.getView(), normalView = me.normalGrid.getView(), lockedRowEls = lockedView.all.slice(), normalRowEls = normalView.all.slice(), ln = lockedRowEls.length, scrollTop;
  if (normalRowEls.length === ln) {
    for (i = 0; i < ln; i++) {
      normalView.syncRowHeights(lockedRowEls[i], normalRowEls[i]);
    }
    scrollTop = normalView.el.dom.scrollTop;
    normalView.el.dom.scrollTop = scrollTop;
    lockedView.el.dom.scrollTop = scrollTop;
  }
}, modifyHeaderCt:function() {
  var me = this;
  me.lockedGrid.headerCt.getMenuItems = me.getMenuItems(me.lockedGrid.headerCt.getMenuItems, true);
  me.normalGrid.headerCt.getMenuItems = me.getMenuItems(me.normalGrid.headerCt.getMenuItems, false);
  me.lockedGrid.headerCt.showMenuBy = Ext.Function.createInterceptor(me.lockedGrid.headerCt.showMenuBy, me.showMenuBy);
  me.normalGrid.headerCt.showMenuBy = Ext.Function.createInterceptor(me.normalGrid.headerCt.showMenuBy, me.showMenuBy);
}, onUnlockMenuClick:function() {
  this.unlock();
}, onLockMenuClick:function() {
  this.lock();
}, showMenuBy:function(t, header) {
  var menu = this.getMenu(), unlockItem = menu.down('#unlockItem'), lockItem = menu.down('#lockItem'), sep = unlockItem.prev();
  if (header.lockable === false) {
    sep.hide();
    unlockItem.hide();
    lockItem.hide();
  } else {
    sep.show();
    unlockItem.show();
    lockItem.show();
    if (!unlockItem.initialConfig.disabled) {
      unlockItem.setDisabled(header.lockable === false);
    }
    if (!lockItem.initialConfig.disabled) {
      lockItem.setDisabled(!header.isLockable());
    }
  }
}, getMenuItems:function(getMenuItems, locked) {
  var me = this, unlockText = me.unlockText, lockText = me.lockText, unlockCls = Ext.baseCSSPrefix + 'hmenu-unlock', lockCls = Ext.baseCSSPrefix + 'hmenu-lock', unlockHandler = Ext.Function.bind(me.onUnlockMenuClick, me), lockHandler = Ext.Function.bind(me.onLockMenuClick, me);
  return function() {
    var o = getMenuItems.call(this);
    o.push('-', {itemId:'unlockItem', cls:unlockCls, text:unlockText, handler:unlockHandler, disabled:!locked});
    o.push({itemId:'lockItem', cls:lockCls, text:lockText, handler:lockHandler, disabled:locked});
    return o;
  };
}, syncLockedWidth:function() {
  var me = this, locked = me.lockedGrid, lockedView = locked.view, lockedViewEl = lockedView.el.dom, normal = me.normalGrid, lockedColCount = locked.headerCt.getVisibleGridColumns().length, normalColCount = normal.headerCt.getVisibleGridColumns().length;
  Ext.suspendLayouts();
  if (normalColCount) {
    normal.show();
    if (lockedColCount) {
      if (!locked.headerCt.forceFit) {
        delete locked.flex;
        locked.setWidth(locked.headerCt.getFullWidth());
      }
      locked.addCls(me.lockedGridCls);
      locked.show();
    } else {
      locked.getView().refresh();
      locked.hide();
    }
    lockedView.el.setStyle(lockedView.getOverflowStyle());
    me.ignoreMousewheel = lockedView.scrollFlags.y;
  } else {
    normal.hide();
    lockedViewEl.style.borderBottomWidth = '0';
    locked.flex = 1;
    delete locked.width;
    locked.removeCls(me.lockedGridCls);
    locked.show();
    lockedView.el.setStyle(normal.view.getOverflowStyle());
    me.ignoreMousewheel = true;
  }
  Ext.resumeLayouts(true);
  return [lockedColCount, normalColCount];
}, onLockedHeaderAdd:function() {
  if (!this.ignoreAddLockedColumn) {
    this.syncLockedWidth();
  }
}, onLockedHeaderResize:function() {
  this.syncLockedWidth();
}, onLockedHeaderHide:function() {
  this.syncLockedWidth();
}, onLockedHeaderShow:function() {
  this.syncLockedWidth();
}, onLockedHeaderSortChange:function(headerCt, header, sortState) {
  if (sortState) {
    this.normalGrid.headerCt.clearOtherSortStates(null, true);
  }
}, onNormalHeaderSortChange:function(headerCt, header, sortState) {
  if (sortState) {
    this.lockedGrid.headerCt.clearOtherSortStates(null, true);
  }
}, lock:function(activeHd, toIdx) {
  var me = this, normalGrid = me.normalGrid, lockedGrid = me.lockedGrid, normalHCt = normalGrid.headerCt, lockedHCt = lockedGrid.headerCt, refreshFlags, ownerCt;
  activeHd = activeHd || normalHCt.getMenu().activeHeader;
  ownerCt = activeHd.ownerCt;
  if (!activeHd.isLockable()) {
    return;
  }
  if (activeHd.flex) {
    activeHd.width = activeHd.getWidth();
    activeHd.flex = null;
  }
  Ext.suspendLayouts();
  ownerCt.remove(activeHd, false);
  activeHd.locked = true;
  me.ignoreAddLockedColumn = true;
  if (Ext.isDefined(toIdx)) {
    lockedHCt.insert(toIdx, activeHd);
  } else {
    lockedHCt.add(activeHd);
  }
  me.ignoreAddLockedColumn = false;
  refreshFlags = me.syncLockedWidth();
  if (refreshFlags[0]) {
    lockedGrid.getView().refresh();
  }
  if (refreshFlags[1]) {
    normalGrid.getView().refresh();
  }
  Ext.resumeLayouts(true);
  me.fireEvent('lockcolumn', me, activeHd);
}, unlock:function(activeHd, toIdx) {
  var me = this, normalGrid = me.normalGrid, lockedGrid = me.lockedGrid, normalHCt = normalGrid.headerCt, lockedHCt = lockedGrid.headerCt, refreshFlags;
  if (!Ext.isDefined(toIdx)) {
    toIdx = 0;
  }
  activeHd = activeHd || lockedHCt.getMenu().activeHeader;
  Ext.suspendLayouts();
  activeHd.ownerCt.remove(activeHd, false);
  activeHd.locked = false;
  normalHCt.insert(toIdx, activeHd);
  refreshFlags = me.syncLockedWidth();
  if (refreshFlags[0]) {
    lockedGrid.getView().refresh();
  }
  if (refreshFlags[1]) {
    normalGrid.getView().refresh();
  }
  Ext.resumeLayouts(true);
  me.fireEvent('unlockcolumn', me, activeHd);
}, reconfigureLockable:function(store, columns) {
  var me = this, oldStore = me.store, lockedGrid = me.lockedGrid, normalGrid = me.normalGrid;
  Ext.suspendLayouts();
  if (columns) {
    lockedGrid.headerCt.removeAll();
    normalGrid.headerCt.removeAll();
    columns = me.processColumns(columns);
    me.ignoreAddLockedColumn = true;
    lockedGrid.headerCt.add(columns.locked.items);
    me.ignoreAddLockedColumn = false;
    normalGrid.headerCt.add(columns.normal.items);
    me.syncLockedWidth();
  }
  if (store && store !== oldStore) {
    store = Ext.data.StoreManager.lookup(store);
    me.store = store;
    lockedGrid.bindStore(store);
    normalGrid.bindStore(store);
  } else {
    lockedGrid.getView().refresh();
    normalGrid.getView().refresh();
  }
  Ext.resumeLayouts(true);
}, constructLockableFeatures:function() {
  var features = this.features, feature, featureClone, lockedFeatures, normalFeatures, i = 0, len;
  if (features) {
    lockedFeatures = [];
    normalFeatures = [];
    len = features.length;
    for (; i < len; i++) {
      feature = features[i];
      if (!feature.isFeature) {
        feature = Ext.create('feature.' + feature.ftype, feature);
      }
      switch(feature.lockableScope) {
        case 'locked':
          lockedFeatures.push(feature);
          break;
        case 'normal':
          normalFeatures.push(feature);
          break;
        default:
          feature.lockableScope = 'both';
          lockedFeatures.push(feature);
          normalFeatures.push(featureClone = feature.clone());
          featureClone.lockingPartner = feature;
          feature.lockingPartner = featureClone;
      }
    }
  }
  return {normalFeatures:normalFeatures, lockedFeatures:lockedFeatures};
}, constructLockablePlugins:function() {
  var plugins = this.plugins, plugin, normalPlugin, lockedPlugin, topPlugins, lockedPlugins, normalPlugins, i = 0, len;
  if (plugins) {
    topPlugins = [];
    lockedPlugins = [];
    normalPlugins = [];
    len = plugins.length;
    for (; i < len; i++) {
      plugin = plugins[i];
      switch(plugin.lockableScope) {
        case 'both':
          lockedPlugins.push(lockedPlugin = plugin.clonePlugin());
          normalPlugins.push(normalPlugin = plugin.clonePlugin());
          lockedPlugin.lockingPartner = normalPlugin;
          normalPlugin.lockingPartner = lockedPlugin;
          Ext.destroy(plugin);
          break;
        case 'locked':
          lockedPlugins.push(plugin);
          break;
        case 'normal':
          normalPlugins.push(plugin);
          break;
        default:
          topPlugins.push(plugin);
      }
    }
  }
  return {topPlugins:topPlugins, normalPlugins:normalPlugins, lockedPlugins:lockedPlugins};
}, destroyLockable:function() {
  Ext.destroy(this.view);
}}, function() {
  this.borrow(Ext.AbstractComponent, ['constructPlugin']);
});
Ext.define('Ext.grid.plugin.BufferedRenderer', {extend:Ext.AbstractPlugin, alias:'plugin.bufferedrenderer', lockableScope:'both', percentageFromEdge:0.35, variableRowHeight:false, numFromEdge:8, trailingBufferZone:10, leadingBufferZone:20, synchronousRender:true, scrollToLoadBuffer:200, viewSize:0, rowHeight:21, position:0, lastScrollDirection:1, bodyTop:0, init:function(grid) {
  var me = this, view = grid.view, viewListeners = {scroll:{fn:me.onViewScroll, element:'el', scope:me}, boxready:me.onViewResize, resize:me.onViewResize, refresh:me.onViewRefresh, scope:me, destroyable:true};
  if (!me.variableRowHeight && grid.ownerLockable) {
    grid.ownerLockable.syncRowHeight = false;
  }
  if (grid.isTree || grid.ownerLockable && grid.ownerLockable.isTree) {
    view.blockRefresh = false;
    view.loadMask = true;
  }
  if (view.positionBody) {
    viewListeners.refresh = me.onViewRefresh;
  }
  me.grid = grid;
  me.view = view;
  view.bufferedRenderer = me;
  view.preserveScrollOnRefresh = true;
  me.bindStore(view.dataSource);
  view.getViewRange = function() {
    return me.getViewRange();
  };
  me.position = 0;
  me.gridListeners = grid.on('reconfigure', me.onReconfigure, me);
  me.viewListeners = view.on(viewListeners);
}, bindStore:function(store) {
  var me = this;
  if (me.store) {
    me.unbindStore();
  }
  me.storeListeners = store.on({scope:me, clear:me.onStoreClear, destroyable:true});
  me.store = store;
  if (me.view.componentLayout.layoutCount) {
    me.onViewResize(me.view, 0, me.view.getHeight());
  }
}, onReconfigure:function(grid, store) {
  if (store && store !== this.store) {
    this.bindStore(store);
  }
}, unbindStore:function() {
  this.storeListeners.destroy();
  this.store = null;
}, onStoreClear:function() {
  var me = this;
  if (me.view.rendered && !me.store.isDestroyed) {
    if (me.scrollTop !== 0) {
      me.ignoreNextScrollEvent = true;
      me.view.el.dom.scrollTop = me.bodyTop = me.scrollTop = 0;
    }
    me.position = me.scrollHeight = 0;
    me.lastScrollDirection = me.scrollOffset = null;
    delete me.rowHeight;
  }
}, onViewRefresh:function() {
  var me = this, view = me.view, oldScrollHeight = me.scrollHeight, scrollHeight;
  if (view.all.getCount()) {
    delete me.rowHeight;
  }
  scrollHeight = me.getScrollHeight();
  if (!oldScrollHeight || scrollHeight != oldScrollHeight) {
    me.stretchView(view, scrollHeight);
  }
  if (me.scrollTop !== view.el.dom.scrollTop) {
    me.onViewScroll();
  } else {
    me.setBodyTop(me.bodyTop);
    if (view.all.getCount()) {
      me.viewSize = 0;
      me.onViewResize(view, null, view.getHeight());
    }
  }
}, onViewResize:function(view, width, height, oldWidth, oldHeight) {
  if (!oldHeight || height !== oldHeight) {
    var me = this, newViewSize;
    newViewSize = Math.ceil(height / me.rowHeight) + me.trailingBufferZone + me.leadingBufferZone;
    me.viewSize = me.setViewSize(newViewSize);
  }
}, stretchView:function(view, scrollRange) {
  var me = this, recordCount = me.store.buffered ? me.store.getTotalCount() : me.store.getCount();
  if (me.stretcher) {
    me.stretcher.dom.style.marginTop = scrollRange - 1 + 'px';
  } else {
    var el = view.el;
    if (view.refreshCounter) {
      view.fixedNodes++;
    }
    if (recordCount && me.view.all.endIndex === recordCount - 1) {
      scrollRange = me.bodyTop + view.body.dom.offsetHeight;
    }
    this.stretcher = el.createChild({style:{width:'1px', height:'1px', 'marginTop':scrollRange - 1 + 'px', left:0, position:'absolute'}}, el.dom.firstChild);
  }
}, setViewSize:function(viewSize) {
  if (viewSize !== this.viewSize) {
    this.scrollTop = this.view.el.dom.scrollTop;
    var me = this, store = me.store, elCount = me.view.all.getCount(), start, end, lockingPartner = me.lockingPartner;
    me.viewSize = store.viewSize = viewSize;
    if (elCount) {
      start = me.view.all.startIndex;
      end = Math.min(start + viewSize - 1, (store.buffered ? store.getTotalCount() : store.getCount()) - 1);
      if (lockingPartner) {
        lockingPartner.disable();
      }
      me.renderRange(start, end);
      if (lockingPartner) {
        lockingPartner.enable();
      }
    }
  }
  return viewSize;
}, getViewRange:function() {
  var me = this, rows = me.view.all, store = me.store;
  if (store.data.getCount()) {
    return store.getRange(rows.startIndex, rows.startIndex + (me.viewSize || me.store.defaultViewSize) - 1);
  } else {
    return [];
  }
}, scrollTo:function(recordIdx, doSelect, callback, scope) {
  var me = this, view = me.view, viewDom = view.el.dom, store = me.store, total = store.buffered ? store.getTotalCount() : store.getCount(), startIdx, endIdx, targetRec, targetRow, tableTop;
  recordIdx = Math.min(Math.max(recordIdx, 0), total - 1);
  startIdx = Math.max(Math.min(recordIdx - (me.leadingBufferZone + me.trailingBufferZone) / 2, total - me.viewSize + 1), 0);
  tableTop = startIdx * me.rowHeight;
  endIdx = Math.min(startIdx + me.viewSize - 1, total - 1);
  store.getRange(startIdx, endIdx, {callback:function(range, start, end) {
    me.renderRange(start, end, true);
    targetRec = store.data.getRange(recordIdx, recordIdx)[0];
    targetRow = view.getNode(targetRec, false);
    view.body.dom.style.top = tableTop + 'px';
    me.position = me.scrollTop = viewDom.scrollTop = tableTop = Math.min(Math.max(0, tableTop - view.body.getOffsetsTo(targetRow)[1]), viewDom.scrollHeight - viewDom.clientHeight);
    if (Ext.isIE) {
      viewDom.scrollTop = tableTop;
    }
    if (doSelect) {
      view.selModel.select(targetRec);
    }
    if (callback) {
      callback.call(scope || me, recordIdx, targetRec);
    }
  }});
}, onViewScroll:function(e, t) {
  var me = this, store = me.store, totalCount = store.buffered ? store.getTotalCount() : store.getCount(), vscrollDistance, scrollDirection, scrollTop = me.scrollTop = me.view.el.dom.scrollTop, scrollHandled = false;
  if (me.ignoreNextScrollEvent) {
    me.ignoreNextScrollEvent = false;
    return;
  }
  if (!(me.disabled || totalCount < me.viewSize)) {
    vscrollDistance = scrollTop - me.position;
    scrollDirection = vscrollDistance > 0 ? 1 : -1;
    if (Math.abs(vscrollDistance) >= 20 || scrollDirection !== me.lastScrollDirection) {
      me.lastScrollDirection = scrollDirection;
      me.handleViewScroll(me.lastScrollDirection);
      scrollHandled = true;
    }
  }
  if (!scrollHandled) {
    if (me.lockingPartner && me.lockingPartner.scrollTop !== scrollTop) {
      me.lockingPartner.view.el.dom.scrollTop = scrollTop;
    }
  }
}, handleViewScroll:function(direction) {
  var me = this, rows = me.view.all, store = me.store, viewSize = me.viewSize, totalCount = store.buffered ? store.getTotalCount() : store.getCount(), requestStart, requestEnd;
  if (direction == -1) {
    if (rows.startIndex) {
      if (me.getFirstVisibleRowIndex() - rows.startIndex < me.numFromEdge) {
        requestStart = Math.max(0, me.getLastVisibleRowIndex() + me.trailingBufferZone - viewSize);
      }
    }
  } else {
    if (rows.endIndex < totalCount - 1) {
      if (rows.endIndex - me.getLastVisibleRowIndex() < me.numFromEdge) {
        requestStart = Math.max(0, me.getFirstVisibleRowIndex() - me.trailingBufferZone);
      }
    }
  }
  if (requestStart != null) {
    requestEnd = Math.min(requestStart + viewSize - 1, totalCount - 1);
    if (requestStart !== rows.startIndex || requestEnd !== rows.endIndex) {
      me.renderRange(requestStart, requestEnd);
      return;
    }
  }
  if (me.lockingPartner && me.lockingPartner.view.el && me.lockingPartner.scrollTop !== me.scrollTop) {
    me.lockingPartner.view.el.dom.scrollTop = me.scrollTop;
  }
}, renderRange:function(start, end, forceSynchronous) {
  var me = this, store = me.store;
  if (store.rangeCached(start, end)) {
    me.cancelLoad();
    if (me.synchronousRender || forceSynchronous) {
      me.onRangeFetched(null, start, end);
    } else {
      if (!me.renderTask) {
        me.renderTask = new Ext.util.DelayedTask(me.onRangeFetched, me, null, false);
      }
      me.renderTask.delay(1, null, null, [null, start, end]);
    }
  } else {
    me.attemptLoad(start, end);
  }
}, onRangeFetched:function(range, start, end, fromLockingPartner) {
  var me = this, view = me.view, oldStart, rows = view.all, removeCount, increment = 0, calculatedTop = start * me.rowHeight, top, lockingPartner = me.lockingPartner;
  if (view.isDestroyed) {
    return;
  }
  if (!range) {
    range = me.store.getRange(start, end);
    if (!range) {
      return;
    }
  }
  if (start > rows.endIndex || end < rows.startIndex) {
    rows.clear(true);
    top = calculatedTop;
  }
  if (!rows.getCount()) {
    view.doAdd(range, start);
  } else {
    if (end > rows.endIndex) {
      removeCount = Math.max(start - rows.startIndex, 0);
      if (me.variableRowHeight) {
        increment = rows.item(rows.startIndex + removeCount, true).offsetTop;
      }
      rows.scroll(Ext.Array.slice(range, rows.endIndex + 1 - start), 1, removeCount, start, end);
      if (me.variableRowHeight) {
        top = me.bodyTop + increment;
      } else {
        top = calculatedTop;
      }
    } else {
      removeCount = Math.max(rows.endIndex - end, 0);
      oldStart = rows.startIndex;
      rows.scroll(Ext.Array.slice(range, 0, rows.startIndex - start), -1, removeCount, start, end);
      if (me.variableRowHeight) {
        top = me.bodyTop - rows.item(oldStart, true).offsetTop;
      } else {
        top = calculatedTop;
      }
    }
  }
  me.position = me.scrollTop;
  if (view.positionBody) {
    me.setBodyTop(top, calculatedTop);
  }
  if (lockingPartner && !lockingPartner.disabled && !fromLockingPartner) {
    lockingPartner.onRangeFetched(range, start, end, true);
    if (lockingPartner.scrollTop !== me.scrollTop) {
      lockingPartner.view.el.dom.scrollTop = me.scrollTop;
    }
  }
}, setBodyTop:function(bodyTop, calculatedTop) {
  var me = this, view = me.view, store = me.store, body = view.body.dom, delta;
  bodyTop = Math.floor(bodyTop);
  if (calculatedTop !== undefined) {
    delta = bodyTop - calculatedTop;
    bodyTop = calculatedTop;
  }
  body.style.position = 'absolute';
  body.style.top = (me.bodyTop = bodyTop) + 'px';
  if (delta) {
    me.scrollTop = me.position = view.el.dom.scrollTop -= delta;
  }
  if (view.all.endIndex === (store.buffered ? store.getTotalCount() : store.getCount()) - 1) {
    me.stretchView(view, me.bodyTop + body.offsetHeight);
  }
}, getFirstVisibleRowIndex:function(startRow, endRow, viewportTop, viewportBottom) {
  var me = this, view = me.view, rows = view.all, elements = rows.elements, clientHeight = view.el.dom.clientHeight, target, targetTop;
  if (rows.getCount() && me.variableRowHeight) {
    if (!arguments.length) {
      startRow = rows.startIndex;
      endRow = rows.endIndex;
      viewportTop = me.scrollTop;
      viewportBottom = viewportTop + clientHeight;
      if (me.bodyTop > viewportBottom || me.bodyTop + view.body.getHeight() < viewportTop) {
        return Math.floor(me.scrollTop / me.rowHeight);
      }
      target = startRow + Math.min(me.numFromEdge + (me.lastScrollDirection == -1 ? me.leadingBufferZone : me.trailingBufferZone), Math.floor((endRow - startRow) / 2));
    } else {
      target = startRow + Math.floor((endRow - startRow) / 2);
    }
    targetTop = me.bodyTop + elements[target].offsetTop;
    if (targetTop + elements[target].offsetHeight < viewportTop) {
      return me.getFirstVisibleRowIndex(target + 1, endRow, viewportTop, viewportBottom);
    }
    if (targetTop <= viewportTop) {
      return target;
    } else {
      if (target !== startRow) {
        return me.getFirstVisibleRowIndex(startRow, target - 1, viewportTop, viewportBottom);
      }
    }
  }
  return Math.floor(me.scrollTop / me.rowHeight);
}, getLastVisibleRowIndex:function(startRow, endRow, viewportTop, viewportBottom) {
  var me = this, view = me.view, rows = view.all, elements = rows.elements, clientHeight = view.el.dom.clientHeight, target, targetTop, targetBottom;
  if (rows.getCount() && me.variableRowHeight) {
    if (!arguments.length) {
      startRow = rows.startIndex;
      endRow = rows.endIndex;
      viewportTop = me.scrollTop;
      viewportBottom = viewportTop + clientHeight;
      if (me.bodyTop > viewportBottom || me.bodyTop + view.body.getHeight() < viewportTop) {
        return Math.floor(me.scrollTop / me.rowHeight) + Math.ceil(clientHeight / me.rowHeight);
      }
      target = endRow - Math.min(me.numFromEdge + (me.lastScrollDirection == 1 ? me.leadingBufferZone : me.trailingBufferZone), Math.floor((endRow - startRow) / 2));
    } else {
      target = startRow + Math.floor((endRow - startRow) / 2);
    }
    targetTop = me.bodyTop + elements[target].offsetTop;
    if (targetTop > viewportBottom) {
      return me.getLastVisibleRowIndex(startRow, target - 1, viewportTop, viewportBottom);
    }
    targetBottom = targetTop + elements[target].offsetHeight;
    if (targetBottom >= viewportBottom) {
      return target;
    } else {
      if (target !== endRow) {
        return me.getLastVisibleRowIndex(target + 1, endRow, viewportTop, viewportBottom);
      }
    }
  }
  return me.getFirstVisibleRowIndex() + Math.ceil(clientHeight / me.rowHeight);
}, getScrollHeight:function() {
  var me = this, view = me.view, store = me.store, doCalcHeight = !me.hasOwnProperty('rowHeight'), storeCount = me.store.getCount();
  if (!storeCount) {
    return 0;
  }
  if (doCalcHeight) {
    if (view.all.getCount()) {
      me.rowHeight = Math.floor(view.body.getHeight() / view.all.getCount());
    }
  }
  return this.scrollHeight = Math.floor((store.buffered ? store.getTotalCount() : store.getCount()) * me.rowHeight);
}, attemptLoad:function(start, end) {
  var me = this;
  if (me.scrollToLoadBuffer) {
    if (!me.loadTask) {
      me.loadTask = new Ext.util.DelayedTask(me.doAttemptLoad, me, []);
    }
    me.loadTask.delay(me.scrollToLoadBuffer, me.doAttemptLoad, me, [start, end]);
  } else {
    me.store.getRange(start, end, {callback:me.onRangeFetched, scope:me, fireEvent:false});
  }
}, cancelLoad:function() {
  if (this.loadTask) {
    this.loadTask.cancel();
  }
}, doAttemptLoad:function(start, end) {
  this.store.getRange(start, end, {callback:this.onRangeFetched, scope:this, fireEvent:false});
}, destroy:function() {
  var me = this, view = me.view;
  if (view && view.el) {
    view.el.un('scroll', me.onViewScroll, me);
  }
  Ext.destroy(me.viewListeners, me.storeListeners, me.gridListeners);
}});
Ext.define('Ext.layout.ClassList', function() {
  var splitWords = Ext.String.splitWords, toMap = Ext.Array.toMap;
  return {dirty:false, constructor:function(owner) {
    this.owner = owner;
    this.map = toMap(this.classes = splitWords(owner.el.className));
  }, add:function(cls) {
    var me = this;
    if (!me.map[cls]) {
      me.map[cls] = true;
      me.classes.push(cls);
      if (!me.dirty) {
        me.dirty = true;
        me.owner.markDirty();
      }
    }
  }, addMany:function(classes) {
    Ext.each(splitWords(classes), this.add, this);
  }, contains:function(cls) {
    return this.map[cls];
  }, flush:function() {
    this.owner.el.className = this.classes.join(' ');
    this.dirty = false;
  }, remove:function(cls) {
    var me = this;
    if (me.map[cls]) {
      delete me.map[cls];
      me.classes = Ext.Array.filter(me.classes, function(c) {
        return c != cls;
      });
      if (!me.dirty) {
        me.dirty = true;
        me.owner.markDirty();
      }
    }
  }, removeMany:function(classes) {
    var me = this, remove = toMap(splitWords(classes));
    me.classes = Ext.Array.filter(me.classes, function(c) {
      if (!remove[c]) {
        return true;
      }
      delete me.map[c];
      if (!me.dirty) {
        me.dirty = true;
        me.owner.markDirty();
      }
      return false;
    });
  }};
}());
Ext.define('Ext.util.Queue', {constructor:function() {
  this.clear();
}, add:function(obj) {
  var me = this, key = me.getKey(obj);
  if (!me.map[key]) {
    ++me.length;
    me.items.push(obj);
    me.map[key] = obj;
  }
  return obj;
}, clear:function() {
  var me = this, items = me.items;
  me.items = [];
  me.map = {};
  me.length = 0;
  return items;
}, contains:function(obj) {
  var key = this.getKey(obj);
  return this.map.hasOwnProperty(key);
}, getCount:function() {
  return this.length;
}, getKey:function(obj) {
  return obj.id;
}, remove:function(obj) {
  var me = this, key = me.getKey(obj), items = me.items, index;
  if (me.map[key]) {
    index = Ext.Array.indexOf(items, obj);
    Ext.Array.erase(items, index, 1);
    delete me.map[key];
    --me.length;
  }
  return obj;
}});
Ext.define('Ext.layout.ContextItem', {heightModel:null, widthModel:null, sizeModel:null, optOut:false, ownerSizePolicy:null, boxChildren:null, boxParent:null, isBorderBoxValue:null, children:[], dirty:null, dirtyCount:0, hasRawContent:true, isContextItem:true, isTopLevel:false, consumersContentHeight:0, consumersContentWidth:0, consumersContainerHeight:0, consumersContainerWidth:0, consumersHeight:0, consumersWidth:0, ownerCtContext:null, remainingChildDimensions:0, props:null, state:null, wrapsComponent:false, 
constructor:function(config) {
  var me = this, sizeModels = Ext.layout.SizeModel.sizeModels, configured = sizeModels.configured, shrinkWrap = sizeModels.shrinkWrap, el, lastBox, ownerCt, ownerCtContext, props, sizeModel, target, lastWidth, lastHeight, sameWidth, sameHeight, widthModel, heightModel, optOut;
  Ext.apply(me, config);
  el = me.el;
  me.id = el.id;
  me.flushedProps = {};
  me.props = props = {};
  me.styles = {};
  target = me.target;
  if (!target.isComponent) {
    lastBox = el.lastBox;
  } else {
    me.wrapsComponent = true;
    me.framing = target.frameSize || null;
    me.isComponentChild = target.ownerLayout && target.ownerLayout.isComponentLayout;
    lastBox = target.lastBox;
    ownerCt = target.ownerCt;
    if (ownerCt && (ownerCtContext = ownerCt.el && me.context.items[ownerCt.el.id])) {
      me.ownerCtContext = ownerCtContext;
    }
    me.sizeModel = sizeModel = target.getSizeModel(ownerCtContext && ownerCtContext.widthModel.pairsByHeightOrdinal[ownerCtContext.heightModel.ordinal]);
    me.widthModel = widthModel = sizeModel.width;
    me.heightModel = heightModel = sizeModel.height;
    if (lastBox && lastBox.invalid === false) {
      sameWidth = target.width === (lastWidth = lastBox.width);
      sameHeight = target.height === (lastHeight = lastBox.height);
      if (widthModel === shrinkWrap && heightModel === shrinkWrap) {
        optOut = true;
      } else {
        if (widthModel === configured && sameWidth) {
          optOut = heightModel === shrinkWrap || heightModel === configured && sameHeight;
        }
      }
      if (optOut) {
        me.optOut = true;
        props.width = lastWidth;
        props.height = lastHeight;
      }
    }
  }
  me.lastBox = lastBox;
}, init:function(full, options) {
  var me = this, oldProps = me.props, oldDirty = me.dirty, ownerCtContext = me.ownerCtContext, ownerLayout = me.target.ownerLayout, firstTime = !me.state, ret = full || firstTime, children, i, n, ownerCt, sizeModel, target, oldHeightModel = me.heightModel, oldWidthModel = me.widthModel, newHeightModel, newWidthModel, remainingCount = 0;
  me.dirty = me.invalid = false;
  me.props = {};
  me.remainingChildDimensions = 0;
  if (me.boxChildren) {
    me.boxChildren.length = 0;
  }
  if (!firstTime) {
    me.clearAllBlocks('blocks');
    me.clearAllBlocks('domBlocks');
  }
  if (!me.wrapsComponent) {
    return ret;
  }
  target = me.target;
  me.state = {};
  if (firstTime) {
    if (target.beforeLayout && target.beforeLayout !== Ext.emptyFn) {
      target.beforeLayout();
    }
    if (!ownerCtContext && (ownerCt = target.ownerCt)) {
      ownerCtContext = me.context.items[ownerCt.el.id];
    }
    if (ownerCtContext) {
      me.ownerCtContext = ownerCtContext;
      me.isBoxParent = target.ownerLayout.isItemBoxParent(me);
    } else {
      me.isTopLevel = true;
    }
    me.frameBodyContext = me.getEl('frameBody');
  } else {
    ownerCtContext = me.ownerCtContext;
    me.isTopLevel = !ownerCtContext;
    children = me.children;
    for (i = 0, n = children.length; i < n; ++i) {
      children[i].init(true);
    }
  }
  me.hasRawContent = !(target.isContainer && target.items.items.length > 0);
  if (full) {
    me.widthModel = me.heightModel = null;
    sizeModel = target.getSizeModel(ownerCtContext && ownerCtContext.widthModel.pairsByHeightOrdinal[ownerCtContext.heightModel.ordinal]);
    if (firstTime) {
      me.sizeModel = sizeModel;
    }
    me.widthModel = sizeModel.width;
    me.heightModel = sizeModel.height;
    if (ownerCtContext && !me.isComponentChild) {
      ownerCtContext.remainingChildDimensions += 2;
    }
  } else {
    if (oldProps) {
      me.recoverProp('x', oldProps, oldDirty);
      me.recoverProp('y', oldProps, oldDirty);
      if (me.widthModel.calculated) {
        me.recoverProp('width', oldProps, oldDirty);
      } else {
        if ('width' in oldProps) {
          ++remainingCount;
        }
      }
      if (me.heightModel.calculated) {
        me.recoverProp('height', oldProps, oldDirty);
      } else {
        if ('height' in oldProps) {
          ++remainingCount;
        }
      }
      if (ownerCtContext && !me.isComponentChild) {
        ownerCtContext.remainingChildDimensions += remainingCount;
      }
    }
  }
  if (oldProps && ownerLayout && ownerLayout.manageMargins) {
    me.recoverProp('margin-top', oldProps, oldDirty);
    me.recoverProp('margin-right', oldProps, oldDirty);
    me.recoverProp('margin-bottom', oldProps, oldDirty);
    me.recoverProp('margin-left', oldProps, oldDirty);
  }
  if (options) {
    newHeightModel = options.heightModel;
    newWidthModel = options.widthModel;
    if (newWidthModel && newHeightModel && oldWidthModel && oldHeightModel) {
      if (oldWidthModel.shrinkWrap && oldHeightModel.shrinkWrap) {
        if (newWidthModel.constrainedMax && newHeightModel.constrainedMin) {
          newHeightModel = null;
        }
      }
    }
    if (newWidthModel) {
      me.widthModel = newWidthModel;
    }
    if (newHeightModel) {
      me.heightModel = newHeightModel;
    }
    if (options.state) {
      Ext.apply(me.state, options.state);
    }
  }
  return ret;
}, initContinue:function(full) {
  var me = this, ownerCtContext = me.ownerCtContext, comp = me.target, widthModel = me.widthModel, hierarchyState = comp.getHierarchyState(), boxParent;
  if (widthModel.fixed) {
    hierarchyState.inShrinkWrapTable = false;
  } else {
    delete hierarchyState.inShrinkWrapTable;
  }
  if (full) {
    if (ownerCtContext && widthModel.shrinkWrap) {
      boxParent = ownerCtContext.isBoxParent ? ownerCtContext : ownerCtContext.boxParent;
      if (boxParent) {
        boxParent.addBoxChild(me);
      }
    } else {
      if (widthModel.natural) {
        me.boxParent = ownerCtContext;
      }
    }
  }
  return full;
}, initDone:function(containerLayoutDone) {
  var me = this, props = me.props, state = me.state;
  if (me.remainingChildDimensions === 0) {
    props.containerChildrenSizeDone = true;
  }
  if (containerLayoutDone) {
    props.containerLayoutDone = true;
  }
  if (me.boxChildren && me.boxChildren.length && me.widthModel.shrinkWrap) {
    me.el.setWidth(10000);
    state.blocks = (state.blocks || 0) + 1;
  }
}, initAnimation:function() {
  var me = this, target = me.target, ownerCtContext = me.ownerCtContext;
  if (ownerCtContext && ownerCtContext.isTopLevel) {
    me.animatePolicy = target.ownerLayout.getAnimatePolicy(me);
  } else {
    if (!ownerCtContext && target.isCollapsingOrExpanding && target.animCollapse) {
      me.animatePolicy = target.componentLayout.getAnimatePolicy(me);
    }
  }
  if (me.animatePolicy) {
    me.context.queueAnimation(me);
  }
}, addCls:function(newCls) {
  this.getClassList().addMany(newCls);
}, removeCls:function(removeCls) {
  this.getClassList().removeMany(removeCls);
}, addBlock:function(name, layout, propName) {
  var me = this, collection = me[name] || (me[name] = {}), blockedLayouts = collection[propName] || (collection[propName] = {});
  if (!blockedLayouts[layout.id]) {
    blockedLayouts[layout.id] = layout;
    ++layout.blockCount;
    ++me.context.blockCount;
  }
}, addBoxChild:function(boxChildItem) {
  var me = this, children, widthModel = boxChildItem.widthModel;
  boxChildItem.boxParent = this;
  boxChildItem.measuresBox = widthModel.shrinkWrap ? boxChildItem.hasRawContent : widthModel.natural;
  if (boxChildItem.measuresBox) {
    children = me.boxChildren;
    if (children) {
      children.push(boxChildItem);
    } else {
      me.boxChildren = [boxChildItem];
    }
  }
}, addPositionStyles:function(styles, props) {
  var x = props.x, y = props.y, count = 0;
  if (x !== undefined) {
    styles.left = x + 'px';
    ++count;
  }
  if (y !== undefined) {
    styles.top = y + 'px';
    ++count;
  }
  return count;
}, addTrigger:function(propName, inDom) {
  var me = this, name = inDom ? 'domTriggers' : 'triggers', collection = me[name] || (me[name] = {}), context = me.context, layout = context.currentLayout, triggers = collection[propName] || (collection[propName] = {});
  if (!triggers[layout.id]) {
    triggers[layout.id] = layout;
    ++layout.triggerCount;
    triggers = context.triggers[inDom ? 'dom' : 'data'];
    (triggers[layout.id] || (triggers[layout.id] = [])).push({item:this, prop:propName});
    if (me.props[propName] !== undefined) {
      if (!inDom || !(me.dirty && propName in me.dirty)) {
        ++layout.firedTriggers;
      }
    }
  }
}, boxChildMeasured:function() {
  var me = this, state = me.state, count = state.boxesMeasured = (state.boxesMeasured || 0) + 1;
  if (count == me.boxChildren.length) {
    state.clearBoxWidth = 1;
    ++me.context.progressCount;
    me.markDirty();
  }
}, borderNames:['border-top-width', 'border-right-width', 'border-bottom-width', 'border-left-width'], marginNames:['margin-top', 'margin-right', 'margin-bottom', 'margin-left'], paddingNames:['padding-top', 'padding-right', 'padding-bottom', 'padding-left'], trblNames:['top', 'right', 'bottom', 'left'], cacheMissHandlers:{borderInfo:function(me) {
  var info = me.getStyles(me.borderNames, me.trblNames);
  info.width = info.left + info.right;
  info.height = info.top + info.bottom;
  return info;
}, marginInfo:function(me) {
  var info = me.getStyles(me.marginNames, me.trblNames);
  info.width = info.left + info.right;
  info.height = info.top + info.bottom;
  return info;
}, paddingInfo:function(me) {
  var item = me.frameBodyContext || me, info = item.getStyles(me.paddingNames, me.trblNames);
  info.width = info.left + info.right;
  info.height = info.top + info.bottom;
  return info;
}}, checkCache:function(entry) {
  return this.cacheMissHandlers[entry](this);
}, clearAllBlocks:function(name) {
  var collection = this[name], propName;
  if (collection) {
    for (propName in collection) {
      this.clearBlocks(name, propName);
    }
  }
}, clearBlocks:function(name, propName) {
  var collection = this[name], blockedLayouts = collection && collection[propName], context, layout, layoutId;
  if (blockedLayouts) {
    delete collection[propName];
    context = this.context;
    for (layoutId in blockedLayouts) {
      layout = blockedLayouts[layoutId];
      --context.blockCount;
      if (!--layout.blockCount && !layout.pending && !layout.done) {
        context.queueLayout(layout);
      }
    }
  }
}, block:function(layout, propName) {
  this.addBlock('blocks', layout, propName);
}, domBlock:function(layout, propName) {
  this.addBlock('domBlocks', layout, propName);
}, fireTriggers:function(name, propName) {
  var collection = this[name], triggers = collection && collection[propName], context = this.context, layout, layoutId;
  if (triggers) {
    for (layoutId in triggers) {
      layout = triggers[layoutId];
      ++layout.firedTriggers;
      if (!layout.done && !layout.blockCount && !layout.pending) {
        context.queueLayout(layout);
      }
    }
  }
}, flush:function() {
  var me = this, dirty = me.dirty, state = me.state, targetEl = me.el;
  me.dirtyCount = 0;
  if (me.classList && me.classList.dirty) {
    me.classList.flush();
  }
  if ('attributes' in me) {
    targetEl.set(me.attributes);
    delete me.attributes;
  }
  if ('innerHTML' in me) {
    targetEl.innerHTML = me.innerHTML;
    delete me.innerHTML;
  }
  if (state && state.clearBoxWidth) {
    state.clearBoxWidth = 0;
    me.el.setStyle('width', null);
    if (!--state.blocks) {
      me.context.queueItemLayouts(me);
    }
  }
  if (dirty) {
    delete me.dirty;
    me.writeProps(dirty, true);
  }
}, flushAnimations:function() {
  var me = this, animateFrom = me.previousSize, target, targetAnim, duration, animateProps, anim, changeCount, j, propsLen, propName, oldValue, newValue;
  if (animateFrom) {
    target = me.target;
    targetAnim = target.layout && target.layout.animate;
    if (targetAnim) {
      duration = Ext.isNumber(targetAnim) ? targetAnim : targetAnim.duration;
    }
    animateProps = Ext.Object.getKeys(me.animatePolicy);
    anim = Ext.apply({}, {from:{}, to:{}, duration:duration || Ext.fx.Anim.prototype.duration}, targetAnim);
    for (changeCount = 0, j = 0, propsLen = animateProps.length; j < propsLen; j++) {
      propName = animateProps[j];
      oldValue = animateFrom[propName];
      newValue = me.peek(propName);
      if (oldValue != newValue) {
        propName = me.translateProps[propName] || propName;
        anim.from[propName] = oldValue;
        anim.to[propName] = newValue;
        ++changeCount;
      }
    }
    if (changeCount) {
      if (me.isCollapsingOrExpanding === 1) {
        target.componentLayout.undoLayout(me);
      } else {
        me.writeProps(anim.from);
      }
      me.el.animate(anim);
      Ext.fx.Manager.getFxQueue(me.el.id)[0].on({afteranimate:function() {
        if (me.isCollapsingOrExpanding === 1) {
          target.componentLayout.redoLayout(me);
          target.afterCollapse(true);
        } else {
          if (me.isCollapsingOrExpanding === 2) {
            target.afterExpand(true);
          }
        }
      }});
    }
  }
}, getBorderInfo:function() {
  var me = this, info = me.borderInfo;
  if (!info) {
    me.borderInfo = info = me.checkCache('borderInfo');
  }
  return info;
}, getClassList:function() {
  return this.classList || (this.classList = new Ext.layout.ClassList(this));
}, getEl:function(nameOrEl, owner) {
  var me = this, src, el, elContext;
  if (nameOrEl) {
    if (nameOrEl.dom) {
      el = nameOrEl;
    } else {
      src = me.target;
      if (owner) {
        src = owner;
      }
      el = src[nameOrEl];
      if (typeof el == 'function') {
        el = el.call(src);
        if (el === me.el) {
          return this;
        }
      }
    }
    if (el) {
      elContext = me.context.getEl(me, el);
    }
  }
  return elContext || null;
}, getFrameInfo:function() {
  var me = this, info = me.frameInfo, framing, border;
  if (!info) {
    framing = me.framing;
    border = me.getBorderInfo();
    me.frameInfo = info = framing ? {top:framing.top + border.top, right:framing.right + border.right, bottom:framing.bottom + border.bottom, left:framing.left + border.left, width:framing.width + border.width, height:framing.height + border.height} : border;
  }
  return info;
}, getMarginInfo:function() {
  var me = this, info = me.marginInfo, comp, manageMargins, margins, ownerLayout, ownerLayoutId;
  if (!info) {
    if (!me.wrapsComponent) {
      info = me.checkCache('marginInfo');
    } else {
      comp = me.target;
      ownerLayout = comp.ownerLayout;
      ownerLayoutId = ownerLayout ? ownerLayout.id : null;
      manageMargins = ownerLayout && ownerLayout.manageMargins;
      info = comp.margin$;
      if (info && info.ownerId !== ownerLayoutId) {
        info = null;
      }
      if (!info) {
        info = me.parseMargins(comp, comp.margin) || me.checkCache('marginInfo');
        if (manageMargins) {
          margins = me.parseMargins(comp, comp.margins, ownerLayout.defaultMargins);
          if (margins) {
            info = {top:info.top + margins.top, right:info.right + margins.right, bottom:info.bottom + margins.bottom, left:info.left + margins.left};
          }
          me.setProp('margin-top', 0);
          me.setProp('margin-right', 0);
          me.setProp('margin-bottom', 0);
          me.setProp('margin-left', 0);
        }
        info.ownerId = ownerLayoutId;
        comp.margin$ = info;
      }
      info.width = info.left + info.right;
      info.height = info.top + info.bottom;
    }
    me.marginInfo = info;
  }
  return info;
}, clearMarginCache:function() {
  delete this.marginInfo;
  delete this.target.margin$;
}, getPaddingInfo:function() {
  var me = this, info = me.paddingInfo;
  if (!info) {
    me.paddingInfo = info = me.checkCache('paddingInfo');
  }
  return info;
}, getProp:function(propName) {
  var me = this, result = me.props[propName];
  me.addTrigger(propName);
  return result;
}, getDomProp:function(propName) {
  var me = this, result = me.dirty && propName in me.dirty ? undefined : me.props[propName];
  me.addTrigger(propName, true);
  return result;
}, getStyle:function(styleName) {
  var me = this, styles = me.styles, info, value;
  if (styleName in styles) {
    value = styles[styleName];
  } else {
    info = me.styleInfo[styleName];
    value = me.el.getStyle(styleName);
    if (info && info.parseInt) {
      value = parseInt(value, 10) || 0;
    }
    styles[styleName] = value;
  }
  return value;
}, getStyles:function(styleNames, altNames) {
  var me = this, styleCache = me.styles, values = {}, hits = 0, n = styleNames.length, i, missing, missingAltNames, name, info, styleInfo, styles, value;
  altNames = altNames || styleNames;
  for (i = 0; i < n; ++i) {
    name = styleNames[i];
    if (name in styleCache) {
      values[altNames[i]] = styleCache[name];
      ++hits;
      if (i && hits == 1) {
        missing = styleNames.slice(0, i);
        missingAltNames = altNames.slice(0, i);
      }
    } else {
      if (hits) {
        (missing || (missing = [])).push(name);
        (missingAltNames || (missingAltNames = [])).push(altNames[i]);
      }
    }
  }
  if (hits < n) {
    missing = missing || styleNames;
    missingAltNames = missingAltNames || altNames;
    styleInfo = me.styleInfo;
    styles = me.el.getStyle(missing);
    for (i = missing.length; i--;) {
      name = missing[i];
      info = styleInfo[name];
      value = styles[name];
      if (info && info.parseInt) {
        value = parseInt(value, 10) || 0;
      }
      values[missingAltNames[i]] = value;
      styleCache[name] = value;
    }
  }
  return values;
}, hasProp:function(propName) {
  return this.getProp(propName) != null;
}, hasDomProp:function(propName) {
  return this.getDomProp(propName) != null;
}, invalidate:function(options) {
  this.context.queueInvalidate(this, options);
}, markDirty:function() {
  if (++this.dirtyCount == 1) {
    this.context.queueFlush(this);
  }
}, onBoxMeasured:function() {
  var boxParent = this.boxParent, state = this.state;
  if (boxParent && boxParent.widthModel.shrinkWrap && !state.boxMeasured && this.measuresBox) {
    state.boxMeasured = 1;
    boxParent.boxChildMeasured();
  }
}, parseMargins:function(comp, margins, defaultMargins) {
  if (margins === true) {
    margins = 5;
  }
  var type = typeof margins, ret;
  if (type == 'string' || type == 'number') {
    ret = comp.parseBox(margins);
  } else {
    if (margins || defaultMargins) {
      ret = {top:0, right:0, bottom:0, left:0};
      if (defaultMargins) {
        Ext.apply(ret, this.parseMargins(comp, defaultMargins));
      }
      if (margins) {
        margins = Ext.apply(ret, comp.parseBox(margins));
      }
    }
  }
  return ret;
}, peek:function(propName) {
  return this.props[propName];
}, recoverProp:function(propName, oldProps, oldDirty) {
  var me = this, props = me.props, dirty;
  if (propName in oldProps) {
    props[propName] = oldProps[propName];
    if (oldDirty && propName in oldDirty) {
      dirty = me.dirty || (me.dirty = {});
      dirty[propName] = oldDirty[propName];
    }
  }
}, redo:function(deep) {
  var me = this, items, len, i;
  me.revertProps(me.props);
  if (deep && me.wrapsComponent) {
    if (me.childItems) {
      for (i = 0, items = me.childItems, len = items.length; i < len; i++) {
        items[i].redo(deep);
      }
    }
    for (i = 0, items = me.children, len = items.length; i < len; i++) {
      items[i].redo();
    }
  }
}, removeEl:function(nameOrEl, owner) {
  var me = this, src, el;
  if (nameOrEl) {
    if (nameOrEl.dom) {
      el = nameOrEl;
    } else {
      src = me.target;
      if (owner) {
        src = owner;
      }
      el = src[nameOrEl];
      if (typeof el == 'function') {
        el = el.call(src);
        if (el === me.el) {
          return this;
        }
      }
    }
    if (el) {
      me.context.removeEl(me, el);
    }
  }
}, revertProps:function(props) {
  var name, flushed = this.flushedProps, reverted = {};
  for (name in props) {
    if (flushed.hasOwnProperty(name)) {
      reverted[name] = props[name];
    }
  }
  this.writeProps(reverted);
}, setAttribute:function(name, value) {
  var me = this;
  if (!me.attributes) {
    me.attributes = {};
  }
  me.attributes[name] = value;
  me.markDirty();
}, setBox:function(box) {
  var me = this;
  if ('left' in box) {
    me.setProp('x', box.left);
  }
  if ('top' in box) {
    me.setProp('y', box.top);
  }
  me.setSize(box.width, box.height);
}, setContentHeight:function(height, measured) {
  if (!measured && this.hasRawContent) {
    return 1;
  }
  return this.setProp('contentHeight', height);
}, setContentWidth:function(width, measured) {
  if (!measured && this.hasRawContent) {
    return 1;
  }
  return this.setProp('contentWidth', width);
}, setContentSize:function(width, height, measured) {
  return this.setContentWidth(width, measured) + this.setContentHeight(height, measured) == 2;
}, setProp:function(propName, value, dirty) {
  var me = this, valueType = typeof value, borderBox, info;
  if (valueType == 'undefined' || valueType === 'number' && isNaN(value)) {
    return 0;
  }
  if (me.props[propName] === value) {
    return 1;
  }
  me.props[propName] = value;
  ++me.context.progressCount;
  if (dirty === false) {
    me.fireTriggers('domTriggers', propName);
    me.clearBlocks('domBlocks', propName);
  } else {
    info = me.styleInfo[propName];
    if (info) {
      if (!me.dirty) {
        me.dirty = {};
      }
      if (propName == 'width' || propName == 'height') {
        borderBox = me.isBorderBoxValue;
        if (borderBox === null) {
          me.isBorderBoxValue = borderBox = !!me.el.isBorderBox();
        }
        if (!borderBox) {
          me.borderInfo || me.getBorderInfo();
          me.paddingInfo || me.getPaddingInfo();
        }
      }
      me.dirty[propName] = value;
      me.markDirty();
    }
  }
  me.fireTriggers('triggers', propName);
  me.clearBlocks('blocks', propName);
  return 1;
}, setHeight:function(height, dirty) {
  var me = this, comp = me.target, ownerCtContext = me.ownerCtContext, frameBody, frameInfo, min, oldHeight, rem;
  if (height < 0) {
    height = 0;
  }
  if (!me.wrapsComponent) {
    if (!me.setProp('height', height, dirty)) {
      return NaN;
    }
  } else {
    min = me.collapsedVert ? 0 : comp.minHeight || 0;
    height = Ext.Number.constrain(height, min, comp.maxHeight);
    oldHeight = me.props.height;
    if (!me.setProp('height', height, dirty)) {
      return NaN;
    }
    if (ownerCtContext && !me.isComponentChild && isNaN(oldHeight)) {
      rem = --ownerCtContext.remainingChildDimensions;
      if (!rem) {
        ownerCtContext.setProp('containerChildrenSizeDone', true);
      }
    }
    frameBody = me.frameBodyContext;
    if (frameBody) {
      frameInfo = me.getFrameInfo();
      frameBody.setHeight(height - frameInfo.height, dirty);
    }
  }
  return height;
}, setWidth:function(width, dirty) {
  var me = this, comp = me.target, ownerCtContext = me.ownerCtContext, frameBody, frameInfo, min, oldWidth, rem;
  if (width < 0) {
    width = 0;
  }
  if (!me.wrapsComponent) {
    if (!me.setProp('width', width, dirty)) {
      return NaN;
    }
  } else {
    min = me.collapsedHorz ? 0 : comp.minWidth || 0;
    width = Ext.Number.constrain(width, min, comp.maxWidth);
    oldWidth = me.props.width;
    if (!me.setProp('width', width, dirty)) {
      return NaN;
    }
    if (ownerCtContext && !me.isComponentChild && isNaN(oldWidth)) {
      rem = --ownerCtContext.remainingChildDimensions;
      if (!rem) {
        ownerCtContext.setProp('containerChildrenSizeDone', true);
      }
    }
    frameBody = me.frameBodyContext;
    if (frameBody) {
      frameInfo = me.getFrameInfo();
      frameBody.setWidth(width - frameInfo.width, dirty);
    }
  }
  return width;
}, setSize:function(width, height, dirty) {
  this.setWidth(width, dirty);
  this.setHeight(height, dirty);
}, translateProps:{x:'left', y:'top'}, undo:function(deep) {
  var me = this, items, len, i;
  me.revertProps(me.lastBox);
  if (deep && me.wrapsComponent) {
    if (me.childItems) {
      for (i = 0, items = me.childItems, len = items.length; i < len; i++) {
        items[i].undo(deep);
      }
    }
    for (i = 0, items = me.children, len = items.length; i < len; i++) {
      items[i].undo();
    }
  }
}, unsetProp:function(propName) {
  var dirty = this.dirty;
  delete this.props[propName];
  if (dirty) {
    delete dirty[propName];
  }
}, writeProps:function(dirtyProps, flushing) {
  if (!(dirtyProps && typeof dirtyProps == 'object')) {
    Ext.Logger.warn('writeProps expected dirtyProps to be an object');
    return;
  }
  var me = this, el = me.el, styles = {}, styleCount = 0, styleInfo = me.styleInfo, info, propName, numericValue, width = dirtyProps.width, height = dirtyProps.height, isBorderBox = me.isBorderBoxValue, target = me.target, max = Math.max, paddingWidth = 0, paddingHeight = 0, hasWidth, hasHeight, isAbsolute, scrollbarSize, style, targetEl;
  if ('displayed' in dirtyProps) {
    el.setDisplayed(dirtyProps.displayed);
  }
  for (propName in dirtyProps) {
    if (flushing) {
      me.fireTriggers('domTriggers', propName);
      me.clearBlocks('domBlocks', propName);
      me.flushedProps[propName] = 1;
    }
    info = styleInfo[propName];
    if (info && info.dom) {
      if (info.suffix && (numericValue = parseInt(dirtyProps[propName], 10))) {
        styles[propName] = numericValue + info.suffix;
      } else {
        styles[propName] = dirtyProps[propName];
      }
      ++styleCount;
    }
  }
  if ('x' in dirtyProps || 'y' in dirtyProps) {
    if (target.isComponent) {
      target.setPosition(dirtyProps.x, dirtyProps.y);
    } else {
      styleCount += me.addPositionStyles(styles, dirtyProps);
    }
  }
  if (!isBorderBox && (width > 0 || height > 0)) {
    if (!(me.borderInfo && me.paddingInfo)) {
      throw Error("Needed to have gotten the borderInfo and paddingInfo when the width or height was setProp'd");
    }
    if (!me.frameBodyContext) {
      paddingWidth = me.paddingInfo.width;
      paddingHeight = me.paddingInfo.height;
    }
    if (width) {
      width = max(parseInt(width, 10) - (me.borderInfo.width + paddingWidth), 0);
      styles.width = width + 'px';
      ++styleCount;
    }
    if (height) {
      height = max(parseInt(height, 10) - (me.borderInfo.height + paddingHeight), 0);
      styles.height = height + 'px';
      ++styleCount;
    }
  }
  if (me.wrapsComponent && Ext.isIE9 && Ext.isStrict) {
    if ((hasWidth = width !== undefined && me.hasOverflowY) || (hasHeight = height !== undefined && me.hasOverflowX)) {
      isAbsolute = me.isAbsolute;
      if (isAbsolute === undefined) {
        isAbsolute = false;
        targetEl = me.target.getTargetEl();
        style = targetEl.getStyle('position');
        if (style == 'absolute') {
          style = targetEl.getStyle('box-sizing');
          isAbsolute = style == 'border-box';
        }
        me.isAbsolute = isAbsolute;
      }
      if (isAbsolute) {
        scrollbarSize = Ext.getScrollbarSize();
        if (hasWidth) {
          width = parseInt(width, 10) + scrollbarSize.width;
          styles.width = width + 'px';
          ++styleCount;
        }
        if (hasHeight) {
          height = parseInt(height, 10) + scrollbarSize.height;
          styles.height = height + 'px';
          ++styleCount;
        }
      }
    }
  }
  if (styleCount) {
    el.setStyle(styles);
  }
}}, function() {
  var px = {dom:true, parseInt:true, suffix:'px'}, isDom = {dom:true}, faux = {dom:false};
  this.prototype.styleInfo = {containerChildrenSizeDone:faux, containerLayoutDone:faux, displayed:faux, done:faux, x:faux, y:faux, columnWidthsDone:faux, left:px, top:px, right:px, bottom:px, width:px, height:px, 'border-top-width':px, 'border-right-width':px, 'border-bottom-width':px, 'border-left-width':px, 'margin-top':px, 'margin-right':px, 'margin-bottom':px, 'margin-left':px, 'padding-top':px, 'padding-right':px, 'padding-bottom':px, 'padding-left':px, 'line-height':isDom, display:isDom};
});
Ext.define('Ext.layout.Context', {remainingLayouts:0, state:0, constructor:function(config) {
  var me = this;
  Ext.apply(me, config);
  me.items = {};
  me.layouts = {};
  me.blockCount = 0;
  me.cycleCount = 0;
  me.flushCount = 0;
  me.calcCount = 0;
  me.animateQueue = me.newQueue();
  me.completionQueue = me.newQueue();
  me.finalizeQueue = me.newQueue();
  me.finishQueue = me.newQueue();
  me.flushQueue = me.newQueue();
  me.invalidateData = {};
  me.layoutQueue = me.newQueue();
  me.invalidQueue = [];
  me.triggers = {data:{}, dom:{}};
}, callLayout:function(layout, methodName) {
  this.currentLayout = layout;
  layout[methodName](this.getCmp(layout.owner));
}, cancelComponent:function(comp, isChild, isDestroying) {
  var me = this, components = comp, isArray = !comp.isComponent, length = isArray ? components.length : 1, i, k, klen, items, layout, newQueue, oldQueue, entry, temp, ownerCtContext;
  for (i = 0; i < length; ++i) {
    if (isArray) {
      comp = components[i];
    }
    if (isDestroying && comp.ownerCt) {
      ownerCtContext = this.items[comp.ownerCt.el.id];
      if (ownerCtContext) {
        Ext.Array.remove(ownerCtContext.childItems, me.getCmp(comp));
      }
    }
    if (!isChild) {
      oldQueue = me.invalidQueue;
      klen = oldQueue.length;
      if (klen) {
        me.invalidQueue = newQueue = [];
        for (k = 0; k < klen; ++k) {
          entry = oldQueue[k];
          temp = entry.item.target;
          if (temp != comp && !temp.isDescendant(comp)) {
            newQueue.push(entry);
          }
        }
      }
    }
    layout = comp.componentLayout;
    me.cancelLayout(layout);
    if (layout.getLayoutItems) {
      items = layout.getLayoutItems();
      if (items.length) {
        me.cancelComponent(items, true);
      }
    }
    if (comp.isContainer && !comp.collapsed) {
      layout = comp.layout;
      me.cancelLayout(layout);
      items = layout.getVisibleItems();
      if (items.length) {
        me.cancelComponent(items, true);
      }
    }
  }
}, cancelLayout:function(layout) {
  var me = this;
  me.completionQueue.remove(layout);
  me.finalizeQueue.remove(layout);
  me.finishQueue.remove(layout);
  me.layoutQueue.remove(layout);
  if (layout.running) {
    me.layoutDone(layout);
  }
  layout.ownerContext = null;
}, clearTriggers:function(layout, inDom) {
  var id = layout.id, collection = this.triggers[inDom ? 'dom' : 'data'], triggers = collection && collection[id], length = triggers && triggers.length || 0, i, item, trigger;
  for (i = 0; i < length; ++i) {
    trigger = triggers[i];
    item = trigger.item;
    collection = inDom ? item.domTriggers : item.triggers;
    delete collection[trigger.prop][id];
  }
}, flush:function() {
  var me = this, items = me.flushQueue.clear(), length = items.length, i;
  if (length) {
    ++me.flushCount;
    for (i = 0; i < length; ++i) {
      items[i].flush();
    }
  }
}, flushAnimations:function() {
  var me = this, items = me.animateQueue.clear(), len = items.length, i;
  if (len) {
    for (i = 0; i < len; i++) {
      if (items[i].target.animate !== false) {
        items[i].flushAnimations();
      }
    }
    Ext.fx.Manager.runner();
  }
}, flushInvalidates:function() {
  var me = this, queue = me.invalidQueue, length = queue && queue.length, comp, components, entry, i;
  me.invalidQueue = [];
  if (length) {
    components = [];
    for (i = 0; i < length; ++i) {
      comp = (entry = queue[i]).item.target;
      if (!comp.container.isDetachedBody) {
        components.push(comp);
        if (entry.options) {
          me.invalidateData[comp.id] = entry.options;
        }
      }
    }
    me.invalidate(components, null);
  }
}, flushLayouts:function(queueName, methodName, dontClear) {
  var me = this, layouts = dontClear ? me[queueName].items : me[queueName].clear(), length = layouts.length, i, layout;
  if (length) {
    for (i = 0; i < length; ++i) {
      layout = layouts[i];
      if (!layout.running) {
        me.callLayout(layout, methodName);
      }
    }
    me.currentLayout = null;
  }
}, getCmp:function(cmp) {
  return this.getItem(cmp, cmp.el);
}, getEl:function(parent, el) {
  var item = this.getItem(el, el);
  if (!item.parent) {
    item.parent = parent;
    if (parent.children.length) {
      parent.children.push(item);
    } else {
      parent.children = [item];
    }
  }
  return item;
}, getItem:function(target, el) {
  var id = el.id, items = this.items, item = items[id] || (items[id] = new Ext.layout.ContextItem({context:this, target:target, el:el}));
  return item;
}, handleFailure:function() {
  var layouts = this.layouts, layout, key;
  Ext.failedLayouts = (Ext.failedLayouts || 0) + 1;
  for (key in layouts) {
    layout = layouts[key];
    if (layouts.hasOwnProperty(key)) {
      layout.running = false;
      layout.ownerContext = null;
    }
  }
  if (Ext.repoDevMode && !this.pageAnalyzerMode) {
    Ext.Error.raise('Layout run failed');
  } else {
    Ext.log.error('Layout run failed');
  }
}, invalidate:function(components, full) {
  var me = this, isArray = !components.isComponent, containerLayoutDone, firstTime, i, comp, item, items, length, componentLayout, layout, invalidateOptions, token;
  for (i = 0, length = isArray ? components.length : 1; i < length; ++i) {
    comp = isArray ? components[i] : components;
    if (comp.rendered && !comp.hidden) {
      item = me.getCmp(comp);
      componentLayout = comp.componentLayout;
      firstTime = !componentLayout.ownerContext;
      layout = comp.isContainer && !comp.collapsed ? comp.layout : null;
      invalidateOptions = me.invalidateData[item.id];
      delete me.invalidateData[item.id];
      token = item.init(full, invalidateOptions);
      if (invalidateOptions) {
        me.processInvalidate(invalidateOptions, item, 'before');
      }
      if (componentLayout.beforeLayoutCycle) {
        componentLayout.beforeLayoutCycle(item);
      }
      if (layout && layout.beforeLayoutCycle) {
        layout.beforeLayoutCycle(item);
      }
      token = item.initContinue(token);
      containerLayoutDone = true;
      if (componentLayout.getLayoutItems) {
        componentLayout.renderChildren();
        items = componentLayout.getLayoutItems();
        if (items.length) {
          me.invalidate(items, true);
        }
      }
      if (layout) {
        containerLayoutDone = false;
        layout.renderChildren();
        items = layout.getVisibleItems();
        if (items.length) {
          me.invalidate(items, true);
        }
      }
      item.initDone(containerLayoutDone);
      me.resetLayout(componentLayout, item, firstTime);
      if (layout) {
        me.resetLayout(layout, item, firstTime);
      }
      item.initAnimation();
      if (invalidateOptions) {
        me.processInvalidate(invalidateOptions, item, 'after');
      }
    }
  }
  me.currentLayout = null;
}, layoutDone:function(layout) {
  var ownerContext = layout.ownerContext;
  layout.running = false;
  if (layout.isComponentLayout) {
    if (ownerContext.measuresBox) {
      ownerContext.onBoxMeasured();
    }
    ownerContext.setProp('done', true);
  } else {
    ownerContext.setProp('containerLayoutDone', true);
  }
  --this.remainingLayouts;
  ++this.progressCount;
}, newQueue:function() {
  return new Ext.util.Queue;
}, processInvalidate:function(options, item, name) {
  if (options[name]) {
    var me = this, currentLayout = me.currentLayout;
    me.currentLayout = options.layout || null;
    options[name](item, options);
    me.currentLayout = currentLayout;
  }
}, queueAnimation:function(item) {
  this.animateQueue.add(item);
}, queueCompletion:function(layout) {
  this.completionQueue.add(layout);
}, queueFinalize:function(layout) {
  this.finalizeQueue.add(layout);
}, queueFlush:function(item) {
  this.flushQueue.add(item);
}, chainFns:function(oldOptions, newOptions, funcName) {
  var me = this, oldLayout = oldOptions.layout, newLayout = newOptions.layout, oldFn = oldOptions[funcName], newFn = newOptions[funcName];
  return function(contextItem) {
    var prev = me.currentLayout;
    if (oldFn) {
      me.currentLayout = oldLayout;
      oldFn.call(oldOptions.scope || oldOptions, contextItem, oldOptions);
    }
    me.currentLayout = newLayout;
    newFn.call(newOptions.scope || newOptions, contextItem, newOptions);
    me.currentLayout = prev;
  };
}, queueInvalidate:function(item, options) {
  var me = this, newQueue = [], oldQueue = me.invalidQueue, index = oldQueue.length, comp, old, oldComp, oldOptions, oldState;
  if (item.isComponent) {
    item = me.getCmp(comp = item);
  } else {
    comp = item.target;
  }
  item.invalid = true;
  while (index--) {
    old = oldQueue[index];
    oldComp = old.item.target;
    if (comp.isDescendant(oldComp)) {
      return;
    }
    if (oldComp == comp) {
      if (!(oldOptions = old.options)) {
        old.options = options;
      } else {
        if (options) {
          if (options.widthModel) {
            oldOptions.widthModel = options.widthModel;
          }
          if (options.heightModel) {
            oldOptions.heightModel = options.heightModel;
          }
          if (!(oldState = oldOptions.state)) {
            oldOptions.state = options.state;
          } else {
            if (options.state) {
              Ext.apply(oldState, options.state);
            }
          }
          if (options.before) {
            oldOptions.before = me.chainFns(oldOptions, options, 'before');
          }
          if (options.after) {
            oldOptions.after = me.chainFns(oldOptions, options, 'after');
          }
        }
      }
      return;
    }
    if (!oldComp.isDescendant(comp)) {
      newQueue.push(old);
    }
  }
  newQueue.push({item:item, options:options});
  me.invalidQueue = newQueue;
}, queueItemLayouts:function(item) {
  var comp = item.isComponent ? item : item.target, layout = comp.componentLayout;
  if (!layout.pending && !layout.invalid && !layout.done) {
    this.queueLayout(layout);
  }
  layout = comp.layout;
  if (layout && !layout.pending && !layout.invalid && !layout.done) {
    this.queueLayout(layout);
  }
}, queueLayout:function(layout) {
  this.layoutQueue.add(layout);
  layout.pending = true;
}, removeEl:function(parent, el) {
  var id = el.id, children = parent.children, items = this.items;
  if (children) {
    Ext.Array.remove(children, items[id]);
  }
  delete items[id];
}, resetLayout:function(layout, ownerContext, firstTime) {
  var me = this;
  me.currentLayout = layout;
  layout.done = false;
  layout.pending = true;
  layout.firedTriggers = 0;
  me.layoutQueue.add(layout);
  if (firstTime) {
    me.layouts[layout.id] = layout;
    layout.running = true;
    if (layout.finishedLayout) {
      me.finishQueue.add(layout);
    }
    ++me.remainingLayouts;
    ++layout.layoutCount;
    layout.ownerContext = ownerContext;
    layout.beginCount = 0;
    layout.blockCount = 0;
    layout.calcCount = 0;
    layout.triggerCount = 0;
    if (!layout.initialized) {
      layout.initLayout();
    }
    layout.beginLayout(ownerContext);
  } else {
    ++layout.beginCount;
    if (!layout.running) {
      ++me.remainingLayouts;
      layout.running = true;
      if (layout.isComponentLayout) {
        ownerContext.unsetProp('done');
      }
      me.completionQueue.remove(layout);
      me.finalizeQueue.remove(layout);
    }
  }
  layout.beginLayoutCycle(ownerContext, firstTime);
}, run:function() {
  var me = this, flushed = false, watchDog = 100;
  me.flushInvalidates();
  me.state = 1;
  me.totalCount = me.layoutQueue.getCount();
  me.flush();
  while ((me.remainingLayouts || me.invalidQueue.length) && watchDog--) {
    if (me.invalidQueue.length) {
      me.flushInvalidates();
    }
    if (me.runCycle()) {
      flushed = false;
    } else {
      if (!flushed) {
        me.flush();
        flushed = true;
        me.flushLayouts('completionQueue', 'completeLayout');
      } else {
        if (!me.invalidQueue.length) {
          me.state = 2;
          break;
        }
      }
    }
    if (!(me.remainingLayouts || me.invalidQueue.length)) {
      me.flush();
      me.flushLayouts('completionQueue', 'completeLayout');
      me.flushLayouts('finalizeQueue', 'finalizeLayout');
    }
  }
  return me.runComplete();
}, runComplete:function() {
  var me = this;
  me.state = 2;
  if (me.remainingLayouts) {
    me.handleFailure();
    return false;
  }
  me.flush();
  me.flushLayouts('finishQueue', 'finishedLayout', true);
  me.flushLayouts('finishQueue', 'notifyOwner');
  me.flush();
  me.flushAnimations();
  return true;
}, runCycle:function() {
  var me = this, layouts = me.layoutQueue.clear(), length = layouts.length, i;
  ++me.cycleCount;
  me.progressCount = 0;
  for (i = 0; i < length; ++i) {
    me.runLayout(me.currentLayout = layouts[i]);
  }
  me.currentLayout = null;
  return me.progressCount > 0;
}, runLayout:function(layout) {
  var me = this, ownerContext = me.getCmp(layout.owner);
  layout.pending = false;
  if (ownerContext.state.blocks) {
    return;
  }
  layout.done = true;
  ++layout.calcCount;
  ++me.calcCount;
  layout.calculate(ownerContext);
  if (layout.done) {
    me.layoutDone(layout);
    if (layout.completeLayout) {
      me.queueCompletion(layout);
    }
    if (layout.finalizeLayout) {
      me.queueFinalize(layout);
    }
  } else {
    if (!layout.pending && !layout.invalid && !(layout.blockCount + layout.triggerCount - layout.firedTriggers)) {
      me.queueLayout(layout);
    }
  }
}, setItemSize:function(item, width, height) {
  var items = item, len = 1, contextItem, i;
  if (item.isComposite) {
    items = item.elements;
    len = items.length;
    item = items[0];
  } else {
    if (!item.dom && !item.el) {
      len = items.length;
      item = items[0];
    }
  }
  for (i = 0; i < len;) {
    contextItem = this.get(item);
    contextItem.setSize(width, height);
    item = items[++i];
  }
}});
Ext.define('Ext.layout.component.Body', {alias:['layout.body'], extend:Ext.layout.component.Auto, type:'body', beginLayout:function(ownerContext) {
  this.callParent(arguments);
  ownerContext.bodyContext = ownerContext.getEl('body');
}, beginLayoutCycle:function(ownerContext, firstCycle) {
  var me = this, lastWidthModel = me.lastWidthModel, lastHeightModel = me.lastHeightModel, body = me.owner.body;
  me.callParent(arguments);
  if (lastWidthModel && lastWidthModel.fixed && ownerContext.widthModel.shrinkWrap) {
    body.setWidth(null);
  }
  if (lastHeightModel && lastHeightModel.fixed && ownerContext.heightModel.shrinkWrap) {
    body.setHeight(null);
  }
}, calculateOwnerHeightFromContentHeight:function(ownerContext, contentHeight) {
  var height = this.callParent(arguments);
  if (ownerContext.targetContext != ownerContext) {
    height += ownerContext.getPaddingInfo().height;
  }
  return height;
}, calculateOwnerWidthFromContentWidth:function(ownerContext, contentWidth) {
  var width = this.callParent(arguments);
  if (ownerContext.targetContext != ownerContext) {
    width += ownerContext.getPaddingInfo().width;
  }
  return width;
}, measureContentWidth:function(ownerContext) {
  return ownerContext.bodyContext.setWidth(ownerContext.bodyContext.el.dom.offsetWidth, false);
}, measureContentHeight:function(ownerContext) {
  return ownerContext.bodyContext.setHeight(ownerContext.bodyContext.el.dom.offsetHeight, false);
}, publishInnerHeight:function(ownerContext, height) {
  var innerHeight = height - ownerContext.getFrameInfo().height, targetContext = ownerContext.targetContext;
  if (targetContext != ownerContext) {
    innerHeight -= ownerContext.getPaddingInfo().height;
  }
  return ownerContext.bodyContext.setHeight(innerHeight, !ownerContext.heightModel.natural);
}, publishInnerWidth:function(ownerContext, width) {
  var innerWidth = width - ownerContext.getFrameInfo().width, targetContext = ownerContext.targetContext;
  if (targetContext != ownerContext) {
    innerWidth -= ownerContext.getPaddingInfo().width;
  }
  ownerContext.bodyContext.setWidth(innerWidth, !ownerContext.widthModel.natural);
}});
Ext.define('Ext.layout.container.Accordion', {extend:Ext.layout.container.VBox, alias:['layout.accordion'], alternateClassName:'Ext.layout.AccordionLayout', targetCls:Ext.baseCSSPrefix + 'accordion-layout-ct', itemCls:[Ext.baseCSSPrefix + 'box-item', Ext.baseCSSPrefix + 'accordion-item'], align:'stretch', fill:true, titleCollapse:true, hideCollapseTool:false, collapseFirst:undefined, animate:true, activeOnTop:false, multi:false, defaultAnimatePolicy:{y:true, height:true}, constructor:function() {
  var me = this;
  me.callParent(arguments);
  if (!me.multi && me.animate) {
    me.animatePolicy = Ext.apply({}, me.defaultAnimatePolicy);
  } else {
    me.animatePolicy = null;
  }
}, beforeRenderItems:function(items) {
  var me = this, ln = items.length, i = 0, owner = me.owner, collapseFirst = me.collapseFirst, hasCollapseFirst = Ext.isDefined(collapseFirst), expandedItem = me.getExpanded(true)[0], multi = me.multi, comp;
  for (; i < ln; i++) {
    comp = items[i];
    if (!comp.rendered) {
      if (!multi || comp.collapsible !== false) {
        comp.collapsible = true;
      }
      if (comp.collapsible) {
        if (hasCollapseFirst) {
          comp.collapseFirst = collapseFirst;
        }
        if (me.hideCollapseTool) {
          comp.hideCollapseTool = me.hideCollapseTool;
          comp.titleCollapse = true;
        } else {
          if (me.titleCollapse && comp.titleCollapse === undefined) {
            comp.titleCollapse = me.titleCollapse;
          }
        }
      }
      delete comp.hideHeader;
      delete comp.width;
      comp.title = comp.title || '\x26#160;';
      comp.addBodyCls(Ext.baseCSSPrefix + 'accordion-body');
      if (!multi) {
        if (expandedItem) {
          comp.collapsed = expandedItem !== comp;
        } else {
          if (comp.hasOwnProperty('collapsed') && comp.collapsed === false) {
            expandedItem = comp;
          } else {
            comp.collapsed = true;
          }
        }
        owner.mon(comp, {show:me.onComponentShow, beforeexpand:me.onComponentExpand, beforecollapse:me.onComponentCollapse, scope:me});
      }
      owner.mon(comp, 'beforecollapse', me.onComponentCollapse, me);
      comp.headerOverCls = Ext.baseCSSPrefix + 'accordion-hd-over';
    }
  }
  if (!multi) {
    if (!expandedItem) {
      if (ln) {
        items[0].collapsed = false;
      }
    } else {
      if (me.activeOnTop) {
        expandedItem.collapsed = false;
        me.configureItem(expandedItem);
        if (owner.items.indexOf(expandedItem) > 0) {
          owner.insert(0, expandedItem);
        }
      }
    }
  }
}, getItemsRenderTree:function(items) {
  this.beforeRenderItems(items);
  return this.callParent(arguments);
}, renderItems:function(items, target) {
  this.beforeRenderItems(items);
  this.callParent(arguments);
}, configureItem:function(item) {
  this.callParent(arguments);
  item.animCollapse = item.border = false;
  if (this.fill) {
    item.flex = 1;
  }
}, beginLayout:function(ownerContext) {
  this.callParent(arguments);
  this.updatePanelClasses(ownerContext);
}, updatePanelClasses:function(ownerContext) {
  var children = ownerContext.visibleItems, ln = children.length, siblingCollapsed = true, i, child, header;
  for (i = 0; i < ln; i++) {
    child = children[i];
    header = child.header;
    header.addCls(Ext.baseCSSPrefix + 'accordion-hd');
    if (siblingCollapsed) {
      header.removeCls(Ext.baseCSSPrefix + 'accordion-hd-sibling-expanded');
    } else {
      header.addCls(Ext.baseCSSPrefix + 'accordion-hd-sibling-expanded');
    }
    if (i + 1 == ln && child.collapsed) {
      header.addCls(Ext.baseCSSPrefix + 'accordion-hd-last-collapsed');
    } else {
      header.removeCls(Ext.baseCSSPrefix + 'accordion-hd-last-collapsed');
    }
    siblingCollapsed = child.collapsed;
  }
}, onComponentExpand:function(toExpand) {
  var me = this, owner = me.owner, multi = me.multi, animate = me.animate, moveToTop = !multi && !me.animate && me.activeOnTop, expanded, expandedCount, i, previousValue;
  if (!me.processing) {
    me.processing = true;
    previousValue = owner.deferLayouts;
    owner.deferLayouts = true;
    expanded = multi ? [] : me.getExpanded();
    expandedCount = expanded.length;
    for (i = 0; i < expandedCount; i++) {
      expanded[i].collapse();
    }
    if (moveToTop) {
      Ext.suspendLayouts();
      owner.insert(0, toExpand);
      Ext.resumeLayouts();
    }
    owner.deferLayouts = previousValue;
    me.processing = false;
  }
}, onComponentCollapse:function(comp) {
  var me = this, owner = me.owner, toExpand, expanded, previousValue;
  if (me.owner.items.getCount() === 1) {
    return false;
  }
  if (!me.processing) {
    me.processing = true;
    previousValue = owner.deferLayouts;
    owner.deferLayouts = true;
    toExpand = comp.next() || comp.prev();
    if (me.multi) {
      expanded = me.getExpanded();
      if (expanded.length === 1) {
        toExpand.expand();
      }
    } else {
      if (toExpand) {
        toExpand.expand();
      }
    }
    owner.deferLayouts = previousValue;
    me.processing = false;
  }
}, onComponentShow:function(comp) {
  this.onComponentExpand(comp);
}, getExpanded:function(explicitCheck) {
  var items = this.owner.items.items, len = items.length, i = 0, out = [], add, item;
  for (; i < len; ++i) {
    item = items[i];
    if (explicitCheck) {
      add = item.hasOwnProperty('collapsed') && item.collapsed === false;
    } else {
      add = !item.collapsed;
    }
    if (add) {
      out.push(item);
    }
  }
  return out;
}});
Ext.define('Ext.resizer.Splitter', {extend:Ext.Component, alias:'widget.splitter', childEls:['collapseEl'], renderTpl:['\x3ctpl if\x3d"collapsible\x3d\x3d\x3dtrue"\x3e', '\x3cdiv id\x3d"{id}-collapseEl" class\x3d"', Ext.baseCSSPrefix, 'collapse-el ', Ext.baseCSSPrefix, 'layout-split-{collapseDir}{childElCls}"\x3e\x26#160;', '\x3c/div\x3e', '\x3c/tpl\x3e'], baseCls:Ext.baseCSSPrefix + 'splitter', collapsedClsInternal:Ext.baseCSSPrefix + 'splitter-collapsed', canResize:true, collapsible:false, collapseOnDblClick:true, 
defaultSplitMin:40, defaultSplitMax:1000, collapseTarget:'next', horizontal:false, vertical:false, size:5, getTrackerConfig:function() {
  return {xclass:'Ext.resizer.SplitterTracker', el:this.el, splitter:this};
}, beforeRender:function() {
  var me = this, target = me.getCollapseTarget();
  me.callParent();
  if (target.collapsed) {
    me.addCls(me.collapsedClsInternal);
  }
  if (!me.canResize) {
    me.addCls(me.baseCls + '-noresize');
  }
  Ext.applyIf(me.renderData, {collapseDir:me.getCollapseDirection(), collapsible:me.collapsible || target.collapsible});
  me.protoEl.unselectable();
}, onRender:function() {
  var me = this, collapseEl;
  me.callParent(arguments);
  if (me.performCollapse !== false) {
    if (me.renderData.collapsible) {
      me.mon(me.collapseEl, 'click', me.toggleTargetCmp, me);
    }
    if (me.collapseOnDblClick) {
      me.mon(me.el, 'dblclick', me.toggleTargetCmp, me);
    }
  }
  me.mon(me.getCollapseTarget(), {collapse:me.onTargetCollapse, expand:me.onTargetExpand, beforeexpand:me.onBeforeTargetExpand, beforecollapse:me.onBeforeTargetCollapse, scope:me});
  if (me.canResize) {
    me.tracker = Ext.create(me.getTrackerConfig());
    me.relayEvents(me.tracker, ['beforedragstart', 'dragstart', 'dragend']);
  }
  collapseEl = me.collapseEl;
  if (collapseEl) {
    collapseEl.lastCollapseDirCls = me.collapseDirProps[me.collapseDirection].cls;
  }
}, getCollapseDirection:function() {
  var me = this, dir = me.collapseDirection, collapseTarget, idx, items, type;
  if (!dir) {
    collapseTarget = me.collapseTarget;
    if (collapseTarget.isComponent) {
      dir = collapseTarget.collapseDirection;
    }
    if (!dir) {
      type = me.ownerCt.layout.type;
      if (collapseTarget.isComponent) {
        items = me.ownerCt.items;
        idx = Number(items.indexOf(collapseTarget) === items.indexOf(me) - 1) << 1 | Number(type === 'hbox');
      } else {
        idx = Number(me.collapseTarget === 'prev') << 1 | Number(type === 'hbox');
      }
      dir = ['bottom', 'right', 'top', 'left'][idx];
    }
    me.collapseDirection = dir;
  }
  me.setOrientation(dir === 'top' || dir === 'bottom' ? 'horizontal' : 'vertical');
  return dir;
}, getCollapseTarget:function() {
  var me = this;
  return me.collapseTarget.isComponent ? me.collapseTarget : me.collapseTarget === 'prev' ? me.previousSibling() : me.nextSibling();
}, setCollapseEl:function(display) {
  var el = this.collapseEl;
  if (el) {
    el.setDisplayed(display);
  }
}, onBeforeTargetExpand:function(target) {
  this.setCollapseEl('none');
}, onBeforeTargetCollapse:function() {
  this.setCollapseEl('none');
}, onTargetCollapse:function(target) {
  this.el.addCls([this.collapsedClsInternal, this.collapsedCls]);
  this.setCollapseEl('');
}, onTargetExpand:function(target) {
  this.el.removeCls([this.collapsedClsInternal, this.collapsedCls]);
  this.setCollapseEl('');
}, collapseDirProps:{top:{cls:Ext.baseCSSPrefix + 'layout-split-top'}, right:{cls:Ext.baseCSSPrefix + 'layout-split-right'}, bottom:{cls:Ext.baseCSSPrefix + 'layout-split-bottom'}, left:{cls:Ext.baseCSSPrefix + 'layout-split-left'}}, orientationProps:{horizontal:{opposite:'vertical', fixedAxis:'height', stretchedAxis:'width'}, vertical:{opposite:'horizontal', fixedAxis:'width', stretchedAxis:'height'}}, applyCollapseDirection:function() {
  var me = this, collapseEl = me.collapseEl, collapseDirProps = me.collapseDirProps[me.collapseDirection], cls;
  if (collapseEl) {
    cls = collapseEl.lastCollapseDirCls;
    if (cls) {
      collapseEl.removeCls(cls);
    }
    collapseEl.addCls(collapseEl.lastCollapseDirCls = collapseDirProps.cls);
  }
}, applyOrientation:function() {
  var me = this, orientation = me.orientation, orientationProps = me.orientationProps[orientation], defaultSize = me.size, fixedSizeProp = orientationProps.fixedAxis, stretchSizeProp = orientationProps.stretchedAxis, cls = me.baseCls + '-';
  me[orientation] = true;
  me[orientationProps.opposite] = false;
  if (!me.hasOwnProperty(fixedSizeProp) || me[fixedSizeProp] === '100%') {
    me[fixedSizeProp] = defaultSize;
  }
  if (!me.hasOwnProperty(stretchSizeProp) || me[stretchSizeProp] === defaultSize) {
    me[stretchSizeProp] = '100%';
  }
  me.removeCls(cls + orientationProps.opposite);
  me.addCls(cls + orientation);
}, setOrientation:function(orientation) {
  var me = this;
  if (me.orientation !== orientation) {
    me.orientation = orientation;
    me.applyOrientation();
  }
}, updateOrientation:function() {
  delete this.collapseDirection;
  this.getCollapseDirection();
  this.applyCollapseDirection();
}, toggleTargetCmp:function(e, t) {
  var cmp = this.getCollapseTarget(), placeholder = cmp.placeholder, toggle;
  if (Ext.isFunction(cmp.expand) && Ext.isFunction(cmp.collapse)) {
    if (placeholder && !placeholder.hidden) {
      toggle = true;
    } else {
      toggle = !cmp.hidden;
    }
    if (toggle) {
      if (cmp.collapsed) {
        cmp.expand();
      } else {
        if (cmp.collapseDirection) {
          cmp.collapse();
        } else {
          cmp.collapse(this.renderData.collapseDir);
        }
      }
    }
  }
}, setSize:function() {
  var me = this;
  me.callParent(arguments);
  if (Ext.isIE && me.el) {
    me.el.repaint();
  }
}, beforeDestroy:function() {
  Ext.destroy(this.tracker);
  this.callParent();
}});
Ext.define('Ext.resizer.BorderSplitter', {extend:Ext.resizer.Splitter, alias:'widget.bordersplitter', collapseTarget:null, getTrackerConfig:function() {
  var trackerConfig = this.callParent();
  trackerConfig.xclass = 'Ext.resizer.BorderSplitterTracker';
  return trackerConfig;
}});
Ext.define('Ext.layout.container.Border', {extend:Ext.layout.container.Container, alias:'layout.border', alternateClassName:'Ext.layout.BorderLayout', targetCls:Ext.baseCSSPrefix + 'border-layout-ct', itemCls:[Ext.baseCSSPrefix + 'border-item', Ext.baseCSSPrefix + 'box-item'], type:'border', isBorderLayout:true, padding:undefined, percentageRe:/(\d+)%/, horzMarginProp:'left', padOnContainerProp:'left', padNotOnContainerProp:'right', axisProps:{horz:{borderBegin:'west', borderEnd:'east', horizontal:true, 
posProp:'x', sizeProp:'width', sizePropCap:'Width'}, vert:{borderBegin:'north', borderEnd:'south', horizontal:false, posProp:'y', sizeProp:'height', sizePropCap:'Height'}}, centerRegion:null, manageMargins:true, panelCollapseAnimate:true, panelCollapseMode:'placeholder', regionWeights:{north:20, south:10, center:0, west:-10, east:-20}, beginAxis:function(ownerContext, regions, name) {
  var me = this, props = me.axisProps[name], isVert = !props.horizontal, sizeProp = props.sizeProp, totalFlex = 0, childItems = ownerContext.childItems, length = childItems.length, center, i, childContext, centerFlex, comp, region, match, size, type, target, placeholder;
  for (i = 0; i < length; ++i) {
    childContext = childItems[i];
    comp = childContext.target;
    childContext.layoutPos = {};
    if (comp.region) {
      childContext.region = region = comp.region;
      childContext.isCenter = comp.isCenter;
      childContext.isHorz = comp.isHorz;
      childContext.isVert = comp.isVert;
      childContext.weight = comp.weight || me.regionWeights[region] || 0;
      regions[comp.id] = childContext;
      if (comp.isCenter) {
        center = childContext;
        centerFlex = comp.flex;
        ownerContext.centerRegion = center;
        continue;
      }
      if (isVert !== childContext.isVert) {
        continue;
      }
      childContext.reverseWeighting = region == props.borderEnd;
      size = comp[sizeProp];
      type = typeof size;
      if (!comp.collapsed) {
        if (type == 'string' && (match = me.percentageRe.exec(size))) {
          childContext.percentage = parseInt(match[1], 10);
        } else {
          if (comp.flex) {
            totalFlex += childContext.flex = comp.flex;
          }
        }
      }
    }
  }
  if (center) {
    target = center.target;
    if (placeholder = target.placeholderFor) {
      if (!centerFlex && isVert === placeholder.collapsedVertical()) {
        centerFlex = 0;
        center.collapseAxis = name;
      }
    } else {
      if (target.collapsed && isVert === target.collapsedVertical()) {
        centerFlex = 0;
        center.collapseAxis = name;
      }
    }
  }
  if (centerFlex == null) {
    centerFlex = 1;
  }
  totalFlex += centerFlex;
  return Ext.apply({before:isVert ? 'top' : 'left', totalFlex:totalFlex}, props);
}, beginLayout:function(ownerContext) {
  var me = this, items = me.getLayoutItems(), pad = me.padding, type = typeof pad, padOnContainer = false, childContext, item, length, i, regions, collapseTarget, doShow, hidden, region;
  if (pad) {
    if (type == 'string' || type == 'number') {
      pad = Ext.util.Format.parseBox(pad);
    }
  } else {
    pad = ownerContext.getEl('getTargetEl').getPaddingInfo();
    padOnContainer = true;
  }
  ownerContext.outerPad = pad;
  ownerContext.padOnContainer = padOnContainer;
  for (i = 0, length = items.length; i < length; ++i) {
    item = items[i];
    collapseTarget = me.getSplitterTarget(item);
    if (collapseTarget) {
      doShow = undefined;
      hidden = !!item.hidden;
      if (!collapseTarget.split) {
        if (collapseTarget.isCollapsingOrExpanding) {
          doShow = !!collapseTarget.collapsed;
        }
      } else {
        if (hidden !== collapseTarget.hidden) {
          doShow = !collapseTarget.hidden;
        }
      }
      if (doShow) {
        item.show();
      } else {
        if (doShow === false) {
          item.hide();
        }
      }
    }
  }
  me.callParent(arguments);
  items = ownerContext.childItems;
  length = items.length;
  regions = {};
  ownerContext.borderAxisHorz = me.beginAxis(ownerContext, regions, 'horz');
  ownerContext.borderAxisVert = me.beginAxis(ownerContext, regions, 'vert');
  for (i = 0; i < length; ++i) {
    childContext = items[i];
    collapseTarget = me.getSplitterTarget(childContext.target);
    if (collapseTarget) {
      region = regions[collapseTarget.id];
      if (!region) {
        region = ownerContext.getEl(collapseTarget.el, me);
        region.region = collapseTarget.region;
      }
      childContext.collapseTarget = collapseTarget = region;
      childContext.weight = collapseTarget.weight;
      childContext.reverseWeighting = collapseTarget.reverseWeighting;
      collapseTarget.splitter = childContext;
      childContext.isHorz = collapseTarget.isHorz;
      childContext.isVert = collapseTarget.isVert;
    }
  }
  me.sortWeightedItems(items, 'reverseWeighting');
  me.setupSplitterNeighbors(items);
}, calculate:function(ownerContext) {
  var me = this, containerSize = me.getContainerSize(ownerContext), childItems = ownerContext.childItems, length = childItems.length, horz = ownerContext.borderAxisHorz, vert = ownerContext.borderAxisVert, pad = ownerContext.outerPad, padOnContainer = ownerContext.padOnContainer, i, childContext, childMargins, size, horzPercentTotal, vertPercentTotal;
  horz.begin = pad[me.padOnContainerProp];
  vert.begin = pad.top;
  horzPercentTotal = horz.end = horz.flexSpace = containerSize.width + (padOnContainer ? pad[me.padOnContainerProp] : -pad[me.padNotOnContainerProp]);
  vertPercentTotal = vert.end = vert.flexSpace = containerSize.height + (padOnContainer ? pad.top : -pad.bottom);
  for (i = 0; i < length; ++i) {
    childContext = childItems[i];
    childMargins = childContext.getMarginInfo();
    if (childContext.isHorz || childContext.isCenter) {
      horz.addUnflexed(childMargins.width);
      horzPercentTotal -= childMargins.width;
    }
    if (childContext.isVert || childContext.isCenter) {
      vert.addUnflexed(childMargins.height);
      vertPercentTotal -= childMargins.height;
    }
    if (!childContext.flex && !childContext.percentage) {
      if (childContext.isHorz || childContext.isCenter && childContext.collapseAxis === 'horz') {
        size = childContext.getProp('width');
        horz.addUnflexed(size);
        if (childContext.collapseTarget) {
          horzPercentTotal -= size;
        }
      } else {
        if (childContext.isVert || childContext.isCenter && childContext.collapseAxis === 'vert') {
          size = childContext.getProp('height');
          vert.addUnflexed(size);
          if (childContext.collapseTarget) {
            vertPercentTotal -= size;
          }
        }
      }
    }
  }
  for (i = 0; i < length; ++i) {
    childContext = childItems[i];
    childMargins = childContext.getMarginInfo();
    if (childContext.percentage) {
      if (childContext.isHorz) {
        size = Math.ceil(horzPercentTotal * childContext.percentage / 100);
        size = childContext.setWidth(size);
        horz.addUnflexed(size);
      } else {
        if (childContext.isVert) {
          size = Math.ceil(vertPercentTotal * childContext.percentage / 100);
          size = childContext.setHeight(size);
          vert.addUnflexed(size);
        }
      }
    }
  }
  for (i = 0; i < length; ++i) {
    childContext = childItems[i];
    if (!childContext.isCenter) {
      me.calculateChildAxis(childContext, horz);
      me.calculateChildAxis(childContext, vert);
    }
  }
  if (me.finishAxis(ownerContext, vert) + me.finishAxis(ownerContext, horz) < 2) {
    me.done = false;
  } else {
    me.finishPositions(childItems);
  }
}, calculateChildAxis:function(childContext, axis) {
  var collapseTarget = childContext.collapseTarget, setSizeMethod = 'set' + axis.sizePropCap, sizeProp = axis.sizeProp, childMarginSize = childContext.getMarginInfo()[sizeProp], region, isBegin, flex, pos, size;
  if (collapseTarget) {
    region = collapseTarget.region;
  } else {
    region = childContext.region;
    flex = childContext.flex;
  }
  isBegin = region == axis.borderBegin;
  if (!isBegin && region != axis.borderEnd) {
    childContext[setSizeMethod](axis.end - axis.begin - childMarginSize);
    pos = axis.begin;
  } else {
    if (flex) {
      size = Math.ceil(axis.flexSpace * (flex / axis.totalFlex));
      size = childContext[setSizeMethod](size);
    } else {
      if (childContext.percentage) {
        size = childContext.peek(sizeProp);
      } else {
        size = childContext.getProp(sizeProp);
      }
    }
    size += childMarginSize;
    if (isBegin) {
      pos = axis.begin;
      axis.begin += size;
    } else {
      axis.end = pos = axis.end - size;
    }
  }
  childContext.layoutPos[axis.posProp] = pos;
}, finishAxis:function(ownerContext, axis) {
  var size = axis.end - axis.begin, center = ownerContext.centerRegion;
  if (center) {
    center['set' + axis.sizePropCap](size - center.getMarginInfo()[axis.sizeProp]);
    center.layoutPos[axis.posProp] = axis.begin;
  }
  return Ext.isNumber(size) ? 1 : 0;
}, finishPositions:function(childItems) {
  var length = childItems.length, index, childContext, marginProp = this.horzMarginProp;
  for (index = 0; index < length; ++index) {
    childContext = childItems[index];
    childContext.setProp('x', childContext.layoutPos.x + childContext.marginInfo[marginProp]);
    childContext.setProp('y', childContext.layoutPos.y + childContext.marginInfo.top);
  }
}, getLayoutItems:function() {
  var owner = this.owner, ownerItems = owner && owner.items && owner.items.items || [], length = ownerItems.length, items = [], i = 0, ownerItem, placeholderFor;
  for (; i < length; i++) {
    ownerItem = ownerItems[i];
    placeholderFor = ownerItem.placeholderFor;
    if (ownerItem.hidden || (!ownerItem.floated || ownerItem.isCollapsingOrExpanding === 2) && !(placeholderFor && placeholderFor.isCollapsingOrExpanding === 2)) {
      items.push(ownerItem);
    }
  }
  return items;
}, getPlaceholder:function(comp) {
  return comp.getPlaceholder && comp.getPlaceholder();
}, getSplitterTarget:function(splitter) {
  var collapseTarget = splitter.collapseTarget;
  if (collapseTarget && collapseTarget.collapsed) {
    return collapseTarget.placeholder || collapseTarget;
  }
  return collapseTarget;
}, isItemBoxParent:function(itemContext) {
  return true;
}, isItemShrinkWrap:function(item) {
  return true;
}, insertSplitter:function(item, index, hidden, splitterCfg) {
  var region = item.region, splitter = Ext.apply({xtype:'bordersplitter', collapseTarget:item, id:item.id + '-splitter', hidden:hidden, canResize:item.splitterResize !== false, splitterFor:item}, splitterCfg), at = index + (region === 'south' || region === 'east' ? 0 : 1);
  if (item.collapseMode === 'mini') {
    splitter.collapsedCls = item.collapsedCls;
  }
  item.splitter = this.owner.add(at, splitter);
}, onAdd:function(item, index) {
  var me = this, placeholderFor = item.placeholderFor, region = item.region, split, hidden, cfg;
  me.callParent(arguments);
  if (region) {
    Ext.apply(item, me.regionFlags[region]);
    if (item.initBorderRegion) {
      item.initBorderRegion();
    }
    if (region === 'center') {
      if (me.centerRegion) {
        Ext.Error.raise('Cannot have multiple center regions in a BorderLayout.');
      }
      me.centerRegion = item;
    } else {
      split = item.split;
      hidden = !!item.hidden;
      if (typeof split === 'object') {
        cfg = split;
        split = true;
      }
      if ((item.isHorz || item.isVert) && (split || item.collapseMode == 'mini')) {
        me.insertSplitter(item, index, hidden || !split, cfg);
      }
    }
    if (!item.hasOwnProperty('collapseMode')) {
      item.collapseMode = me.panelCollapseMode;
    }
    if (!item.hasOwnProperty('animCollapse')) {
      if (item.collapseMode !== 'placeholder') {
        item.animCollapse = false;
      } else {
        item.animCollapse = me.panelCollapseAnimate;
      }
    }
  } else {
    if (placeholderFor) {
      Ext.apply(item, me.regionFlags[placeholderFor.region]);
      item.region = placeholderFor.region;
      item.weight = placeholderFor.weight;
    }
  }
}, onDestroy:function() {
  this.centerRegion = null;
  this.callParent();
}, onRemove:function(item) {
  var me = this, region = item.region, splitter = item.splitter;
  if (region) {
    if (item.isCenter) {
      me.centerRegion = null;
    }
    delete item.isCenter;
    delete item.isHorz;
    delete item.isVert;
    if (splitter) {
      me.owner.doRemove(splitter, true);
      delete item.splitter;
    }
  }
  me.callParent(arguments);
}, regionMeta:{center:{splitterDelta:0}, north:{splitterDelta:1}, south:{splitterDelta:-1}, west:{splitterDelta:1}, east:{splitterDelta:-1}}, regionFlags:{center:{isCenter:true, isHorz:false, isVert:false}, north:{isCenter:false, isHorz:false, isVert:true, collapseDirection:'top'}, south:{isCenter:false, isHorz:false, isVert:true, collapseDirection:'bottom'}, west:{isCenter:false, isHorz:true, isVert:false, collapseDirection:'left'}, east:{isCenter:false, isHorz:true, isVert:false, collapseDirection:'right'}}, 
setupSplitterNeighbors:function(items) {
  var edgeRegions = {}, length = items.length, touchedRegions = this.touchedRegions, i, j, center, count, edge, comp, region, splitter, touched;
  for (i = 0; i < length; ++i) {
    comp = items[i].target;
    region = comp.region;
    if (comp.isCenter) {
      center = comp;
    } else {
      if (region) {
        touched = touchedRegions[region];
        for (j = 0, count = touched.length; j < count; ++j) {
          edge = edgeRegions[touched[j]];
          if (edge) {
            edge.neighbors.push(comp);
          }
        }
        if (comp.placeholderFor) {
          splitter = comp.placeholderFor.splitter;
        } else {
          splitter = comp.splitter;
        }
        if (splitter) {
          splitter.neighbors = [];
        }
        edgeRegions[region] = splitter;
      }
    }
  }
  if (center) {
    touched = touchedRegions.center;
    for (j = 0, count = touched.length; j < count; ++j) {
      edge = edgeRegions[touched[j]];
      if (edge) {
        edge.neighbors.push(center);
      }
    }
  }
}, touchedRegions:{center:['north', 'south', 'east', 'west'], north:['north', 'east', 'west'], south:['south', 'east', 'west'], east:['east', 'north', 'south'], west:['west', 'north', 'south']}, sizePolicies:{vert:{readsWidth:0, readsHeight:1, setsWidth:1, setsHeight:0}, horz:{readsWidth:1, readsHeight:0, setsWidth:0, setsHeight:1}, flexAll:{readsWidth:0, readsHeight:0, setsWidth:1, setsHeight:1}}, getItemSizePolicy:function(item) {
  var me = this, policies = this.sizePolicies, collapseTarget, size, policy, placeholderFor;
  if (item.isCenter) {
    placeholderFor = item.placeholderFor;
    if (placeholderFor) {
      if (placeholderFor.collapsedVertical()) {
        return policies.vert;
      }
      return policies.horz;
    }
    if (item.collapsed) {
      if (item.collapsedVertical()) {
        return policies.vert;
      }
      return policies.horz;
    }
    return policies.flexAll;
  }
  collapseTarget = item.collapseTarget;
  if (collapseTarget) {
    return collapseTarget.isVert ? policies.vert : policies.horz;
  }
  if (item.region) {
    if (item.isVert) {
      size = item.height;
      policy = policies.vert;
    } else {
      size = item.width;
      policy = policies.horz;
    }
    if (item.flex || typeof size == 'string' && me.percentageRe.test(size)) {
      return policies.flexAll;
    }
    return policy;
  }
  return me.autoSizePolicy;
}}, function() {
  var methods = {addUnflexed:function(px) {
    this.flexSpace = Math.max(this.flexSpace - px, 0);
  }}, props = this.prototype.axisProps;
  Ext.apply(props.horz, methods);
  Ext.apply(props.vert, methods);
});
Ext.define('Ext.layout.container.Fit', {extend:Ext.layout.container.Container, alternateClassName:'Ext.layout.FitLayout', alias:'layout.fit', itemCls:Ext.baseCSSPrefix + 'fit-item', targetCls:Ext.baseCSSPrefix + 'layout-fit', type:'fit', defaultMargins:{top:0, right:0, bottom:0, left:0}, manageMargins:true, sizePolicies:{0:{readsWidth:1, readsHeight:1, setsWidth:0, setsHeight:0}, 1:{readsWidth:0, readsHeight:1, setsWidth:1, setsHeight:0}, 2:{readsWidth:1, readsHeight:0, setsWidth:0, setsHeight:1}, 
3:{readsWidth:0, readsHeight:0, setsWidth:1, setsHeight:1}}, getItemSizePolicy:function(item, ownerSizeModel) {
  var sizeModel = ownerSizeModel || this.owner.getSizeModel(), mode = (sizeModel.width.shrinkWrap ? 0 : 1) | (sizeModel.height.shrinkWrap ? 0 : 2);
  return this.sizePolicies[mode];
}, beginLayoutCycle:function(ownerContext, firstCycle) {
  var me = this, resetHeight = me.lastHeightModel && me.lastHeightModel.calculated, resetWidth = me.lastWidthModel && me.lastWidthModel.calculated, resetSizes = resetWidth || resetHeight, maxChildMinHeight = 0, maxChildMinWidth = 0, c, childItems, i, item, length, margins, minHeight, minWidth, style, undef;
  me.callParent(arguments);
  if (resetSizes && ownerContext.targetContext.el.dom.tagName.toUpperCase() != 'TD') {
    resetSizes = resetWidth = resetHeight = false;
  }
  childItems = ownerContext.childItems;
  length = childItems.length;
  for (i = 0; i < length; ++i) {
    item = childItems[i];
    if (firstCycle) {
      c = item.target;
      minHeight = c.minHeight;
      minWidth = c.minWidth;
      if (minWidth || minHeight) {
        margins = item.marginInfo || item.getMarginInfo();
        minHeight += margins.height;
        minWidth += margins.height;
        if (maxChildMinHeight < minHeight) {
          maxChildMinHeight = minHeight;
        }
        if (maxChildMinWidth < minWidth) {
          maxChildMinWidth = minWidth;
        }
      }
    }
    if (resetSizes) {
      style = item.el.dom.style;
      if (resetHeight) {
        style.height = '';
      }
      if (resetWidth) {
        style.width = '';
      }
    }
  }
  if (firstCycle) {
    ownerContext.maxChildMinHeight = maxChildMinHeight;
    ownerContext.maxChildMinWidth = maxChildMinWidth;
  }
  c = ownerContext.target;
  ownerContext.overflowX = !ownerContext.widthModel.shrinkWrap && ownerContext.maxChildMinWidth && c.scrollFlags.x || undef;
  ownerContext.overflowY = !ownerContext.heightModel.shrinkWrap && ownerContext.maxChildMinHeight && c.scrollFlags.y || undef;
}, calculate:function(ownerContext) {
  var me = this, childItems = ownerContext.childItems, length = childItems.length, containerSize = me.getContainerSize(ownerContext), info = {length:length, ownerContext:ownerContext, targetSize:containerSize}, shrinkWrapWidth = ownerContext.widthModel.shrinkWrap, shrinkWrapHeight = ownerContext.heightModel.shrinkWrap, overflowX = ownerContext.overflowX, overflowY = ownerContext.overflowY, scrollbars, scrollbarSize, padding, i, contentWidth, contentHeight;
  if (overflowX || overflowY) {
    scrollbars = me.getScrollbarsNeeded(overflowX && containerSize.width, overflowY && containerSize.height, ownerContext.maxChildMinWidth, ownerContext.maxChildMinHeight);
    if (scrollbars) {
      scrollbarSize = Ext.getScrollbarSize();
      if (scrollbars & 1) {
        containerSize.height -= scrollbarSize.height;
      }
      if (scrollbars & 2) {
        containerSize.width -= scrollbarSize.width;
      }
    }
  }
  for (i = 0; i < length; ++i) {
    info.index = i;
    me.fitItem(childItems[i], info);
  }
  if (shrinkWrapHeight || shrinkWrapWidth) {
    padding = ownerContext.targetContext.getPaddingInfo();
    if (shrinkWrapWidth) {
      if (overflowY && !containerSize.gotHeight) {
        me.done = false;
      } else {
        contentWidth = info.contentWidth + padding.width;
        if (scrollbars & 2) {
          contentWidth += scrollbarSize.width;
        }
        if (!ownerContext.setContentWidth(contentWidth)) {
          me.done = false;
        }
      }
    }
    if (shrinkWrapHeight) {
      if (overflowX && !containerSize.gotWidth) {
        me.done = false;
      } else {
        contentHeight = info.contentHeight + padding.height;
        if (scrollbars & 1) {
          contentHeight += scrollbarSize.height;
        }
        if (!ownerContext.setContentHeight(contentHeight)) {
          me.done = false;
        }
      }
    }
  }
}, fitItem:function(itemContext, info) {
  var me = this;
  if (itemContext.invalid) {
    me.done = false;
    return;
  }
  info.margins = itemContext.getMarginInfo();
  info.needed = info.got = 0;
  me.fitItemWidth(itemContext, info);
  me.fitItemHeight(itemContext, info);
  if (info.got != info.needed) {
    me.done = false;
  }
}, fitItemWidth:function(itemContext, info) {
  var contentWidth, width;
  if (info.ownerContext.widthModel.shrinkWrap) {
    width = itemContext.getProp('width') + info.margins.width;
    contentWidth = info.contentWidth;
    if (contentWidth === undefined) {
      info.contentWidth = width;
    } else {
      info.contentWidth = Math.max(contentWidth, width);
    }
  } else {
    if (itemContext.widthModel.calculated) {
      ++info.needed;
      if (info.targetSize.gotWidth) {
        ++info.got;
        this.setItemWidth(itemContext, info);
      }
    }
  }
  this.positionItemX(itemContext, info);
}, fitItemHeight:function(itemContext, info) {
  var contentHeight, height;
  if (info.ownerContext.heightModel.shrinkWrap) {
    height = itemContext.getProp('height') + info.margins.height;
    contentHeight = info.contentHeight;
    if (contentHeight === undefined) {
      info.contentHeight = height;
    } else {
      info.contentHeight = Math.max(contentHeight, height);
    }
  } else {
    if (itemContext.heightModel.calculated) {
      ++info.needed;
      if (info.targetSize.gotHeight) {
        ++info.got;
        this.setItemHeight(itemContext, info);
      }
    }
  }
  this.positionItemY(itemContext, info);
}, positionItemX:function(itemContext, info) {
  var margins = info.margins;
  if (info.index || margins.left) {
    itemContext.setProp('x', margins.left);
  }
  if (margins.width) {
    itemContext.setProp('margin-right', margins.width);
  }
}, positionItemY:function(itemContext, info) {
  var margins = info.margins;
  if (info.index || margins.top) {
    itemContext.setProp('y', margins.top);
  }
  if (margins.height) {
    itemContext.setProp('margin-bottom', margins.height);
  }
}, setItemHeight:function(itemContext, info) {
  itemContext.setHeight(info.targetSize.height - info.margins.height);
}, setItemWidth:function(itemContext, info) {
  itemContext.setWidth(info.targetSize.width - info.margins.width);
}});
Ext.define('Ext.layout.container.Card', {extend:Ext.layout.container.Fit, alternateClassName:'Ext.layout.CardLayout', alias:'layout.card', type:'card', hideInactive:true, deferredRender:false, getRenderTree:function() {
  var me = this, activeItem = me.getActiveItem();
  if (activeItem) {
    if (activeItem.hasListeners.beforeactivate && activeItem.fireEvent('beforeactivate', activeItem) === false) {
      activeItem = me.activeItem = me.owner.activeItem = null;
    } else {
      if (activeItem.hasListeners.activate) {
        activeItem.on({boxready:function() {
          activeItem.fireEvent('activate', activeItem);
        }, single:true});
      }
    }
    if (me.deferredRender) {
      if (activeItem) {
        return me.getItemsRenderTree([activeItem]);
      }
    } else {
      return me.callParent(arguments);
    }
  }
}, renderChildren:function() {
  var me = this, active = me.getActiveItem();
  if (!me.deferredRender) {
    me.callParent();
  } else {
    if (active) {
      me.renderItems([active], me.getRenderTarget());
    }
  }
}, isValidParent:function(item, target, position) {
  var itemEl = item.el ? item.el.dom : Ext.getDom(item);
  return itemEl && itemEl.parentNode === (target.dom || target) || false;
}, getActiveItem:function() {
  var me = this, result = me.parseActiveItem(me.activeItem || me.owner && me.owner.activeItem);
  if (result && me.owner.items.indexOf(result) != -1) {
    me.activeItem = result;
  } else {
    me.activeItem = null;
  }
  return me.activeItem;
}, parseActiveItem:function(item) {
  if (item && item.isComponent) {
    return item;
  } else {
    if (typeof item == 'number' || item === undefined) {
      return this.getLayoutItems()[item || 0];
    } else {
      return this.owner.getComponent(item);
    }
  }
}, configureItem:function(item) {
  if (item === this.getActiveItem()) {
    item.hidden = false;
  } else {
    item.hidden = true;
  }
  this.callParent(arguments);
}, onRemove:function(component) {
  var me = this;
  if (component === me.activeItem) {
    me.activeItem = null;
  }
}, getAnimation:function(newCard, owner) {
  var newAnim = (newCard || {}).cardSwitchAnimation;
  if (newAnim === false) {
    return false;
  }
  return newAnim || owner.cardSwitchAnimation;
}, getNext:function() {
  var wrap = arguments[0], items = this.getLayoutItems(), index = Ext.Array.indexOf(items, this.activeItem);
  return items[index + 1] || (wrap ? items[0] : false);
}, next:function() {
  var anim = arguments[0], wrap = arguments[1];
  return this.setActiveItem(this.getNext(wrap), anim);
}, getPrev:function() {
  var wrap = arguments[0], items = this.getLayoutItems(), index = Ext.Array.indexOf(items, this.activeItem);
  return items[index - 1] || (wrap ? items[items.length - 1] : false);
}, prev:function() {
  var anim = arguments[0], wrap = arguments[1];
  return this.setActiveItem(this.getPrev(wrap), anim);
}, setActiveItem:function(newCard) {
  var me = this, owner = me.owner, oldCard = me.activeItem, rendered = owner.rendered, newIndex;
  newCard = me.parseActiveItem(newCard);
  newIndex = owner.items.indexOf(newCard);
  if (newIndex == -1) {
    newIndex = owner.items.items.length;
    Ext.suspendLayouts();
    newCard = owner.add(newCard);
    Ext.resumeLayouts();
  }
  if (newCard && oldCard != newCard) {
    if (newCard.fireEvent('beforeactivate', newCard, oldCard) === false) {
      return false;
    }
    if (oldCard && oldCard.fireEvent('beforedeactivate', oldCard, newCard) === false) {
      return false;
    }
    if (rendered) {
      Ext.suspendLayouts();
      if (!newCard.rendered) {
        me.renderItem(newCard, me.getRenderTarget(), owner.items.length);
      }
      if (oldCard) {
        if (me.hideInactive) {
          oldCard.hide();
          oldCard.hiddenByLayout = true;
        }
        oldCard.fireEvent('deactivate', oldCard, newCard);
      }
      if (newCard.hidden) {
        newCard.show();
      }
      if (!newCard.hidden) {
        me.activeItem = newCard;
      }
      Ext.resumeLayouts(true);
    } else {
      me.activeItem = newCard;
    }
    newCard.fireEvent('activate', newCard, oldCard);
    return me.activeItem;
  }
  return false;
}});
Ext.define('Ext.menu.Item', {extend:Ext.Component, alias:'widget.menuitem', alternateClassName:'Ext.menu.TextItem', mixins:{queryable:Ext.Queryable}, activeCls:Ext.baseCSSPrefix + 'menu-item-active', ariaRole:'menuitem', canActivate:true, clickHideDelay:0, destroyMenu:true, disabledCls:Ext.baseCSSPrefix + 'menu-item-disabled', hideOnClick:true, isMenuItem:true, menuAlign:'tl-tr?', menuExpandDelay:200, menuHideDelay:200, tooltipType:'qtip', arrowCls:Ext.baseCSSPrefix + 'menu-item-arrow', childEls:['itemEl', 
'iconEl', 'textEl', 'arrowEl'], renderTpl:['\x3ctpl if\x3d"plain"\x3e', '{text}', '\x3ctpl else\x3e', '\x3ca id\x3d"{id}-itemEl"', ' class\x3d"' + Ext.baseCSSPrefix + 'menu-item-link{childElCls}"', ' href\x3d"{href}"', '\x3ctpl if\x3d"hrefTarget"\x3e target\x3d"{hrefTarget}"\x3c/tpl\x3e', ' hidefocus\x3d"true"', ' unselectable\x3d"on"', '\x3ctpl if\x3d"tabIndex"\x3e', ' tabIndex\x3d"{tabIndex}"', '\x3c/tpl\x3e', '\x3e', '\x3cdiv role\x3d"img" id\x3d"{id}-iconEl" class\x3d"' + Ext.baseCSSPrefix + 
'menu-item-icon {iconCls}', '{childElCls} {glyphCls}" style\x3d"\x3ctpl if\x3d"icon"\x3ebackground-image:url({icon});\x3c/tpl\x3e', '\x3ctpl if\x3d"glyph \x26\x26 glyphFontFamily"\x3efont-family:{glyphFontFamily};\x3c/tpl\x3e"\x3e', '\x3ctpl if\x3d"glyph"\x3e\x26#{glyph};\x3c/tpl\x3e', '\x3c/div\x3e', '\x3cspan id\x3d"{id}-textEl" class\x3d"' + Ext.baseCSSPrefix + 'menu-item-text" unselectable\x3d"on"\x3e{text}\x3c/span\x3e', '\x3cimg id\x3d"{id}-arrowEl" src\x3d"{blank}" class\x3d"{arrowCls}', '{childElCls}"/\x3e', 
'\x3c/a\x3e', '\x3c/tpl\x3e'], maskOnDisable:false, activate:function() {
  var me = this;
  if (!me.activated && me.canActivate && me.rendered && !me.isDisabled() && me.isVisible()) {
    me.el.addCls(me.activeCls);
    me.focus();
    me.activated = true;
    me.fireEvent('activate', me);
  }
}, getFocusEl:function() {
  return this.itemEl;
}, deactivate:function() {
  var me = this;
  if (me.activated) {
    me.el.removeCls(me.activeCls);
    me.blur();
    me.hideMenu();
    me.activated = false;
    me.fireEvent('deactivate', me);
  }
}, deferHideMenu:function() {
  if (this.menu.isVisible()) {
    this.menu.hide();
  }
}, cancelDeferHide:function() {
  clearTimeout(this.hideMenuTimer);
}, deferHideParentMenus:function() {
  var ancestor;
  Ext.menu.Manager.hideAll();
  if (!Ext.Element.getActiveElement()) {
    ancestor = this.up(':not([hidden])');
    if (ancestor) {
      ancestor.focus();
    }
  }
}, expandMenu:function(delay) {
  var me = this;
  if (me.menu) {
    me.cancelDeferHide();
    if (delay === 0) {
      me.doExpandMenu();
    } else {
      clearTimeout(me.expandMenuTimer);
      me.expandMenuTimer = Ext.defer(me.doExpandMenu, Ext.isNumber(delay) ? delay : me.menuExpandDelay, me);
    }
  }
}, doExpandMenu:function() {
  var me = this, menu = me.menu;
  if (me.activated && (!menu.rendered || !menu.isVisible())) {
    me.parentMenu.activeChild = menu;
    menu.parentItem = me;
    menu.parentMenu = me.parentMenu;
    menu.showBy(me, me.menuAlign);
  }
}, getRefItems:function(deep) {
  var menu = this.menu, items;
  if (menu) {
    items = menu.getRefItems(deep);
    items.unshift(menu);
  }
  return items || [];
}, hideMenu:function(delay) {
  var me = this;
  if (me.menu) {
    clearTimeout(me.expandMenuTimer);
    me.hideMenuTimer = Ext.defer(me.deferHideMenu, Ext.isNumber(delay) ? delay : me.menuHideDelay, me);
  }
}, initComponent:function() {
  var me = this, prefix = Ext.baseCSSPrefix, cls = [prefix + 'menu-item'], menu;
  me.addEvents('activate', 'click', 'deactivate', 'textchange', 'iconchange');
  if (me.plain) {
    cls.push(prefix + 'menu-item-plain');
  }
  if (me.cls) {
    cls.push(me.cls);
  }
  me.cls = cls.join(' ');
  if (me.menu) {
    menu = me.menu;
    delete me.menu;
    me.setMenu(menu);
  }
  me.callParent(arguments);
}, onClick:function(e) {
  var me = this, clickHideDelay = me.clickHideDelay;
  if (!me.href) {
    e.stopEvent();
  }
  if (me.disabled) {
    return;
  }
  if (me.hideOnClick) {
    if (!clickHideDelay) {
      me.deferHideParentMenus();
    } else {
      me.deferHideParentMenusTimer = Ext.defer(me.deferHideParentMenus, clickHideDelay, me);
    }
  }
  Ext.callback(me.handler, me.scope || me, [me, e]);
  me.fireEvent('click', me, e);
  if (!me.hideOnClick) {
    me.focus();
  }
}, onRemoved:function() {
  var me = this;
  if (me.activated && me.parentMenu.activeItem === me) {
    me.parentMenu.deactivateActiveItem();
  }
  me.callParent(arguments);
  me.parentMenu = me.ownerButton = null;
}, beforeDestroy:function() {
  var me = this;
  if (me.rendered) {
    me.clearTip();
  }
  me.callParent();
}, onDestroy:function() {
  var me = this;
  clearTimeout(me.expandMenuTimer);
  me.cancelDeferHide();
  clearTimeout(me.deferHideParentMenusTimer);
  me.setMenu(null);
  me.callParent(arguments);
}, beforeRender:function() {
  var me = this, blank = Ext.BLANK_IMAGE_URL, glyph = me.glyph, glyphFontFamily = Ext._glyphFontFamily, glyphParts, iconCls, arrowCls;
  me.callParent();
  if (me.iconAlign === 'right') {
    iconCls = me.checkChangeDisabled ? me.disabledCls : '';
    arrowCls = Ext.baseCSSPrefix + 'menu-item-icon-right ' + me.iconCls;
  } else {
    iconCls = (me.iconCls || '') + (me.checkChangeDisabled ? ' ' + me.disabledCls : '');
    arrowCls = me.menu ? me.arrowCls : '';
  }
  if (typeof glyph === 'string') {
    glyphParts = glyph.split('@');
    glyph = glyphParts[0];
    glyphFontFamily = glyphParts[1];
  }
  Ext.applyIf(me.renderData, {href:me.href || '#', hrefTarget:me.hrefTarget, icon:me.icon, iconCls:iconCls, glyph:glyph, glyphCls:glyph ? Ext.baseCSSPrefix + 'menu-item-glyph' : undefined, glyphFontFamily:glyphFontFamily, hasIcon:!!(me.icon || me.iconCls || glyph), iconAlign:me.iconAlign, plain:me.plain, text:me.text, arrowCls:arrowCls, blank:blank, tabIndex:me.tabIndex});
}, onRender:function() {
  var me = this;
  me.callParent(arguments);
  if (me.tooltip) {
    me.setTooltip(me.tooltip, true);
  }
}, setMenu:function(menu, destroyMenu) {
  var me = this, oldMenu = me.menu, arrowEl = me.arrowEl;
  if (oldMenu) {
    delete oldMenu.parentItem;
    delete oldMenu.parentMenu;
    delete oldMenu.ownerItem;
    if (destroyMenu === true || destroyMenu !== false && me.destroyMenu) {
      Ext.destroy(oldMenu);
    }
  }
  if (menu) {
    me.menu = Ext.menu.Manager.get(menu);
    me.menu.ownerItem = me;
  } else {
    me.menu = null;
  }
  if (me.rendered && !me.destroying && arrowEl) {
    arrowEl[me.menu ? 'addCls' : 'removeCls'](me.arrowCls);
  }
}, setHandler:function(fn, scope) {
  this.handler = fn || null;
  this.scope = scope;
}, setIcon:function(icon) {
  var iconEl = this.iconEl, oldIcon = this.icon;
  if (iconEl) {
    iconEl.src = icon || Ext.BLANK_IMAGE_URL;
  }
  this.icon = icon;
  this.fireEvent('iconchange', this, oldIcon, icon);
}, setIconCls:function(iconCls) {
  var me = this, iconEl = me.iconEl, oldCls = me.iconCls;
  if (iconEl) {
    if (me.iconCls) {
      iconEl.removeCls(me.iconCls);
    }
    if (iconCls) {
      iconEl.addCls(iconCls);
    }
  }
  me.iconCls = iconCls;
  me.fireEvent('iconchange', me, oldCls, iconCls);
}, setText:function(text) {
  var me = this, el = me.textEl || me.el, oldText = me.text;
  me.text = text;
  if (me.rendered) {
    el.update(text || '');
    me.ownerCt.updateLayout();
  }
  me.fireEvent('textchange', me, oldText, text);
}, getTipAttr:function() {
  return this.tooltipType == 'qtip' ? 'data-qtip' : 'title';
}, clearTip:function() {
  if (Ext.quickTipsActive && Ext.isObject(this.tooltip)) {
    Ext.tip.QuickTipManager.unregister(this.itemEl);
  }
}, setTooltip:function(tooltip, initial) {
  var me = this;
  if (me.rendered) {
    if (!initial) {
      me.clearTip();
    }
    if (Ext.quickTipsActive && Ext.isObject(tooltip)) {
      Ext.tip.QuickTipManager.register(Ext.apply({target:me.itemEl.id}, tooltip));
      me.tooltip = tooltip;
    } else {
      me.itemEl.dom.setAttribute(me.getTipAttr(), tooltip);
    }
  } else {
    me.tooltip = tooltip;
  }
  return me;
}});
Ext.define('Ext.menu.CheckItem', {extend:Ext.menu.Item, alias:'widget.menucheckitem', checkedCls:Ext.baseCSSPrefix + 'menu-item-checked', uncheckedCls:Ext.baseCSSPrefix + 'menu-item-unchecked', groupCls:Ext.baseCSSPrefix + 'menu-group-icon', hideOnClick:false, checkChangeDisabled:false, childEls:['itemEl', 'iconEl', 'textEl', 'checkEl'], showCheckbox:true, renderTpl:['\x3ctpl if\x3d"plain"\x3e', '{text}', '\x3ctpl else\x3e', '{%var showCheckbox \x3d values.showCheckbox,', '      rightCheckbox \x3d showCheckbox \x26\x26 values.hasIcon \x26\x26 (values.iconAlign !\x3d\x3d "left"), textCls \x3d rightCheckbox ? "' + 
Ext.baseCSSPrefix + 'right-check-item-text" : "";%}', '\x3ca id\x3d"{id}-itemEl" class\x3d"' + Ext.baseCSSPrefix + 'menu-item-link{childElCls}" href\x3d"{href}" \x3ctpl if\x3d"hrefTarget"\x3etarget\x3d"{hrefTarget}"\x3c/tpl\x3e hidefocus\x3d"true" unselectable\x3d"on"', '\x3ctpl if\x3d"tabIndex"\x3e', ' tabIndex\x3d"{tabIndex}"', '\x3c/tpl\x3e', '\x3e', '{%if (values.hasIcon \x26\x26 (values.iconAlign !\x3d\x3d "left")) {%}', '\x3cdiv role\x3d"img" id\x3d"{id}-iconEl" class\x3d"' + Ext.baseCSSPrefix + 
'menu-item-icon {iconCls}', '{childElCls} {glyphCls}" style\x3d"\x3ctpl if\x3d"icon"\x3ebackground-image:url({icon});\x3c/tpl\x3e', '\x3ctpl if\x3d"glyph \x26\x26 glyphFontFamily"\x3efont-family:{glyphFontFamily};\x3c/tpl\x3e"\x3e', '\x3ctpl if\x3d"glyph"\x3e\x26#{glyph};\x3c/tpl\x3e', '\x3c/div\x3e', '{%} else if (showCheckbox){%}', '\x3cimg id\x3d"{id}-checkEl" src\x3d"{blank}" class\x3d"' + Ext.baseCSSPrefix + 'menu-item-icon{childElCls}" /\x3e', '{%}%}', '\x3cspan id\x3d"{id}-textEl" class\x3d"' + 
Ext.baseCSSPrefix + 'menu-item-text {[textCls]}{childElCls}" \x3ctpl if\x3d"arrowCls"\x3estyle\x3d"margin-right: 17px;"\x3c/tpl\x3e \x3e{text}\x3c/span\x3e', '{%if (rightCheckbox) {%}', '\x3cimg id\x3d"{id}-checkEl" src\x3d"{blank}" class\x3d"' + Ext.baseCSSPrefix + 'menu-item-icon-right{childElCls}" /\x3e', '{%} else if (values.arrowCls) {%}', '\x3cimg id\x3d"{id}-arrowEl" src\x3d"{blank}" class\x3d"{arrowCls}{childElCls}"/\x3e', '{%}%}', '\x3c/a\x3e', '\x3c/tpl\x3e'], initComponent:function() {
  var me = this;
  me.checked = !!me.checked;
  me.addEvents('beforecheckchange', 'checkchange');
  me.callParent(arguments);
  Ext.menu.Manager.registerCheckable(me);
  if (me.group) {
    me.showCheckbox = false;
    if (!(me.iconCls || me.icon || me.glyph)) {
      me.iconCls = me.groupCls;
    }
    if (me.initialConfig.hideOnClick !== false) {
      me.hideOnClick = true;
    }
  }
}, beforeRender:function() {
  this.callParent();
  this.renderData.showCheckbox = this.showCheckbox;
}, afterRender:function() {
  var me = this;
  me.callParent();
  me.checked = !me.checked;
  me.setChecked(!me.checked, true);
  if (me.checkChangeDisabled) {
    me.disableCheckChange();
  }
}, disableCheckChange:function() {
  var me = this, checkEl = me.checkEl;
  if (checkEl) {
    checkEl.addCls(me.disabledCls);
  }
  if (!(Ext.isIE10p || Ext.isIE9 && Ext.isStrict) && me.rendered) {
    me.el.repaint();
  }
  me.checkChangeDisabled = true;
}, enableCheckChange:function() {
  var me = this, checkEl = me.checkEl;
  if (checkEl) {
    checkEl.removeCls(me.disabledCls);
  }
  me.checkChangeDisabled = false;
}, onClick:function(e) {
  var me = this;
  if (!me.disabled && !me.checkChangeDisabled && !(me.checked && me.group)) {
    me.setChecked(!me.checked);
  }
  this.callParent([e]);
}, onDestroy:function() {
  Ext.menu.Manager.unregisterCheckable(this);
  this.callParent(arguments);
}, setChecked:function(checked, suppressEvents) {
  var me = this;
  if (me.checked !== checked && (suppressEvents || me.fireEvent('beforecheckchange', me, checked) !== false)) {
    if (me.el) {
      me.el[checked ? 'addCls' : 'removeCls'](me.checkedCls)[!checked ? 'addCls' : 'removeCls'](me.uncheckedCls);
    }
    me.checked = checked;
    Ext.menu.Manager.onCheckChange(me, checked);
    if (!suppressEvents) {
      Ext.callback(me.checkHandler, me.scope, [me, checked]);
      me.fireEvent('checkchange', me, checked);
    }
  }
}});
Ext.define('Ext.menu.KeyNav', {extend:Ext.util.KeyNav, constructor:function(config) {
  var me = this;
  me.menu = config.target;
  me.callParent([Ext.apply({down:me.down, enter:me.enter, esc:me.escape, left:me.left, right:me.right, space:me.enter, tab:me.tab, up:me.up}, config)]);
}, down:function(e) {
  var me = this, fi = me.menu.focusedItem;
  if (fi && e.getKey() == Ext.EventObject.DOWN && me.isWhitelisted(fi)) {
    return true;
  }
  me.focusNextItem(1);
}, enter:function(e) {
  var menu = this.menu, focused = menu.focusedItem;
  if (menu.activeItem) {
    menu.onClick(e);
  } else {
    if (focused && focused.isFormField) {
      return true;
    }
  }
}, escape:function(e) {
  Ext.menu.Manager.hideAll();
}, focusNextItem:function(step) {
  var menu = this.menu, items = menu.items, focusedItem = menu.focusedItem, startIdx = focusedItem ? items.indexOf(focusedItem) : -1, idx = startIdx + step, len = items.length, count = 0, item;
  while (count < len && idx !== startIdx) {
    if (idx < 0) {
      idx = len - 1;
    } else {
      if (idx >= len) {
        idx = 0;
      }
    }
    item = items.getAt(idx);
    if (menu.canActivateItem(item)) {
      menu.setActiveItem(item);
      break;
    }
    idx += step;
    ++count;
  }
}, isWhitelisted:function(item) {
  return Ext.FocusManager.isWhitelisted(item);
}, left:function(e) {
  var menu = this.menu, fi = menu.focusedItem;
  if (fi && this.isWhitelisted(fi)) {
    return true;
  }
  menu.hide();
  if (menu.parentMenu) {
    menu.parentMenu.focus();
  }
}, right:function(e) {
  var menu = this.menu, fi = menu.focusedItem, ai = menu.activeItem, am;
  if (fi && this.isWhitelisted(fi)) {
    return true;
  }
  if (ai) {
    am = menu.activeItem.menu;
    if (am) {
      ai.expandMenu(0);
      am.setActiveItem(am.child(':focusable'));
    }
  }
}, tab:function(e) {
  var me = this;
  if (e.shiftKey) {
    me.up(e);
  } else {
    me.down(e);
  }
}, up:function(e) {
  var me = this, fi = me.menu.focusedItem;
  if (fi && e.getKey() == Ext.EventObject.UP && me.isWhitelisted(fi)) {
    return true;
  }
  me.focusNextItem(-1);
}});
Ext.define('Ext.menu.Separator', {extend:Ext.menu.Item, alias:'widget.menuseparator', canActivate:false, focusable:false, hideOnClick:false, plain:true, separatorCls:Ext.baseCSSPrefix + 'menu-item-separator', text:'\x26#160;', beforeRender:function(ct, pos) {
  var me = this;
  me.callParent();
  me.addCls(me.separatorCls);
}});
Ext.define('Ext.menu.Menu', {extend:Ext.panel.Panel, alias:'widget.menu', enableKeyNav:true, allowOtherMenus:false, ariaRole:'menu', floating:true, constrain:true, hidden:true, hideMode:'visibility', ignoreParentClicks:false, isMenu:true, showSeparator:true, minWidth:undefined, defaultMinWidth:120, initComponent:function() {
  var me = this, prefix = Ext.baseCSSPrefix, cls = [prefix + 'menu'], bodyCls = me.bodyCls ? [me.bodyCls] : [], isFloating = me.floating !== false;
  me.addEvents('click', 'mouseenter', 'mouseleave', 'mouseover');
  Ext.menu.Manager.register(me);
  if (me.plain) {
    cls.push(prefix + 'menu-plain');
  }
  me.cls = cls.join(' ');
  bodyCls.push(prefix + 'menu-body', Ext.dom.Element.unselectableCls);
  me.bodyCls = bodyCls.join(' ');
  if (!me.layout) {
    me.layout = {type:'vbox', align:'stretchmax', overflowHandler:'Scroller'};
  }
  if (isFloating) {
    if (me.minWidth === undefined) {
      me.minWidth = me.defaultMinWidth;
    }
  } else {
    me.hidden = !!me.initialConfig.hidden;
    me.constrain = false;
  }
  me.callParent(arguments);
}, registerWithOwnerCt:function() {
  if (this.floating) {
    this.ownerCt = null;
    Ext.WindowManager.register(this);
  }
}, initHierarchyEvents:Ext.emptyFn, isVisible:function() {
  return this.callParent();
}, getHierarchyState:function() {
  var result = this.callParent();
  result.hidden = this.hidden;
  return result;
}, beforeRender:function() {
  this.callParent(arguments);
  if (!this.getSizeModel().width.shrinkWrap) {
    this.layout.align = 'stretch';
  }
}, onBoxReady:function() {
  var me = this;
  me.callParent(arguments);
  if (me.showSeparator) {
    me.iconSepEl = me.layout.getElementTarget().insertFirst({cls:Ext.baseCSSPrefix + 'menu-icon-separator', html:'\x26#160;'});
  }
  me.mon(me.el, {click:me.onClick, mouseover:me.onMouseOver, scope:me});
  me.mouseMonitor = me.el.monitorMouseLeave(100, me.onMouseLeave, me);
  if (me.enableKeyNav) {
    me.keyNav = new Ext.menu.KeyNav({target:me, keyMap:me.getKeyMap()});
  }
}, getRefOwner:function() {
  return this.parentMenu || this.ownerButton || this.callParent(arguments);
}, canActivateItem:function(item) {
  return item && !item.isDisabled() && item.isVisible() && (item.canActivate || item.getXTypes().indexOf('menuitem') < 0);
}, deactivateActiveItem:function(andBlurFocusedItem) {
  var me = this, activeItem = me.activeItem, focusedItem = me.focusedItem;
  if (activeItem) {
    activeItem.deactivate();
    if (!activeItem.activated) {
      delete me.activeItem;
    }
  }
  if (focusedItem && andBlurFocusedItem) {
    focusedItem.blur();
    delete me.focusedItem;
  }
}, getFocusEl:function() {
  return this.focusedItem || this.el;
}, hide:function() {
  this.deactivateActiveItem(true);
  this.callParent(arguments);
}, getItemFromEvent:function(e) {
  return this.getChildByElement(e.getTarget());
}, lookupComponent:function(cmp) {
  var me = this;
  if (typeof cmp == 'string') {
    cmp = me.lookupItemFromString(cmp);
  } else {
    if (Ext.isObject(cmp)) {
      cmp = me.lookupItemFromObject(cmp);
    }
  }
  cmp.minWidth = cmp.minWidth || me.minWidth;
  return cmp;
}, lookupItemFromObject:function(cmp) {
  var me = this, prefix = Ext.baseCSSPrefix, cls;
  if (!cmp.isComponent) {
    if (!cmp.xtype) {
      cmp = Ext.create('Ext.menu.' + (Ext.isBoolean(cmp.checked) ? 'Check' : '') + 'Item', cmp);
    } else {
      cmp = Ext.ComponentManager.create(cmp, cmp.xtype);
    }
  }
  if (cmp.isMenuItem) {
    cmp.parentMenu = me;
  }
  if (!cmp.isMenuItem && !cmp.dock) {
    cls = [prefix + 'menu-item-cmp'];
    if (!me.plain && (cmp.indent !== false || cmp.iconCls === 'no-icon')) {
      cls.push(prefix + 'menu-item-indent');
    }
    if (cmp.rendered) {
      cmp.el.addCls(cls);
    } else {
      cmp.cls = (cmp.cls || '') + ' ' + cls.join(' ');
    }
  }
  return cmp;
}, lookupItemFromString:function(cmp) {
  return cmp == 'separator' || cmp == '-' ? new Ext.menu.Separator : new Ext.menu.Item({canActivate:false, hideOnClick:false, plain:true, text:cmp});
}, onClick:function(e) {
  var me = this, item;
  if (me.disabled) {
    e.stopEvent();
    return;
  }
  item = e.type === 'click' ? me.getItemFromEvent(e) : me.activeItem;
  if (item && item.isMenuItem) {
    if (!item.menu || !me.ignoreParentClicks) {
      item.onClick(e);
    } else {
      e.stopEvent();
    }
  }
  if (!item || item.disabled) {
    item = undefined;
  }
  me.fireEvent('click', me, item, e);
}, onDestroy:function() {
  var me = this;
  Ext.menu.Manager.unregister(me);
  me.parentMenu = me.ownerButton = null;
  if (me.rendered) {
    me.el.un(me.mouseMonitor);
    Ext.destroy(me.keyNav);
    me.keyNav = null;
  }
  me.callParent(arguments);
}, onMouseLeave:function(e) {
  var me = this;
  me.deactivateActiveItem();
  if (me.disabled) {
    return;
  }
  me.fireEvent('mouseleave', me, e);
}, onMouseOver:function(e) {
  var me = this, fromEl = e.getRelatedTarget(), mouseEnter = !me.el.contains(fromEl), item = me.getItemFromEvent(e), parentMenu = me.parentMenu, parentItem = me.parentItem;
  if (mouseEnter && parentMenu) {
    parentMenu.setActiveItem(parentItem);
    parentItem.cancelDeferHide();
    parentMenu.mouseMonitor.mouseenter();
  }
  if (me.disabled) {
    return;
  }
  if (item && !item.activated) {
    me.setActiveItem(item);
    if (item.activated && item.expandMenu) {
      item.expandMenu();
    }
  }
  if (mouseEnter) {
    me.fireEvent('mouseenter', me, e);
  }
  me.fireEvent('mouseover', me, item, e);
}, setActiveItem:function(item) {
  var me = this;
  if (item && item != me.activeItem) {
    me.deactivateActiveItem();
    if (me.canActivateItem(item)) {
      if (item.activate) {
        item.activate();
        if (item.activated) {
          me.activeItem = item;
          me.focusedItem = item;
          me.focus();
        }
      } else {
        item.focus();
        me.focusedItem = item;
      }
    }
    item.el.scrollIntoView(me.layout.getRenderTarget());
  }
}, showBy:function(cmp, pos, off) {
  var me = this;
  me.callParent(arguments);
  if (!me.hidden) {
    me.setVerticalPosition();
  }
  return me;
}, beforeShow:function() {
  var me = this, viewHeight;
  if (me.floating) {
    me.savedMaxHeight = me.maxHeight;
    viewHeight = me.container.getViewSize().height;
    me.maxHeight = Math.min(me.maxHeight || viewHeight, viewHeight);
  }
  me.callParent(arguments);
}, afterShow:function() {
  var me = this;
  me.callParent(arguments);
  if (me.floating) {
    me.maxHeight = me.savedMaxHeight;
  }
}, setVerticalPosition:function() {
  var me = this, max, y = me.getY(), returnY = y, height = me.getHeight(), viewportHeight = Ext.Element.getViewportHeight().height, parentEl = me.el.parent(), viewHeight = parentEl.getViewSize().height, normalY = y - parentEl.getScroll().top;
  parentEl = null;
  if (me.floating) {
    max = me.maxHeight ? me.maxHeight : viewHeight - normalY;
    if (height > viewHeight) {
      returnY = y - normalY;
    } else {
      if (max < height) {
        returnY = y - (height - max);
      } else {
        if (y + height > viewportHeight) {
          returnY = viewportHeight - height;
        }
      }
    }
  }
  me.setY(returnY);
}});
Ext.define('Ext.panel.Tool', {extend:Ext.Component, alias:'widget.tool', isTool:true, baseCls:Ext.baseCSSPrefix + 'tool', disabledCls:Ext.baseCSSPrefix + 'tool-disabled', toolPressedCls:Ext.baseCSSPrefix + 'tool-pressed', toolOverCls:Ext.baseCSSPrefix + 'tool-over', ariaRole:'button', childEls:['toolEl'], renderTpl:['\x3cimg role\x3d"presentation" id\x3d"{id}-toolEl" src\x3d"{blank}" class\x3d"{baseCls}-img {baseCls}-{type}' + '{childElCls}" role\x3d"presentation"/\x3e'], toolOwner:null, tooltipType:'qtip', 
stopEvent:true, height:15, width:15, _toolTypes:{close:1, collapse:1, down:1, expand:1, gear:1, help:1, left:1, maximize:1, minimize:1, minus:1, next:1, pin:1, plus:1, prev:1, print:1, refresh:1, restore:1, right:1, save:1, search:1, toggle:1, unpin:1, up:1}, initComponent:function() {
  var me = this;
  me.addEvents('click');
  if (me.id && me._toolTypes[me.id] && Ext.global.console) {
    Ext.global.console.warn('When specifying a tool you should use the type option, the id can conflict now that tool is a Component');
  }
  me.type = me.type || me.id;
  Ext.applyIf(me.renderData, {baseCls:me.baseCls, blank:Ext.BLANK_IMAGE_URL, type:me.type});
  me.tooltip = me.tooltip || me.qtip;
  me.callParent();
}, afterRender:function() {
  var me = this, attr;
  me.callParent(arguments);
  me.el.on({click:me.onClick, mousedown:me.onMouseDown, mouseover:me.onMouseOver, mouseout:me.onMouseOut, scope:me});
  if (me.tooltip) {
    if (Ext.quickTipsActive && Ext.isObject(me.tooltip)) {
      Ext.tip.QuickTipManager.register(Ext.apply({target:me.id}, me.tooltip));
    } else {
      attr = me.tooltipType == 'qtip' ? 'data-qtip' : 'title';
      me.el.dom.setAttribute(attr, me.tooltip);
    }
  }
}, getFocusEl:function() {
  return this.el;
}, setType:function(type) {
  var me = this, oldType = me.type;
  me.type = type;
  if (me.rendered) {
    if (oldType) {
      me.toolEl.removeCls(me.baseCls + '-' + oldType);
    }
    me.toolEl.addCls(me.baseCls + '-' + type);
  } else {
    me.renderData.type = type;
  }
  return me;
}, onClick:function(e, target) {
  var me = this;
  if (me.disabled) {
    return false;
  }
  me.el.removeCls(me.toolPressedCls);
  me.el.removeCls(me.toolOverCls);
  if (me.stopEvent !== false) {
    e.stopEvent();
  }
  if (me.handler) {
    Ext.callback(me.handler, me.scope || me, [e, target, me.ownerCt, me]);
  } else {
    if (me.callback) {
      Ext.callback(me.callback, me.scope || me, [me.toolOwner || me.ownerCt, me, e]);
    }
  }
  me.fireEvent('click', me, e);
  return true;
}, onDestroy:function() {
  if (Ext.quickTipsActive && Ext.isObject(this.tooltip)) {
    Ext.tip.QuickTipManager.unregister(this.id);
  }
  this.callParent();
}, onMouseDown:function() {
  if (this.disabled) {
    return false;
  }
  this.el.addCls(this.toolPressedCls);
}, onMouseOver:function() {
  if (this.disabled) {
    return false;
  }
  this.el.addCls(this.toolOverCls);
}, onMouseOut:function() {
  this.el.removeCls(this.toolOverCls);
}});
Ext.define('Ext.resizer.SplitterTracker', {extend:Ext.dd.DragTracker, enabled:true, overlayCls:Ext.baseCSSPrefix + 'resizable-overlay', createDragOverlay:function() {
  var overlay;
  overlay = this.overlay = Ext.getBody().createChild({cls:this.overlayCls, html:'\x26#160;'});
  overlay.unselectable();
  overlay.setSize(Ext.Element.getViewWidth(true), Ext.Element.getViewHeight(true));
  overlay.show();
}, getPrevCmp:function() {
  var splitter = this.getSplitter();
  return splitter.previousSibling(':not([hidden])');
}, getNextCmp:function() {
  var splitter = this.getSplitter();
  return splitter.nextSibling(':not([hidden])');
}, onBeforeStart:function(e) {
  var me = this, prevCmp = me.getPrevCmp(), nextCmp = me.getNextCmp(), collapseEl = me.getSplitter().collapseEl, target = e.getTarget(), box;
  if (!prevCmp || !nextCmp) {
    return false;
  }
  if (collapseEl && target === me.getSplitter().collapseEl.dom) {
    return false;
  }
  if (nextCmp.collapsed || prevCmp.collapsed) {
    return false;
  }
  me.prevBox = prevCmp.getEl().getBox();
  me.nextBox = nextCmp.getEl().getBox();
  me.constrainTo = box = me.calculateConstrainRegion();
  if (!box) {
    return false;
  }
  return box;
}, onStart:function(e) {
  var splitter = this.getSplitter();
  this.createDragOverlay();
  splitter.addCls(splitter.baseCls + '-active');
}, calculateConstrainRegion:function() {
  var me = this, splitter = me.getSplitter(), splitWidth = splitter.getWidth(), defaultMin = splitter.defaultSplitMin, orient = splitter.orientation, prevBox = me.prevBox, prevCmp = me.getPrevCmp(), nextBox = me.nextBox, nextCmp = me.getNextCmp(), prevConstrainRegion, nextConstrainRegion, constrainOptions;
  if (orient === 'vertical') {
    constrainOptions = {prevCmp:prevCmp, nextCmp:nextCmp, prevBox:prevBox, nextBox:nextBox, defaultMin:defaultMin, splitWidth:splitWidth};
    prevConstrainRegion = new Ext.util.Region(prevBox.y, me.getVertPrevConstrainRight(constrainOptions), prevBox.bottom, me.getVertPrevConstrainLeft(constrainOptions));
    nextConstrainRegion = new Ext.util.Region(nextBox.y, me.getVertNextConstrainRight(constrainOptions), nextBox.bottom, me.getVertNextConstrainLeft(constrainOptions));
  } else {
    prevConstrainRegion = new Ext.util.Region(prevBox.y + (prevCmp.minHeight || defaultMin), prevBox.right, (prevCmp.maxHeight ? prevBox.y + prevCmp.maxHeight : nextBox.bottom - (nextCmp.minHeight || defaultMin)) + splitWidth, prevBox.x);
    nextConstrainRegion = new Ext.util.Region((nextCmp.maxHeight ? nextBox.bottom - nextCmp.maxHeight : prevBox.y + (prevCmp.minHeight || defaultMin)) - splitWidth, nextBox.right, nextBox.bottom - (nextCmp.minHeight || defaultMin), nextBox.x);
  }
  return prevConstrainRegion.intersect(nextConstrainRegion);
}, performResize:function(e, offset) {
  var me = this, splitter = me.getSplitter(), orient = splitter.orientation, prevCmp = me.getPrevCmp(), nextCmp = me.getNextCmp(), owner = splitter.ownerCt, flexedSiblings = owner.query('\x3e[flex]'), len = flexedSiblings.length, vertical = orient === 'vertical', i = 0, dimension = vertical ? 'width' : 'height', totalFlex = 0, item, size;
  for (; i < len; i++) {
    item = flexedSiblings[i];
    size = vertical ? item.getWidth() : item.getHeight();
    totalFlex += size;
    item.flex = size;
  }
  offset = vertical ? offset[0] : offset[1];
  if (prevCmp) {
    size = me.prevBox[dimension] + offset;
    if (prevCmp.flex) {
      prevCmp.flex = size;
    } else {
      prevCmp[dimension] = size;
    }
  }
  if (nextCmp) {
    size = me.nextBox[dimension] - offset;
    if (nextCmp.flex) {
      nextCmp.flex = size;
    } else {
      nextCmp[dimension] = size;
    }
  }
  owner.updateLayout();
}, endDrag:function() {
  var me = this;
  if (me.overlay) {
    me.overlay.remove();
    delete me.overlay;
  }
  me.callParent(arguments);
}, onEnd:function(e) {
  var me = this, splitter = me.getSplitter();
  splitter.removeCls(splitter.baseCls + '-active');
  me.performResize(e, me.getResizeOffset());
}, onDrag:function(e) {
  var me = this, offset = me.getOffset('dragTarget'), splitter = me.getSplitter(), splitEl = splitter.getEl(), orient = splitter.orientation;
  if (orient === 'vertical') {
    splitEl.setX(me.startRegion.left + offset[0]);
  } else {
    splitEl.setY(me.startRegion.top + offset[1]);
  }
}, getSplitter:function() {
  return this.splitter;
}, getVertPrevConstrainRight:function(o) {
  return (o.prevCmp.maxWidth ? o.prevBox.x + o.prevCmp.maxWidth : o.nextBox.right - (o.nextCmp.minWidth || o.defaultMin)) + o.splitWidth;
}, getVertPrevConstrainLeft:function(o) {
  return o.prevBox.x + (o.prevCmp.minWidth || o.defaultMin);
}, getVertNextConstrainRight:function(o) {
  return o.nextBox.right - (o.nextCmp.minWidth || o.defaultMin);
}, getVertNextConstrainLeft:function(o) {
  return (o.nextCmp.maxWidth ? o.nextBox.right - o.nextCmp.maxWidth : o.prevBox.x + (o.prevBox.minWidth || o.defaultMin)) - o.splitWidth;
}, getResizeOffset:function() {
  return this.getOffset('dragTarget');
}});
Ext.define('Ext.resizer.BorderSplitterTracker', {extend:Ext.resizer.SplitterTracker, getPrevCmp:null, getNextCmp:null, calculateConstrainRegion:function() {
  var me = this, splitter = me.splitter, collapseTarget = splitter.collapseTarget, defaultSplitMin = splitter.defaultSplitMin, sizePropCap = splitter.vertical ? 'Width' : 'Height', minSizeProp = 'min' + sizePropCap, maxSizeProp = 'max' + sizePropCap, getSizeMethod = 'get' + sizePropCap, neighbors = splitter.neighbors, length = neighbors.length, box = collapseTarget.el.getBox(), left = box.x, top = box.y, right = box.right, bottom = box.bottom, size = splitter.vertical ? right - left : bottom - top, 
  i, neighbor, minRange, maxRange, maxGrowth, maxShrink, targetSize;
  minRange = (collapseTarget[minSizeProp] || Math.min(size, defaultSplitMin)) - size;
  maxRange = collapseTarget[maxSizeProp];
  if (!maxRange) {
    maxRange = 1000000000;
  } else {
    maxRange -= size;
  }
  targetSize = size;
  for (i = 0; i < length; ++i) {
    neighbor = neighbors[i];
    size = neighbor[getSizeMethod]();
    maxGrowth = size - neighbor[maxSizeProp];
    maxShrink = size - (neighbor[minSizeProp] || Math.min(size, defaultSplitMin));
    if (!isNaN(maxGrowth)) {
      if (minRange < maxGrowth) {
        minRange = maxGrowth;
      }
    }
    if (maxRange > maxShrink) {
      maxRange = maxShrink;
    }
  }
  if (maxRange - minRange < 2) {
    return null;
  }
  box = new Ext.util.Region(top, right, bottom, left);
  me.constraintAdjusters[me.getCollapseDirection()](box, minRange, maxRange, splitter);
  me.dragInfo = {minRange:minRange, maxRange:maxRange, targetSize:targetSize};
  return box;
}, constraintAdjusters:{left:function(box, minRange, maxRange, splitter) {
  box[0] = box.x = box.left = box.right + minRange;
  box.right += maxRange + splitter.getWidth();
}, top:function(box, minRange, maxRange, splitter) {
  box[1] = box.y = box.top = box.bottom + minRange;
  box.bottom += maxRange + splitter.getHeight();
}, bottom:function(box, minRange, maxRange, splitter) {
  box.bottom = box.top - minRange;
  box.top -= maxRange + splitter.getHeight();
}, right:function(box, minRange, maxRange, splitter) {
  box.right = box.left - minRange;
  box[0] = box.x = box.left = box.x - maxRange + splitter.getWidth();
}}, onBeforeStart:function(e) {
  var me = this, splitter = me.splitter, collapseTarget = splitter.collapseTarget, neighbors = splitter.neighbors, collapseEl = me.getSplitter().collapseEl, target = e.getTarget(), length = neighbors.length, i, neighbor;
  if (collapseEl && target === splitter.collapseEl.dom) {
    return false;
  }
  if (collapseTarget.collapsed) {
    return false;
  }
  for (i = 0; i < length; ++i) {
    neighbor = neighbors[i];
    if (neighbor.collapsed && neighbor.isHorz === collapseTarget.isHorz) {
      return false;
    }
  }
  if (!(me.constrainTo = me.calculateConstrainRegion())) {
    return false;
  }
  return true;
}, performResize:function(e, offset) {
  var me = this, splitter = me.splitter, collapseDirection = splitter.getCollapseDirection(), collapseTarget = splitter.collapseTarget, adjusters = me.splitAdjusters[splitter.vertical ? 'horz' : 'vert'], delta = offset[adjusters.index], dragInfo = me.dragInfo, owner;
  if (collapseDirection == 'right' || collapseDirection == 'bottom') {
    delta = -delta;
  }
  delta = Math.min(Math.max(dragInfo.minRange, delta), dragInfo.maxRange);
  if (delta) {
    (owner = splitter.ownerCt).suspendLayouts();
    adjusters.adjustTarget(collapseTarget, dragInfo.targetSize, delta);
    owner.resumeLayouts(true);
  }
}, splitAdjusters:{horz:{index:0, adjustTarget:function(target, size, delta) {
  target.flex = null;
  target.setSize(size + delta);
}}, vert:{index:1, adjustTarget:function(target, targetSize, delta) {
  target.flex = null;
  target.setSize(undefined, targetSize + delta);
}}}, getCollapseDirection:function() {
  return this.splitter.getCollapseDirection();
}});
Ext.define('Ext.resizer.ResizeTracker', {extend:Ext.dd.DragTracker, dynamic:true, preserveRatio:false, constrainTo:null, proxyCls:Ext.baseCSSPrefix + 'resizable-proxy', constructor:function(config) {
  var me = this, widthRatio, heightRatio, throttledResizeFn;
  if (!config.el) {
    if (config.target.isComponent) {
      me.el = config.target.getEl();
    } else {
      me.el = config.target;
    }
  }
  this.callParent(arguments);
  if (me.preserveRatio && me.minWidth && me.minHeight) {
    widthRatio = me.minWidth / me.el.getWidth();
    heightRatio = me.minHeight / me.el.getHeight();
    if (heightRatio > widthRatio) {
      me.minWidth = me.el.getWidth() * heightRatio;
    } else {
      me.minHeight = me.el.getHeight() * widthRatio;
    }
  }
  if (me.throttle) {
    throttledResizeFn = Ext.Function.createThrottled(function() {
      Ext.resizer.ResizeTracker.prototype.resize.apply(me, arguments);
    }, me.throttle);
    me.resize = function(box, direction, atEnd) {
      if (atEnd) {
        Ext.resizer.ResizeTracker.prototype.resize.apply(me, arguments);
      } else {
        throttledResizeFn.apply(null, arguments);
      }
    };
  }
}, onBeforeStart:function(e) {
  this.startBox = this.target.getBox();
}, getDynamicTarget:function() {
  var me = this, target = me.target;
  if (me.dynamic) {
    return target;
  } else {
    if (!me.proxy) {
      me.proxy = me.createProxy(target);
    }
  }
  me.proxy.show();
  return me.proxy;
}, createProxy:function(target) {
  var proxy, cls = this.proxyCls;
  if (target.isComponent) {
    proxy = target.getProxy().addCls(cls);
  } else {
    proxy = target.createProxy({tag:'div', cls:cls, id:target.id + '-rzproxy'}, Ext.getBody());
  }
  proxy.removeCls(Ext.baseCSSPrefix + 'proxy-el');
  return proxy;
}, onStart:function(e) {
  this.activeResizeHandle = Ext.get(this.getDragTarget().id);
  if (!this.dynamic) {
    this.resize(this.startBox, {horizontal:'none', vertical:'none'});
  }
}, onDrag:function(e) {
  if (this.dynamic || this.proxy) {
    this.updateDimensions(e);
  }
}, updateDimensions:function(e, atEnd) {
  var me = this, region = me.activeResizeHandle.region, offset = me.getOffset(me.constrainTo ? 'dragTarget' : null), box = me.startBox, ratio, widthAdjust = 0, heightAdjust = 0, snappedWidth, snappedHeight, adjustX = 0, adjustY = 0, dragRatio, horizDir = offset[0] < 0 ? 'right' : 'left', vertDir = offset[1] < 0 ? 'down' : 'up', oppositeCorner, axis, newBox, newHeight, newWidth;
  region = me.convertRegionName(region);
  switch(region) {
    case 'south':
      heightAdjust = offset[1];
      axis = 2;
      break;
    case 'north':
      heightAdjust = -offset[1];
      adjustY = -heightAdjust;
      axis = 2;
      break;
    case 'east':
      widthAdjust = offset[0];
      axis = 1;
      break;
    case 'west':
      widthAdjust = -offset[0];
      adjustX = -widthAdjust;
      axis = 1;
      break;
    case 'northeast':
      heightAdjust = -offset[1];
      adjustY = -heightAdjust;
      widthAdjust = offset[0];
      oppositeCorner = [box.x, box.y + box.height];
      axis = 3;
      break;
    case 'southeast':
      heightAdjust = offset[1];
      widthAdjust = offset[0];
      oppositeCorner = [box.x, box.y];
      axis = 3;
      break;
    case 'southwest':
      widthAdjust = -offset[0];
      adjustX = -widthAdjust;
      heightAdjust = offset[1];
      oppositeCorner = [box.x + box.width, box.y];
      axis = 3;
      break;
    case 'northwest':
      heightAdjust = -offset[1];
      adjustY = -heightAdjust;
      widthAdjust = -offset[0];
      adjustX = -widthAdjust;
      oppositeCorner = [box.x + box.width, box.y + box.height];
      axis = 3;
      break;
  }
  newBox = {width:box.width + widthAdjust, height:box.height + heightAdjust, x:box.x + adjustX, y:box.y + adjustY};
  snappedWidth = Ext.Number.snap(newBox.width, me.widthIncrement);
  snappedHeight = Ext.Number.snap(newBox.height, me.heightIncrement);
  if (snappedWidth != newBox.width || snappedHeight != newBox.height) {
    switch(region) {
      case 'northeast':
        newBox.y -= snappedHeight - newBox.height;
        break;
      case 'north':
        newBox.y -= snappedHeight - newBox.height;
        break;
      case 'southwest':
        newBox.x -= snappedWidth - newBox.width;
        break;
      case 'west':
        newBox.x -= snappedWidth - newBox.width;
        break;
      case 'northwest':
        newBox.x -= snappedWidth - newBox.width;
        newBox.y -= snappedHeight - newBox.height;
    }
    newBox.width = snappedWidth;
    newBox.height = snappedHeight;
  }
  if (newBox.width < me.minWidth || newBox.width > me.maxWidth) {
    newBox.width = Ext.Number.constrain(newBox.width, me.minWidth, me.maxWidth);
    if (adjustX) {
      newBox.x = box.x + (box.width - newBox.width);
    }
  } else {
    me.lastX = newBox.x;
  }
  if (newBox.height < me.minHeight || newBox.height > me.maxHeight) {
    newBox.height = Ext.Number.constrain(newBox.height, me.minHeight, me.maxHeight);
    if (adjustY) {
      newBox.y = box.y + (box.height - newBox.height);
    }
  } else {
    me.lastY = newBox.y;
  }
  if (me.preserveRatio || e.shiftKey) {
    ratio = me.startBox.width / me.startBox.height;
    newHeight = Math.min(Math.max(me.minHeight, newBox.width / ratio), me.maxHeight);
    newWidth = Math.min(Math.max(me.minWidth, newBox.height * ratio), me.maxWidth);
    if (axis == 1) {
      newBox.height = newHeight;
    } else {
      if (axis == 2) {
        newBox.width = newWidth;
      } else {
        dragRatio = Math.abs(oppositeCorner[0] - this.lastXY[0]) / Math.abs(oppositeCorner[1] - this.lastXY[1]);
        if (dragRatio > ratio) {
          newBox.height = newHeight;
        } else {
          newBox.width = newWidth;
        }
        if (region == 'northeast') {
          newBox.y = box.y - (newBox.height - box.height);
        } else {
          if (region == 'northwest') {
            newBox.y = box.y - (newBox.height - box.height);
            newBox.x = box.x - (newBox.width - box.width);
          } else {
            if (region == 'southwest') {
              newBox.x = box.x - (newBox.width - box.width);
            }
          }
        }
      }
    }
  }
  if (heightAdjust === 0) {
    vertDir = 'none';
  }
  if (widthAdjust === 0) {
    horizDir = 'none';
  }
  me.resize(newBox, {horizontal:horizDir, vertical:vertDir}, atEnd);
}, getResizeTarget:function(atEnd) {
  return atEnd ? this.target : this.getDynamicTarget();
}, resize:function(box, direction, atEnd) {
  var me = this, target = me.getResizeTarget(atEnd);
  target.setBox(box);
  if (me.originalTarget && (me.dynamic || atEnd)) {
    me.originalTarget.setBox(box);
  }
}, onEnd:function(e) {
  this.updateDimensions(e, true);
  if (this.proxy) {
    this.proxy.hide();
  }
}, convertRegionName:function(name) {
  return name;
}});
Ext.define('Ext.resizer.Resizer', {mixins:{observable:Ext.util.Observable}, alternateClassName:'Ext.Resizable', handleCls:Ext.baseCSSPrefix + 'resizable-handle', pinnedCls:Ext.baseCSSPrefix + 'resizable-pinned', overCls:Ext.baseCSSPrefix + 'resizable-over', wrapCls:Ext.baseCSSPrefix + 'resizable-wrap', delimiterRe:/(?:\s*[,;]\s*)|\s+/, dynamic:true, handles:'s e se', height:null, width:null, heightIncrement:0, widthIncrement:0, minHeight:20, minWidth:20, maxHeight:10000, maxWidth:10000, pinned:false, 
preserveRatio:false, transparent:false, possiblePositions:{n:'north', s:'south', e:'east', w:'west', se:'southeast', sw:'southwest', nw:'northwest', ne:'northeast'}, constructor:function(config) {
  var me = this, target, targetEl, tag, handles = me.handles, handleCls, possibles, len, i = 0, pos, handleEls = [], eastWestStyle, style, box, targetBaseCls, unselectableCls = Ext.dom.Element.unselectableCls;
  me.addEvents('beforeresize', 'resizedrag', 'resize');
  if (Ext.isString(config) || Ext.isElement(config) || config.dom) {
    target = config;
    config = arguments[1] || {};
    config.target = target;
  }
  me.mixins.observable.constructor.call(me, config);
  target = me.target;
  if (target) {
    if (target.isComponent) {
      target.addClsWithUI('resizable');
      me.el = target.getEl();
      if (target.minWidth) {
        me.minWidth = target.minWidth;
      }
      if (target.minHeight) {
        me.minHeight = target.minHeight;
      }
      if (target.maxWidth) {
        me.maxWidth = target.maxWidth;
      }
      if (target.maxHeight) {
        me.maxHeight = target.maxHeight;
      }
      if (target.floating) {
        if (!me.hasOwnProperty('handles')) {
          me.handles = 'n ne e se s sw w nw';
        }
      }
    } else {
      me.el = me.target = Ext.get(target);
    }
  } else {
    me.target = me.el = Ext.get(me.el);
  }
  tag = me.el.dom.tagName.toUpperCase();
  if (tag == 'TEXTAREA' || tag == 'IMG' || tag == 'TABLE') {
    me.originalTarget = me.target;
    targetEl = me.el;
    box = targetEl.getBox();
    me.target = me.el = me.el.wrap({cls:me.wrapCls, id:me.el.id + '-rzwrap', style:targetEl.getStyles('margin-top', 'margin-bottom')});
    me.el.setPositioning(targetEl.getPositioning());
    targetEl.clearPositioning();
    me.el.setBox(box);
    targetEl.setStyle('position', 'absolute');
  }
  me.el.position();
  if (me.pinned) {
    me.el.addCls(me.pinnedCls);
  }
  me.resizeTracker = new Ext.resizer.ResizeTracker({disabled:me.disabled, target:me.target, constrainTo:me.constrainTo, overCls:me.overCls, throttle:me.throttle, originalTarget:me.originalTarget, delegate:'.' + me.handleCls, dynamic:me.dynamic, preserveRatio:me.preserveRatio, heightIncrement:me.heightIncrement, widthIncrement:me.widthIncrement, minHeight:me.minHeight, maxHeight:me.maxHeight, minWidth:me.minWidth, maxWidth:me.maxWidth});
  me.resizeTracker.on({mousedown:me.onBeforeResize, drag:me.onResize, dragend:me.onResizeEnd, scope:me});
  if (me.handles == 'all') {
    me.handles = 'n s e w ne nw se sw';
  }
  handles = me.handles = me.handles.split(me.delimiterRe);
  possibles = me.possiblePositions;
  len = handles.length;
  handleCls = me.handleCls + ' ' + me.handleCls + '-{0}';
  if (me.target.isComponent) {
    targetBaseCls = me.target.baseCls;
    handleCls += ' ' + targetBaseCls + '-handle ' + targetBaseCls + '-handle-{0}';
    if (Ext.supports.CSS3BorderRadius) {
      handleCls += ' ' + targetBaseCls + '-handle-{0}-br';
    }
  }
  eastWestStyle = Ext.isIE6 ? ' style\x3d"height:' + me.el.getHeight() + 'px"' : '';
  for (; i < len; i++) {
    if (handles[i] && possibles[handles[i]]) {
      pos = possibles[handles[i]];
      if (pos === 'east' || pos === 'west') {
        style = eastWestStyle;
      } else {
        style = '';
      }
      handleEls.push('\x3cdiv id\x3d"', me.el.id, '-', pos, '-handle"', ' class\x3d"', Ext.String.format(handleCls, pos), ' ', unselectableCls, '"', ' unselectable\x3d"on"', style, '\x3e\x3c/div\x3e');
    }
  }
  Ext.DomHelper.append(me.el, handleEls.join(''));
  for (i = 0; i < len; i++) {
    if (handles[i] && possibles[handles[i]]) {
      pos = possibles[handles[i]];
      me[pos] = me.el.getById(me.el.id + '-' + pos + '-handle');
      me[pos].region = pos;
      if (me.transparent) {
        me[pos].setOpacity(0);
      }
    }
  }
  if (Ext.isNumber(me.width)) {
    me.width = Ext.Number.constrain(me.width, me.minWidth, me.maxWidth);
  }
  if (Ext.isNumber(me.height)) {
    me.height = Ext.Number.constrain(me.height, me.minHeight, me.maxHeight);
  }
  if (me.width !== null || me.height !== null) {
    if (me.originalTarget) {
      me.originalTarget.setWidth(me.width);
      me.originalTarget.setHeight(me.height);
    }
    me.resizeTo(me.width, me.height);
  }
  me.forceHandlesHeight();
}, disable:function() {
  this.resizeTracker.disable();
}, enable:function() {
  this.resizeTracker.enable();
}, onBeforeResize:function(tracker, e) {
  var box = this.el.getBox();
  return this.fireEvent('beforeresize', this, box.width, box.height, e);
}, onResize:function(tracker, e) {
  var me = this, box = me.el.getBox();
  me.forceHandlesHeight();
  return me.fireEvent('resizedrag', me, box.width, box.height, e);
}, onResizeEnd:function(tracker, e) {
  var me = this, box = me.el.getBox();
  me.forceHandlesHeight();
  return me.fireEvent('resize', me, box.width, box.height, e);
}, resizeTo:function(width, height) {
  var me = this;
  me.target.setSize(width, height);
  me.fireEvent('resize', me, width, height, null);
}, getEl:function() {
  return this.el;
}, getTarget:function() {
  return this.target;
}, destroy:function() {
  var me = this, i, handles = me.handles, len = handles.length, positions = me.possiblePositions, handle;
  me.resizeTracker.destroy();
  for (i = 0; i < len; i++) {
    if (handle = me[positions[handles[i]]]) {
      handle.remove();
    }
  }
}, forceHandlesHeight:function() {
  var me = this, handle;
  if (Ext.isIE6) {
    handle = me.east;
    if (handle) {
      handle.setHeight(me.el.getHeight());
    }
    handle = me.west;
    if (handle) {
      handle.setHeight(me.el.getHeight());
    }
    me.el.repaint();
  }
}});
Ext.define('Ext.selection.CellModel', {extend:Ext.selection.Model, alias:'selection.cellmodel', isCellModel:true, enableKeyNav:true, preventWrap:false, noSelection:{row:-1, column:-1}, constructor:function() {
  this.addEvents('deselect', 'select');
  this.callParent(arguments);
}, bindComponent:function(view) {
  var me = this, grid = view.ownerCt;
  me.primaryView = view;
  me.views = me.views || [];
  me.views.push(view);
  me.bindStore(view.getStore(), true);
  view.on({cellmousedown:me.onMouseDown, refresh:me.onViewRefresh, scope:me});
  if (grid.optimizedColumnMove !== false) {
    grid.on('columnmove', me.onColumnMove, me);
  }
  if (me.enableKeyNav) {
    me.initKeyNav(view);
  }
}, initKeyNav:function(view) {
  var me = this;
  if (!view.rendered) {
    view.on('render', Ext.Function.bind(me.initKeyNav, me, [view], 0), me, {single:true});
    return;
  }
  view.el.set({tabIndex:-1});
  me.keyNav = new Ext.util.KeyNav({target:view.el, ignoreInputFields:true, up:me.onKeyUp, down:me.onKeyDown, right:me.onKeyRight, left:me.onKeyLeft, tab:me.onKeyTab, scope:me});
}, getHeaderCt:function() {
  var selection = this.getCurrentPosition(), view = selection ? selection.view : this.primaryView;
  return view.headerCt;
}, onKeyUp:function(e) {
  this.doMove('up', e);
}, onKeyDown:function(e) {
  this.doMove('down', e);
}, onKeyLeft:function(e) {
  this.doMove('left', e);
}, onKeyRight:function(e) {
  this.doMove('right', e);
}, doMove:function(direction, e) {
  this.keyNavigation = true;
  this.move(direction, e);
  this.keyNavigation = false;
}, onVetoUIEvent:Ext.emptyFn, select:function(pos, keepExisting, suppressEvent) {
  var me = this, row, oldPos = me.getCurrentPosition(), store = me.view.store;
  if (pos || pos === 0) {
    if (pos.isModel) {
      row = store.indexOf(pos);
      if (row !== -1) {
        pos = {row:row, column:oldPos ? oldPos.column : 0};
      } else {
        pos = null;
      }
    } else {
      if (typeof pos === 'number') {
        pos = {row:pos, column:0};
      }
    }
  }
  if (pos) {
    me.selectByPosition(pos, suppressEvent);
  } else {
    me.deselect();
  }
}, deselect:function(record, suppressEvent) {
  this.selectByPosition(null, suppressEvent);
}, move:function(dir, e) {
  var me = this, pos = me.getCurrentPosition(), newPos;
  if (pos) {
    newPos = pos.view.walkCells(pos, dir, e, me.preventWrap);
    if (newPos) {
      newPos.view = pos.view;
      return me.setCurrentPosition(newPos);
    }
  }
  return null;
}, getCurrentPosition:function() {
  return this.selecting ? this.nextSelection : this.selection;
}, setCurrentPosition:function(pos, suppressEvent) {
  var me = this, last = me.selection;
  me.lastSelection = last;
  if (last) {
    if (pos && (pos.record === last.record && pos.columnHeader === last.columnHeader && pos.view === last.view)) {
      pos = null;
    } else {
      me.onCellDeselect(me.selection, suppressEvent);
    }
  }
  if (pos) {
    me.nextSelection = (new Ext.grid.CellContext(me.primaryView)).setPosition(pos);
    me.selecting = true;
    me.onCellSelect(me.nextSelection, suppressEvent);
    me.selecting = false;
    return me.selection = me.nextSelection;
  }
  return null;
}, isCellSelected:function(view, row, column) {
  var me = this, testPos, pos = me.getCurrentPosition();
  if (pos && pos.view === view) {
    testPos = (new Ext.grid.CellContext(view)).setPosition({row:row, column:column});
    return testPos.record === pos.record && testPos.columnHeader === pos.columnHeader;
  }
}, onStoreRemove:function(store, records, indexes) {
  var me = this, pos = me.getCurrentPosition(), i, length = records.length, index, shuffleCount = 0;
  me.callParent(arguments);
  if (pos) {
    if (indexes[0] > pos.row) {
      return;
    }
    for (i = 0; i < length; i++) {
      index = indexes[i];
      if (index < pos.row) {
        shuffleCount++;
      } else {
        break;
      }
    }
    if (shuffleCount) {
      pos.setRow(pos.row - shuffleCount);
    }
  }
}, onMouseDown:function(view, cell, cellIndex, record, row, recordIndex, e) {
  if (recordIndex !== -1) {
    this.setCurrentPosition({view:view, row:row, column:cellIndex});
  }
}, onCellSelect:function(position, supressEvent) {
  if (position && position.row !== undefined && position.row > -1) {
    this.doSelect(position.record, false, supressEvent);
  }
}, onCellDeselect:function(position, supressEvent) {
  if (position && position.row !== undefined) {
    this.doDeselect(position.record, supressEvent);
  }
}, onSelectChange:function(record, isSelected, suppressEvent, commitFn) {
  var me = this, pos, eventName, view;
  if (isSelected) {
    pos = me.nextSelection;
    eventName = 'select';
  } else {
    pos = me.lastSelection || me.noSelection;
    eventName = 'deselect';
  }
  view = pos.view || me.primaryView;
  if ((suppressEvent || me.fireEvent('before' + eventName, me, record, pos.row, pos.column)) !== false && commitFn() !== false) {
    if (isSelected) {
      view.focusRow(record, true);
      view.onCellSelect(pos);
    } else {
      view.onCellDeselect(pos);
      delete me.selection;
    }
    if (!suppressEvent) {
      me.fireEvent(eventName, me, record, pos.row, pos.column);
    }
  }
}, onKeyTab:function(e, t) {
  var me = this, pos = me.getCurrentPosition(), editingPlugin;
  if (pos) {
    editingPlugin = pos.view.editingPlugin;
    if (editingPlugin && me.wasEditing) {
      me.onEditorTab(editingPlugin, e);
    } else {
      me.move(e.shiftKey ? 'left' : 'right', e);
    }
  }
}, onEditorTab:function(editingPlugin, e) {
  var me = this, direction = e.shiftKey ? 'left' : 'right', position = me.move(direction, e);
  if (position) {
    if (editingPlugin.startEdit(position.record, position.columnHeader)) {
      me.wasEditing = false;
    } else {
      me.wasEditing = true;
    }
  }
}, refresh:function() {
  var pos = this.getCurrentPosition(), selRowIdx;
  if (pos && (selRowIdx = this.store.indexOf(this.selected.last())) !== -1) {
    pos.row = selRowIdx;
  }
}, onColumnMove:function(headerCt, header, fromIdx, toIdx) {
  var grid = headerCt.up('tablepanel');
  if (grid) {
    this.onViewRefresh(grid.view);
  }
}, onUpdate:function(record) {
  var me = this, pos;
  if (me.isSelected(record)) {
    pos = me.selecting ? me.nextSelection : me.selection;
    me.view.onCellSelect(pos);
  }
}, onViewRefresh:function(view) {
  var me = this, pos = me.getCurrentPosition(), headerCt = view.headerCt, record, columnHeader;
  if (pos && pos.view === view) {
    record = pos.record;
    columnHeader = pos.columnHeader;
    if (!columnHeader.isDescendantOf(headerCt)) {
      columnHeader = headerCt.queryById(columnHeader.id) || headerCt.down('[text\x3d"' + columnHeader.text + '"]') || headerCt.down('[dataIndex\x3d"' + columnHeader.dataIndex + '"]');
    }
    if (columnHeader && view.store.indexOfId(record.getId()) !== -1) {
      me.setCurrentPosition({row:record, column:columnHeader, view:view});
    }
  }
}, selectByPosition:function(position, suppressEvent) {
  this.setCurrentPosition(position, suppressEvent);
}});
Ext.define('Ext.selection.RowModel', {extend:Ext.selection.Model, alias:'selection.rowmodel', deltaScroll:5, enableKeyNav:true, ignoreRightMouseSelection:false, constructor:function() {
  this.addEvents('beforedeselect', 'beforeselect', 'deselect', 'select');
  this.views = [];
  this.callParent(arguments);
}, bindComponent:function(view) {
  var me = this;
  view.on({itemmousedown:me.onRowMouseDown, itemclick:me.onRowClick, scope:me});
  if (me.enableKeyNav) {
    me.initKeyNav(view);
  }
}, initKeyNav:function(view) {
  var me = this;
  if (!view.rendered) {
    view.on('render', Ext.Function.bind(me.initKeyNav, me, [view], 0), me, {single:true});
    return;
  }
  view.el.set({tabIndex:-1});
  me.keyNav = new Ext.util.KeyNav({target:view, ignoreInputFields:true, eventName:'itemkeydown', processEvent:function(view, record, node, index, event) {
    event.record = record;
    event.recordIndex = index;
    return event;
  }, up:me.onKeyUp, down:me.onKeyDown, right:me.onKeyRight, left:me.onKeyLeft, pageDown:me.onKeyPageDown, pageUp:me.onKeyPageUp, home:me.onKeyHome, end:me.onKeyEnd, space:me.onKeySpace, enter:me.onKeyEnter, scope:me});
}, onUpdate:function(record) {
  var me = this, view = me.view, index;
  if (view && me.isSelected(record)) {
    index = view.indexOf(record);
    view.onRowSelect(index);
    if (record === me.lastFocused) {
      view.onRowFocus(index, true);
    }
  }
}, getRowsVisible:function() {
  var rowsVisible = false, view = this.views[0], firstRow = view.all.first(), rowHeight, gridViewHeight;
  if (firstRow) {
    rowHeight = firstRow.getHeight();
    gridViewHeight = view.el.getHeight();
    rowsVisible = Math.floor(gridViewHeight / rowHeight);
  }
  return rowsVisible;
}, onKeyEnd:function(e) {
  var me = this, view = me.views[0];
  if (view.bufferedRenderer) {
    view.bufferedRenderer.scrollTo(me.store.getCount() - 1, false, function(newIdx, newRecord) {
      me.afterKeyNavigate(e, newRecord);
    });
  } else {
    me.afterKeyNavigate(e, view.getRecord(view.all.getCount() - 1));
  }
}, onKeyHome:function(e) {
  var me = this, view = me.views[0];
  if (view.bufferedRenderer) {
    view.bufferedRenderer.scrollTo(0, false, function(newIdx, newRecord) {
      me.afterKeyNavigate(e, newRecord);
    });
  } else {
    me.afterKeyNavigate(e, view.getRecord(0));
  }
}, onKeyPageUp:function(e) {
  var me = this, view = me.views[0], rowsVisible = me.getRowsVisible(), newIdx, newRecord;
  if (rowsVisible) {
    if (view.bufferedRenderer) {
      newIdx = Math.max(e.recordIndex - rowsVisible, 0);
      (me.lastKeyEvent || (me.lastKeyEvent = new Ext.EventObjectImpl)).setEvent(e.browserEvent);
      view.bufferedRenderer.scrollTo(newIdx, false, me.afterBufferedScrollTo, me);
    } else {
      newRecord = view.walkRecs(e.record, -rowsVisible);
      me.afterKeyNavigate(e, newRecord);
    }
  }
}, onKeyPageDown:function(e) {
  var me = this, view = me.views[0], rowsVisible = me.getRowsVisible(), newIdx, newRecord;
  if (rowsVisible) {
    if (view.bufferedRenderer) {
      newIdx = Math.min(e.recordIndex + rowsVisible, me.store.getCount() - 1);
      (me.lastKeyEvent || (me.lastKeyEvent = new Ext.EventObjectImpl)).setEvent(e.browserEvent);
      view.bufferedRenderer.scrollTo(newIdx, false, me.afterBufferedScrollTo, me);
    } else {
      newRecord = view.walkRecs(e.record, rowsVisible);
      me.afterKeyNavigate(e, newRecord);
    }
  }
}, onKeySpace:function(e) {
  var record = this.lastFocused;
  if (record) {
    this.afterKeyNavigate(e, record);
  }
}, onKeyEnter:Ext.emptyFn, onKeyUp:function(e) {
  var newRecord = this.views[0].walkRecs(e.record, -1);
  if (newRecord) {
    this.afterKeyNavigate(e, newRecord);
  }
}, onKeyDown:function(e) {
  var newRecord = this.views[0].walkRecs(e.record, 1);
  if (newRecord) {
    this.afterKeyNavigate(e, newRecord);
  }
}, afterBufferedScrollTo:function(newIdx, newRecord) {
  this.afterKeyNavigate(this.lastKeyEvent, newRecord);
}, scrollByDeltaX:function(delta) {
  var view = this.views[0], section = view.up(), hScroll = section.horizontalScroller;
  if (hScroll) {
    hScroll.scrollByDeltaX(delta);
  }
}, onKeyLeft:function(e) {
  this.scrollByDeltaX(-this.deltaScroll);
}, onKeyRight:function(e) {
  this.scrollByDeltaX(this.deltaScroll);
}, onRowMouseDown:function(view, record, item, index, e) {
  var me = this;
  if (index !== -1) {
    if (!me.allowRightMouseSelection(e)) {
      return;
    }
    if (!me.isSelected(record)) {
      me.mousedownAction = true;
      me.processSelection(view, record, item, index, e);
    } else {
      me.mousedownAction = false;
    }
  }
}, onVetoUIEvent:function(type, view, cell, rowIndex, cellIndex, e, record) {
  if (type == 'mousedown') {
    this.mousedownAction = !this.isSelected(record);
  }
}, onRowClick:function(view, record, item, index, e) {
  if (this.mousedownAction) {
    this.mousedownAction = false;
  } else {
    this.processSelection(view, record, item, index, e);
  }
}, processSelection:function(view, record, item, index, e) {
  this.selectWithEvent(record, e);
}, allowRightMouseSelection:function(e) {
  var disallow = this.ignoreRightMouseSelection && e.button !== 0;
  if (disallow) {
    disallow = this.hasSelection();
  }
  return !disallow;
}, onSelectChange:function(record, isSelected, suppressEvent, commitFn) {
  var me = this, views = me.views, viewsLn = views.length, rowIdx = views[0].indexOf(record), eventName = isSelected ? 'select' : 'deselect', i = 0;
  if ((suppressEvent || me.fireEvent('before' + eventName, me, record, rowIdx)) !== false && commitFn() !== false) {
    for (; i < viewsLn; i++) {
      if (isSelected) {
        views[i].onRowSelect(rowIdx, suppressEvent);
      } else {
        views[i].onRowDeselect(rowIdx, suppressEvent);
      }
    }
    if (!suppressEvent) {
      me.fireEvent(eventName, me, record, rowIdx);
    }
  }
}, onLastFocusChanged:function(oldFocused, newFocused, supressFocus) {
  var views = this.views, viewsLn = views.length, rowIdx, i = 0;
  if (oldFocused) {
    rowIdx = views[0].indexOf(oldFocused);
    if (rowIdx != -1) {
      for (; i < viewsLn; i++) {
        views[i].onRowFocus(rowIdx, false, true);
      }
    }
  }
  if (newFocused) {
    rowIdx = views[0].indexOf(newFocused);
    if (rowIdx != -1) {
      for (i = 0; i < viewsLn; i++) {
        views[i].onRowFocus(rowIdx, true, supressFocus);
      }
    }
  }
  this.callParent(arguments);
}, onEditorTab:function(editingPlugin, e) {
  var me = this, view = me.views[0], record = editingPlugin.getActiveRecord(), header = editingPlugin.getActiveColumn(), position = view.getPosition(record, header), direction = e.shiftKey ? 'left' : 'right';
  do {
    position = view.walkCells(position, direction, e, me.preventWrap);
  } while (position && (!position.columnHeader.getEditor(record) || !editingPlugin.startEditByPosition(position)));
}, getCurrentPosition:function() {
  var firstSelection = this.selected.items[0];
  if (firstSelection) {
    return (new Ext.grid.CellContext(this.view)).setPosition(this.store.indexOf(firstSelection), 0);
  }
}, selectByPosition:function(position) {
  this.select(this.store.getAt(position.row));
}, selectNext:function(keepExisting, suppressEvent) {
  var me = this, store = me.store, selection = me.getSelection(), record = selection[selection.length - 1], index = me.views[0].indexOf(record) + 1, success;
  if (index === store.getCount() || index === 0) {
    success = false;
  } else {
    me.doSelect(index, keepExisting, suppressEvent);
    success = true;
  }
  return success;
}, selectPrevious:function(keepExisting, suppressEvent) {
  var me = this, selection = me.getSelection(), record = selection[0], index = me.views[0].indexOf(record) - 1, success;
  if (index < 0) {
    success = false;
  } else {
    me.doSelect(index, keepExisting, suppressEvent);
    success = true;
  }
  return success;
}, isRowSelected:function(record, index) {
  return this.isSelected(record);
}});
Ext.define('Ext.selection.CheckboxModel', {alias:'selection.checkboxmodel', extend:Ext.selection.RowModel, mode:'MULTI', injectCheckbox:0, checkOnly:false, showHeaderCheckbox:undefined, checkSelector:'.' + Ext.baseCSSPrefix + 'grid-row-checker', headerWidth:24, checkerOnCls:Ext.baseCSSPrefix + 'grid-hd-checker-on', constructor:function() {
  var me = this;
  me.callParent(arguments);
  if (me.mode === 'SINGLE' && me.showHeaderCheckbox !== true) {
    me.showHeaderCheckbox = false;
  }
}, beforeViewRender:function(view) {
  var me = this, owner;
  me.callParent(arguments);
  if (!me.hasLockedHeader() || view.headerCt.lockedCt) {
    if (me.showHeaderCheckbox !== false) {
      view.headerCt.on('headerclick', me.onHeaderClick, me);
    }
    me.addCheckbox(view, true);
    owner = view.ownerCt;
    if (view.headerCt.lockedCt) {
      owner = owner.ownerCt;
    }
    me.mon(owner, 'reconfigure', me.onReconfigure, me);
  }
}, bindComponent:function(view) {
  var me = this;
  me.sortable = false;
  me.callParent(arguments);
}, hasLockedHeader:function() {
  var views = this.views, vLen = views.length, v;
  for (v = 0; v < vLen; v++) {
    if (views[v].headerCt.lockedCt) {
      return true;
    }
  }
  return false;
}, addCheckbox:function(view, initial) {
  var me = this, checkbox = me.injectCheckbox, headerCt = view.headerCt;
  if (checkbox !== false) {
    if (checkbox == 'first') {
      checkbox = 0;
    } else {
      if (checkbox == 'last') {
        checkbox = headerCt.getColumnCount();
      }
    }
    Ext.suspendLayouts();
    if (view.getStore().buffered) {
      me.showHeaderCheckbox = false;
    }
    headerCt.add(checkbox, me.getHeaderConfig());
    Ext.resumeLayouts();
  }
  if (initial !== true) {
    view.refresh();
  }
}, onReconfigure:function(grid, store, columns) {
  if (columns) {
    this.addCheckbox(this.views[0]);
  }
}, toggleUiHeader:function(isChecked) {
  var view = this.views[0], headerCt = view.headerCt, checkHd = headerCt.child('gridcolumn[isCheckerHd]'), cls = this.checkerOnCls;
  if (checkHd) {
    if (isChecked) {
      checkHd.addCls(cls);
    } else {
      checkHd.removeCls(cls);
    }
  }
}, onHeaderClick:function(headerCt, header, e) {
  if (header.isCheckerHd) {
    e.stopEvent();
    var me = this, isChecked = header.el.hasCls(Ext.baseCSSPrefix + 'grid-hd-checker-on');
    me.preventFocus = true;
    if (isChecked) {
      me.deselectAll();
    } else {
      me.selectAll();
    }
    delete me.preventFocus;
  }
}, getHeaderConfig:function() {
  var me = this, showCheck = me.showHeaderCheckbox !== false;
  return {isCheckerHd:showCheck, text:'\x26#160;', clickTargetName:'el', width:me.headerWidth, sortable:false, draggable:false, resizable:false, hideable:false, menuDisabled:true, dataIndex:'', cls:showCheck ? Ext.baseCSSPrefix + 'column-header-checkbox ' : '', renderer:Ext.Function.bind(me.renderer, me), editRenderer:me.editRenderer || me.renderEmpty, locked:me.hasLockedHeader()};
}, renderEmpty:function() {
  return '\x26#160;';
}, refresh:function() {
  this.callParent(arguments);
  this.updateHeaderState();
}, renderer:function(value, metaData, record, rowIndex, colIndex, store, view) {
  var baseCSSPrefix = Ext.baseCSSPrefix;
  metaData.tdCls = baseCSSPrefix + 'grid-cell-special ' + baseCSSPrefix + 'grid-cell-row-checker';
  return '\x3cdiv class\x3d"' + baseCSSPrefix + 'grid-row-checker"\x3e\x26#160;\x3c/div\x3e';
}, processSelection:function(view, record, item, index, e) {
  var me = this, checker = e.getTarget(me.checkSelector), mode;
  if (me.checkOnly && !checker) {
    return;
  }
  if (checker) {
    mode = me.getSelectionMode();
    if (mode !== 'SINGLE') {
      me.setSelectionMode('SIMPLE');
    }
    me.selectWithEvent(record, e);
    me.setSelectionMode(mode);
  } else {
    me.selectWithEvent(record, e);
  }
}, onSelectChange:function() {
  this.callParent(arguments);
  if (!this.suspendChange) {
    this.updateHeaderState();
  }
}, onStoreLoad:function() {
  this.callParent(arguments);
  this.updateHeaderState();
}, onStoreAdd:function() {
  this.callParent(arguments);
  this.updateHeaderState();
}, onStoreRemove:function() {
  this.callParent(arguments);
  this.updateHeaderState();
}, onStoreRefresh:function() {
  this.callParent(arguments);
  this.updateHeaderState();
}, maybeFireSelectionChange:function(fireEvent) {
  if (fireEvent && !this.suspendChange) {
    this.updateHeaderState();
  }
  this.callParent(arguments);
}, resumeChanges:function() {
  this.callParent();
  if (!this.suspendChange) {
    this.updateHeaderState();
  }
}, updateHeaderState:function() {
  var me = this, store = me.store, storeCount = store.getCount(), views = me.views, hdSelectStatus = false, selectedCount = 0, selected, len, i;
  if (!store.buffered && storeCount > 0) {
    selected = me.selected;
    hdSelectStatus = true;
    for (i = 0, len = selected.getCount(); i < len; ++i) {
      if (!me.storeHasSelected(selected.getAt(i))) {
        break;
      }
      ++selectedCount;
    }
    hdSelectStatus = storeCount === selectedCount;
  }
  if (views && views.length) {
    me.toggleUiHeader(hdSelectStatus);
  }
}});
Ext.define('Ext.selection.TreeModel', {extend:Ext.selection.RowModel, alias:'selection.treemodel', constructor:function(config) {
  this.callParent(arguments);
  if (this.pruneRemoved) {
    this.pruneRemoved = false;
    this.pruneRemovedNodes = true;
  }
}, bindStore:function(store, initial) {
  var me = this;
  me.callParent(arguments);
  if (me.pruneRemovedNodes) {
    me.view.mon(me.treeStore, {remove:me.onNodeRemove, scope:me});
  }
}, onNodeRemove:function(parent, node, isMove) {
  if (!isMove) {
    this.deselectDeletedRecords([node]);
  }
}, onKeyRight:function(e, t) {
  this.navExpand(e, t);
}, navExpand:function(e, t) {
  var focused = this.getLastFocused(), view = this.view;
  if (focused) {
    if (focused.isExpanded()) {
      this.onKeyDown(e, t);
    } else {
      if (focused.isExpandable()) {
        if (!view.isTreeView) {
          view = view.lockingPartner;
        }
        view.expand(focused);
      }
    }
  }
}, onKeyLeft:function(e, t) {
  this.navCollapse(e, t);
}, navCollapse:function(e, t) {
  var me = this, focused = this.getLastFocused(), view = this.view, parentNode;
  if (focused) {
    parentNode = focused.parentNode;
    if (focused.isExpanded()) {
      if (!view.isTreeView) {
        view = view.lockingPartner;
      }
      view.collapse(focused);
    } else {
      if (parentNode && !parentNode.isRoot()) {
        if (e.shiftKey) {
          me.selectRange(parentNode, focused, e.ctrlKey, 'up');
          me.setLastFocused(parentNode);
        } else {
          if (e.ctrlKey) {
            me.setLastFocused(parentNode);
          } else {
            me.select(parentNode);
          }
        }
      }
    }
  }
}, onKeySpace:function(e, t) {
  if (e.record.data.checked != null) {
    this.toggleCheck(e);
  } else {
    this.callParent(arguments);
  }
}, onKeyEnter:function(e, t) {
  if (e.record.data.checked != null) {
    this.toggleCheck(e);
  } else {
    this.callParent(arguments);
  }
}, toggleCheck:function(e) {
  var view = this.view, selected = this.getLastSelected();
  e.stopEvent();
  if (selected) {
    if (!view.isTreeView) {
      view = view.lockingPartner;
    }
    view.onCheckChange(selected);
  }
}});
Ext.define('Ext.tab.Tab', {extend:Ext.button.Button, alias:'widget.tab', isTab:true, baseCls:Ext.baseCSSPrefix + 'tab', closeElOverCls:Ext.baseCSSPrefix + 'tab-close-btn-over', activeCls:'active', closableCls:'closable', closable:true, closeText:'Close Tab', active:false, childEls:['closeEl'], scale:false, position:'top', initComponent:function() {
  var me = this;
  me.addEvents('activate', 'deactivate', 'beforeclose', 'close');
  me.callParent(arguments);
  if (me.card) {
    me.setCard(me.card);
  }
  me.overCls = ['over', me.position + '-over'];
}, getTemplateArgs:function() {
  var me = this, result = me.callParent();
  result.closable = me.closable;
  result.closeText = me.closeText;
  return result;
}, getFramingInfoCls:function() {
  return this.baseCls + '-' + this.ui + '-' + this.position;
}, beforeRender:function() {
  var me = this, tabBar = me.up('tabbar'), tabPanel = me.up('tabpanel');
  me.callParent();
  me.addClsWithUI(me.position);
  if (me.active) {
    me.addClsWithUI([me.activeCls, me.position + '-' + me.activeCls]);
  }
  me.syncClosableUI();
  if (!me.minWidth) {
    me.minWidth = tabBar ? tabBar.minTabWidth : me.minWidth;
    if (!me.minWidth && tabPanel) {
      me.minWidth = tabPanel.minTabWidth;
    }
    if (me.minWidth && me.iconCls) {
      me.minWidth += 25;
    }
  }
  if (!me.maxWidth) {
    me.maxWidth = tabBar ? tabBar.maxTabWidth : me.maxWidth;
    if (!me.maxWidth && tabPanel) {
      me.maxWidth = tabPanel.maxTabWidth;
    }
  }
}, onRender:function() {
  var me = this;
  me.setElOrientation();
  me.callParent(arguments);
  if (me.closable) {
    me.closeEl.addClsOnOver(me.closeElOverCls);
  }
  me.keyNav = new Ext.util.KeyNav(me.el, {enter:me.onEnterKey, del:me.onDeleteKey, scope:me});
}, setElOrientation:function() {
  var position = this.position;
  if (position === 'left' || position === 'right') {
    this.el.setVertical(position === 'right' ? 90 : 270);
  }
}, enable:function(silent) {
  var me = this;
  me.callParent(arguments);
  me.removeClsWithUI(me.position + '-disabled');
  return me;
}, disable:function(silent) {
  var me = this;
  me.callParent(arguments);
  me.addClsWithUI(me.position + '-disabled');
  return me;
}, onDestroy:function() {
  var me = this;
  Ext.destroy(me.keyNav);
  delete me.keyNav;
  me.callParent(arguments);
}, setClosable:function(closable) {
  var me = this;
  closable = !arguments.length || !!closable;
  if (me.closable != closable) {
    me.closable = closable;
    if (me.card) {
      me.card.closable = closable;
    }
    me.syncClosableUI();
    if (me.rendered) {
      me.syncClosableElements();
      me.updateLayout();
    }
  }
}, syncClosableElements:function() {
  var me = this, closeEl = me.closeEl;
  if (me.closable) {
    if (!closeEl) {
      closeEl = me.closeEl = me.btnWrap.insertSibling({tag:'a', cls:me.baseCls + '-close-btn', href:'#', title:me.closeText}, 'after');
    }
    closeEl.addClsOnOver(me.closeElOverCls);
  } else {
    if (closeEl) {
      closeEl.remove();
      delete me.closeEl;
    }
  }
}, syncClosableUI:function() {
  var me = this, classes = [me.closableCls, me.closableCls + '-' + me.position];
  if (me.closable) {
    me.addClsWithUI(classes);
  } else {
    me.removeClsWithUI(classes);
  }
}, setCard:function(card) {
  var me = this;
  me.card = card;
  me.setText(me.title || card.title);
  me.setIconCls(me.iconCls || card.iconCls);
  me.setIcon(me.icon || card.icon);
  me.setGlyph(me.glyph || card.glyph);
}, onCloseClick:function() {
  var me = this;
  if (me.fireEvent('beforeclose', me) !== false) {
    if (me.tabBar) {
      if (me.tabBar.closeTab(me) === false) {
        return;
      }
    } else {
      me.fireClose();
    }
  }
}, fireClose:function() {
  this.fireEvent('close', this);
}, onEnterKey:function(e) {
  var me = this;
  if (me.tabBar) {
    me.tabBar.onClick(e, me.el);
  }
}, onDeleteKey:function(e) {
  if (this.closable) {
    this.onCloseClick();
  }
}, activate:function(supressEvent) {
  var me = this;
  me.active = true;
  me.addClsWithUI([me.activeCls, me.position + '-' + me.activeCls]);
  if (supressEvent !== true) {
    me.fireEvent('activate', me);
  }
}, deactivate:function(supressEvent) {
  var me = this;
  me.active = false;
  me.removeClsWithUI([me.activeCls, me.position + '-' + me.activeCls]);
  if (supressEvent !== true) {
    me.fireEvent('deactivate', me);
  }
}});
Ext.define('Ext.util.Point', {extend:Ext.util.Region, statics:{fromEvent:function(e) {
  e = e.browserEvent || e;
  e = e.changedTouches && e.changedTouches.length > 0 ? e.changedTouches[0] : e;
  return new this(e.pageX, e.pageY);
}}, constructor:function(x, y) {
  this.callParent([y, x, y, x]);
}, toString:function() {
  return 'Point[' + this.x + ',' + this.y + ']';
}, equals:function(p) {
  return this.x == p.x && this.y == p.y;
}, isWithin:function(p, threshold) {
  if (!Ext.isObject(threshold)) {
    threshold = {x:threshold, y:threshold};
  }
  return this.x <= p.x + threshold.x && this.x >= p.x - threshold.x && this.y <= p.y + threshold.y && this.y >= p.y - threshold.y;
}, isContainedBy:function(region) {
  if (!(region instanceof Ext.util.Region)) {
    region = Ext.get(region.el || region).getRegion();
  }
  return region.contains(this);
}, roundedEquals:function(p) {
  return Math.round(this.x) == Math.round(p.x) && Math.round(this.y) == Math.round(p.y);
}}, function() {
  this.prototype.translate = Ext.util.Region.prototype.translateBy;
});
Ext.define('Ext.tab.Bar', {extend:Ext.panel.Header, alias:'widget.tabbar', baseCls:Ext.baseCSSPrefix + 'tab-bar', isTabBar:true, defaultType:'tab', plain:false, childEls:['body', 'strip'], renderTpl:['\x3cdiv id\x3d"{id}-body" class\x3d"{baseCls}-body {bodyCls} {bodyTargetCls}{childElCls}\x3ctpl if\x3d"ui"\x3e {baseCls}-body-{ui}\x3ctpl for\x3d"uiCls"\x3e {parent.baseCls}-body-{parent.ui}-{.}\x3c/tpl\x3e\x3c/tpl\x3e"\x3ctpl if\x3d"bodyStyle"\x3e style\x3d"{bodyStyle}"\x3c/tpl\x3e\x3e', '{%this.renderContainer(out,values)%}', 
'\x3c/div\x3e', '\x3cdiv id\x3d"{id}-strip" class\x3d"{baseCls}-strip {baseCls}-strip-{dock}{childElCls}', '\x3ctpl if\x3d"ui"\x3e {baseCls}-strip-{ui}', '\x3ctpl for\x3d"uiCls"\x3e {parent.baseCls}-strip-{parent.ui}-{.}\x3c/tpl\x3e', '\x3c/tpl\x3e"\x3e', '\x3c/div\x3e'], _reverseDockNames:{left:'right', right:'left'}, initComponent:function() {
  var me = this;
  if (me.plain) {
    me.addCls(me.baseCls + '-plain');
  }
  me.addClsWithUI(me.orientation);
  me.addEvents('change');
  me.callParent(arguments);
  Ext.merge(me.layout, me.initialConfig.layout);
  me.layout.align = me.orientation == 'vertical' ? 'left' : 'top';
  me.layout.overflowHandler = new Ext.layout.container.boxOverflow.Scroller(me.layout);
  me.remove(me.titleCmp);
  delete me.titleCmp;
  Ext.apply(me.renderData, {bodyCls:me.bodyCls, dock:me.dock});
}, onRender:function() {
  var me = this;
  me.callParent();
  if (me.orientation === 'vertical' && (Ext.isIE8 || Ext.isIE9) && Ext.isStrict) {
    me.el.on({mousemove:me.onMouseMove, scope:me});
  }
}, afterRender:function() {
  var layout = this.layout;
  this.callParent();
  if (Ext.isIE9 && Ext.isStrict && this.orientation === 'vertical') {
    layout.innerCt.on('scroll', function() {
      layout.innerCt.dom.scrollLeft = 0;
    });
  }
}, afterLayout:function() {
  this.adjustTabPositions();
  this.callParent(arguments);
}, adjustTabPositions:function() {
  var items = this.items.items, i = items.length, tab;
  if (!Ext.isIE9m) {
    if (this.dock === 'right') {
      while (i--) {
        tab = items[i];
        if (tab.isVisible()) {
          tab.el.setStyle('left', tab.lastBox.width + 'px');
        }
      }
    } else {
      if (this.dock === 'left') {
        while (i--) {
          tab = items[i];
          if (tab.isVisible()) {
            tab.el.setStyle('left', -tab.lastBox.height + 'px');
          }
        }
      }
    }
  }
}, getLayout:function() {
  var me = this;
  me.layout.type = me.orientation === 'horizontal' ? 'hbox' : 'vbox';
  return me.callParent(arguments);
}, onAdd:function(tab) {
  tab.position = this.dock;
  this.callParent(arguments);
}, onRemove:function(tab) {
  var me = this;
  if (tab === me.previousTab) {
    me.previousTab = null;
  }
  me.callParent(arguments);
}, afterComponentLayout:function(width) {
  var me = this, needsScroll = me.needsScroll;
  me.callParent(arguments);
  if (needsScroll) {
    me.layout.overflowHandler.scrollToItem(me.activeTab);
  }
  delete me.needsScroll;
}, onClick:function(e, target) {
  var me = this, tabPanel = me.tabPanel, tabEl, tab, isCloseClick, tabInfo;
  if (e.getTarget('.' + Ext.baseCSSPrefix + 'box-scroller')) {
    return;
  }
  if (me.orientation === 'vertical' && (Ext.isIE8 || Ext.isIE9) && Ext.isStrict) {
    tabInfo = me.getTabInfoFromPoint(e.getXY());
    tab = tabInfo.tab;
    isCloseClick = tabInfo.close;
  } else {
    tabEl = e.getTarget('.' + Ext.tab.Tab.prototype.baseCls);
    tab = tabEl && Ext.getCmp(tabEl.id);
    isCloseClick = tab && tab.closeEl && target === tab.closeEl.dom;
  }
  if (isCloseClick) {
    e.preventDefault();
  }
  if (tab && tab.isDisabled && !tab.isDisabled()) {
    if (tab.closable && isCloseClick) {
      tab.onCloseClick();
    } else {
      if (tabPanel) {
        tabPanel.setActiveTab(tab.card);
      } else {
        me.setActiveTab(tab);
      }
      tab.focus();
    }
  }
}, onMouseMove:function(e) {
  var me = this, overTab = me._overTab, tabInfo, tab;
  if (e.getTarget('.' + Ext.baseCSSPrefix + 'box-scroller')) {
    return;
  }
  tabInfo = me.getTabInfoFromPoint(e.getXY());
  tab = tabInfo.tab;
  if (tab !== overTab) {
    if (overTab && overTab.rendered) {
      overTab.onMouseLeave(e);
      me._overTab = null;
    }
    if (tab) {
      tab.onMouseEnter(e);
      me._overTab = tab;
      if (!tab.disabled) {
        me.el.setStyle('cursor', 'pointer');
      }
    } else {
      me.el.setStyle('cursor', 'default');
    }
  }
}, onMouseLeave:function(e) {
  var overTab = this._overTab;
  if (overTab && overTab.rendered) {
    overTab.onMouseLeave(e);
  }
}, getTabInfoFromPoint:function(xy) {
  var me = this, tabs = me.items.items, length = tabs.length, innerCt = me.layout.innerCt, innerCtXY = innerCt.getXY(), point = new Ext.util.Point(xy[0], xy[1]), i = 0, lastBox, tabRegion, closeEl, close, closeXY, closeX, closeY, closeWidth, closeHeight, tabX, tabY, tabWidth, tabHeight, closeRegion, isTabReversed, direction, tab;
  for (; i < length; i++) {
    lastBox = tabs[i].lastBox;
    tabX = innerCtXY[0] + lastBox.x;
    tabY = innerCtXY[1] - innerCt.dom.scrollTop + lastBox.y;
    tabWidth = lastBox.width;
    tabHeight = lastBox.height;
    tabRegion = new Ext.util.Region(tabY, tabX + tabWidth, tabY + tabHeight, tabX);
    if (tabRegion.contains(point)) {
      tab = tabs[i];
      closeEl = tab.closeEl;
      if (closeEl) {
        closeXY = closeEl.getXY();
        closeWidth = closeEl.getWidth();
        closeHeight = closeEl.getHeight();
        if (me._isTabReversed === undefined) {
          me._isTabReversed = isTabReversed = tab.btnWrap.dom.currentStyle.filter.indexOf('rotation\x3d2') !== -1;
        }
        direction = isTabReversed ? this._reverseDockNames[me.dock] : me.dock;
        if (direction === 'right') {
          closeX = tabX + tabWidth - (closeXY[1] - tabY + closeEl.getHeight());
          closeY = tabY + (closeXY[0] - tabX);
        } else {
          closeX = tabX + (closeXY[1] - tabY);
          closeY = tabY + tabX + tabHeight - closeXY[0] - closeEl.getWidth();
        }
        closeRegion = new Ext.util.Region(closeY, closeX + closeWidth, closeY + closeHeight, closeX);
        close = closeRegion.contains(point);
      }
      break;
    }
  }
  return {tab:tab, close:close};
}, closeTab:function(toClose) {
  var me = this, card = toClose.card, tabPanel = me.tabPanel, toActivate;
  if (card && card.fireEvent('beforeclose', card) === false) {
    return false;
  }
  toActivate = me.findNextActivatable(toClose);
  Ext.suspendLayouts();
  if (tabPanel && card) {
    delete toClose.ownerCt;
    card.fireEvent('close', card);
    tabPanel.remove(card);
    if (!tabPanel.getComponent(card)) {
      toClose.fireClose();
      me.remove(toClose);
    } else {
      toClose.ownerCt = me;
      Ext.resumeLayouts(true);
      return false;
    }
  }
  if (toActivate) {
    if (tabPanel) {
      tabPanel.setActiveTab(toActivate.card);
    } else {
      me.setActiveTab(toActivate);
    }
    toActivate.focus();
  }
  Ext.resumeLayouts(true);
}, findNextActivatable:function(toClose) {
  var me = this;
  if (toClose.active && me.items.getCount() > 1) {
    return me.previousTab && me.previousTab !== toClose && !me.previousTab.disabled ? me.previousTab : toClose.next('tab[disabled\x3dfalse]') || toClose.prev('tab[disabled\x3dfalse]');
  }
}, setActiveTab:function(tab, initial) {
  var me = this;
  if (!tab.disabled && tab !== me.activeTab) {
    if (me.activeTab) {
      if (me.activeTab.isDestroyed) {
        me.previousTab = null;
      } else {
        me.previousTab = me.activeTab;
        me.activeTab.deactivate();
      }
    }
    tab.activate();
    me.activeTab = tab;
    me.needsScroll = true;
    if (!initial) {
      me.fireEvent('change', me, tab, tab.card);
      me.updateLayout();
    }
  }
}});
Ext.define('Ext.tab.Panel', {extend:Ext.panel.Panel, alias:'widget.tabpanel', alternateClassName:['Ext.TabPanel'], tabPosition:'top', removePanelHeader:true, plain:false, itemCls:Ext.baseCSSPrefix + 'tabpanel-child', minTabWidth:undefined, maxTabWidth:undefined, deferredRender:true, initComponent:function() {
  var me = this, dockedItems = [].concat(me.dockedItems || []), activeTab = me.activeTab || (me.activeTab = 0), tabPosition = me.tabPosition;
  me.layout = new Ext.layout.container.Card(Ext.apply({owner:me, deferredRender:me.deferredRender, itemCls:me.itemCls, activeItem:activeTab}, me.layout));
  me.tabBar = new Ext.tab.Bar(Ext.apply({ui:me.ui, dock:me.tabPosition, orientation:tabPosition == 'top' || tabPosition == 'bottom' ? 'horizontal' : 'vertical', plain:me.plain, cardLayout:me.layout, tabPanel:me}, me.tabBar));
  dockedItems.push(me.tabBar);
  me.dockedItems = dockedItems;
  me.addEvents('beforetabchange', 'tabchange');
  me.callParent(arguments);
  activeTab = me.activeTab = me.getComponent(activeTab);
  if (activeTab) {
    me.tabBar.setActiveTab(activeTab.tab, true);
  }
}, setActiveTab:function(card) {
  var me = this, previous;
  card = me.getComponent(card);
  if (card) {
    previous = me.getActiveTab();
    if (previous !== card && me.fireEvent('beforetabchange', me, card, previous) === false) {
      return false;
    }
    if (!card.isComponent) {
      Ext.suspendLayouts();
      card = me.add(card);
      Ext.resumeLayouts();
    }
    me.activeTab = card;
    Ext.suspendLayouts();
    me.layout.setActiveItem(card);
    card = me.activeTab = me.layout.getActiveItem();
    if (card && card !== previous) {
      me.tabBar.setActiveTab(card.tab);
      Ext.resumeLayouts(true);
      if (previous !== card) {
        me.fireEvent('tabchange', me, card, previous);
      }
    } else {
      Ext.resumeLayouts(true);
    }
    return card;
  }
}, getActiveTab:function() {
  var me = this, result = me.getComponent(me.activeTab);
  if (result && me.items.indexOf(result) != -1) {
    me.activeTab = result;
  } else {
    me.activeTab = null;
  }
  return me.activeTab;
}, getTabBar:function() {
  return this.tabBar;
}, onAdd:function(item, index) {
  var me = this, cfg = item.tabConfig || {}, defaultConfig = {xtype:'tab', ui:me.tabBar.ui, card:item, disabled:item.disabled, closable:item.closable, hidden:item.hidden && !item.hiddenByLayout, tooltip:item.tooltip, tabBar:me.tabBar, position:me.tabPosition, closeText:item.closeText};
  cfg = Ext.applyIf(cfg, defaultConfig);
  item.tab = me.tabBar.insert(index, cfg);
  item.on({scope:me, enable:me.onItemEnable, disable:me.onItemDisable, beforeshow:me.onItemBeforeShow, iconchange:me.onItemIconChange, iconclschange:me.onItemIconClsChange, titlechange:me.onItemTitleChange});
  if (item.isPanel) {
    if (me.removePanelHeader) {
      if (item.rendered) {
        if (item.header) {
          item.header.hide();
        }
      } else {
        item.header = false;
      }
    }
    if (item.isPanel && me.border) {
      item.setBorder(false);
    }
  }
}, onItemEnable:function(item) {
  item.tab.enable();
}, onItemDisable:function(item) {
  item.tab.disable();
}, onItemBeforeShow:function(item) {
  if (item !== this.activeTab) {
    this.setActiveTab(item);
    return false;
  }
}, onItemIconChange:function(item, newIcon) {
  item.tab.setIcon(newIcon);
}, onItemIconClsChange:function(item, newIconCls) {
  item.tab.setIconCls(newIconCls);
}, onItemTitleChange:function(item, newTitle) {
  item.tab.setText(newTitle);
}, doRemove:function(item, autoDestroy) {
  var me = this, toActivate;
  if (me.destroying || me.items.getCount() == 1) {
    me.activeTab = null;
  } else {
    if ((toActivate = me.tabBar.items.indexOf(me.tabBar.findNextActivatable(item.tab))) !== -1) {
      me.setActiveTab(toActivate);
    }
  }
  this.callParent(arguments);
  delete item.tab.card;
  delete item.tab;
}, onRemove:function(item, destroying) {
  var me = this;
  item.un({scope:me, enable:me.onItemEnable, disable:me.onItemDisable, beforeshow:me.onItemBeforeShow});
  if (!me.destroying && item.tab.ownerCt === me.tabBar) {
    me.tabBar.remove(item.tab);
  }
}});
Ext.define('Ext.tree.Column', {extend:Ext.grid.column.Column, alias:'widget.treecolumn', tdCls:Ext.baseCSSPrefix + 'grid-cell-treecolumn', autoLock:true, lockable:false, draggable:false, hideable:false, iconCls:Ext.baseCSSPrefix + 'tree-icon', checkboxCls:Ext.baseCSSPrefix + 'tree-checkbox', elbowCls:Ext.baseCSSPrefix + 'tree-elbow', expanderCls:Ext.baseCSSPrefix + 'tree-expander', textCls:Ext.baseCSSPrefix + 'tree-node-text', innerCls:Ext.baseCSSPrefix + 'grid-cell-inner-treecolumn', isTreeColumn:true, 
cellTpl:['\x3ctpl for\x3d"lines"\x3e', '\x3cimg src\x3d"{parent.blankUrl}" class\x3d"{parent.childCls} {parent.elbowCls}-img ', '{parent.elbowCls}-\x3ctpl if\x3d"."\x3eline\x3ctpl else\x3eempty\x3c/tpl\x3e"/\x3e', '\x3c/tpl\x3e', '\x3cimg src\x3d"{blankUrl}" class\x3d"{childCls} {elbowCls}-img {elbowCls}', '\x3ctpl if\x3d"isLast"\x3e-end\x3c/tpl\x3e\x3ctpl if\x3d"expandable"\x3e-plus {expanderCls}\x3c/tpl\x3e"/\x3e', '\x3ctpl if\x3d"checked !\x3d\x3d null"\x3e', '\x3cinput type\x3d"button" role\x3d"checkbox" \x3ctpl if\x3d"checked"\x3earia-checked\x3d"true" \x3c/tpl\x3e', 
'class\x3d"{childCls} {checkboxCls}\x3ctpl if\x3d"checked"\x3e {checkboxCls}-checked\x3c/tpl\x3e"/\x3e', '\x3c/tpl\x3e', '\x3cimg src\x3d"{blankUrl}" class\x3d"{childCls} {baseIconCls} ', '{baseIconCls}-\x3ctpl if\x3d"leaf"\x3eleaf\x3ctpl else\x3eparent\x3c/tpl\x3e {iconCls}"', '\x3ctpl if\x3d"icon"\x3estyle\x3d"background-image:url({icon})"\x3c/tpl\x3e/\x3e', '\x3ctpl if\x3d"href"\x3e', '\x3ca href\x3d"{href}" target\x3d"{hrefTarget}" class\x3d"{textCls} {childCls}"\x3e{value}\x3c/a\x3e', '\x3ctpl else\x3e', 
'\x3cspan class\x3d"{textCls} {childCls}"\x3e{value}\x3c/span\x3e', '\x3c/tpl\x3e'], initComponent:function() {
  var me = this;
  me.origRenderer = me.renderer;
  me.origScope = me.scope || window;
  me.renderer = me.treeRenderer;
  me.scope = me;
  me.callParent();
}, treeRenderer:function(value, metaData, record, rowIdx, colIdx, store, view) {
  var me = this, cls = record.get('cls'), renderer = me.origRenderer, data = record.data, parent = record.parentNode, rootVisible = view.rootVisible, lines = [], parentData;
  if (cls) {
    metaData.tdCls += ' ' + cls;
  }
  while (parent && (rootVisible || parent.data.depth > 0)) {
    parentData = parent.data;
    lines[rootVisible ? parentData.depth : parentData.depth - 1] = parentData.isLast ? 0 : 1;
    parent = parent.parentNode;
  }
  return me.getTpl('cellTpl').apply({record:record, baseIconCls:me.iconCls, iconCls:data.iconCls, icon:data.icon, checkboxCls:me.checkboxCls, checked:data.checked, elbowCls:me.elbowCls, expanderCls:me.expanderCls, textCls:me.textCls, leaf:data.leaf, expandable:record.isExpandable(), isLast:data.isLast, blankUrl:Ext.BLANK_IMAGE_URL, href:data.href, hrefTarget:data.hrefTarget, lines:lines, metaData:metaData, childCls:me.getChildCls ? me.getChildCls() + ' ' : '', value:renderer ? renderer.apply(me.origScope, 
  arguments) : value});
}});
Ext.define('Ext.tree.View', {extend:Ext.view.Table, alias:'widget.treeview', isTreeView:true, loadingCls:Ext.baseCSSPrefix + 'grid-tree-loading', expandedCls:Ext.baseCSSPrefix + 'grid-tree-node-expanded', leafCls:Ext.baseCSSPrefix + 'grid-tree-node-leaf', expanderSelector:'.' + Ext.baseCSSPrefix + 'tree-expander', checkboxSelector:'.' + Ext.baseCSSPrefix + 'tree-checkbox', expanderIconOverCls:Ext.baseCSSPrefix + 'tree-expander-over', nodeAnimWrapCls:Ext.baseCSSPrefix + 'tree-animator-wrap', blockRefresh:true, 
loadMask:false, rootVisible:true, deferInitialRefresh:false, expandDuration:250, collapseDuration:250, toggleOnDblClick:true, stripeRows:false, uiFields:['expanded', 'loaded', 'checked', 'expandable', 'leaf', 'icon', 'iconCls', 'loading', 'qtip', 'qtitle'], treeRowTpl:['{%', 'this.processRowValues(values);', 'this.nextTpl.applyOut(values, out, parent);', 'delete values.rowAttr["data-qtip"];', 'delete values.rowAttr["data-qtitle"];', '%}', {priority:10, processRowValues:function(rowValues) {
  var record = rowValues.record, view = rowValues.view, qtip = record.get('qtip'), qtitle = record.get('qttle');
  rowValues.rowAttr = {};
  if (qtip) {
    rowValues.rowAttr['data-qtip'] = qtip;
  }
  if (qtitle) {
    rowValues.rowAttr['data-qtitle'] = qtitle;
  }
  if (record.isExpanded()) {
    rowValues.rowClasses.push(view.expandedCls);
  }
  if (record.isLeaf()) {
    rowValues.rowClasses.push(view.leafCls);
  }
  if (record.isLoading()) {
    rowValues.rowClasses.push(view.loadingCls);
  }
}}], initComponent:function() {
  var me = this, treeStore = me.panel.getStore(), store = me.store;
  if (me.initialConfig.animate === undefined) {
    me.animate = Ext.enableFx;
  }
  if (!store || store === treeStore) {
    me.store = store = new Ext.data.NodeStore({treeStore:treeStore, recursive:true, rootVisible:me.rootVisible});
  }
  if (me.node) {
    me.setRootNode(me.node);
  }
  me.animQueue = {};
  me.animWraps = {};
  me.addEvents('afteritemexpand', 'afteritemcollapse', 'nodedragover');
  me.callParent(arguments);
  me.addRowTpl(Ext.XTemplate.getTpl(me, 'treeRowTpl'));
}, onBeforeFill:function(treeStore, fillRoot) {
  this.store.suspendEvents();
}, onFillComplete:function(treeStore, fillRoot, newNodes) {
  var me = this, store = me.store, start = store.indexOf(newNodes[0]);
  store.resumeEvents();
  fillRoot.triggerUIUpdate();
  if (!newNodes.length || start === -1) {
    return;
  }
  me.onAdd(me.store, newNodes, start);
  me.refreshPartner();
}, onBeforeSort:function() {
  this.store.suspendEvents();
}, onSort:function(o) {
  if (o.isStore) {
    this.store.resumeEvents();
    this.refresh();
    this.refreshPartner();
  }
}, refreshPartner:function() {
  var partner = this.lockingPartner;
  if (partner) {
    partner.refresh();
  }
}, getMaskStore:function() {
  return this.panel.getStore();
}, afterRender:function() {
  var me = this;
  me.callParent(arguments);
  me.el.on({scope:me, delegate:me.expanderSelector, mouseover:me.onExpanderMouseOver, mouseout:me.onExpanderMouseOut, click:{delegate:me.checkboxSelector, fn:me.onCheckboxChange, scope:me}});
}, afterComponentLayout:function() {
  this.callParent(arguments);
  var stretcher = this.stretcher;
  if (stretcher) {
    stretcher.setWidth(this.getWidth() - Ext.getScrollbarSize().width);
  }
}, processUIEvent:function(e) {
  if (e.getTarget('.' + this.nodeAnimWrapCls, this.el)) {
    return false;
  }
  return this.callParent(arguments);
}, onClear:function() {
  this.store.removeAll();
}, setRootNode:function(node) {
  var me = this;
  me.store.setNode(node);
  me.node = node;
}, onCheckboxChange:function(e, t) {
  var me = this, item = e.getTarget(me.getItemSelector(), me.getTargetEl());
  if (item) {
    me.onCheckChange(me.getRecord(item));
  }
}, onCheckChange:function(record) {
  var checked = record.get('checked');
  if (Ext.isBoolean(checked)) {
    checked = !checked;
    record.set('checked', checked);
    this.fireEvent('checkchange', record, checked);
  }
}, getChecked:function() {
  var checked = [];
  this.node.cascadeBy(function(rec) {
    if (rec.get('checked')) {
      checked.push(rec);
    }
  });
  return checked;
}, isItemChecked:function(rec) {
  return rec.get('checked');
}, createAnimWrap:function(record, index) {
  var me = this, node = me.getNode(record), tmpEl, nodeEl, columnSizer = [];
  me.renderColumnSizer(columnSizer);
  nodeEl = Ext.get(node);
  tmpEl = nodeEl.insertSibling({tag:'tr', html:['\x3ctd colspan\x3d"' + me.panel.headerCt.getColumnCount() + '"\x3e', '\x3cdiv class\x3d"' + me.nodeAnimWrapCls + '"\x3e', '\x3ctable class\x3d"' + Ext.baseCSSPrefix + me.id + '-table ' + Ext.baseCSSPrefix + 'grid-table" style\x3d"border:0" cellspacing\x3d"0" cellpadding\x3d"0"\x3e', columnSizer.join(''), '\x3ctbody\x3e\x3c/tbody\x3e\x3c/table\x3e', '\x3c/div\x3e', '\x3c/td\x3e'].join('')}, 'after');
  return {record:record, node:node, el:tmpEl, expanding:false, collapsing:false, animating:false, animateEl:tmpEl.down('div'), targetEl:tmpEl.down('tbody')};
}, getAnimWrap:function(parent, bubble) {
  if (!this.animate) {
    return null;
  }
  var wraps = this.animWraps, wrap = wraps[parent.internalId];
  if (bubble !== false) {
    while (!wrap && parent) {
      parent = parent.parentNode;
      if (parent) {
        wrap = wraps[parent.internalId];
      }
    }
  }
  return wrap;
}, doAdd:function(records, index) {
  var me = this, nodes = me.bufferRender(records, index, true), record = records[0], parent = record.parentNode, all = me.all, relativeIndex, animWrap = me.getAnimWrap(parent), targetEl, children, len;
  if (!animWrap || !animWrap.expanding) {
    return me.callParent(arguments);
  }
  parent = animWrap.record;
  targetEl = animWrap.targetEl;
  children = targetEl.dom.childNodes;
  len = children.length;
  relativeIndex = index - me.indexInStore(parent) - 1;
  if (!len || relativeIndex >= len) {
    targetEl.appendChild(nodes);
  } else {
    Ext.fly(children[relativeIndex]).insertSibling(nodes, 'before', true);
  }
  all.insert(index, nodes);
  if (animWrap.isAnimating) {
    me.onExpand(parent);
  }
}, onRemove:function(ds, records, indexes) {
  var me = this, empty, i;
  if (me.viewReady) {
    empty = me.store.getCount() === 0;
    if (empty) {
      me.refresh();
    } else {
      for (i = indexes.length - 1; i >= 0; --i) {
        me.doRemove(records[i], indexes[i]);
      }
    }
    if (me.hasListeners.itemremove) {
      for (i = indexes.length - 1; i >= 0; --i) {
        me.fireEvent('itemremove', records[i], indexes[i]);
      }
    }
  }
}, doRemove:function(record, index) {
  var me = this, all = me.all, animWrap = me.getAnimWrap(record), item = all.item(index), node = item ? item.dom : null;
  if (!node || !animWrap || !animWrap.collapsing) {
    return me.callParent(arguments);
  }
  animWrap.targetEl.dom.insertBefore(node, animWrap.targetEl.dom.firstChild);
  all.removeElement(index);
}, onBeforeExpand:function(parent, records, index) {
  var me = this, animWrap;
  if (me.rendered && me.all.getCount() && me.animate) {
    if (me.getNode(parent)) {
      animWrap = me.getAnimWrap(parent, false);
      if (!animWrap) {
        animWrap = me.animWraps[parent.internalId] = me.createAnimWrap(parent);
        animWrap.animateEl.setHeight(0);
      } else {
        if (animWrap.collapsing) {
          animWrap.targetEl.select(me.itemSelector).remove();
        }
      }
      animWrap.expanding = true;
      animWrap.collapsing = false;
    }
  }
}, onExpand:function(parent) {
  var me = this, queue = me.animQueue, id = parent.getId(), node = me.getNode(parent), index = node ? me.indexOf(node) : -1, animWrap, animateEl, targetEl, fromHeight = Ext.isIEQuirks ? 1 : 0;
  if (me.singleExpand) {
    me.ensureSingleExpand(parent);
  }
  if (index === -1) {
    return;
  }
  animWrap = me.getAnimWrap(parent, false);
  if (!animWrap) {
    parent.isExpandingOrCollapsing = false;
    me.fireEvent('afteritemexpand', parent, index, node);
    me.refreshSize();
    return;
  }
  animateEl = animWrap.animateEl;
  targetEl = animWrap.targetEl;
  animateEl.stopAnimation();
  queue[id] = true;
  animateEl.dom.style.height = fromHeight + 'px';
  animateEl.animate({from:{height:fromHeight}, to:{height:targetEl.getHeight()}, duration:me.expandDuration, listeners:{afteranimate:function() {
    var items = targetEl.query(me.itemSelector);
    if (items.length) {
      animWrap.el.insertSibling(items, 'before', true);
    }
    animWrap.el.remove();
    me.refreshSize();
    delete me.animWraps[animWrap.record.internalId];
    delete queue[id];
  }}, callback:function() {
    parent.isExpandingOrCollapsing = false;
    me.fireEvent('afteritemexpand', parent, index, node);
  }});
  animWrap.isAnimating = true;
}, onBeforeCollapse:function(parent, records, index, callback, scope) {
  var me = this, animWrap;
  if (me.rendered && me.all.getCount()) {
    if (me.animate) {
      if (Ext.Array.contains(parent.stores, me.store)) {
        animWrap = me.getAnimWrap(parent);
        if (!animWrap) {
          animWrap = me.animWraps[parent.internalId] = me.createAnimWrap(parent, index);
        } else {
          if (animWrap.expanding) {
            animWrap.targetEl.select(this.itemSelector).remove();
          }
        }
        animWrap.expanding = false;
        animWrap.collapsing = true;
        animWrap.callback = callback;
        animWrap.scope = scope;
      }
    } else {
      me.onCollapseCallback = callback;
      me.onCollapseScope = scope;
    }
  }
}, onCollapse:function(parent) {
  var me = this, queue = me.animQueue, id = parent.getId(), node = me.getNode(parent), index = node ? me.indexOf(node) : -1, animWrap = me.getAnimWrap(parent), animateEl;
  if (!me.all.getCount() || !Ext.Array.contains(parent.stores, me.store)) {
    return;
  }
  if (!animWrap) {
    parent.isExpandingOrCollapsing = false;
    me.fireEvent('afteritemcollapse', parent, index, node);
    me.refreshSize();
    Ext.callback(me.onCollapseCallback, me.onCollapseScope);
    me.onCollapseCallback = me.onCollapseScope = null;
    return;
  }
  animateEl = animWrap.animateEl;
  queue[id] = true;
  animateEl.stopAnimation();
  animateEl.animate({to:{height:Ext.isIEQuirks ? 1 : 0}, duration:me.collapseDuration, listeners:{afteranimate:function() {
    animWrap.el.remove();
    me.refreshSize();
    delete me.animWraps[animWrap.record.internalId];
    delete queue[id];
  }}, callback:function() {
    parent.isExpandingOrCollapsing = false;
    me.fireEvent('afteritemcollapse', parent, index, node);
    Ext.callback(animWrap.callback, animWrap.scope);
    animWrap.callback = animWrap.scope = null;
  }});
  animWrap.isAnimating = true;
}, isAnimating:function(node) {
  return !!this.animQueue[node.getId()];
}, expand:function(record, deep, callback, scope) {
  var me = this, doAnimate = !!me.animate, result;
  if (!doAnimate || !record.isExpandingOrCollapsing) {
    if (!record.isLeaf()) {
      record.isExpandingOrCollapsing = doAnimate;
    }
    Ext.suspendLayouts();
    result = record.expand(deep, callback, scope);
    Ext.resumeLayouts(true);
    return result;
  }
}, collapse:function(record, deep, callback, scope) {
  var me = this, doAnimate = !!me.animate;
  if (!doAnimate || !record.isExpandingOrCollapsing) {
    if (!record.isLeaf()) {
      record.isExpandingOrCollapsing = doAnimate;
    }
    return record.collapse(deep, callback, scope);
  }
}, toggle:function(record, deep, callback, scope) {
  if (record.isExpanded()) {
    this.collapse(record, deep, callback, scope);
  } else {
    this.expand(record, deep, callback, scope);
  }
}, onItemDblClick:function(record, item, index) {
  var me = this, editingPlugin = me.editingPlugin;
  me.callParent(arguments);
  if (me.toggleOnDblClick && record.isExpandable() && !(editingPlugin && editingPlugin.clicksToEdit === 2)) {
    me.toggle(record);
  }
}, onBeforeItemMouseDown:function(record, item, index, e) {
  if (e.getTarget(this.expanderSelector, item)) {
    return false;
  }
  return this.callParent(arguments);
}, onItemClick:function(record, item, index, e) {
  if (e.getTarget(this.expanderSelector, item) && record.isExpandable()) {
    this.toggle(record, e.ctrlKey);
    return false;
  }
  return this.callParent(arguments);
}, onExpanderMouseOver:function(e, t) {
  e.getTarget(this.cellSelector, 10, true).addCls(this.expanderIconOverCls);
}, onExpanderMouseOut:function(e, t) {
  e.getTarget(this.cellSelector, 10, true).removeCls(this.expanderIconOverCls);
}, getStoreListeners:function() {
  var me = this, listeners = me.callParent(arguments);
  return Ext.apply(listeners, {beforeexpand:me.onBeforeExpand, expand:me.onExpand, beforecollapse:me.onBeforeCollapse, collapse:me.onCollapse, write:me.onStoreWrite, datachanged:me.onStoreDataChanged});
}, onBindStore:function() {
  var me = this, treeStore = me.getTreeStore();
  me.callParent(arguments);
  me.mon(treeStore, {scope:me, beforefill:me.onBeforeFill, fillcomplete:me.onFillComplete});
  if (!treeStore.remoteSort) {
    me.mon(treeStore, {scope:me, beforesort:me.onBeforeSort, sort:me.onSort});
  }
}, onUnbindStore:function() {
  var me = this, treeStore = me.getTreeStore();
  me.callParent(arguments);
  me.mun(treeStore, {scope:me, beforefill:me.onBeforeFill, fillcomplete:me.onFillComplete});
  if (!treeStore.remoteSort) {
    me.mun(treeStore, {scope:me, beforesort:me.onBeforeSort, sort:me.onSort});
  }
}, getTreeStore:function() {
  return this.panel.store;
}, ensureSingleExpand:function(node) {
  var parent = node.parentNode;
  if (parent) {
    parent.eachChild(function(child) {
      if (child !== node && child.isExpanded()) {
        child.collapse();
      }
    });
  }
}, shouldUpdateCell:function(record, column, changedFieldNames) {
  if (changedFieldNames) {
    var i = 0, len = changedFieldNames.length;
    for (; i < len; ++i) {
      if (Ext.Array.contains(this.uiFields, changedFieldNames[i])) {
        return true;
      }
    }
  }
  return this.callParent(arguments);
}, onStoreWrite:function(store, operation) {
  var treeStore = this.panel.store;
  treeStore.fireEvent('write', treeStore, operation);
}, onStoreDataChanged:function(store, operation) {
  var treeStore = this.panel.store;
  treeStore.fireEvent('datachanged', treeStore);
}});
Ext.define('Ext.grid.plugin.BufferedRendererTreeView', {override:'Ext.tree.View', onRemove:function(store, records, indices) {
  var me = this;
  if (me.rendered && me.bufferedRenderer) {
    me.refreshView();
  } else {
    me.callParent([store, records, indices]);
  }
}});
Ext.define('Ext.tree.Panel', {extend:Ext.panel.Table, alias:'widget.treepanel', alternateClassName:['Ext.tree.TreePanel', 'Ext.TreePanel'], viewType:'treeview', selType:'treemodel', treeCls:Ext.baseCSSPrefix + 'tree-panel', deferRowRender:false, rowLines:false, lines:true, useArrows:false, singleExpand:false, ddConfig:{enableDrag:true, enableDrop:true}, rootVisible:true, displayField:'text', root:null, normalCfgCopy:['displayField', 'root', 'singleExpand', 'useArrows', 'lines', 'rootVisible', 'scroll'], 
lockedCfgCopy:['displayField', 'root', 'singleExpand', 'useArrows', 'lines', 'rootVisible'], isTree:true, arrowCls:Ext.baseCSSPrefix + 'tree-arrows', linesCls:Ext.baseCSSPrefix + 'tree-lines', noLinesCls:Ext.baseCSSPrefix + 'tree-no-lines', autoWidthCls:Ext.baseCSSPrefix + 'autowidth-table', constructor:function(config) {
  config = config || {};
  if (config.animate === undefined) {
    config.animate = Ext.isBoolean(this.animate) ? this.animate : Ext.enableFx;
  }
  this.enableAnimations = config.animate;
  delete config.animate;
  this.callParent([config]);
}, initComponent:function() {
  var me = this, cls = [me.treeCls], store = me.store, view;
  if (me.useArrows) {
    cls.push(me.arrowCls);
    me.lines = false;
  }
  if (me.lines) {
    cls.push(me.linesCls);
  } else {
    if (!me.useArrows) {
      cls.push(me.noLinesCls);
    }
  }
  if (Ext.isString(store)) {
    store = me.store = Ext.StoreMgr.lookup(store);
  } else {
    if (!store || Ext.isObject(store) && !store.isStore) {
      store = me.store = new Ext.data.TreeStore(Ext.apply({root:me.root, fields:me.fields, model:me.model, folderSort:me.folderSort}, store));
    } else {
      if (me.root) {
        store = me.store = Ext.data.StoreManager.lookup(store);
        store.setRootNode(me.root);
        if (me.folderSort !== undefined) {
          store.folderSort = me.folderSort;
          store.sort();
        }
      }
    }
  }
  me.viewConfig = Ext.apply({rootVisible:me.rootVisible, animate:me.enableAnimations, singleExpand:me.singleExpand, node:store.getRootNode(), hideHeaders:me.hideHeaders}, me.viewConfig);
  if (!me.columns) {
    if (me.initialConfig.hideHeaders === undefined) {
      me.hideHeaders = true;
    }
    me.addCls(me.autoWidthCls);
    me.columns = [{xtype:'treecolumn', text:'Name', width:Ext.isIE6 ? '100%' : 10000, dataIndex:me.displayField}];
  }
  if (me.cls) {
    cls.push(me.cls);
  }
  me.cls = cls.join(' ');
  me.callParent();
  me.selModel.treeStore = me.store;
  view = me.getView();
  me.relayEvents(view, ['checkchange', 'afteritemexpand', 'afteritemcollapse']);
  if (!view.isLockingView) {
    if (!view.rootVisible && !me.getRootNode()) {
      me.setRootNode({expanded:true});
    }
  }
}, bindStore:function(store, initial) {
  var me = this;
  me.store = store;
  me.storeListeners = me.mon(store, {destroyable:true, load:me.onStoreLoad, rootchange:me.onRootChange, clear:me.onClear, scope:me});
  me.storeRelayers = me.relayEvents(store, ['beforeload', 'load']);
  me.storeRelayers1 = me.mon(store, {destroyable:true, append:me.createRelayer('itemappend'), remove:me.createRelayer('itemremove'), move:me.createRelayer('itemmove', [0, 4]), insert:me.createRelayer('iteminsert'), beforeappend:me.createRelayer('beforeitemappend'), beforeremove:me.createRelayer('beforeitemremove'), beforemove:me.createRelayer('beforeitemmove'), beforeinsert:me.createRelayer('beforeiteminsert'), expand:me.createRelayer('itemexpand', [0, 1]), collapse:me.createRelayer('itemcollapse', 
  [0, 1]), beforeexpand:me.createRelayer('beforeitemexpand', [0, 1]), beforecollapse:me.createRelayer('beforeitemcollapse', [0, 1])});
  store.ownerTree = me;
  if (!initial) {
    me.view.setRootNode(me.getRootNode());
  }
}, unbindStore:function() {
  var me = this, store = me.store;
  if (store) {
    Ext.destroy(me.storeListeners, me.storeRelayers, me.storeRelayers1);
    delete store.ownerTree;
  }
}, onClear:function() {
  this.view.onClear();
}, setRootNode:function() {
  return this.store.setRootNode.apply(this.store, arguments);
}, getRootNode:function() {
  return this.store.getRootNode();
}, onRootChange:function(root) {
  this.view.setRootNode(root);
}, getChecked:function() {
  return this.getView().getChecked();
}, isItemChecked:function(rec) {
  return rec.get('checked');
}, expandNode:function(record, deep, callback, scope) {
  return this.getView().expand(record, deep, callback, scope || this);
}, collapseNode:function(record, deep, callback, scope) {
  return this.getView().collapse(record, deep, callback, scope || this);
}, expandAll:function(callback, scope) {
  var me = this, root = me.getRootNode(), animate = me.enableAnimations;
  if (root) {
    if (!animate) {
      Ext.suspendLayouts();
    }
    root.expand(true, callback, scope || me);
    if (!animate) {
      Ext.resumeLayouts(true);
    }
  }
}, collapseAll:function(callback, scope) {
  var me = this, root = me.getRootNode(), animate = me.enableAnimations, view = me.getView();
  if (root) {
    if (!animate) {
      Ext.suspendLayouts();
    }
    scope = scope || me;
    if (view.rootVisible) {
      root.collapse(true, callback, scope);
    } else {
      root.collapseChildren(true, callback, scope);
    }
    if (!animate) {
      Ext.resumeLayouts(true);
    }
  }
}, expandPath:function(path, field, separator, callback, scope) {
  var me = this, current = me.getRootNode(), index = 1, view = me.getView(), keys, expander;
  field = field || me.getRootNode().idProperty;
  separator = separator || '/';
  if (Ext.isEmpty(path)) {
    Ext.callback(callback, scope || me, [false, null]);
    return;
  }
  keys = path.split(separator);
  if (current.get(field) != keys[1]) {
    Ext.callback(callback, scope || me, [false, current]);
    return;
  }
  expander = function() {
    if (++index === keys.length) {
      Ext.callback(callback, scope || me, [true, current]);
      return;
    }
    var node = current.findChild(field, keys[index]);
    if (!node) {
      Ext.callback(callback, scope || me, [false, current]);
      return;
    }
    current = node;
    current.expand(false, expander);
  };
  current.expand(false, expander);
}, selectPath:function(path, field, separator, callback, scope) {
  var me = this, root, keys, last;
  field = field || me.getRootNode().idProperty;
  separator = separator || '/';
  keys = path.split(separator);
  last = keys.pop();
  if (keys.length > 1) {
    me.expandPath(keys.join(separator), field, separator, function(success, node) {
      var lastNode = node;
      if (success && node) {
        node = node.findChild(field, last);
        if (node) {
          me.getSelectionModel().select(node);
          Ext.callback(callback, scope || me, [true, node]);
          return;
        }
      }
      Ext.callback(callback, scope || me, [false, lastNode]);
    }, me);
  } else {
    root = me.getRootNode();
    if (root.getId() === last) {
      me.getSelectionModel().select(root);
      Ext.callback(callback, scope || me, [true, root]);
    } else {
      Ext.callback(callback, scope || me, [false, null]);
    }
  }
}});
Ext.define('Ext.util.Grouper', {extend:Ext.util.Sorter, isGrouper:true, getGroupString:function(instance) {
  return instance.get(this.property);
}});
Ext.define('OPS.Global', {singleton:true, baseUrl:''});
Ext.define('GeoExt.tree.LayerNode', {extend:Ext.AbstractPlugin, alias:'plugin.gx_layer', init:function(target) {
  this.target = target;
  var layer = target.get('layer');
  target.set('checked', layer.getVisibility());
  if (!target.get('checkedGroup') && layer.isBaseLayer) {
    target.set('checkedGroup', 'gx_baselayer');
  }
  target.set('fixedText', !!target.text);
  target.set('leaf', true);
  if (!target.get('iconCls')) {
    target.set('iconCls', 'gx-tree-layer-icon');
  }
  target.on('afteredit', this.onAfterEdit, this);
  layer.events.on({'visibilitychanged':this.onLayerVisibilityChanged, scope:this});
}, onAfterEdit:function(node, modifiedFields) {
  var me = this;
  if (~Ext.Array.indexOf(modifiedFields, 'checked')) {
    me.onCheckChange();
  }
}, onLayerVisibilityChanged:function() {
  if (!this._visibilityChanging) {
    this.target.set('checked', this.target.get('layer').getVisibility());
  }
}, onCheckChange:function() {
  var node = this.target, checked = this.target.get('checked');
  if (checked != node.get('layer').getVisibility()) {
    node._visibilityChanging = true;
    var layer = node.get('layer');
    if (checked && layer.isBaseLayer && layer.map) {
      layer.map.setBaseLayer(layer);
    } else {
      if (!checked && layer.isBaseLayer && layer.map && layer.map.baseLayer && layer.id == layer.map.baseLayer.id) {
        node.set('checked', layer.getVisibility());
      } else {
        layer.setVisibility(checked);
      }
    }
    delete node._visibilityChanging;
  }
}});
Ext.define('GeoExt.tree.LayerLoader', {extend:Ext.util.Observable, store:null, filter:function(record) {
  return record.getLayer().displayInLayerSwitcher === true;
}, baseAttrs:null, load:function(node) {
  if (this.fireEvent('beforeload', this, node)) {
    this.removeStoreHandlers();
    while (node.firstChild) {
      node.removeChild(node.firstChild);
    }
    if (!this.store) {
      this.store = GeoExt.MapPanel.guess().layers;
    }
    this.store.each(function(record) {
      this.addLayerNode(node, record);
    }, this);
    this.addStoreHandlers(node);
    this.fireEvent('load', this, node);
  }
}, onStoreAdd:function(store, records, index, node) {
  if (!this._reordering) {
    var nodeIndex = node.get('container').recordIndexToNodeIndex(index + records.length - 1, node);
    for (var i = 0, ii = records.length; i < ii; ++i) {
      this.addLayerNode(node, records[i], nodeIndex);
    }
  }
}, onStoreRemove:function(layerRecord, node) {
  if (!this._reordering) {
    this.removeLayerNode(node, layerRecord);
  }
}, addLayerNode:function(node, layerRecord, index) {
  index = index || 0;
  if (this.filter(layerRecord) === true) {
    var layer = layerRecord.getLayer();
    var child = this.createNode({plugins:[{ptype:'gx_layer'}], layer:layer, text:layer.name, listeners:{move:this.onChildMove, scope:this}});
    if (index !== undefined) {
      node.insertChild(index, child);
    } else {
      node.appendChild(child);
    }
    node.getChildAt(index).on('move', this.onChildMove, this);
  }
}, removeLayerNode:function(node, layerRecord) {
  if (this.filter(layerRecord) === true) {
    var child = node.findChildBy(function(node) {
      return node.get('layer') == layerRecord.getLayer();
    });
    if (child) {
      child.un('move', this.onChildMove, this);
      child.remove();
    }
  }
}, onChildMove:function(node, oldParent, newParent, index) {
  var me = this, record = me.store.getByLayer(node.get('layer')), container = newParent.get('container'), parentLoader = container.loader;
  me._reordering = true;
  if (parentLoader instanceof me.self && me.store === parentLoader.store) {
    parentLoader._reordering = true;
    me.store.remove(record);
    var newRecordIndex;
    if (newParent.childNodes.length > 1) {
      var searchIndex = index === 0 ? index + 1 : index - 1;
      newRecordIndex = me.store.findBy(function(r) {
        return newParent.childNodes[searchIndex].get('layer') === r.getLayer();
      });
      if (index === 0) {
        newRecordIndex++;
      }
    } else {
      if (oldParent.parentNode === newParent.parentNode) {
        var prev = newParent;
        do {
          prev = prev.previousSibling;
        } while (prev && !(prev.get('container') instanceof container.self && prev.lastChild));
        if (prev) {
          newRecordIndex = me.store.findBy(function(r) {
            return prev.lastChild.get('layer') === r.getLayer();
          });
        } else {
          var next = newParent;
          do {
            next = next.nextSibling;
          } while (next && !(next.get('container') instanceof container.self && next.firstChild));
          if (next) {
            newRecordIndex = me.store.findBy(function(r) {
              return next.firstChild.get('layer') === r.getLayer();
            });
          }
          newRecordIndex++;
        }
      }
    }
    if (newRecordIndex !== undefined) {
      me.store.insert(newRecordIndex, [record]);
    } else {
      me.store.insert(oldRecordIndex, [record]);
    }
    delete parentLoader._reordering;
  }
  delete me._reordering;
}, addStoreHandlers:function(node) {
  if (!this._storeHandlers) {
    this._storeHandlers = {'add':function(store, layerRecords, index) {
      this.onStoreAdd(store, layerRecords, index, node);
    }, 'remove':function(parent, removedRecord) {
      this.onStoreRemove(removedRecord, node);
    }};
    for (var evt in this._storeHandlers) {
      this.store.on(evt, this._storeHandlers[evt], this);
    }
  }
}, removeStoreHandlers:function() {
  if (this._storeHandlers) {
    for (var evt in this._storeHandlers) {
      this.store.un(evt, this._storeHandlers[evt], this);
    }
    delete this._storeHandlers;
  }
}, createNode:function(attr) {
  if (this.baseAttrs) {
    Ext.apply(attr, this.baseAttrs);
  }
  return attr;
}, destroy:function() {
  this.removeStoreHandlers();
}});
Ext.define('GeoExt.tree.LayerContainer', {extend:Ext.AbstractPlugin, alias:'plugin.gx_layercontainer', defaultText:'Layers', init:function(target) {
  var me = this;
  var loader = me.loader;
  me.loader = loader && loader instanceof GeoExt.tree.LayerLoader ? loader : new GeoExt.tree.LayerLoader(loader);
  target.set('container', me);
  if (!target.get('text')) {
    target.set('text', me.defaultText);
    target.commit();
  }
  me.loader.load(target);
}, recordIndexToNodeIndex:function(index, node) {
  var me = this;
  var store = me.loader.store;
  var count = store.getCount();
  var nodeCount = node.childNodes.length;
  var nodeIndex = -1;
  for (var i = count - 1; i >= 0; --i) {
    if (me.loader.filter(store.getAt(i)) === true) {
      ++nodeIndex;
      if (index === i || nodeIndex > nodeCount - 1) {
        break;
      }
    }
  }
  return nodeIndex;
}});
Ext.define('GeoExt.tree.OverlayLayerContainer', {extend:GeoExt.tree.LayerContainer, alias:'plugin.gx_overlaylayercontainer', defaultText:'Overlays', init:function(target) {
  var me = this;
  var loader = me.loader;
  me.loader = Ext.applyIf(loader || {}, {filter:function(record) {
    var layer = record.getLayer();
    return layer.displayInLayerSwitcher && !layer.isBaseLayer;
  }});
  me.callParent(arguments);
}});
Ext.define('GeoExt.tree.BaseLayerContainer', {extend:GeoExt.tree.LayerContainer, alias:'plugin.gx_baselayercontainer', defaultText:'Base Layers', init:function(target) {
  var me = this, loader = me.loader;
  me.loader = Ext.applyIf(loader || {}, {baseAttrs:Ext.applyIf(loader && loader.baseAttrs || {}, {iconCls:'gx-tree-baselayer-icon', checkedGroup:'baselayer'}), filter:function(record) {
    var layer = record.getLayer();
    return layer.displayInLayerSwitcher === true && layer.isBaseLayer === true;
  }});
  me.callParent(arguments);
}});
Ext.define('GeoExt.data.LayerTreeModel', {alternateClassName:'GeoExt.data.LayerTreeRecord', extend:Ext.data.Model, alias:'model.gx_layertree', fields:[{name:'text', type:'string'}, {name:'plugins'}, {name:'layer'}, {name:'container'}, {name:'checkedGroup', type:'string'}, {name:'fixedText', type:'bool'}, {name:'component'}], proxy:{type:'memory'}, constructor:function(data, id, raw, convertedData) {
  var me = this;
  me.callParent(arguments);
  window.setTimeout(function() {
    var plugins = me.get('plugins');
    if (plugins) {
      var plugin, instance;
      for (var i = 0, ii = plugins.length; i < ii; ++i) {
        plugin = plugins[i];
        instance = Ext.PluginMgr.create(Ext.isString(plugin) ? {ptype:plugin} : plugin);
        instance.init(me);
      }
    }
  });
}, afterEdit:function(modifiedFieldNames) {
  var me = this;
  me.callParent(arguments);
  me.fireEvent('afteredit', this, modifiedFieldNames);
}});
Ext.define('GeoExt.data.LayerModel', {alternateClassName:'GeoExt.data.LayerRecord', extend:Ext.data.Model, alias:'model.gx_layer', statics:{createFromLayer:function(layer) {
  return this.proxy.reader.readRecords([layer]).records[0];
}}, fields:['id', {name:'title', type:'string', mapping:'name'}, {name:'legendURL', type:'string', mapping:'metadata.legendURL'}, {name:'hideTitle', type:'bool', mapping:'metadata.hideTitle'}, {name:'hideInLegend', type:'bool', mapping:'metadata.hideInLegend'}], proxy:{type:'memory', reader:{type:'json'}}, getLayer:function() {
  return this.raw;
}});
Ext.define('GeoExt.data.LayerStore', {extend:Ext.data.Store, model:'GeoExt.data.LayerModel', statics:{MAP_TO_STORE:1, STORE_TO_MAP:2}, map:null, constructor:function(config) {
  var me = this;
  config = Ext.apply({}, config);
  var map = GeoExt.MapPanel && config.map instanceof GeoExt.MapPanel ? config.map.map : config.map;
  delete config.map;
  if (config.layers) {
    config.data = config.layers;
  }
  delete config.layers;
  var options = {initDir:config.initDir};
  delete config.initDir;
  me.callParent([config]);
  if (map) {
    this.bind(map, options);
  }
}, bind:function(map, options) {
  var me = this;
  if (me.map) {
    return;
  }
  me.map = map;
  options = Ext.apply({}, options);
  var initDir = options.initDir;
  if (options.initDir == undefined) {
    initDir = GeoExt.data.LayerStore.MAP_TO_STORE | GeoExt.data.LayerStore.STORE_TO_MAP;
  }
  var layers = map.layers.slice(0);
  if (initDir & GeoExt.data.LayerStore.STORE_TO_MAP) {
    me.each(function(record) {
      me.map.addLayer(record.getLayer());
    }, me);
  }
  if (initDir & GeoExt.data.LayerStore.MAP_TO_STORE) {
    me.loadRawData(layers, true);
  }
  map.events.on({'changelayer':me.onChangeLayer, 'addlayer':me.onAddLayer, 'removelayer':me.onRemoveLayer, scope:me});
  me.on({'load':me.onLoad, 'clear':me.onClear, 'add':me.onAdd, 'remove':me.onRemove, 'update':me.onStoreUpdate, scope:me});
  me.data.on({'replace':me.onReplace, scope:me});
  me.fireEvent('bind', me, map);
}, unbind:function() {
  var me = this;
  if (me.map) {
    me.map.events.un({'changelayer':me.onChangeLayer, 'addlayer':me.onAddLayer, 'removelayer':me.onRemoveLayer, scope:me});
    me.un('load', me.onLoad, me);
    me.un('clear', me.onClear, me);
    me.un('add', me.onAdd, me);
    me.un('remove', me.onRemove, me);
    me.un('update', me.onStoreUpdate, me);
    me.data.un('replace', me.onReplace, me);
    me.map = null;
  }
}, onChangeLayer:function(evt) {
  var layer = evt.layer;
  var recordIndex = this.findBy(function(rec, id) {
    return rec.getLayer() === layer;
  });
  if (recordIndex > -1) {
    var record = this.getAt(recordIndex);
    if (evt.property === 'order') {
      if (!this._adding && !this._removing) {
        var layerIndex = this.map.getLayerIndex(layer);
        if (layerIndex !== recordIndex) {
          this._removing = true;
          this.remove(record);
          delete this._removing;
          this._adding = true;
          this.insert(layerIndex, [record]);
          delete this._adding;
        }
      }
    } else {
      if (evt.property === 'name') {
        record.set('title', layer.name);
      } else {
        this.fireEvent('update', this, record, Ext.data.Record.EDIT);
      }
    }
  }
}, onAddLayer:function(evt) {
  var me = this;
  if (!me._adding) {
    me._adding = true;
    var result = me.proxy.reader.read(evt.layer);
    me.add(result.records);
    delete me._adding;
  }
}, onRemoveLayer:function(evt) {
  if (this.map.unloadDestroy) {
    if (!this._removing) {
      var layer = evt.layer, rec = this.getByLayer(layer);
      if (rec) {
        this._removing = true;
        this.remove(this.getByLayer(layer));
        delete this._removing;
      }
    }
  } else {
    this.unbind();
  }
}, onLoad:function(store, records, successful) {
  if (successful) {
    if (!Ext.isArray(records)) {
      records = [records];
    }
    if (!this._addRecords) {
      this._removing = true;
      for (var i = this.map.layers.length - 1; i >= 0; i--) {
        this.map.removeLayer(this.map.layers[i]);
      }
      delete this._removing;
    }
    var len = records.length;
    if (len > 0) {
      var layers = new Array(len);
      for (var j = 0; j < len; j++) {
        layers[j] = records[j].getLayer();
      }
      this._adding = true;
      this.map.addLayers(layers);
      delete this._adding;
    }
  }
  delete this._addRecords;
}, onClear:function(store) {
  this._removing = true;
  for (var i = this.map.layers.length - 1; i >= 0; i--) {
    this.map.removeLayer(this.map.layers[i]);
  }
  delete this._removing;
}, onAdd:function(store, records, index) {
  if (!this._adding) {
    this._adding = true;
    var layer;
    for (var i = records.length - 1; i >= 0; --i) {
      layer = records[i].getLayer();
      this.map.addLayer(layer);
      if (index !== this.map.layers.length - 1) {
        this.map.setLayerIndex(layer, index);
      }
    }
    delete this._adding;
  }
}, onRemove:function(store, record, index) {
  if (!this._removing) {
    var layer = record.getLayer();
    if (this.map.getLayer(layer.id) != null) {
      this._removing = true;
      this.removeMapLayer(record);
      delete this._removing;
    }
  }
}, onStoreUpdate:function(store, record, operation) {
  if (operation === Ext.data.Record.EDIT) {
    if (record.modified && record.modified.title) {
      var layer = record.getLayer();
      var title = record.get('title');
      if (title !== layer.name) {
        layer.setName(title);
      }
    }
  }
}, removeMapLayer:function(record) {
  this.map.removeLayer(record.getLayer());
}, onReplace:function(key, oldRecord, newRecord) {
  this.removeMapLayer(oldRecord);
}, getByLayer:function(layer) {
  var index = this.findBy(function(r) {
    return r.getLayer() === layer;
  });
  if (index > -1) {
    return this.getAt(index);
  }
}, destroy:function() {
  this.unbind();
  this.callParent();
}, loadRecords:function(records, options) {
  if (options && options.addRecords) {
    this._addRecords = true;
  }
  this.callParent(arguments);
}, loadRawData:function(data, append) {
  var me = this, result = me.proxy.reader.read(data), records = result.records;
  if (result.success) {
    me.totalCount = result.total;
    me.loadRecords(records, append ? me.addRecordsOptions : undefined);
    me.fireEvent('load', me, records, true);
  }
}});
Ext.define('GeoExt.panel.Map', {extend:Ext.panel.Panel, alias:'widget.gx_mappanel', alternateClassName:'GeoExt.MapPanel', statics:{guess:function() {
  var candidates = Ext.ComponentQuery.query('gx_mappanel');
  return candidates && candidates.length > 0 ? candidates[0] : null;
}}, center:null, zoom:null, extent:null, prettyStateKeys:false, map:null, layout:'fit', layers:null, stateEvents:['aftermapmove', 'afterlayervisibilitychange', 'afterlayeropacitychange', 'afterlayerorderchange', 'afterlayernamechange', 'afterlayeradd', 'afterlayerremove'], initComponent:function() {
  if (!(this.map instanceof OpenLayers.Map)) {
    this.map = new OpenLayers.Map(Ext.applyIf(this.map || {}, {allOverlays:true}));
  }
  var layers = this.layers;
  if (!layers || layers instanceof Array) {
    this.layers = Ext.create('GeoExt.data.LayerStore', {layers:layers, map:this.map.layers.length > 0 ? this.map : null});
  }
  if (Ext.isString(this.center)) {
    this.center = OpenLayers.LonLat.fromString(this.center);
  } else {
    if (Ext.isArray(this.center)) {
      this.center = new OpenLayers.LonLat(this.center[0], this.center[1]);
    }
  }
  if (Ext.isString(this.extent)) {
    this.extent = OpenLayers.Bounds.fromString(this.extent);
  } else {
    if (Ext.isArray(this.extent)) {
      this.extent = OpenLayers.Bounds.fromArray(this.extent);
    }
  }
  this.callParent(arguments);
  this.on('resize', this.onResize, this);
  this.on('afterlayout', function() {
    if (typeof this.map.getViewport === 'function') {
      this.items.each(function(cmp) {
        if (typeof cmp.addToMapPanel === 'function') {
          cmp.getEl().appendTo(this.body);
        }
      }, this);
    }
  }, this);
  this.map.events.on({'moveend':this.onMoveend, 'changelayer':this.onChangelayer, 'addlayer':this.onAddlayer, 'removelayer':this.onRemovelayer, scope:this});
}, onMoveend:function(e) {
  this.fireEvent('aftermapmove', this, this.map, e);
}, onChangelayer:function(e) {
  var map = this.map;
  if (e.property) {
    if (e.property === 'visibility') {
      this.fireEvent('afterlayervisibilitychange', this, map, e);
    } else {
      if (e.property === 'order') {
        this.fireEvent('afterlayerorderchange', this, map, e);
      } else {
        if (e.property === 'nathis') {
          this.fireEvent('afterlayernathischange', this, map, e);
        } else {
          if (e.property === 'opacity') {
            this.fireEvent('afterlayeropacitychange', this, map, e);
          }
        }
      }
    }
  }
}, onAddlayer:function() {
  this.fireEvent('afterlayeradd');
}, onRemovelayer:function() {
  this.fireEvent('afterlayerremove');
}, onResize:function() {
  var map = this.map;
  if (this.body.dom !== map.div) {
    map.render(this.body.dom);
    this.layers.bind(map);
    if (map.layers.length > 0) {
      this.setInitialExtent();
    } else {
      this.layers.on('add', this.setInitialExtent, this, {single:true});
    }
  } else {
    map.updateSize();
  }
}, setInitialExtent:function() {
  var map = this.map;
  if (!map.getCenter()) {
    if (this.center || this.zoom) {
      map.setCenter(this.center, this.zoom);
    } else {
      if (this.extent instanceof OpenLayers.Bounds) {
        map.zoomToExtent(this.extent, true);
      } else {
        map.zoomToMaxExtent();
      }
    }
  }
}, getState:function() {
  var me = this, map = me.map, state = me.callParent(arguments) || {}, layer;
  if (!map) {
    return;
  }
  var center = map.getCenter();
  center && Ext.applyIf(state, {'x':center.lon, 'y':center.lat, 'zoom':map.getZoom()});
  me.layers.each(function(modelInstance) {
    layer = modelInstance.getLayer();
    layerId = this.prettyStateKeys ? modelInstance.get('title') : modelInstance.get('id');
    state = me.addPropertyToState(state, 'visibility_' + layerId, layer.getVisibility());
    state = me.addPropertyToState(state, 'opacity_' + layerId, layer.opacity === null ? 1 : layer.opacity);
  }, me);
  return state;
}, applyState:function(state) {
  var me = this;
  map = me.map;
  me.center = new OpenLayers.LonLat(state.x, state.y);
  me.zoom = state.zoom;
  var i, l, layer, layerId, visibility, opacity;
  var layers = map.layers;
  for (i = 0, l = layers.length; i < l; i++) {
    layer = layers[i];
    layerId = me.prettyStateKeys ? layer.name : layer.id;
    visibility = state['visibility_' + layerId];
    if (visibility !== undefined) {
      visibility = /^true$/i.test(visibility);
      if (layer.isBaseLayer) {
        if (visibility) {
          map.setBaseLayer(layer);
        }
      } else {
        layer.setVisibility(visibility);
      }
    }
    opacity = state['opacity_' + layerId];
    if (opacity !== undefined) {
      layer.setOpacity(opacity);
    }
  }
}, onBeforeAdd:function(item) {
  if (Ext.isFunction(item.addToMapPanel)) {
    item.addToMapPanel(this);
  }
  this.callParent(arguments);
}, beforeDestroy:function() {
  if (this.map && this.map.events) {
    this.map.events.un({'moveend':this.onMoveend, 'changelayer':this.onChangelayer, scope:this});
  }
  if (!this.initialConfig.map || !(this.initialConfig.map instanceof OpenLayers.Map)) {
    if (this.map && this.map.destroy) {
      this.map.destroy();
    }
  }
  delete this.map;
  this.callParent(arguments);
}});
Ext.define('GeoExt.Action', {extend:Ext.Action, alias:'widget.gx_action', control:null, activateOnEnable:false, deactivateOnDisable:false, map:null, uScope:null, uHandler:null, uToggleHandler:null, uCheckHandler:null, constructor:function(config) {
  this.uScope = config.scope;
  this.uHandler = config.handler;
  this.uToggleHandler = config.toggleHandler;
  this.uCheckHandler = config.checkHandler;
  config.scope = this;
  config.handler = this.pHandler;
  config.toggleHandler = this.pToggleHandler;
  config.checkHandler = this.pCheckHandler;
  this.control = config.control;
  var ctrl = this.control;
  delete config.control;
  this.activateOnEnable = !!config.activateOnEnable;
  delete config.activateOnEnable;
  this.deactivateOnDisable = !!config.deactivateOnDisable;
  delete config.deactivateOnDisable;
  if (ctrl) {
    if (config.map) {
      config.map.addControl(ctrl);
      delete config.map;
    }
    if ((config.pressed || config.checked) && ctrl.map) {
      ctrl.activate();
    }
    if (ctrl.active) {
      config.pressed = true;
      config.checked = true;
    }
    ctrl.events.on({activate:this.onCtrlActivate, deactivate:this.onCtrlDeactivate, scope:this});
  }
  this.callParent(arguments);
}, pHandler:function(cmp) {
  var ctrl = this.control;
  if (ctrl && ctrl.type == OpenLayers.Control.TYPE_BUTTON) {
    ctrl.trigger();
  }
  if (this.uHandler) {
    this.uHandler.apply(this.uScope, arguments);
  }
}, pToggleHandler:function(cmp, state) {
  this.changeControlState(state);
  if (this.uToggleHandler) {
    this.uToggleHandler.apply(this.uScope, arguments);
  }
}, pCheckHandler:function(cmp, state) {
  this.changeControlState(state);
  if (this.uCheckHandler) {
    this.uCheckHandler.apply(this.uScope, arguments);
  }
}, changeControlState:function(state) {
  if (state) {
    if (!this._activating) {
      this._activating = true;
      this.control.activate();
      this.initialConfig.pressed = true;
      this.initialConfig.checked = true;
      this._activating = false;
    }
  } else {
    if (!this._deactivating) {
      this._deactivating = true;
      this.control.deactivate();
      this.initialConfig.pressed = false;
      this.initialConfig.checked = false;
      this._deactivating = false;
    }
  }
}, onCtrlActivate:function() {
  var ctrl = this.control;
  if (ctrl.type == OpenLayers.Control.TYPE_BUTTON) {
    this.enable();
  } else {
    this.safeCallEach('toggle', [true]);
    this.safeCallEach('setChecked', [true]);
  }
}, onCtrlDeactivate:function() {
  var ctrl = this.control;
  if (ctrl.type == OpenLayers.Control.TYPE_BUTTON) {
    this.disable();
  } else {
    this.safeCallEach('toggle', [false]);
    this.safeCallEach('setChecked', [false]);
  }
}, safeCallEach:function(fnName, args) {
  var cs = this.items;
  for (var i = 0, len = cs.length; i < len; i++) {
    if (cs[i][fnName]) {
      cs[i].rendered ? cs[i][fnName].apply(cs[i], args) : cs[i].on({'render':Ext.Function.bind(cs[i][fnName], cs[i], args), single:true});
    }
  }
}, setDisabled:function(v) {
  if (!v && this.activateOnEnable && this.control && !this.control.active) {
    this.control.activate();
  }
  if (v && this.deactivateOnDisable && this.control && this.control.active) {
    this.control.deactivate();
  }
  return GeoExt.Action.superclass.setDisabled.apply(this, arguments);
}});
Ext.define('GeoExt.tree.Column', {extend:Ext.tree.Column, alias:'widget.gx_treecolumn', initComponent:function() {
  var me = this;
  me.callParent();
  var parentRenderer = me.renderer;
  this.renderer = function(value, metaData, record, rowIdx, colIdx, store, view) {
    var buf = [parentRenderer.call(this, value, metaData, record, rowIdx, colIdx, store, view)];
    if (record.get('checkedGroup')) {
      buf[0] = buf[0].replace(/class="([^-]+)-tree-checkbox([^"]+)?"/, 'class\x3d"$1-tree-checkbox$2 gx-tree-radio"');
    }
    buf.push('\x3cdiv class\x3d"gx-tree-component gx-tree-component-off" id\x3d"tree-record-' + record.id + '"\x3e\x3c/div\x3e');
    return buf.join('');
  };
}, defaultRenderer:function(value) {
  return value;
}});
Ext.define('GeoExt.tree.View', {extend:Ext.tree.View, alias:'widget.gx_treeview', initComponent:function() {
  var me = this;
  me.on('itemupdate', this.onItem, this);
  me.on('itemadd', this.onItem, this);
  me.on('createchild', this.createChild, this);
  return me.callParent(arguments);
}, onItem:function(records, index, node, options) {
  var me = this;
  if (!(records instanceof Array)) {
    records = [records];
  }
  for (var i = 0; i < records.length; i++) {
    this.onNodeRendered(records[i]);
  }
}, onNodeRendered:function(node) {
  var me = this;
  var el = Ext.get('tree-record-' + node.id);
  if (!el) {
    return;
  }
  if (node.get('layer')) {
    me.fireEvent('createchild', el, node);
  }
  if (node.hasChildNodes()) {
    node.eachChild(function(node) {
      me.onNodeRendered(node);
    }, me);
  }
}, createChild:function(el, node) {
  var component = node.get('component'), cmpObj;
  if (component) {
    cmpObj = Ext.ComponentManager.create(component);
    if (cmpObj.xtype && node.gx_treecomponents && node.gx_treecomponents[cmpObj.xtype]) {
      node.gx_treecomponents[cmpObj.xtype].destroy();
      delete node.gx_treecomponents[cmpObj.xtype];
    }
    if (!node.gx_treecomponents) {
      node.gx_treecomponents = {};
    }
    node.gx_treecomponents[cmpObj.xtype] = cmpObj;
    cmpObj.render(el);
    el.removeCls('gx-tree-component-off');
  }
}});
Ext.define('GeoExt.tree.Panel', {extend:Ext.tree.Panel, alias:'widget.gx_treepanel', viewType:'gx_treeview', initComponent:function() {
  var me = this;
  if (!me.columns) {
    if (me.initialConfig.hideHeaders === undefined) {
      me.hideHeaders = true;
    }
    me.addCls(Ext.baseCSSPrefix + 'autowidth-table');
    me.columns = [{xtype:'gx_treecolumn', text:'Name', width:Ext.isIE6 ? null : 10000, dataIndex:me.displayField}];
  }
  me.callParent();
}});
var arcticWms = OPS.Global.baseUrl.concat('/geoserver/arctic/wms');
var arcticMapPanel = Ext.create('GeoExt.panel.Map', {region:'center', itemId:'arcticMap', map:{allOverlays:false, projection:'EPSG:3413', displayProjection:new OpenLayers.Projection('EPSG:4326'), units:'dd', maxExtent:new OpenLayers.Bounds(-8125549, -6101879, 8186727, 3197247), controls:[new OpenLayers.Control.Navigation({dragPanOptions:{enableKinetic:true}}), new OpenLayers.Control.Zoom, new OpenLayers.Control.MousePosition({prefix:'\x3ca target\x3d"_blank" href\x3d"http://spatialreference.org/ref/epsg/wgs-84/"\x3eWGS:84\x3c/a\x3e: ', 
separator:' E; ', suffix:' N'}), new OpenLayers.Control.ScaleLine]}, center:[110200, -1900000], zoom:4, layers:[new OpenLayers.Layer.WMS('Natural Earth I', arcticWms, {layers:'arctic:arctic_naturalearth'}, {isBaseLayer:true}), new OpenLayers.Layer.WMS('Landsat7 Natual 90m', arcticWms, {layers:'arctic:arctic_natural_90m'}, {isBaseLayer:true}), new OpenLayers.Layer.WMS('Landsat7 BW 45m', arcticWms, {layers:'arctic:greenland_bw_45m'}, {isBaseLayer:true}), new OpenLayers.Layer.WMS('Bamber V3 Bed', arcticWms, 
{layers:'arctic:greenland_bamberV3_bed'}, {isBaseLayer:true}), new OpenLayers.Layer.WMS('2011 Joughin Velocity', arcticWms, {layers:'arctic:greenland_joughin2011_velocity_log_magnitude'}, {isBaseLayer:true}), new OpenLayers.Layer.WMS('Greenland Coastline', arcticWms, {layers:'arctic:greenland_coastline', transparent:true}, {isBaseLayer:true, visibility:false}), new OpenLayers.Layer.WMS('Radar Depth Sounder', arcticWms, {layers:'arctic:arctic_rds_line_paths', transparent:true}, {isBaseLayer:false, 
visibility:true}), new OpenLayers.Layer.WMS('Accumulation Radar', arcticWms, {layers:'arctic:arctic_accum_line_paths', transparent:true}, {isBaseLayer:false, visibility:false}), new OpenLayers.Layer.WMS('Snow Radar', arcticWms, {layers:'arctic:arctic_snow_line_paths', transparent:true}, {isBaseLayer:false, visibility:false}), new OpenLayers.Layer.WMS('KuBand Radar', arcticWms, {layers:'arctic:arctic_kuband_line_paths', transparent:true}, {isBaseLayer:false, visibility:false}), arcticSelectedLine = 
new OpenLayers.Layer.Vector('', {displayInLayerSwitcher:false})]});
var toolbarItems = [];
mapHelp = Ext.create('Ext.button.Button', {text:'map help', handler:function() {
  Ext.Ajax.request({url:'/resources/maphelp.html', success:function(response) {
    Ext.create('Ext.window.Window', {title:'Map Help Documentation', height:600, width:600, layout:'fit', autoScroll:true, closable:true, padding:'10 10 10 10', items:[{xtype:'label', html:response.responseText}]}).show();
  }});
}});
toolbarItems.push(mapHelp);
toolbarItems.push('-');
action = Ext.create('GeoExt.Action', {control:new OpenLayers.Control.ZoomToMaxExtent, map:arcticMapPanel.map, text:'max extent', tooltip:'zoom to the maps max extent'});
toolbarItems.push(Ext.create('Ext.button.Button', action));
toolbarItems.push('-');
var lineMeasure = new OpenLayers.Control.DynamicMeasure(OpenLayers.Handler.Path, {maxSegments:10, immediate:true});
var areaMeasure = new OpenLayers.Control.DynamicMeasure(OpenLayers.Handler.Polygon, {maxSegments:10, immediate:true});
action = Ext.create('GeoExt.Action', {itemId:'lineMeasure', control:lineMeasure, map:arcticMapPanel.map, text:'measure distance', tooltip:'draw a line to measure a distance, click the button again to clear the drawing.', enableToggle:true, toggleGroup:'measureTools'});
toolbarItems.push(Ext.create('Ext.button.Button', action));
action = Ext.create('GeoExt.Action', {itemId:'areaMeasure', control:areaMeasure, map:arcticMapPanel.map, text:'measure area', tooltip:'draw a polygon to measure an area, click the button again to clear the drawing.', enableToggle:true, toggleGroup:'measureTools'});
toolbarItems.push(Ext.create('Ext.button.Button', action));
toolbarItems.push('-');
arcticMapPanel.map.events.register('click', arcticMapPanel.map, function(clickPt) {
  var clickCoords = arcticMapPanel.map.getLonLatFromPixel(clickPt.xy);
  var selectedSystem = Ext.ComponentQuery.query('#selectedSystem')[0].value;
  var selectedSeasons = Ext.ComponentQuery.query('#selectedSeasons')[0].value;
  var startDate = Ext.ComponentQuery.query('#startDate')[0].getRawValue();
  var stopDate = Ext.ComponentQuery.query('#stopDate')[0].getRawValue();
  if (!selectedSystem) {
    alert('ERROR: SELECT SYSTEM IN THE MENU BEFORE CLICKING ON THE MAP.');
    return;
  }
  if (!selectedSeasons || selectedSeasons.length == 0) {
    useSeasons = false;
  } else {
    useSeasons = true;
  }
  if (!startDate) {
    startDateSeg = '00000000_00';
  } else {
    startDateSeg = startDate.concat('_00');
  }
  if (!stopDate) {
    stopDateSeg = '99999999_99';
  } else {
    stopDateSeg = stopDate.concat('_99');
  }
  if (useSeasons) {
    inputJSON = JSON.stringify({'properties':{'location':'arctic', 'x':clickCoords.lon, 'y':clickCoords.lat, 'season':selectedSeasons, 'startseg':startDateSeg, 'stopseg':stopDateSeg}});
  } else {
    inputJSON = JSON.stringify({'properties':{'location':'arctic', 'x':clickCoords.lon, 'y':clickCoords.lat, 'startseg':startDateSeg, 'stopseg':stopDateSeg}});
  }
  Ext.getBody().mask('Loading Echogram Browser');
  Ext.Ajax.request({type:'POST', url:'/ops/get/frame/closest', params:{app:selectedSystem, data:inputJSON}, success:function(response) {
    arcticRenderClosestFrame(response.responseText);
  }, error:function() {
    alert('ERROR FINDING CLOSEST FRAME ON CLICK EVENT.');
  }});
});
function arcticRenderClosestFrame(response) {
  responseData = JSON.parse(response);
  if (responseData.status == 0) {
    alert(responseData.data);
    return;
  }
  var outEchogramUrls = [];
  var outEchogramNames = ['Echogram', 'Echogram + Layers'];
  for (var i = 0; i < responseData.data.echograms.length; i++) {
    outEchogramUrls.push([responseData.data.echograms[i], outEchogramNames[i]]);
  }
  var echogramCombo = Ext.ComponentQuery.query('#arcticEchogramSelector')[0];
  echogramCombo.setValue('');
  echogramStore = new Ext.data.ArrayStore({fields:['echogram_url', 'echogram_name'], data:outEchogramUrls});
  echogramCombo.bindStore(echogramStore);
  function collapseTree() {
    var treePanel = Ext.ComponentQuery.query('#arcticTree')[0];
    treePanel.collapse();
  }
  function collapseMenu() {
    var menusPanel = Ext.ComponentQuery.query('menus')[0];
    menusPanel.collapse();
  }
  function renderLine() {
    arcticSelectedLine.removeAllFeatures();
    var points = new Array;
    var startX = responseData.data.X[0];
    var startY = responseData.data.Y[0];
    minGps = responseData.data.gps_time[0];
    for (idx = 0; idx <= responseData.data.X.length; idx++) {
      if (!isNaN(responseData.data.X[idx])) {
        if (responseData.data.gps_time[idx] < minGps) {
          minGps = responseData.data.gps_time[idx];
          startX = responseData.data.X[idx];
          startY = responseData.data.Y[idx];
        }
        points.push(new OpenLayers.Geometry.Point(responseData.data.X[idx], responseData.data.Y[idx]));
      }
    }
    var startPoint = new OpenLayers.Geometry.Point(startX, startY);
    var startPointStyle = {fillColor:'#FF0000', pointRadius:10, strokeColor:'#FF0000'};
    var line = new OpenLayers.Geometry.LineString(points);
    var style = {strokeColor:'#FF0000', strokeWidth:5};
    var lineFeature = new OpenLayers.Feature.Vector(line, null, style);
    var pointFeature = new OpenLayers.Feature.Vector(startPoint, null, startPointStyle);
    arcticSelectedLine.addFeatures([lineFeature, pointFeature]);
    arcticSelectedLine.redraw(true);
  }
  function renderImage() {
    var cArcticImageBrowserPanel = Ext.ComponentQuery.query('#arcticImageBrowserPanel')[0];
    cArcticImageBrowserPanel.removeAll();
    cArcticImageBrowserPanel.expand();
    var arcticEchogramImage = Ext.create('Ext.Img', {id:'arcticEchogramImage', src:responseData.data.echograms[0]});
    cArcticImageBrowserPanel.add(arcticEchogramImage);
  }
  setTimeout(collapseTree, 0);
  setTimeout(collapseMenu, 100);
  setTimeout(renderLine, 500);
  setTimeout(renderImage, 900);
  setTimeout(Ext.getBody().unmask(), 1000);
}
arcticMapPanel.addDocked([{xtype:'toolbar', dock:'top', items:toolbarItems}]);
var arcticStore = Ext.create('Ext.data.TreeStore', {model:'GeoExt.data.LayerTreeModel', root:{expanded:true, children:[{plugins:[{ptype:'gx_overlaylayercontainer', loader:{store:arcticMapPanel.layers}}], expanded:false, text:'Data Layers'}, {plugins:[{ptype:'gx_baselayercontainer', loader:{store:arcticMapPanel.layers, createNode:function(attr) {
  attr.component = {xtype:'gx_wmslegend', layerRecord:arcticMapPanel.layers.getByLayer(attr.layer), showTitle:false, cls:'legend'};
  return GeoExt.tree.LayerLoader.prototype.createNode.call(this, attr);
}}}], expanded:false, text:'Reference Layers'}]}});
var arcticTree = Ext.create('GeoExt.tree.Panel', {itemId:'arcticTree', region:'east', title:'Map Layer Selection', width:250, collapsible:true, autoScroll:true, store:arcticStore, rootVisible:false, lines:true});
var arcticEchogramPanel = Ext.create('Ext.Panel', {layout:'border', itemId:'arcticImageBrowserPanel', defaults:{collapsible:true, bodyStyle:'padding:0px'}, dockedItems:[{xtype:'toolbar', dock:'top', items:[{xtype:'button', itemId:'echogramNotice', text:'Echogram Information', scale:'small', width:150, handler:function() {
  Ext.Msg.alert('NOTICE', 'Echogram images are static previews and may not represent the most recent data. They should be used for reference only.');
}}, {xtype:'combo', fieldLabel:'Echogram Image', itemId:'arcticEchogramSelector', queryMode:'local', displayField:'echogram_name', valueField:'echogram_url', width:300}, {xtype:'button', itemId:'arcticLoadEchogramImage', text:'Draw Echogram', scale:'small', width:150, handler:function() {
  var cArcticImageBrowserPanel = Ext.ComponentQuery.query('#arcticImageBrowserPanel')[0];
  cArcticImageBrowserPanel.removeAll();
  cArcticImageBrowserPanel.expand();
  var arcticEchogramImage = Ext.create('Ext.Img', {id:'arcticEchogramImage', src:Ext.ComponentQuery.query('#arcticEchogramSelector')[0].value});
  cArcticImageBrowserPanel.add(arcticEchogramImage);
}}, {xtype:'button', itemId:'arcticCloseEchogramBrowser', text:'Close Echogram Browser', scale:'small', width:150, handler:function() {
  Ext.getBody().mask('Closing Echogram Browser');
  arcticSelectedLine.removeAllFeatures();
  function expandTree() {
    var treePanel = Ext.ComponentQuery.query('#arcticTree')[0];
    treePanel.expand();
  }
  function expandMenu() {
    var menusPanel = Ext.ComponentQuery.query('menus')[0];
    menusPanel.expand();
  }
  function collapseEchogram() {
    var cArcticImageBrowserPanel = Ext.ComponentQuery.query('#arcticImageBrowserPanel')[0];
    cArcticImageBrowserPanel.collapse();
  }
  setTimeout(collapseEchogram, 0);
  setTimeout(expandTree, 100);
  setTimeout(expandMenu, 500);
  setTimeout(Ext.getBody().unmask(), 900);
}}]}], region:'west', title:'Echogram Image Browser', collapsible:true, collapsed:true, autoScroll:true, resizable:true, width:800});
Ext.define('OPS.view.MapTabs.ArcticTab.ArcticTab', {extend:Ext.Panel, layout:'border', defaults:{collapsible:false, bodyStyle:'padding:0px'}, alias:'widget.arctictab', title:'Arctic', items:[arcticEchogramPanel, arcticMapPanel, arcticTree]});
var antarcticWms = OPS.Global.baseUrl.concat('/geoserver/antarctic/wms');
var antarcticMapPanel = Ext.create('GeoExt.panel.Map', {region:'center', itemId:'antarcticMap', map:{allOverlays:false, projection:'EPSG:3031', displayProjection:new OpenLayers.Projection('EPSG:4326'), units:'dd', maxExtent:new OpenLayers.Bounds(-8221026, -4585257, 8091116, 4715069), controls:[new OpenLayers.Control.Navigation({dragPanOptions:{enableKinetic:true}}), new OpenLayers.Control.Zoom, new OpenLayers.Control.MousePosition({prefix:'\x3ca target\x3d"_blank" href\x3d"http://spatialreference.org/ref/epsg/wgs-84/"\x3eWGS:84\x3c/a\x3e: ', 
separator:' E; ', suffix:' N'}), new OpenLayers.Control.ScaleLine]}, center:[397009, 0], zoom:3, layers:[new OpenLayers.Layer.WMS('Natural Earth I', antarcticWms, {layers:'antarctic:antarctic_naturalearth'}, {isBaseLayer:true}), new OpenLayers.Layer.WMS('Lansat7 (LIMA) 240m', antarcticWms, {layers:'antarctic:antarctica_lima_240m'}, {isBaseLayer:true}), new OpenLayers.Layer.WMS('Bedmap2 Bed', antarcticWms, {layers:'antarctic:antarctica_bedmap2_bed'}, {isBaseLayer:true}), new OpenLayers.Layer.WMS('Measures Velocity', 
antarcticWms, {layers:'antarctic:antarctica_measures_velocity_log_magnitude'}, {isBaseLayer:true}), new OpenLayers.Layer.WMS('Antarctica Coastline', antarcticWms, {layers:'antarctic:antarctica_coastline', transparent:true}, {isBaseLayer:true, visibility:false}), new OpenLayers.Layer.WMS('Radar Depth Sounder', antarcticWms, {layers:'antarctic:antarctic_rds_line_paths', transparent:true}, {isBaseLayer:false, visibility:true}), new OpenLayers.Layer.WMS('Accumulation Radar', antarcticWms, {layers:'antarctic:antarctic_accum_line_paths', 
transparent:true}, {isBaseLayer:false, visibility:false}), new OpenLayers.Layer.WMS('Snow Radar', antarcticWms, {layers:'antarctic:antarctic_snow_line_paths', transparent:true}, {isBaseLayer:false, visibility:false}), new OpenLayers.Layer.WMS('KuBand Radar', antarcticWms, {layers:'antarctic:antarctic_kuband_line_paths', transparent:true}, {isBaseLayer:false, visibility:false}), antarcticSelectedLine = new OpenLayers.Layer.Vector('', {displayInLayerSwitcher:false})]});
var toolbarItems = [];
mapHelp = Ext.create('Ext.button.Button', {text:'map help', handler:function() {
  Ext.Ajax.request({url:'/resources/maphelp.html', success:function(response) {
    Ext.create('Ext.window.Window', {title:'Map Help Documentation', height:600, width:600, layout:'fit', autoScroll:true, closable:true, padding:'10 10 10 10', items:[{xtype:'label', html:response.responseText}]}).show();
  }});
}});
toolbarItems.push(mapHelp);
toolbarItems.push('-');
action = Ext.create('GeoExt.Action', {control:new OpenLayers.Control.ZoomToMaxExtent, map:antarcticMapPanel.map, text:'max extent', tooltip:'zoom to the maps max extent'});
toolbarItems.push(Ext.create('Ext.button.Button', action));
toolbarItems.push('-');
var lineMeasure = new OpenLayers.Control.DynamicMeasure(OpenLayers.Handler.Path, {maxSegments:10, immediate:true});
var areaMeasure = new OpenLayers.Control.DynamicMeasure(OpenLayers.Handler.Polygon, {maxSegments:10, immediate:true});
action = Ext.create('GeoExt.Action', {itemId:'lineMeasure', control:lineMeasure, map:antarcticMapPanel.map, text:'measure distance', tooltip:'draw a line to measure a distance, click the button again to clear the drawing.', enableToggle:true, toggleGroup:'measureTools'});
toolbarItems.push(Ext.create('Ext.button.Button', action));
action = Ext.create('GeoExt.Action', {itemId:'areaMeasure', control:areaMeasure, map:antarcticMapPanel.map, text:'measure area', tooltip:'draw a polygon to measure an area, click the button again to clear the drawing.', enableToggle:true, toggleGroup:'measureTools'});
toolbarItems.push(Ext.create('Ext.button.Button', action));
toolbarItems.push('-');
antarcticMapPanel.map.events.register('click', antarcticMapPanel.map, function(clickPt) {
  var clickCoords = antarcticMapPanel.map.getLonLatFromPixel(clickPt.xy);
  var selectedSystem = Ext.ComponentQuery.query('#selectedSystem')[0].value;
  var selectedSeasons = Ext.ComponentQuery.query('#selectedSeasons')[0].value;
  var startDate = Ext.ComponentQuery.query('#startDate')[0].getRawValue();
  var stopDate = Ext.ComponentQuery.query('#stopDate')[0].getRawValue();
  if (!selectedSystem) {
    alert('ERROR: SELECT SYSTEM IN THE MENU BEFORE CLICKING ON THE MAP.');
    return;
  }
  if (!selectedSeasons || selectedSeasons.length == 0) {
    useSeasons = false;
  } else {
    useSeasons = true;
  }
  if (!startDate) {
    startDateSeg = '00000000_00';
  } else {
    startDateSeg = startDate.concat('_00');
  }
  if (!stopDate) {
    stopDateSeg = '99999999_99';
  } else {
    stopDateSeg = stopDate.concat('_99');
  }
  if (useSeasons) {
    inputJSON = JSON.stringify({'properties':{'location':'antarctic', 'x':clickCoords.lon, 'y':clickCoords.lat, 'season':selectedSeasons, 'startseg':startDateSeg, 'stopseg':stopDateSeg}});
  } else {
    inputJSON = JSON.stringify({'properties':{'location':'antarctic', 'x':clickCoords.lon, 'y':clickCoords.lat, 'startseg':startDateSeg, 'stopseg':stopDateSeg}});
  }
  Ext.getBody().mask('Loading Echogram Browser');
  Ext.Ajax.request({type:'POST', url:'/ops/get/frame/closest', params:{app:selectedSystem, data:inputJSON}, success:function(response) {
    antarcticRenderClosestFrame(response.responseText);
  }, error:function() {
    alert('ERROR FINDING CLOSEST FRAME ON CLICK EVENT.');
  }});
});
function antarcticRenderClosestFrame(response) {
  responseData = JSON.parse(response);
  if (responseData.status == 0) {
    alert(responseData.data);
    return;
  }
  var outEchogramUrls = [];
  var outEchogramNames = ['Echogram', 'Echogram + Layers'];
  for (var i = 0; i < responseData.data.echograms.length; i++) {
    outEchogramUrls.push([responseData.data.echograms[i], outEchogramNames[i]]);
  }
  var echogramCombo = Ext.ComponentQuery.query('#antarcticEchogramSelector')[0];
  echogramCombo.setValue('');
  echogramStore = new Ext.data.ArrayStore({fields:['echogram_url', 'echogram_name'], data:outEchogramUrls});
  echogramCombo.bindStore(echogramStore);
  function collapseTree() {
    var treePanel = Ext.ComponentQuery.query('#antarcticTree')[0];
    treePanel.collapse();
  }
  function collapseMenu() {
    var menusPanel = Ext.ComponentQuery.query('menus')[0];
    menusPanel.collapse();
  }
  function renderLine() {
    antarcticSelectedLine.removeAllFeatures();
    var points = new Array;
    var startX = responseData.data.X[0];
    var startY = responseData.data.Y[0];
    minGps = responseData.data.gps_time[0];
    for (idx = 0; idx <= responseData.data.X.length; idx++) {
      if (!isNaN(responseData.data.X[idx])) {
        if (responseData.data.gps_time[idx] < minGps) {
          minGps = responseData.data.gps_time[idx];
          startX = responseData.data.X[idx];
          startY = responseData.data.Y[idx];
        }
        points.push(new OpenLayers.Geometry.Point(responseData.data.X[idx], responseData.data.Y[idx]));
      }
    }
    var startPoint = new OpenLayers.Geometry.Point(startX, startY);
    var startPointStyle = {fillColor:'#FF0000', pointRadius:10, strokeColor:'#FF0000'};
    var line = new OpenLayers.Geometry.LineString(points);
    var style = {strokeColor:'#FF0000', strokeWidth:5};
    var lineFeature = new OpenLayers.Feature.Vector(line, null, style);
    var pointFeature = new OpenLayers.Feature.Vector(startPoint, null, startPointStyle);
    antarcticSelectedLine.addFeatures([lineFeature, pointFeature]);
    antarcticSelectedLine.redraw(true);
  }
  function renderImage() {
    var cAntarcticImageBrowserPanel = Ext.ComponentQuery.query('#antarcticImageBrowserPanel')[0];
    cAntarcticImageBrowserPanel.removeAll();
    cAntarcticImageBrowserPanel.expand();
    var antarcticEchogramImage = Ext.create('Ext.Img', {id:'antarcticEchogramImage', src:responseData.data.echograms[0]});
    cAntarcticImageBrowserPanel.add(antarcticEchogramImage);
  }
  setTimeout(collapseTree, 0);
  setTimeout(collapseMenu, 100);
  setTimeout(renderLine, 500);
  setTimeout(renderImage, 900);
  setTimeout(Ext.getBody().unmask(), 1000);
}
antarcticMapPanel.addDocked([{xtype:'toolbar', dock:'top', items:toolbarItems}]);
var antarcticStore = Ext.create('Ext.data.TreeStore', {model:'GeoExt.data.LayerTreeModel', root:{expanded:true, children:[{plugins:[{ptype:'gx_overlaylayercontainer', loader:{store:antarcticMapPanel.layers}}], expanded:false, text:'Data Layers'}, {plugins:[{ptype:'gx_baselayercontainer', loader:{store:antarcticMapPanel.layers, createNode:function(attr) {
  attr.component = {xtype:'gx_wmslegend', layerRecord:antarcticMapPanel.layers.getByLayer(attr.layer), showTitle:false, cls:'legend'};
  return GeoExt.tree.LayerLoader.prototype.createNode.call(this, attr);
}}}], expanded:false, text:'Reference Layers'}]}});
var antarcticTree = Ext.create('GeoExt.tree.Panel', {itemId:'antarcticTree', region:'east', title:'Map Layer Selection', width:250, collapsible:true, autoScroll:true, store:antarcticStore, rootVisible:false, lines:true});
var antarcticEchogramPanel = Ext.create('Ext.Panel', {layout:'border', itemId:'antarcticImageBrowserPanel', defaults:{collapsible:true, bodyStyle:'padding:0px'}, dockedItems:[{xtype:'toolbar', dock:'top', items:[{xtype:'button', itemId:'echogramNotice', text:'Echogram Information', scale:'small', width:150, handler:function() {
  Ext.Msg.alert('NOTICE', 'Echogram images are static previews and may not represent the most recent data. They should be used for reference only.');
}}, {xtype:'combo', fieldLabel:'Echogram Image', itemId:'antarcticEchogramSelector', queryMode:'local', displayField:'echogram_name', valueField:'echogram_url', width:300}, {xtype:'button', itemId:'antarcticLoadEchogramImage', text:'Draw Echogram', scale:'small', width:150, handler:function() {
  var cAntarcticImageBrowserPanel = Ext.ComponentQuery.query('#antarcticImageBrowserPanel')[0];
  cAntarcticImageBrowserPanel.removeAll();
  cAntarcticImageBrowserPanel.expand();
  var antarcticEchogramImage = Ext.create('Ext.Img', {id:'antarcticEchogramImage', src:Ext.ComponentQuery.query('#antarcticEchogramSelector')[0].value});
  cAntarcticImageBrowserPanel.add(antarcticEchogramImage);
}}, {xtype:'button', itemId:'antarcticCloseEchogramBrowser', text:'Close Echogram Browser', scale:'small', width:150, handler:function() {
  Ext.getBody().mask('Closing Echogram Browser');
  antarcticSelectedLine.removeAllFeatures();
  function expandTree() {
    var treePanel = Ext.ComponentQuery.query('#antarcticTree')[0];
    treePanel.expand();
  }
  function expandMenu() {
    var menusPanel = Ext.ComponentQuery.query('menus')[0];
    menusPanel.expand();
  }
  function collapseEchogram() {
    var cAntarcticImageBrowserPanel = Ext.ComponentQuery.query('#antarcticImageBrowserPanel')[0];
    cAntarcticImageBrowserPanel.collapse();
  }
  setTimeout(collapseEchogram, 0);
  setTimeout(expandTree, 100);
  setTimeout(expandMenu, 500);
  setTimeout(Ext.getBody().unmask(), 900);
}}]}], region:'west', title:'Echogram Image Browser', collapsible:true, collapsed:true, autoScroll:true, resizable:true, width:800});
Ext.define('OPS.view.MapTabs.AntarcticTab.AntarcticTab', {extend:Ext.Panel, layout:'border', defaults:{collapsible:false, bodyStyle:'padding:0px'}, alias:'widget.antarctictab', title:'Antarctic', items:[antarcticEchogramPanel, antarcticMapPanel, antarcticTree]});
Ext.define('OPS.view.MapTabs.DownloadTab.DownloadTab', {extend:Ext.grid.Panel, alias:'widget.downloadtab', initComponent:function() {
  this.store = Ext.getStore('FileDownloads'), this.columns = [{text:'Download Id', dataIndex:'id', width:15, align:'center', sortable:false, hideable:false}, {text:'Location', dataIndex:'location', width:15, align:'center', sortable:false, hideable:false}, {text:'Download Status', dataIndex:'status', width:15, align:'center', sortable:false, hideable:false}, {text:'Started', dataIndex:'stime', width:15, align:'center', sortable:false, hideable:false}, {text:'Finished', dataIndex:'ftime', width:15, 
  align:'center', sortable:false, hideable:false}, {text:'Download Type', dataIndex:'type', width:15, align:'center', sortable:false, hideable:false}, {text:'Download Link', dataIndex:'url', renderer:function(value) {
    return '\x3ca href\x3d"' + value + '"target\x3d"_blank"\x3e' + value + '\x3c/a\x3e';
  }, sortable:false, hideable:false}], this.forceFit = true;
  this.callParent(arguments);
}});
Ext.define('OPS.view.MapTabs.MapTabs', {extend:Ext.tab.Panel, alias:'widget.maptabs', itemId:'maptabs', initComponent:function() {
  this.items = [{title:'Welcome', xtype:'box', autoEl:{tag:'iframe', src:'/resources/about.html'}}, {xtype:'arctictab', collapsible:false, header:false}, {xtype:'antarctictab', collapsible:false, header:false}, {title:'Downloads', xtype:'downloadtab', collapsible:false}, {title:'CReSIS Data Site', xtype:'box', autoEl:{tag:'iframe', src:'https://data.cresis.ku.edu/'}}];
  this.callParent(arguments);
}});
Ext.define('OPS.model.EpsgWktProj', {extend:Ext.data.Model, fields:[{name:'name', type:'string'}, {name:'value', type:'string'}]});
Ext.define('OPS.model.DownloadType', {extend:Ext.data.Model, fields:[{name:'name', type:'string'}, {name:'value', type:'string'}]});
Ext.define('OPS.model.System', {extend:Ext.data.Model, fields:[{name:'season', type:'string'}, {name:'system', type:'string'}, {name:'location', type:'string'}, {name:'public', type:'BOOL'}]});
Ext.define('OPS.store.EpsgWktProjs', {extend:Ext.data.Store, model:'OPS.model.EpsgWktProj', data:[{'name':'WGS1984 (EPSG:4326)', 'value':'EPSG:4326'}, {'name':'North Stereographic (EPSG:3413)', 'value':'EPSG:3413'}, {'name':'South Stereographic (EPSG:3031)', 'value':'EPSG:3031'}]});
Ext.define('OPS.store.DownloadTypes', {extend:Ext.data.Store, model:'OPS.model.DownloadType', data:[{'name':'CSV', 'value':'csv'}, {'name':'CSV GOOD', 'value':'csv-good'}, {'name':'KML', 'value':'kml'}, {'name':'MAT', 'value':'mat'}, {'name':'NETCDF', 'value':'netcdf'}]});
Ext.define('OPS.store.Systems', {extend:Ext.data.Store, model:'OPS.model.System', proxy:{actionMethods:{read:'POST'}, type:'ajax', url:'/ops/get/system/info', extraParams:{app:'rds', data:JSON.stringify({'properties':{'username':'anonymous', 'isAuthenticated':true, 'mat':true}})}, reader:{type:'json', root:'data'}}, autoLoad:false});
Ext.define('OPS.controller.MapTabs', {extend:Ext.app.Controller, views:['MapTabs.MapTabs'], models:['EpsgWktProj', 'DownloadType', 'System'], stores:['EpsgWktProjs', 'DownloadTypes', 'Systems'], init:function() {
  this.control({'#maptabs':{tabchange:function(tabPanel, newCard, oldCard) {
    var selectedSystem = Ext.ComponentQuery.query('#selectedSystem')[0].value;
    var newTab = newCard.tab.text;
    var oldTab = oldCard.tab.text;
    var menusPanel = Ext.ComponentQuery.query('menus')[0];
    menusPanel.expand();
    if (newTab == 'Arctic' && oldTab == 'Antarctic' || newTab == 'Antarctic' && oldTab == 'Arctic') {
      var startDateCombo = Ext.ComponentQuery.query('#startDate')[0];
      startDateCombo.setValue('19930101');
      var stopDateCombo = Ext.ComponentQuery.query('#stopDate')[0];
      stopDateCombo.setValue(new Date);
      var systemCombo = Ext.ComponentQuery.query('#selectedSystem')[0];
      systemCombo.clearValue();
      var seasonCombo = Ext.ComponentQuery.query('#selectedSeasons')[0];
      seasonCombo.clearValue();
      var layersCombo = Ext.ComponentQuery.query('#selectedLayers')[0];
      layersCombo.clearValue();
      var wktTextArea = Ext.ComponentQuery.query('#wktText')[0];
      wktTextArea.setValue('');
      var wktProjCombo = Ext.ComponentQuery.query('#wktProj')[0];
      wktProjCombo.clearValue();
    }
    var systemStore = Ext.getStore('Systems');
    if (systemStore.getCount() == 0) {
      systemStore.load();
    }
    systemStore.clearFilter();
    var distinctSystems = systemStore.collect('system');
    var outSystems = [];
    for (var i = 0; i < distinctSystems.length; i++) {
      outSystems.push([distinctSystems[i]]);
    }
    var systemCombo = Ext.ComponentQuery.query('#selectedSystem')[0];
    distinctSystemsStore = new Ext.data.ArrayStore({fields:['system'], data:outSystems});
    systemCombo.bindStore(distinctSystemsStore);
    if (selectedSystem == null || selectedSystem.isWhitespace()) {
      systemCombo.setValue('rds');
      seasonCombo = Ext.ComponentQuery.query('#selectedSeasons')[0];
    } else {
      systemCombo.setValue(selectedSystem);
    }
  }}});
}});
Ext.define('OPS.view.Menus.SelectionMenu.SelectionMenu', {extend:Ext.Panel, alias:'widget.selectionmenu', title:'Menu', initComponent:function() {
  this.tools = [{type:'help', dock:'top', handler:function() {
    Ext.Ajax.request({url:'/resources/help.html', success:function(response) {
      Ext.create('Ext.window.Window', {title:'Map Help Documentation', height:600, width:600, layout:'fit', autoScroll:true, closable:true, padding:'10 10 10 10', items:[{xtype:'label', html:response.responseText}]}).show();
    }});
  }}], this.items = [{xtype:'label', html:'\x3ch3 style\x3d"text-align:center;"\x3eBasic Selection Filters\x3c/h4\x3e'}, {xtype:'combo', fieldLabel:'Select System', itemId:'selectedSystem', queryMode:'local', displayField:'system', valueField:'system'}, {xtype:'datefield', fieldLabel:'Start Date', itemId:'startDate', format:'Ymd', value:'19930101', maxValue:new Date}, {xtype:'datefield', fieldLabel:'End Date', itemId:'stopDate', format:'Ymd', value:new Date, minValue:'19930101'}, {xtype:'combo', 
  fieldLabel:'Select Season/s', itemId:'selectedSeasons', queryMode:'local', displayField:'season', valueField:'season', multiSelect:true}, {xtype:'button', itemId:'applyFilters', text:'Apply Filters To Map', scale:'small', width:255, tooltip:'Redraw layers on the map based on the above selected filters. Dont forget to change the layer in the "Map Layer Selection" panel.'}, {xtype:'label', html:'\x3ch1\x3e\x3chr\x3e\x3c/h1\x3e\x3ch3 style\x3d"text-align:center;"\x3eSpatial Selection Filters\x3c/h3\x3e'}, 
  {xtype:'button', itemId:'drawPolygon', text:'Draw A Polygon', scale:'small', width:255, tooltip:'Draw a polygon on the map to select an area for download, see map help for more.'}, {xtype:'button', itemId:'clearDrawing', text:'Clear Drawing', scale:'small', width:255, tooltip:'Clear any drawing made on the map. This is also applied by clicking "Draw A Polygon" again.'}, {xtype:'label', html:'\x3cp style\x3d"text-align:center;"\x3eOR Type/Paste WKT Polygon\x3c/p\x3e'}, {xtype:'textarea', itemId:'wktText', 
  emptyText:'POLYGON((x1 y1,x2 y2,x1 y1))', resizable:true, minWidth:255, maxWidth:255, width:255, height:50, minHeight:50}, {xtype:'combo', fieldLabel:'WKT Projection', itemId:'wktProj', store:'EpsgWktProjs', queryMode:'local', autoSelect:true, displayField:'name', valueField:'value'}, {xtype:'button', itemId:'renderWkt', text:'Render WKT Text', scale:'small', width:255, tooltip:'Render the WKT Polygon to the map using the defined WKT Projection.'}, {xtype:'label', html:'\x3ch1\x3e\x3chr\x3e\x3c/h1\x3e\x3ch3 style\x3d"text-align:center;"\x3eDownload Settings\x3c/h3\x3e\x3cp style\x3d"text-align:center;"\x3e See [?] on the toolbar above for help/info.\x3c/p\x3e'}, 
  {xtype:'combo', fieldLabel:'Output Format', itemId:'outFormat', store:'DownloadTypes', queryMode:'local', displayField:'name', valueField:'value'}, {xtype:'combo', fieldLabel:'Output Layer/s', itemId:'selectedLayers', queryMode:'local', displayField:'lyr_name', valueField:'lyr_name', multiSelect:true}, {xtype:'button', itemId:'downloadData', text:'Download File', scale:'large', width:255, tooltip:'Using all of the above filters and the selected region download data in the specified format.'}, {xtype:'label', 
  html:'\x3cp style\x3d"text-align:center;"\x3eSee Downloads Tab for Results\x3c/p\x3e'}];
  this.callParent(arguments);
}});
Ext.define('OPS.controller.SelectionMenu', {extend:Ext.app.Controller, views:['Menus.SelectionMenu.SelectionMenu'], models:['EpsgWktProj', 'DownloadType', 'System'], stores:['EpsgWktProjs', 'DownloadTypes', 'Systems'], init:function() {
  this.control({'#applyFilters':{click:function() {
    var curTab = Ext.ComponentQuery.query('maptabs')[0].getActiveTab().title;
    if (curTab === 'Arctic') {
      var curMapPanel = arcticMapPanel;
    } else {
      if (curTab === 'Antarctic') {
        var curMapPanel = antarcticMapPanel;
      } else {
        Ext.Msg.alert('SYSTEM ERROR', 'Make sure you are on the Arctic or Antarctic tab.');
      }
    }
    var selectedSystem = Ext.ComponentQuery.query('#selectedSystem')[0].value;
    var selectedSeasons = Ext.ComponentQuery.query('#selectedSeasons')[0].value;
    var startDate = Ext.ComponentQuery.query('#startDate')[0].getRawValue();
    var stopDate = Ext.ComponentQuery.query('#stopDate')[0].getRawValue();
    if (!selectedSystem) {
      Ext.Msg.alert('ERROR', 'System must be selected');
    } else {
      if (!selectedSeasons) {
        selectedSeasons = '';
      }
      if (!startDate) {
        startDateSeg = '00000000_00';
      } else {
        startDateSeg = startDate.concat('_00');
      }
      if (!stopDate) {
        stopDateSeg = '99999999_99';
      } else {
        stopDateSeg = stopDate.concat('_99');
      }
      if (selectedSeasons.length > 0) {
        outStr = '';
        for (var i = 0; i < selectedSeasons.length; i++) {
          if (i < selectedSeasons.length - 1) {
            outStr = outStr + "'" + selectedSeasons[i] + "'" + '\\,';
          } else {
            outStr = outStr + "'" + selectedSeasons[i] + "'" + ';';
          }
        }
        paramStr = "start_seg:'" + startDateSeg + "';stop_seg:'" + stopDateSeg + "';season_name:" + outStr;
      } else {
        paramStr = "start_seg:'" + startDateSeg + "';stop_seg:'" + stopDateSeg + "'";
      }
      if (selectedSystem === 'rds') {
        updateLayer = curMapPanel.map.getLayersByName('Radar Depth Sounder')[0];
      } else {
        if (selectedSystem === 'accum') {
          updateLayer = curMapPanel.map.getLayersByName('Accumulation Radar')[0];
        } else {
          if (selectedSystem === 'kuband') {
            updateLayer = curMapPanel.map.getLayersByName('KuBand Radar')[0];
          } else {
            if (selectedSystem === 'snow') {
              updateLayer = curMapPanel.map.getLayersByName('Snow Radar')[0];
            }
          }
        }
      }
      updateLayer.params.viewparams = paramStr;
      updateLayer.redraw(true);
    }
  }}, '#selectedSystem':{focus:function() {
    var curTab = Ext.ComponentQuery.query('maptabs')[0].getActiveTab().title;
    curLocation = curTab.toLowerCase();
    var systemStore = Ext.getStore('Systems');
    if (systemStore.getCount() == 0) {
      systemStore.load();
    }
    systemStore.clearFilter();
    var distinctSystems = systemStore.collect('system');
    var outSystems = [];
    for (var i = 0; i < distinctSystems.length; i++) {
      outSystems.push([distinctSystems[i]]);
    }
    var systemCombo = Ext.ComponentQuery.query('#selectedSystem')[0];
    distinctSystemsStore = new Ext.data.ArrayStore({fields:['system'], data:outSystems});
    systemCombo.bindStore(distinctSystemsStore);
  }, change:function() {
    var curSystem = Ext.ComponentQuery.query('#selectedSystem')[0].value;
    var systemStore = Ext.getStore('Systems');
    systemStore.clearFilter();
    systemStore.filter('system', curSystem);
    systemStore.filter('location', curLocation);
    var distinctSeasons = systemStore.collect('season');
    var outSeasons = [];
    for (var i = 0; i < distinctSeasons.length; i++) {
      outSeasons.push([distinctSeasons[i]]);
    }
    var seasonCombo = Ext.ComponentQuery.query('#selectedSeasons')[0];
    distinctSeasonsStore = new Ext.data.ArrayStore({fields:['season'], data:outSeasons});
    distinctSeasonsStore.sort('season', 'ASC');
    seasonCombo.bindStore(distinctSeasonsStore);
  }}, '#stopDate':{change:function() {
    var stopDateValue = Ext.ComponentQuery.query('#stopDate')[0].value;
    Ext.ComponentQuery.query('#startDate')[0].setMaxValue(stopDateValue);
  }}, '#startDate':{change:function() {
    var startDateValue = Ext.ComponentQuery.query('#startDate')[0].value;
    Ext.ComponentQuery.query('#stopDate')[0].setMinValue(startDateValue);
  }}, '#drawPolygon':{click:function() {
    var curTab = Ext.ComponentQuery.query('maptabs')[0].getActiveTab().title;
    if (curTab === 'Arctic') {
      var outEPSG = 'EPSG:3413';
      var curMapPanel = arcticMapPanel;
    } else {
      if (curTab === 'Antarctic') {
        var outEPSG = 'EPSG:3031';
        var curMapPanel = antarcticMapPanel;
      } else {
        Ext.Msg.alert('SYSTEM ERROR', 'Make sure you are on the Arctic or Antarctic tab.');
      }
    }
    if (typeof polygonBoundary !== 'undefined') {
      curMapPanel.map.removeLayer(polygonBoundary);
      delete polygonBoundary;
    }
    polygonBoundary = new OpenLayers.Layer.Vector('', {displayInLayerSwitcher:false, styleMap:new OpenLayers.StyleMap({fillColor:'white', fillOpacity:0.5, strokeColor:'#333333', strokeWidth:1, strokeOpacity:1, pointRadius:4, graphicName:'square'})});
    curMapPanel.map.addLayer(polygonBoundary);
    var drawControls = {polygon:new OpenLayers.Control.DrawFeature(polygonBoundary, OpenLayers.Handler.Polygon)};
    for (var key in drawControls) {
      curMapPanel.map.addControl(drawControls[key]);
    }
    drawControls['polygon'].events.register('featureadded', ' ', endDraw);
    function endDraw() {
      drawControls['polygon'].deactivate();
      curMapPanel.map.zoomToExtent(polygonBoundary.getDataExtent());
      var polygonBoundaryWGS84 = polygonBoundary.features[0].geometry.transform(new OpenLayers.Projection(outEPSG), new OpenLayers.Projection('EPSG:4326'));
      Ext.ComponentQuery.query('#wktText')[0].setValue(polygonBoundaryWGS84);
      Ext.ComponentQuery.query('#wktProj')[0].setValue('EPSG:4326');
      polygonBoundary.features[0].geometry.transform(new OpenLayers.Projection('EPSG:4326'), new OpenLayers.Projection(outEPSG));
    }
    drawControls['polygon'].activate();
  }}, '#clearDrawing':{click:function() {
    var curTab = Ext.ComponentQuery.query('maptabs')[0].getActiveTab().title;
    if (curTab === 'Arctic') {
      var curMapPanel = arcticMapPanel;
    } else {
      if (curTab === 'Antarctic') {
        var curMapPanel = antarcticMapPanel;
      } else {
        Ext.Msg.alert('SYSTEM ERROR', 'Make sure you are on the Arctic or Antarctic tab.');
      }
    }
    curMapPanel.map.removeLayer(polygonBoundary);
    delete polygonBoundary;
    curMapPanel.map.zoomOut();
  }}, '#renderWkt':{click:function() {
    var inEPSG = Ext.ComponentQuery.query('#wktProj')[0].value;
    if (inEPSG !== null) {
      var wktString = Ext.ComponentQuery.query('#wktText')[0].value;
      if (wktString !== undefined && wktString.length > 0) {
        var wkt = new OpenLayers.Format.WKT;
        var inFeature = wkt.read(wktString);
        var curTab = Ext.ComponentQuery.query('maptabs')[0].getActiveTab().title;
        if (curTab === 'Arctic') {
          var outEPSG = 'EPSG:3413';
          var curMapPanel = arcticMapPanel;
        } else {
          if (curTab === 'Antarctic') {
            var outEPSG = 'EPSG:3031';
            var curMapPanel = antarcticMapPanel;
          } else {
            Ext.Msg.alert('SYSTEM ERROR', 'Make sure you are on the Arctic or Antarctic tab.');
          }
        }
        polygonBoundary = new OpenLayers.Layer.Vector('', {displayInLayerSwitcher:false, styleMap:new OpenLayers.StyleMap({fillColor:'white', fillOpacity:0.5, strokeColor:'#333333', strokeWidth:1, strokeOpacity:1, pointRadius:4, graphicName:'square'})});
        curMapPanel.map.addLayer(polygonBoundary);
        var drawControls = {polygon:new OpenLayers.Control.DrawFeature(polygonBoundary, OpenLayers.Handler.Polygon)};
        for (var key in drawControls) {
          curMapPanel.map.addControl(drawControls[key]);
        }
        drawControls['polygon'].activate();
        polygonBoundary.addFeatures(inFeature);
        polygonBoundary.features[0].geometry.transform(new OpenLayers.Projection(inEPSG), new OpenLayers.Projection(outEPSG));
        drawControls['polygon'].deactivate();
        curMapPanel.map.zoomToExtent(polygonBoundary.getDataExtent());
      } else {
        Ext.Msg.alert('INPUT ERROR', 'WKT Polygon not defined.');
      }
    } else {
      Ext.Msg.alert('INPUT ERROR', 'WKT Projection not selected.');
    }
  }}, '#downloadData':{click:function() {
    var curTab = Ext.ComponentQuery.query('maptabs')[0].getActiveTab().title;
    if (curTab === 'Arctic') {
      var inEPSG = 'EPSG:3413';
    } else {
      if (curTab === 'Antarctic') {
        var inEPSG = 'EPSG:3031';
      } else {
        Ext.Msg.alert('SYSTEM ERROR', 'Make sure you are on the Arctic or Antarctic tab.');
        return;
      }
    }
    var outFormat = Ext.ComponentQuery.query('#outFormat')[0].value;
    var selectedSystem = Ext.ComponentQuery.query('#selectedSystem')[0].value;
    var selectedSeasons = Ext.ComponentQuery.query('#selectedSeasons')[0].value;
    var startDate = Ext.ComponentQuery.query('#startDate')[0].getRawValue();
    var stopDate = Ext.ComponentQuery.query('#stopDate')[0].getRawValue();
    var selectedLayers = Ext.ComponentQuery.query('#selectedLayers')[0].value;
    if (typeof polygonBoundary === 'undefined') {
      Ext.Msg.alert('ERROR', 'Polygon Boundary must be created using Draw Polygon or Render WKT');
    } else {
      if (!outFormat) {
        Ext.Msg.alert('ERROR', 'Output Format must be set.');
      } else {
        if (!selectedSystem) {
          Ext.Msg.alert('ERROR', 'System must be selected');
        } else {
          if (!selectedSeasons || selectedSeasons.length != 0) {
            useSeasons = true;
          } else {
            useSeasons = false;
          }
          if (!selectedLayers || selectedLayers.length != 0) {
            useLayers = true;
          } else {
            useLayers = false;
          }
          if (!startDate) {
            startDateSeg = '00000000_00';
          } else {
            startDateSeg = startDate.concat('_00');
          }
          if (!stopDate) {
            stopDateSeg = '99999999_99';
          } else {
            stopDateSeg = stopDate.concat('_99');
          }
          Ext.Msg.alert({title:'Confirm Download', msg:'The file will now be downloaded, see the downloads tab for status and results. Please be patient. While the download is processed you can continue to use the OpenPolarServer and even submit more download requests. The files will be available at the download link for 7 days.', buttons:Ext.Msg.OKCANCEL, fn:function(btn) {
            if (btn == 'ok') {
              polygonBoundary.features[0].geometry.transform(new OpenLayers.Projection(inEPSG), new OpenLayers.Projection('EPSG:4326'));
              var wkt = new OpenLayers.Format.WKT;
              var outWkt = wkt.write(polygonBoundary.features[0]);
              if (outFormat === 'csv-good' || outFormat === 'csv' || outFormat === 'kml') {
                if (useSeasons) {
                  var inputJSON = JSON.stringify({'properties':{'bound':outWkt, 'location':curTab.toLowerCase(), 'startseg':startDateSeg, 'stopseg':stopDateSeg, 'season':selectedSeasons}});
                } else {
                  var inputJSON = JSON.stringify({'properties':{'bound':outWkt, 'location':curTab.toLowerCase(), 'startseg':startDateSeg, 'stopseg':stopDateSeg}});
                }
              } else {
                if (outFormat === 'mat') {
                  if (useSeasons && useLayers) {
                    var inputJSON = JSON.stringify({'properties':{'bound':outWkt, 'location':curTab.toLowerCase(), 'startseg':startDateSeg, 'stopseg':stopDateSeg, 'season':selectedSeasons, 'layers':selectedLayers}});
                  } else {
                    if (useSeasons) {
                      var inputJSON = JSON.stringify({'properties':{'bound':outWkt, 'location':curTab.toLowerCase(), 'startseg':startDateSeg, 'stopseg':stopDateSeg, 'season':selectedSeasons}});
                    } else {
                      if (useLayers) {
                        var inputJSON = JSON.stringify({'properties':{'bound':outWkt, 'location':curTab.toLowerCase(), 'startseg':startDateSeg, 'stopseg':stopDateSeg, 'layers':selectedLayers}});
                      } else {
                        var inputJSON = JSON.stringify({'properties':{'bound':outWkt, 'location':curTab.toLowerCase(), 'startseg':startDateSeg, 'stopseg':stopDateSeg}});
                      }
                    }
                  }
                } else {
                  Ext.Msg.alert('NOTIC', 'OUTPUT FORMAT NOT CURRENTLY SUPPORTED');
                  return;
                }
              }
              fileDownloadStore = Ext.data.StoreManager.lookup('FileDownloads');
              if (outFormat === 'csv-good') {
                var getCsvGood = function(selectedSystem, inputJSON, downloadId) {
                  tmp = Ext.Ajax.request({method:'POST', url:'/ops/get/layer/points/csv', timeout:3600000, params:{'app':selectedSystem, 'data':inputJSON}, success:function(response) {
                    fileDownloadStore = Ext.data.StoreManager.lookup('FileDownloads');
                    responseJSON = JSON.parse(response.responseText);
                    if (responseJSON.status == 1) {
                      outRecord = fileDownloadStore.findRecord('id', downloadId);
                      outRecord.data.status = 'Complete';
                      outRecord.data.url = responseJSON.data;
                      outRecord.data.ftime = (new Date).toLocaleTimeString();
                      outRecord.commit();
                      Ext.Msg.alert('NOTICE', 'Download is ready, see the Downloads tab.');
                    } else {
                      outRecord = fileDownloadStore.findRecord('id', downloadId);
                      outRecord.data.status = 'Error';
                      outRecord.data.ftime = (new Date).toLocaleTimeString();
                      outRecord.commit();
                      Ext.Msg.alert('ERROR', responseJSON.data);
                    }
                  }, failure:function() {
                    outRecord = fileDownloadStore.findRecord('id', downloadId);
                    outRecord.data.status = 'Error';
                    outRecord.data.ftime = (new Date).toLocaleTimeString();
                    outRecord.commit();
                    Ext.Msg.alert('ERROR', 'UNKOWN ERROR OCCURED.');
                  }});
                };
                downloadId = Math.floor(Math.random() * 1000000);
                fileDownloadStore.add({'id':downloadId, 'location':curTab, 'status':'Processing', 'stime':(new Date).toLocaleTimeString(), 'ftime':'', 'type':'csv-good', 'url':''});
                fileDownloadStore.commitChanges();
                getCsvGood(selectedSystem, inputJSON, downloadId);
              } else {
                if (outFormat === 'csv') {
                  var getCsv = function(selectedSystem, inputJSON, downloadId) {
                    tmp = Ext.Ajax.request({method:'POST', url:'/ops/get/layer/points/csv', timeout:3600000, params:{'app':selectedSystem, 'data':inputJSON}, success:function(response) {
                      fileDownloadStore = Ext.data.StoreManager.lookup('FileDownloads');
                      responseJSON = JSON.parse(response.responseText);
                      if (responseJSON.status == 1) {
                        outRecord = fileDownloadStore.findRecord('id', downloadId);
                        outRecord.data.status = 'Complete';
                        outRecord.data.url = responseJSON.data;
                        outRecord.data.ftime = (new Date).toLocaleTimeString();
                        outRecord.commit();
                        Ext.Msg.alert('NOTICE', 'Download is ready, see the Downloads tab.');
                      } else {
                        outRecord = fileDownloadStore.findRecord('id', downloadId);
                        outRecord.data.status = 'Error';
                        outRecord.data.ftime = (new Date).toLocaleTimeString();
                        outRecord.commit();
                        Ext.Msg.alert('ERROR', responseJSON.data);
                      }
                    }, failure:function() {
                      outRecord = fileDownloadStore.findRecord('id', downloadId);
                      outRecord.data.status = 'Error';
                      outRecord.data.ftime = (new Date).toLocaleTimeString();
                      outRecord.commit();
                      Ext.Msg.alert('ERROR', 'UNKOWN ERROR OCCURED.');
                    }});
                  };
                  tmpJSON = JSON.parse(inputJSON);
                  tmpJSON.properties.allPoints = true;
                  inputJSON = JSON.stringify(tmpJSON);
                  downloadId = Math.floor(Math.random() * 1000000);
                  fileDownloadStore.add({'id':downloadId, 'location':curTab, 'status':'Processing', 'stime':(new Date).toLocaleTimeString(), 'ftime':'', 'type':'csv', 'url':''});
                  fileDownloadStore.commitChanges();
                  getCsv(selectedSystem, inputJSON, downloadId);
                } else {
                  if (outFormat === 'kml') {
                    var getKml = function(selectedSystem, inputJSON, downloadId) {
                      tmp = Ext.Ajax.request({method:'POST', url:'/ops/get/layer/points/kml', timeout:3600000, params:{'app':selectedSystem, 'data':inputJSON}, success:function(response) {
                        fileDownloadStore = Ext.data.StoreManager.lookup('FileDownloads');
                        responseJSON = JSON.parse(response.responseText);
                        if (responseJSON.status == 1) {
                          outRecord = fileDownloadStore.findRecord('id', downloadId);
                          outRecord.data.status = 'Complete';
                          outRecord.data.url = responseJSON.data;
                          outRecord.data.ftime = (new Date).toLocaleTimeString();
                          outRecord.commit();
                          Ext.Msg.alert('NOTICE', 'Download is ready, see the Downloads tab.');
                        } else {
                          outRecord = fileDownloadStore.findRecord('id', downloadId);
                          outRecord.data.status = 'Error';
                          outRecord.data.ftime = (new Date).toLocaleTimeString();
                          outRecord.commit();
                          Ext.Msg.alert('ERROR', responseJSON.data);
                        }
                      }, failure:function() {
                        outRecord = fileDownloadStore.findRecord('id', downloadId);
                        outRecord.data.status = 'Error';
                        outRecord.data.ftime = (new Date).toLocaleTimeString();
                        outRecord.commit();
                        Ext.Msg.alert('ERROR', 'UNKOWN ERROR OCCURED.');
                      }});
                    };
                    downloadId = Math.floor(Math.random() * 1000000);
                    fileDownloadStore.add({'id':downloadId, 'location':curTab, 'status':'Processing', 'stime':(new Date).toLocaleTimeString(), 'ftime':'', 'type':'kml', 'url':''});
                    fileDownloadStore.commitChanges();
                    getKml(selectedSystem, inputJSON, downloadId);
                  } else {
                    if (outFormat === 'mat') {
                      var getMat = function(selectedSystem, inputJSON, downloadId) {
                        tmp = Ext.Ajax.request({method:'POST', url:'/ops/get/layer/points/mat', timeout:3600000, params:{'app':selectedSystem, 'data':inputJSON}, success:function(response) {
                          fileDownloadStore = Ext.data.StoreManager.lookup('FileDownloads');
                          responseJSON = JSON.parse(response.responseText);
                          if (responseJSON.status == 1) {
                            outRecord = fileDownloadStore.findRecord('id', downloadId);
                            outRecord.data.status = 'Complete';
                            outRecord.data.url = responseJSON.data;
                            outRecord.data.ftime = (new Date).toLocaleTimeString();
                            outRecord.commit();
                            Ext.Msg.alert('NOTICE', 'Download is ready, see the Downloads tab.');
                          } else {
                            outRecord = fileDownloadStore.findRecord('id', downloadId);
                            outRecord.data.status = 'Error';
                            outRecord.data.ftime = (new Date).toLocaleTimeString();
                            outRecord.commit();
                            Ext.Msg.alert('ERROR', responseJSON.data);
                          }
                        }, failure:function() {
                          outRecord = fileDownloadStore.findRecord('id', downloadId);
                          outRecord.data.status = 'Error';
                          outRecord.data.ftime = (new Date).toLocaleTimeString();
                          outRecord.commit();
                          Ext.Msg.alert('ERROR', 'UNKOWN ERROR OCCURED.');
                        }});
                      };
                      downloadId = Math.floor(Math.random() * 1000000);
                      fileDownloadStore.add({'id':downloadId, 'location':curTab, 'status':'Processing', 'stime':(new Date).toLocaleTimeString(), 'ftime':'', 'type':'mat', 'url':''});
                      fileDownloadStore.commitChanges();
                      getMat(selectedSystem, inputJSON, downloadId);
                    } else {
                      if (outFormat === 'netcdf') {
                        Ext.Msg.alert('NOTICE', 'NETCDF FORMAT OUTPUT IN DEVELOPMENT');
                      } else {
                        Ext.Msg.alert('NOTICE', 'OUTPUT FORMAT NOT CURRENTLY SUPPORTED');
                      }
                    }
                  }
                }
              }
              polygonBoundary.features[0].geometry.transform(new OpenLayers.Projection('EPSG:4326'), new OpenLayers.Projection(inEPSG));
            }
          }});
        }
      }
    }
  }}, '#selectedLayers':{focus:function() {
    var curSystem = Ext.ComponentQuery.query('#selectedSystem')[0].value;
    if (!curSystem) {
      Ext.Msg.alert('ERROR', 'System must be selected');
      return;
    }
    inputJSON = JSON.stringify({'none':'none'});
    Ext.Ajax.request({method:'POST', url:'/ops/get/layers', timeout:1200000, params:{'app':curSystem, 'data':inputJSON}, success:function(response) {
      responseJSON = JSON.parse(response.responseText);
      var outLayers = [];
      for (var i = 0; i < responseJSON.data.lyr_name.length; i++) {
        if (responseJSON.data.lyr_name[i] !== 'surface') {
          outLayers.push([responseJSON.data.lyr_name[i]]);
        }
      }
      var layersCombo = Ext.ComponentQuery.query('#selectedLayers')[0];
      layerStore = new Ext.data.ArrayStore({fields:['lyr_name'], data:outLayers});
      layerStore.sort('lyr_name', 'ASC');
      layersCombo.bindStore(layerStore);
      layersCombo.setValue('bottom');
    }, failure:function() {
      Ext.Msg.alert('ERROR', 'UNKOWN ERROR OCCURED.');
    }});
  }}});
}});
Ext.define('OPS.view.Menus.LoginMenu.LoginMenu', {extend:Ext.Panel, alias:'widget.loginmenu', title:'Menu', initComponent:function() {
  this.items = [{xtype:'label', html:'\x3ch3 style\x3d"text-align:center;"\x3eUser Login Menu\x3c/h3\x3e'}, {xtype:'textfield', emptyText:'Username', itemId:'username', width:255}, {xtype:'textfield', emptyText:'Password', inputType:'password', itemId:'password', width:255}, {xtype:'button', itemId:'userLogin', text:'Login', scale:'small', width:255, tooltip:'Login to the OPS system for access to custom datasets authorized to you by CReSIS.'}, {xtype:'button', itemId:'userLogout', text:'Logout', 
  scale:'small', width:255, tooltip:'Logout of the OPS system. This will happen automatically.'}, {xtype:'label', html:'\x3cp style\x3d"text-align:center;"\x3eAuthentication not required for CReSIS data.\x3c/p\x3e'}, {xtype:'button', itemId:'requestAccount', text:'Request Account', scale:'medium', width:255, tooltip:'Request an OPS account. Only do this is you have your own non-public data in the OPS system.'}, {xtype:'label', itemId:'loginStatus', html:'\x3ch3 style\x3d"text-align:center;"\x3eNo user logged in.\x3c/h3\x3e'}];
  this.callParent(arguments);
}});
Ext.define('OPS.controller.LoginMenu', {extend:Ext.app.Controller, views:['Menus.LoginMenu.LoginMenu'], models:[], stores:[], init:function() {
  var username = 'anonymous';
  var password = 'anonymous';
  if (!username || !password) {
    Ext.Msg.alert('ERROR', 'PLEASE ENTER USERNAME AND PASSWORD');
    return;
  }
  var inputJSON = JSON.stringify({'properties':{'userName':username, 'password':password}});
  Ext.Ajax.request({method:'POST', url:'/ops/login/user', timeout:1200000, params:{'app':'rds', 'data':inputJSON}, success:function(response) {
    responseJSON = JSON.parse(response.responseText);
    if (responseJSON.status == 1) {
      Ext.ComponentQuery.query('#username')[0].setValue('');
      Ext.ComponentQuery.query('#password')[0].setValue('');
      Ext.ComponentQuery.query('#loginStatus')[0].update('\x3ch3 style\x3d"text-align:center;"\x3eUser ' + username + ' logged in.\x3c/h3\x3e');
    } else {
      if (responseJSON.status == 2) {
        Ext.Msg.alert('WARNING', responseJSON.data);
      } else {
        Ext.Msg.alert('ERROR', responseJSON.data);
      }
    }
  }, failure:function() {
    Ext.Msg.alert('ERROR', 'UNKOWN ERROR OCCURED.');
  }});
  this.control({'#userLogin':{click:function() {
    var username = Ext.ComponentQuery.query('#username')[0].value;
    var password = Ext.ComponentQuery.query('#password')[0].value;
    if (!username || !password) {
      Ext.Msg.alert('ERROR', 'PLEASE ENTER USERNAME AND PASSWORD');
      return;
    }
    var inputJSON = JSON.stringify({'properties':{'userName':username, 'password':password}});
    Ext.Ajax.request({method:'POST', url:'/ops/login/user', timeout:1200000, params:{'app':'rds', 'data':inputJSON}, success:function(response) {
      responseJSON = JSON.parse(response.responseText);
      if (responseJSON.status == 1) {
        Ext.Msg.alert('NOTICE', responseJSON.data);
        Ext.ComponentQuery.query('#username')[0].setValue('');
        Ext.ComponentQuery.query('#password')[0].setValue('');
        Ext.ComponentQuery.query('#loginStatus')[0].update('\x3ch3 style\x3d"text-align:center;"\x3eUser ' + username + ' logged in.\x3c/h3\x3e');
        var systemStore = Ext.getStore('Systems');
        systemStore.load();
      } else {
        if (responseJSON.status == 2) {
          Ext.Msg.alert('WARNING', responseJSON.data);
        } else {
          Ext.Msg.alert('ERROR', responseJSON.data);
        }
      }
    }, failure:function() {
      Ext.Msg.alert('ERROR', 'UNKOWN ERROR OCCURED.');
    }});
  }}, '#userLogout':{click:function() {
    Ext.Ajax.request({method:'POST', url:'/ops/logout/user', timeout:1200000, params:{}, success:function(response) {
      responseJSON = JSON.parse(response.responseText);
      if (responseJSON.status == 1) {
        Ext.Msg.alert('NOTICE', responseJSON.data);
        Ext.ComponentQuery.query('#username')[0].setValue('');
        Ext.ComponentQuery.query('#password')[0].setValue('');
        Ext.ComponentQuery.query('#loginStatus')[0].update('\x3ch3 style\x3d"text-align:center;"\x3eNo user logged in.\x3c/h3\x3e');
        var systemStore = Ext.getStore('Systems');
        systemStore.removeAll();
        Ext.Msg.alert('NOTICE', 'PLEASE LOGIN OR REFRESH PAGE TO CONTINUE.');
      } else {
        if (responseJSON.status == 2) {
          Ext.Msg.alert('WARNING', responseJSON.data);
        } else {
          Ext.Msg.alert('ERROR', responseJSON.data);
        }
      }
    }, failure:function() {
      Ext.Msg.alert('ERROR', 'UNKOWN ERROR OCCURED.');
    }});
  }}, '#requestAccount':{click:function() {
    Ext.Msg.alert('Notice', 'The OpenPolarServer does not currently require authentication for download of CReSIS data. If you have a custom dataset in the OPS system and have not already recieved an OPS user account please contact us at \x3ca href\x3d"mailto:cresis_data@cresis.ku.edu"\x3ecresis_data@cresis.ku.edu\x3c/a\x3e');
  }}});
}});
Ext.define('OPS.model.FileDownload', {extend:Ext.data.Model, fields:[{name:'id', type:'integer'}, {name:'location', type:'string'}, {name:'status', type:'string'}, {name:'stime', type:'string'}, {name:'ftime', type:'string'}, {name:'type', type:'string'}, {name:'url', type:'string'}]});
Ext.define('OPS.view.HeaderBar', {extend:Ext.Panel, alias:'widget.headerbar', title:'CReSIS OpenPolarServer (OPS) GeoPortal', titleAlign:'center'});
Ext.define('OPS.view.FooterBar', {extend:Ext.Panel, alias:'widget.footerbar', title:'Copyright 2014 CReSIS | The University of Kansas | 785-864-4390 | Nichols Hall | 2335 Irving Hill Road | Lawrence, Kansas 66045', titleAlign:'center'});
Ext.define('OPS.view.Menus.Menus', {extend:Ext.Panel, alias:'widget.menus', title:'Menu', layout:'accordion', defaults:{collapsed:true, titleCollapse:false, animate:true}, initComponent:function() {
  this.items = [{xtype:'selectionmenu', region:'south', collapsible:true, bodyStyle:'padding: 0px 15px 5px 15px', overflowY:'auto', title:'Data Selection'}, {xtype:'loginmenu', region:'north', collapsible:true, bodyStyle:'padding:15px', overflowY:'auto', title:'User Login'}];
  this.callParent(arguments);
}});
Ext.define('OPS.store.FileDownloads', {extend:Ext.data.Store, model:'OPS.model.FileDownload'});
Ext.define('OPS.Application', {name:'OPS', extend:Ext.app.Application, views:['HeaderBar', 'FooterBar', 'MapTabs.MapTabs', 'MapTabs.AntarcticTab.AntarcticTab', 'MapTabs.ArcticTab.ArcticTab', 'MapTabs.DownloadTab.DownloadTab', 'Menus.Menus', 'Menus.SelectionMenu.SelectionMenu', 'Menus.LoginMenu.LoginMenu'], controllers:['MapTabs', 'SelectionMenu', 'LoginMenu'], stores:['DownloadTypes', 'EpsgWktProjs', 'Systems', 'FileDownloads'], models:['DownloadType', 'EpsgWktProj', 'System', 'FileDownload']});
Ext.define('OPS.view.Viewport', {extend:Ext.container.Viewport, layout:'border', defaults:{collapsible:false, split:true, bodyStyle:'padding:15px'}, initComponent:function() {
  this.items = [{xtype:'menus', region:'west', margins:'0 5 0 5', collapsible:true, collapsed:true, bodyStyle:'padding:0px', width:300, minWidth:300, maxWidth:300}, {xtype:'maptabs', region:'center', margins:'0 5 0 0', bodyStyle:'padding:0px', collapsible:false, header:false}];
  this.callParent();
}});
Ext.application({name:'OPS', extend:OPS.Application, autoCreateViewport:true});
Ext.define('GeoExt.LegendImage', {extend:Ext.Component, alias:'widget.gx_legendimage', url:null, defaultImgSrc:null, imgCls:null, noImgCls:'gx-legend-noimage', initComponent:function() {
  var me = this;
  me.callParent(arguments);
  if (this.defaultImgSrc === null) {
    this.defaultImgSrc = Ext.BLANK_IMAGE_URL;
  }
  this.autoEl = {tag:'img', 'class':this.imgCls ? this.imgCls + ' ' + this.noImgCls : this.noImgCls, src:this.defaultImgSrc};
}, setUrl:function(url) {
  this.url = url;
  var el = this.getEl();
  if (el) {
    el.un('load', this.onImageLoad, this);
    el.on('load', this.onImageLoad, this, {single:true});
    el.un('error', this.onImageLoadError, this);
    el.on('error', this.onImageLoadError, this, {single:true});
    el.dom.src = url;
  }
}, onRender:function(ct, position) {
  this.callParent(arguments);
  if (this.url) {
    this.setUrl(this.url);
  }
}, onDestroy:function() {
  var el = this.getEl();
  if (el) {
    el.un('load', this.onImageLoad, this);
    el.un('error', this.onImageLoadError, this);
  }
  this.callParent();
}, onImageLoadError:function() {
  var el = this.getEl();
  el.addCls(this.noImgCls);
  el.dom.src = this.defaultImgSrc;
}, onImageLoad:function() {
  var el = this.getEl();
  if (!OpenLayers.Util.isEquivalentUrl(el.dom.src, this.defaultImgSrc)) {
    el.removeCls(this.noImgCls);
  }
}});
Ext.define('GeoExt.container.LayerLegend', {extend:Ext.container.Container, alias:'widget.gx_layerlegend', alternateClassName:'GeoExt.LayerLegend', statics:{getTypes:function(layerRecord, preferredTypes) {
  var types = (preferredTypes || []).concat(), scoredTypes = [], score, type;
  for (type in this.types) {
    score = this.types[type].supports(layerRecord);
    if (score > 0) {
      if (Ext.Array.indexOf(types, type) == -1) {
        scoredTypes.push({type:type, score:score});
      }
    } else {
      Ext.Array.remove(types, type);
    }
  }
  scoredTypes.sort(function(a, b) {
    return a.score < b.score ? 1 : a.score == b.score ? 0 : -1;
  });
  var len = scoredTypes.length, goodTypes = new Array(len);
  for (var i = 0; i < len; ++i) {
    goodTypes[i] = scoredTypes[i].type;
  }
  return types.concat(goodTypes);
}, supports:function(layerRecord) {
}, types:{}}, layerRecord:null, showTitle:true, legendTitle:null, labelCls:null, layerStore:null, initComponent:function() {
  var me = this;
  me.callParent(arguments);
  me.autoEl = {};
  me.add({xtype:'label', html:this.getLayerTitle(this.layerRecord), cls:'x-form-item x-form-item-label' + (this.labelCls ? ' ' + this.labelCls : '')});
  if (me.layerRecord && me.layerRecord.store) {
    me.layerStore = me.layerRecord.store;
    me.layerStore.on('update', me.onStoreUpdate, me);
    me.layerStore.on('add', me.onStoreAdd, me);
    me.layerStore.on('remove', me.onStoreRemove, me);
  }
}, getLabel:function() {
  var label = this.items.get(0);
  return label.rendered ? label.el.dom.innerHTML : label.html;
}, onStoreRemove:function(store, record, index) {
}, onStoreAdd:function(store, record, index) {
}, onStoreUpdate:function(store, record, operation) {
  if (record === this.layerRecord && this.items.getCount() > 0) {
    var layer = record.getLayer();
    this.setVisible(layer.getVisibility() && layer.calculateInRange() && layer.displayInLayerSwitcher && !record.get('hideInLegend'));
    this.update();
  }
}, update:function() {
  var title = this.getLayerTitle(this.layerRecord);
  var item = this.items.get(0);
  if (item instanceof Ext.form.Label && this.getLabel() !== title) {
    item.setText(title, false);
  }
}, getLayerTitle:function(record) {
  var title = this.legendTitle || '';
  if (this.showTitle && !title) {
    if (record && !record.get('hideTitle')) {
      title = record.get('title') || record.get('name') || record.getLayer().name || '';
    }
  }
  return title;
}, beforeDestroy:function() {
  if (this.layerStore) {
    this.layerStore.un('update', this.onStoreUpdate, this);
    this.layerStore.un('remove', this.onStoreRemove, this);
    this.layerStore.un('add', this.onStoreAdd, this);
  }
  this.callParent();
}, onDestroy:function() {
  this.layerRecord = null;
  this.layerStore = null;
  this.callParent(arguments);
}});
Ext.define('GeoExt.container.WmsLegend', {extend:GeoExt.container.LayerLegend, alias:'widget.gx_wmslegend', alternateClassName:'GeoExt.WMSLegend', statics:{supports:function(layerRecord) {
  return layerRecord.getLayer() instanceof OpenLayers.Layer.WMS ? 1 : 0;
}}, defaultStyleIsFirst:true, useScaleParameter:true, baseParams:null, initComponent:function() {
  var me = this;
  me.callParent();
  var layer = me.layerRecord.getLayer();
  me._noMap = !layer.map;
  layer.events.register('moveend', me, me.onLayerMoveend);
  me.update();
}, onLayerMoveend:function(e) {
  if (e.zoomChanged === true && this.useScaleParameter === true || this._noMap) {
    delete this._noMap;
    this.update();
  }
}, getLegendUrl:function(layerName, layerNames) {
  var rec = this.layerRecord;
  var url;
  var styles = rec && rec.get('styles');
  var layer = rec.getLayer();
  layerNames = layerNames || [layer.params.LAYERS].join(',').split(',');
  var styleNames = layer.params.STYLES && [layer.params.STYLES].join(',').split(',');
  var idx = Ext.Array.indexOf(layerNames, layerName);
  var styleName = styleNames && styleNames[idx];
  if (styles && styles.length > 0) {
    if (styleName) {
      Ext.each(styles, function(s) {
        url = s.name == styleName && s.legend && s.legend.href;
        return !url;
      });
    } else {
      if (this.defaultStyleIsFirst === true && !styleNames && !layer.params.SLD && !layer.params.SLD_BODY) {
        url = styles[0].legend && styles[0].legend.href;
      }
    }
  }
  if (!url) {
    url = layer.getFullRequestString({REQUEST:'GetLegendGraphic', WIDTH:null, HEIGHT:null, EXCEPTIONS:'application/vnd.ogc.se_xml', LAYER:layerName, LAYERS:null, STYLE:styleName !== '' ? styleName : null, STYLES:null, SRS:null, FORMAT:null, TIME:null});
  }
  var params = Ext.apply({}, this.baseParams);
  if (layer.params._OLSALT) {
    params._OLSALT = layer.params._OLSALT;
  }
  url = Ext.urlAppend(url, Ext.urlEncode(params));
  if (url.toLowerCase().indexOf('request\x3dgetlegendgraphic') != -1) {
    if (url.toLowerCase().indexOf('format\x3d') == -1) {
      url = Ext.urlAppend(url, 'FORMAT\x3dimage%2Fgif');
    }
    if (this.useScaleParameter === true) {
      var scale = layer.map.getScale();
      url = Ext.urlAppend(url, 'SCALE\x3d' + scale);
    }
  }
  return url;
}, update:function() {
  var layer = this.layerRecord.getLayer();
  if (!(layer && layer.map)) {
    return;
  }
  this.callParent();
  var layerNames, layerName, i, len;
  layerNames = [layer.params.LAYERS].join(',').split(',');
  var destroyList = [];
  var textCmp = this.items.get(0);
  this.items.each(function(cmp) {
    i = Ext.Array.indexOf(layerNames, cmp.itemId);
    if (i < 0 && cmp != textCmp) {
      destroyList.push(cmp);
    } else {
      if (cmp !== textCmp) {
        layerName = layerNames[i];
        var newUrl = this.getLegendUrl(layerName, layerNames);
        if (!OpenLayers.Util.isEquivalentUrl(newUrl, cmp.url)) {
          cmp.setUrl(newUrl);
        }
      }
    }
  }, this);
  for (i = 0, len = destroyList.length; i < len; i++) {
    var cmp = destroyList[i];
    this.remove(cmp);
    cmp.destroy();
  }
  for (i = 0, len = layerNames.length; i < len; i++) {
    layerName = layerNames[i];
    if (!this.items || !this.getComponent(layerName)) {
      this.add({xtype:'gx_legendimage', url:this.getLegendUrl(layerName, layerNames), itemId:layerName});
    }
  }
  this.doLayout();
}, beforeDestroy:function() {
  if (this.useScaleParameter === true) {
    var layer = this.layerRecord.getLayer();
    layer && layer.events && layer.events.unregister('moveend', this, this.onLayerMoveend);
  }
  this.callParent();
}}, function() {
  GeoExt.container.LayerLegend.types['gx_wmslegend'] = GeoExt.container.WmsLegend;
});
